{"tags":[{"name":"JavaScript","permalink":"http://lingyucoder.github.io/tags/JavaScript/","url":"/async/tags/JavaScript.json","count":39},{"name":"jQuery","permalink":"http://lingyucoder.github.io/tags/jQuery/","url":"/async/tags/jQuery.json","count":1}],"categories":[{"name":"JS技术","permalink":"http://lingyucoder.github.io/categories/JS技术/","url":"/async/categories/JS技术.json","count":13}],"url":"/async/posts/2014/01/28/jquery-resize.json","date":1390838400000,"path":{"year":2014,"month":1,"day":28,"name":"jquery-resize"},"subtitle":"使用jQuery实现","title":"使用jQuery监听DOM元素大小变化","permalink":"http://lingyucoder.github.io/2014/01/28/jquery-resize/","content":"<p>今天写页面的时候突然有这么个需求，由于父元素（一个DIV）的height是由javascript计算出来的固定的值，而在其中增加了一个多说插件，在用户评论后，子元素（DIV）的height属性增加，导致子元素溢出。但是又不知道如何为多说的评论按钮增加回调函数，于是乎就想到了根据子元素的大小变化来重新计算父元素的height。</p>\n<a id=\"more\"></a>\n<h3 id=\"起因\">起因</h3><p>今天写页面的时候突然有这么个需求，由于父元素（一个DIV）的height是由javascript计算出来的固定的值，而在其中增加了一个多说插件，在用户评论后，子元素（DIV）的height属性增加，导致子元素溢出。但是又不知道如何为多说的评论按钮增加回调函数，于是乎就想到了根据子元素的大小变化来重新计算父元素的height。</p>\n<h3 id=\"onresize?\">onresize?</h3><p>平常，都是在整个浏览器窗口变化时触发一个修改布局的回调函数。使用的是window对象的resize事件，利用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onresize = callback;</span><br></pre></td></tr></table></figure></p>\n<p>来绑定。但根据resize事件的target是<figure class=\"highlight\"><figcaption><span>(window)```，这里详见[MDN的resize文档](https://developer.mozilla.org/en-US/docs/Web/Reference/Events/resize)，也就是说只有window对象有resize事件，于是乎就想到使用jQuery自己的事件机制来模拟一个普通元素上的resize事件</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#10;###&#20351;&#29992;jQuery&#20107;&#20214;&#30340;&#23454;&#29616;&#24605;&#36335;&#10;&#21487;&#20197;&#24819;&#21040;&#19968;&#31181;&#27604;&#36739;&#31616;&#21333;&#30340;&#26041;&#24335;&#65306;&#10;1. &#22312;&#20803;&#32032;&#32465;&#23450;resize&#23545;&#35937;&#26102;&#65292;&#35760;&#24405;&#20803;&#32032;&#30340;width&#21644;height&#10;2. &#20351;&#29992;requestAnimationFrame&#12289;setTimeout&#12289;setInterval&#65292;&#27599;&#38548;&#19968;&#27573;&#26102;&#38388;&#26597;&#35810;&#20854;width&#21644;height&#65292;&#22914;&#26524;&#21644;&#35760;&#24405;&#30340;width&#21644;height&#19981;&#19968;&#26679;&#65292;&#36816;&#34892;&#22238;&#35843;&#20989;&#25968;&#24182;&#26356;&#26032;&#35760;&#24405;&#20013;&#30340;width&#20026;height&#10;&#10;###jQuery&#25554;&#20214;&#10;&#36825;&#20010;&#21151;&#33021;Ben Alman&#32534;&#20889;&#20102;&#19968;&#20010;jQuery&#25554;&#20214;&#65292;[&#36825;&#26159;&#20256;&#36865;&#38376;](http://benalman.com/projects/jquery-resize-plugin/)&#10;&#35813;&#25554;&#20214;&#30340;&#20195;&#30721;&#65288;&#26680;&#24515;&#37096;&#20998;&#65289;&#65292;&#35814;&#32454;&#20195;&#30721;&#35831;&#26597;&#30475;[Ben Alman&#21338;&#23458;](https://raw.github.com/cowboy/jquery-resize/v1.1/jquery.ba-resize.js)&#30340;&#20869;&#23481;&#65306;&#10;&#10;```javascript&#10;(function($, window, undefined) &#123;&#10;  var elems = $([]),&#10;    jq_resize = $.resize = $.extend($.resize, &#123;&#125;),&#10;    timeout_id,&#10;    str_setTimeout = &#39;setTimeout&#39;,&#10;    str_resize = &#39;resize&#39;,&#10;    str_data = str_resize + &#39;-special-event&#39;,&#10;    str_delay = &#39;delay&#39;,&#10;    str_throttle = &#39;throttleWindow&#39;;&#10;  jq_resize[str_delay] = 250;&#10;  jq_resize[str_throttle] = true;&#10;  $.event.special[str_resize] = &#123;&#10;    setup: function() &#123;&#10;      if (!jq_resize[str_throttle] &#38;&#38; this[str_setTimeout]) &#123;&#10;        return false;&#10;      &#125;&#10;      var elem = $(this);&#10;      elems = elems.add(elem);&#10;      $.data(this, str_data, &#123;&#10;        w: elem.width(),&#10;        h: elem.height()&#10;      &#125;);&#10;      if (elems.length === 1) &#123;&#10;        loopy();&#10;      &#125;&#10;    &#125;,&#10;    teardown: function() &#123;&#10;      if (!jq_resize[str_throttle] &#38;&#38; this[str_setTimeout]) &#123;&#10;        return false;&#10;      &#125;&#10;      var elem = $(this);&#10;      elems = elems.not(elem);&#10;      elem.removeData(str_data);&#10;      if (!elems.length) &#123;&#10;        clearTimeout(timeout_id);&#10;      &#125;&#10;    &#125;,&#10;    add: function(handleObj) &#123;&#10;      if (!jq_resize[str_throttle] &#38;&#38; this[str_setTimeout]) &#123;&#10;        return false;&#10;      &#125;&#10;      var old_handler;&#10;      function new_handler(e, w, h) &#123;&#10;        var elem = $(this),&#10;          data = $.data(this, str_data);&#10;        data.w = w !== undefined ? w : elem.width();&#10;        data.h = h !== undefined ? h : elem.height();&#10;        old_handler.apply(this, arguments);&#10;      &#125;&#10;      if ($.isFunction(handleObj)) &#123;&#10;        old_handler = handleObj;&#10;        return new_handler;&#10;      &#125; else &#123;&#10;        old_handler = handleObj.handler;&#10;        handleObj.handler = new_handler;&#10;      &#125;&#10;    &#125;&#10;  &#125;;&#10;&#10;  function loopy() &#123;&#10;    timeout_id = window[str_setTimeout](function() &#123;&#10;      elems.each(function() &#123;&#10;        var elem = $(this),&#10;          width = elem.width(),&#10;          height = elem.height(),&#10;          data = $.data(this, str_data);&#10;        if (width !== data.w || height !== data.h) &#123;&#10;          elem.trigger(str_resize, [data.w = width, data.h = height]);&#10;        &#125;&#10;      &#125;);&#10;      loopy();&#10;    &#125;, jq_resize[str_delay]);&#10;  &#125;&#10;&#125;)(jQuery, this);</span><br></pre></td></tr></table></figure></p>\n<p>jQuery为jQuery插件的开发者提供了添加自定义事件的接口，详细可以参考<a href=\"http://learn.jquery.com/events/event-extensions/\" target=\"_blank\" rel=\"external\">jQuery官方文档</a>，这里就是典型的jQuery自定义事件添加方式，其中有三个钩子：</p>\n<ol>\n<li>setup：<code>The setup hook is called the first time an event of a particular type is attached to an element.</code>首次绑定时执行，如果返回 false，使用默认方式绑定事件</li>\n<li>teardown：<code>The teardown hook is called when the final event of a particular type is removed from an element.</code>若指定该方法，其在移除事件处理程序(removeEventListener)前执行，如果返回 false，移除默认绑定事件</li>\n<li>add：<code>Each time an event handler is added to an element through an API such as .on(), jQuery calls this hook.</code>每一次给元素绑定事件，都会执行这个方法</li>\n</ol>\n<p>setup、teardown和add三个钩子，每个钩子最先做的事都是检测是否该对象为window对象，然后根据window对象特殊处理，因为window对象本身有resize事件</p>\n<p>从setup钩子可以看到，在初始化整个事件处理时，创建一个元素队列，队列中的每隔元素都把width和height放在data中，然后每隔250ms启动loopy函数，在loopy函数中判断是否变化，如果有变，触发回调函数并更新data中的width和height</p>\n<p>从teardown钩子可以看到，在元素移除事件时，只需要将元素从元素队列移除，并清除元素中的data数据。如果是元素队列中的最后一个元素，则不再继续执行loopy</p>\n<p>add钩子中，对回调函数进行了包装</p>\n<p>由此可以看到一个简单的jQuery自定义函数的实现机制</p>\n"}