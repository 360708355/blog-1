<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天镶的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://lingyu.wang/"/>
  <updated>2015-04-07T16:54:34.851Z</updated>
  <id>http://lingyu.wang/</id>
  
  <author>
    <name><![CDATA[天镶]]></name>
    <email><![CDATA[lingyucoder@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[读书破万卷，敲码别走神]]></title>
    <link href="http://lingyu.wang/2015/01/26/18-books/"/>
    <id>http://lingyu.wang/2015/01/26/18-books/</id>
    <published>2015-01-25T16:00:00.000Z</published>
    <updated>2015-01-26T18:32:36.477Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章是去年十一月，时隔两个多月了，这段时间由于毕业论文上屁事太多，没有静下心来写文章做总结。虽然学了不少新姿势，但是一直没在博客上做记录，特地写点东西来清清灰。</p>
<a id="more"></a>

<h2 id="电子书和纸质书">电子书和纸质书</h2>
<p>这段时间主要的学习方式是读书，双十一的时候在多看、当当上面买了一大堆电子书。相对于纸质书，电子书有很多的好处：</p>
<ol>
<li>装在手机里能够随时随地拿出来品读，有效地利用了碎片化的时间；</li>
<li>大部分书籍（除了PDF）都可以按照自己需要调节文字的大小、文字颜色、背景颜色，即便是晚上宿舍关灯之后，也可以在被窝里看；</li>
<li>各种电子资源相当便宜，双十一、双十二的时候，多看的书大幅度降价，当当上甚至各种一元一本，对于一些经典书籍（三国、水浒什么的），网上资源也非常多，很容易下载到；</li>
<li>书籍、笔记都在云端，即便更换了设备，也可以登录账号随时下载同步，到哪都能看，也更容易做到“学而时习之”。搬家的时候也轻便得多，我现在就愁宿舍书架上那些纸质书怎么搬走…</li>
</ol>
<p>电子书好处颇多，但相对于纸质书也有不少的不足：</p>
<ol>
<li>排版限制，这是一个很麻烦的问题。比如txt、epub等格式，可以使用电子书阅读软件随意更改字体大小，布局灵活，但在展示像代码这种对布局强依赖的内容时，阅读体验非常差；</li>
<li>书籍限制，各种书籍在出版时依然是纸质书籍为主，虽然电子书阅读软件提供商会购买版权，但书籍数量相当有限，目前电子书覆盖的主要是一些比较经典的书籍和一些网络文学，基本上比较新的书都没有，像一些计算机书籍就算很经典也由于排版调整麻烦所以数量很少（代码多的书籍比较少，理念型的倒还挺多的）；</li>
<li>电子书看书的时候，缺少纸张翻动的感觉，我们在长时间阅读纸质书籍过程中养成的一些阅读习惯都将回归于零。在阅读时经常会需要回头翻看之前的内容，这种需求在纸质书上就很好实现，而在电子书上就颇为吃力；</li>
</ol>
<p>这些都是最近看电子书感受到的，电子阅读还在快速的发展，希望以后在各个阅读平台上能够收录更多的书籍，解决排版限制。至于阅读习惯问题，见仁见智了</p>
<h2 id="书评">书评</h2>
<p>最近的一些书，计算机相关的书籍占绝大多数，有些记了读书笔记，都放在<a href="http://read.lingyu.wang/" target="_blank">我的笔记</a>里。读书笔记使用gitbook搭建，做了一些小修改，里面的内容由于都是一些书籍中的摘抄，所以基本上都是一句一句的，而不组织成文章。</p>
<p><strong>所有的书评仅代表个人观点</strong></p>
<h3 id="产品设计师技能书：知乎马力自选集">产品设计师技能书：知乎马力自选集</h3>
<p>作者：马力</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/zhihu-product-design/README.html" target="_blank">读书笔记</a></p>
<p>一系列文章组成的文集，最初发表在知乎上，作者自己甄选、修改后发布。这种文集的质量一般都比较高。所有内容都是作者的经验总结，阐述了产品、设计、用户之间的关系，阐述了很多经过千锤百炼的产品设计理念，还有很多用户研究的沉淀，非常给力</p>
<h3 id="移动设计">移动设计</h3>
<p>作者：傅小贞 胡甲超 郑元拢</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/mobile-design/README.html" target="_blank">读书笔记</a></p>
<p>我本身不是设计师，但这本书并没有给我带来任何理解障碍。书中结合移动端特有的种种特征，与PC端进行了充分对比，阐述了很多移动端交互、视觉设计的金科玉律，总结出不少优秀的理念和模式。最难能可贵的是，对于所有理念和模式，都辅佐以大量的真实产品实例，直观而生动。</p>
<h3 id="黑客与画家">黑客与画家</h3>
<p>作者：Paul Graham</p>
<p>个人评分：★★★★★</p>
<p>又是一本文集，一本经典之作。作者在人性、个人学习、黑客文化、互联网革命、个人财富、产品设计、创业、编程语言等等方面都有很多独到的见解。阮一峰翻译的，翻译功底了得。收获很多，最近正在整理这本书笔记</p>
<h3 id="产品设计七日修行">产品设计七日修行</h3>
<p>作者：侯振宇</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/7-day-product-design/README.html" target="_blank">读书笔记</a></p>
<p>也是一本文集，同样是作者心血历程的经验总结，内容很少，但字字珠玑。阐述了设计一个产品时应当注意的方方面面，以及一些重要的产品理念</p>
<h3 id="Web站点优化">Web站点优化</h3>
<p>作者：Andrew B. King</p>
<p>个人评分：★★★★★</p>
<p>这本书干货很多，非常详尽的阐述了如何对站点做SEO和性能优化。在提供各种优化方法的同时，还提供了很多的指标用于量化优化效果。虽然有一段时间了，但里面的知识依旧非常实用，不过干货实在太多了，而且比较抽象，吸收比较困难</p>
<h3 id="人性的优点">人性的优点</h3>
<p>作者：卡耐基</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/how-to-stop-worrying-and-start-living/README.html" target="_blank">读书笔记</a></p>
<p>一本读起来热血沸腾的励志书，整本书都是满满的正能量。这本书教导读者抛弃忧虑、相信自我、坚定目标，并提供了一套方法去实现自己的梦想，里面有很多的真人真事来论证方法的正确性，理念通俗易懂，难就难在自身付诸行动</p>
<h3 id="人性的弱点">人性的弱点</h3>
<p>作者：卡耐基</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/how-to-win-friends-and-influence-people/README.html" target="_blank">读书笔记</a></p>
<p>一本教人处理人际关系的书，指导读者如何受他人欢迎、如何受他人信任、如何说服他人以及如何建立和睦家庭。卡耐基的书都是阐述各种道理的同时，通过一些真人真事来论证理论的真确性，通俗易懂。读这本书最大的收获就是自省的依据：根据这些标准，自己日常言行是否欠妥，是否有更好地选择。个人这一方面亟待加强</p>
<h3 id="笑侃NBA">笑侃NBA</h3>
<p>作者：杨毅</p>
<p>个人评分：★★★★</p>
<p>杨毅的解说就很有意思，比较逗比。这本书用说书的方式讲述了一些知名球星的成长历程和他们经历的酸甜苦辣，很多都是老球迷耳熟能详的故事，挺有意思的</p>
<h3 id="编写可读代码的艺术">编写可读代码的艺术</h3>
<p>作者：Dustin Boswell</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/the-art-of-readable-code/README.html" target="_blank">读书笔记</a></p>
<p>一本告诉读者应该如何写可读代码的书。程序员写程序和艺术家创作艺术作品一样，需要有美感，需要认真。这本书阐述了如何写有美感、认真的代码，并从变量命名、语句、注释、循环逻辑、表达式拆分等等具体方面给出了给出了很多例子和细致的修改建议，非常值得阅读，并作为自己编写代码的准则加以实践</p>
<h3 id="淘宝产品十年事">淘宝产品十年事</h3>
<p>作者：苏杰</p>
<p>个人评分：★★★★</p>
<p><a href="http://read.lingyu.wang/taobao-product-10-year/README.html" target="_blank">读书笔记</a></p>
<p>这就是一本历史，淘宝产品的历史。通过一个个阿里的真实产品，从买家、卖家、平台等多个角度，总结了不少宝贵的产品经验。虽然业务上优点上的局限性，但是在尊重、理解用户的前提下权衡产品功能的理念广泛受用</p>
<h3 id="软件开发者路线图——从学徒到高手">软件开发者路线图——从学徒到高手</h3>
<p>作者：Dave H.Hoover</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/apprenticeship-patterns/README.html" target="_blank">读书笔记</a></p>
<p>很有用的一本书，针对刚进入计算机行业的新人，给予了切切实实的指导，教授很多宝贵学习方法的同时，帮助读者认清自己、摆正位置、确定职业发展方向。针对所处的场景，给予了很多非常有建设性的建议，读完之后收益匪浅</p>
<h3 id="JavaScript修炼之道">JavaScript修炼之道</h3>
<p>作者：Christophe Porteneuve</p>
<p>个人评分：★</p>
<p>收获不大，这本书叫JavaScript修炼之道，但对于JavaScript语言本身的学习帮助寥寥。里面都是使用几个特定的框架来完成一些特定的功能。前端更新迭代快速，框架本身淘汰、换代很快，因此书中的知识价值很低，即便是新手也学不到多少东西</p>
<h3 id="HTML5_应用开发实践">HTML5 应用开发实践</h3>
<p>作者：Zachary Kessin</p>
<p>个人评分：★★★</p>
<p><a href="http://read.lingyu.wang/programming-html5-applications/README.html" target="_blank">读书笔记</a></p>
<p>这本书基本上涵盖了H5的本地存储、IndexedDB、File API、Application Cache、Worker、Web Socket、新标记等一些比较重要的功能，但是由于涵盖的内容还是比较多，大都讲了是什么、怎么用起来。可以说是本介绍性质的书籍，较为基础适合初学者。如果对这些H5功能已经有概念了，完全可以不看</p>
<h3 id="jQuery_Mobile即学即用">jQuery Mobile即学即用</h3>
<p>作者：Maximiliano Firtman</p>
<p>个人评分：★★★★</p>
<p><a href="https://github.com/LingyuCoder/Learn-jquery-mobile" target="_blank">一些demo</a></p>
<p>介绍特定UI框架的一本书，就是告诉读者jQuery Mobile是什么、能干什么、怎么用，重要的是学习移动端Web的理念和模式。我还没有读完这本书，读了一半多，写了一些demo。确实使用它搭建移动端Web页面轻松写意加愉快（虽然估计有不少坑）</p>
<h3 id="Node_Web开发">Node Web开发</h3>
<p>作者：David Herron</p>
<p>个人评分：★★★</p>
<p>新手向的一本书，指导读者使用node搭建web server，并连接数据库。基本上就是node基础、web开发基础和express使用指南，外加一些可能会用到的库的介绍…翻译竟然是我之前实习所在的团队…</p>
<h3 id="图解CSS3：核心技术与案例实战">图解CSS3：核心技术与案例实战</h3>
<p>作者：大漠</p>
<p>个人评分：★★★</p>
<p>虽然这书好像挺火的，但是我读着很烦躁，因为读到的东西，文档上都有…基本上就是介绍各个CSS3属性是什么，怎么用，各个值效果是啥。适合新手阅读，或者在有某个属性不记得怎么用的时候，翻一翻…对于新手，全都是干货…</p>
<h3 id="神奇圣人：王阳明">神奇圣人：王阳明</h3>
<p>作者：雾满拦江</p>
<p>个人评分：★★★★</p>
<p>作者文笔俏皮活泼，以类似说书的方式将圣人阳明先生塑造成了一个欢脱的“顽童形象”，叙述了先生的一生，阅读起来很有意思。但全书主要介绍先生生平，对心学理论阐述较少，而且作者主观描述很多</p>
<h3 id="深入理解Bootstrap">深入理解Bootstrap</h3>
<p>作者：徐涛</p>
<p>个人评分：★★★★</p>
<p>汤姆大叔写的。详细介绍了Bootstrap 3.x各个模块如何使用、实现方法和架构理念，书中有很多带了注释的源码，对于有一定基础的读者，即便是没接触过Bootsrap读起来应该也不困难。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章是去年十一月，时隔两个多月了，这段时间由于毕业论文上屁事太多，没有静下心来写文章做总结。虽然学了不少新姿势，但是一直没在博客上做记录，特地写点东西来清清灰。</p>
]]>
    
    </summary>
    
      <category term="生活" scheme="http://lingyu.wang/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书笔记" scheme="http://lingyu.wang/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RisingStack的Node.js风格指南]]></title>
    <link href="http://lingyu.wang/2014/11/24/risingstack-nodejs-style-guide/"/>
    <id>http://lingyu.wang/2014/11/24/risingstack-nodejs-style-guide/</id>
    <published>2014-11-23T16:00:00.000Z</published>
    <updated>2014-11-24T11:39:23.438Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide" target="_blank">RisingStack/node-style-guide</a></p>
<a id="more"></a>

<h2 id="RisingStack_的Node-js_风格指南()_{"><a href="http://risingstack.com" target="_blank">RisingStack</a> 的Node.js 风格指南() {</h2>
<h3 id="文章的大部分内容来自_Airbnb_stlyeguide">文章的大部分内容来自 <a href="https://github.com/airbnb/javascript" target="_blank">Airbnb stlyeguide</a></h3>
<p>以下风格指南对此指南有很大影响:</p>
<ul>
<li>@caolan’s <a href="http://caolanmcmahon.com/posts/nodejs_style_and_structure" target="_blank">Node.js stlyeguide</a></li>
<li>@felixge’s <a href="https://github.com/felixge/node-style-guide" target="_blank">Node.js stlyeguide</a></li>
</ul>
<h2 id="类型">类型</h2>
<ul>
<li><p><strong>原生类型</strong>: 当访问一个原生类型时直接对其值进行操作</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="keyword">var</span> foo = <span class="number">1</span>;
    <span class="keyword">var</span> bar = foo;

    bar = <span class="number">9</span>;

    console.log(foo, bar); <span class="comment">// =&gt; 1, 9</span>
</pre></td></tr></table></figure>


<ul>
<li><p><strong>复杂类型</strong>: 当访问一个复杂类型时，将对其值的引用上进行操作</p>
<ul>
<li><code>object</code></li>
<li><code>array</code></li>
<li><code>function</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>];
    <span class="keyword">var</span> bar = foo;

    bar[<span class="number">0</span>] = <span class="number">9</span>;

    console.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span>
</pre></td></tr></table></figure>


<h2 id="对象">对象</h2>
<ul>
<li>使用字面量创建对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> item = {};
</pre></td></tr></table></figure>


<ul>
<li>用可读的同义单词来代替JavaScript的保留字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐，class是保留字</span>
    <span class="keyword">var</span> superman = {
      <span class="keyword">class</span>: <span class="string">'alien'</span>
    };

    <span class="comment">// 不推荐，klass不具备可读性</span>
    <span class="keyword">var</span> superman = {
      klass: <span class="string">'alien'</span>
    };

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> superman = {
      type: <span class="string">'alien'</span>
    };
</pre></td></tr></table></figure>


<h2 id="数组">数组</h2>
<ul>
<li>使用字面量创建数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> items = [];
</pre></td></tr></table></figure>


<ul>
<li>如果不知道数组的长度，使用Array#push方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>    <span class="keyword">var</span> someStack = [];


    <span class="comment">// 不推荐</span>
    someStack[someStack.length] = <span class="string">'abracadabra'</span>;

    <span class="comment">// 推荐</span>
    someStack.push(<span class="string">'abracadabra'</span>);
</pre></td></tr></table></figure>


<ul>
<li>使用Array#slice来拷贝数组，这样性能较好，详见<a href="http://jsperf.com/converting-arguments-to-an-array/7" target="_blank">jsPerf</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="keyword">var</span> len = items.length;
    <span class="keyword">var</span> itemsCopy = [];
    <span class="keyword">var</span> i;

    <span class="comment">// 不推荐，遍历性能较低</span>
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) {
      itemsCopy[i] = items[i];
    }

    <span class="comment">// 推荐</span>
    itemsCopy = items.slice();
</pre></td></tr></table></figure>


<ul>
<li>将类数组对象转变为数组时，使用Array#slice方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">trigger</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);
      ...
    }
</pre></td></tr></table></figure>


<h2 id="Strings">Strings</h2>
<ul>
<li>对字符串使用单引号<code>&#39;&#39;</code>包裹</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;
</pre></td></tr></table></figure>


<ul>
<li>字符串长度超过80个字符时，应当将字符串写成多行并通过加号进行拼接</li>
<li>注意：如果过度使用长字符串拼接方式将影响性能，详见<a href="http://jsperf.com/ya-string-concat" target="_blank">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" target="_blank">Discussion</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because \
    of Batman. When you stop to think about how Batman had anything to do \
    with this, you would get nowhere \
    fast.'</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because '</span> +
      <span class="string">'of Batman. When you stop to think about how Batman had anything to do '</span> +
      <span class="string">'with this, you would get nowhere fast.'</span>;
</pre></td></tr></table></figure>


<ul>
<li>当以编码的方式构建一个字符串时，使用Array#join方法，而不要拼接字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre>    <span class="keyword">var</span> items;
    <span class="keyword">var</span> messages;
    <span class="keyword">var</span> length;
    <span class="keyword">var</span> i;

    messages = [{
      state: <span class="string">'success'</span>,
      message: <span class="string">'This one worked.'</span>
    }, {
      state: <span class="string">'success'</span>,
      message: <span class="string">'This one worked as well.'</span>
    }, {
      state: <span class="string">'error'</span>,
      message: <span class="string">'This one did not work.'</span>
    }];

    length = messages.length;

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">inbox</span><span class="params">(messages)</span> {</span>
      items = <span class="string">'&lt;ul&gt;'</span>;

      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) {
        items += <span class="string">'&lt;li&gt;'</span> + messages[i].message + <span class="string">'&lt;/li&gt;'</span>;
      }

      <span class="keyword">return</span> items + <span class="string">'&lt;/ul&gt;'</span>;
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">inbox</span><span class="params">(messages)</span> {</span>
      items = [];

      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) {
        items[i] = messages[i].message;
      }

      <span class="keyword">return</span> <span class="string">'&lt;ul&gt;&lt;li&gt;'</span> + items.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>) + <span class="string">'&lt;/li&gt;&lt;/ul&gt;'</span>;
    }
</pre></td></tr></table></figure>


<h2 id="函数">函数</h2>
<ul>
<li>函数表达式:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>    <span class="comment">// 匿名函数表达式</span>
    <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="literal">true</span>;
    };

    <span class="comment">// 命名函数表达式</span>
    <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="literal">true</span>;
    };

    <span class="comment">// 立即执行函数 (immediately-invoked function expression, IIFE)</span>
    (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      console.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);
    })();
</pre></td></tr></table></figure>


<ul>
<li>不要在非函数块（if、while等代码块）中声明函数，这种情况下应当将函数赋值给变量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (currentUser) {
      <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> {</span>
        console.log(<span class="string">'Nope.'</span>);
      }
    }

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> test;
    <span class="keyword">if</span> (currentUser) {
      test = <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> {</span>
        console.log(<span class="string">'Yup.'</span>);
      };
    }
</pre></td></tr></table></figure>


<ul>
<li>不要声明<code>arguments</code>变量，这样将覆盖函数作用域的<code>arguments</code>对象（夺取了优先权，导致无法访问函数作用域的<code>arguments</code>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">nope</span><span class="params">(name, options, arguments)</span> {</span>
      <span class="comment">// ...stuff...</span>
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">yup</span><span class="params">(name, options, args)</span> {</span>
      <span class="comment">// ...stuff...</span>
    }
</pre></td></tr></table></figure>


<h2 id="属性">属性</h2>
<ul>
<li>使用符号<code>.</code>来访问属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="keyword">var</span> luke = {
      jedi: <span class="literal">true</span>,
      age: <span class="number">28</span>
    };

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> isJedi = luke[<span class="string">'jedi'</span>];

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> isJedi = luke.jedi;
</pre></td></tr></table></figure>


<ul>
<li>在需要通过变量访问属性时使用中括号<code>[]</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="keyword">var</span> luke = {
      jedi: <span class="literal">true</span>,
      age: <span class="number">28</span>
    };

    <span class="function"><span class="keyword">function</span> <span class="title">getProp</span><span class="params">(prop)</span> {</span>
      <span class="keyword">return</span> luke[prop];
    }

    <span class="keyword">var</span> isJedi = getProp(<span class="string">'jedi'</span>);
</pre></td></tr></table></figure>


<h2 id="变量">变量</h2>
<ul>
<li>使用<code>var</code>来声明变量，这样能避免意外声明全局变量、污染全局命名空间。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    superPower = <span class="keyword">new</span> SuperPower();

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> superPower = <span class="keyword">new</span> SuperPower();
</pre></td></tr></table></figure>


<ul>
<li>每个变量声明新启一行，并在每个声明前面加上<code>var</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
     <span class="keyword">var</span> items = getItems(),
          goSportsTeam = <span class="literal">true</span>,
          dragonball = <span class="string">'z'</span>;

    <span class="comment">// 推荐</span>
     <span class="keyword">var</span> items = getItems();
     <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>;
     <span class="keyword">var</span> dragonball = <span class="string">'z'</span>;
</pre></td></tr></table></figure>


<ul>
<li>先声明需要赋值的变量，后声明不需要赋值的变量。这样后声明的变量能够依靠前面生成变量来生成自己的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> i;
    <span class="keyword">var</span> items = getItems(),
    <span class="keyword">var</span> dragonball,
    <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,
    <span class="keyword">var</span> len;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> items = getItems(),
    <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,
    <span class="keyword">var</span> dragonball,
    <span class="keyword">var</span> length,
    <span class="keyword">var</span> i;
</pre></td></tr></table></figure>


<ul>
<li>在作用域的顶部声明所有变量，这样有助于避免变量提升导致的相关问题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      test();
      console.log(<span class="string">'doing stuff..'</span>);

      <span class="comment">//..other stuff..</span>

      <span class="keyword">var</span> name = getName();

      <span class="keyword">if</span> (name === <span class="string">'test'</span>) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="keyword">return</span> name;
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> name = getName();

      test();
      console.log(<span class="string">'doing stuff..'</span>);

      <span class="comment">//..other stuff..</span>

      <span class="keyword">if</span> (name === <span class="string">'test'</span>) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="keyword">return</span> name;
    }

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> name = getName();

      <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="keyword">var</span> name = getName();

      <span class="keyword">return</span> <span class="literal">true</span>;
    }
</pre></td></tr></table></figure>


<h2 id="模块引用">模块引用</h2>
<ul>
<li>按照如下顺序引用模块<ul>
<li>核心模块</li>
<li>npm上的工具模块</li>
<li>其他模块</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);
    <span class="keyword">var</span> async = <span class="built_in">require</span>(<span class="string">'async'</span>);
    <span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);
    <span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);

    <span class="keyword">var</span> async = <span class="built_in">require</span>(<span class="string">'async'</span>);
    <span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);

    <span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);
</pre></td></tr></table></figure>


<ul>
<li>在模块引用时不要加上<code>.js</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car.js'</span>);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);
</pre></td></tr></table></figure>


<h2 id="回调函数">回调函数</h2>
<ul>
<li>总是在回调函数中检查是否出现错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  <span class="comment">//不推荐</span>
  database.get(<span class="string">'pokemons'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, pokemons)</span> {</span>
    console.log(pokemons);
  });

  <span class="comment">//推荐</span>
  database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, drabonballs)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span>
      <span class="keyword">return</span> console.log(err);
    }
    console.log(drabonballs);
  });
</pre></td></tr></table></figure>


<ul>
<li>回调函数也需要返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>  <span class="comment">//不推荐</span>
  database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, drabonballs)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="comment">// 如果不在这里返回</span>
      console.log(err);
    }
    <span class="comment">// 这一样依旧会执行</span>
    console.log(drabonballs);
  });

  <span class="comment">//推荐</span>
  database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, drabonballs)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span>
      <span class="keyword">return</span> console.log(err);
    }
    console.log(drabonballs);
  });
</pre></td></tr></table></figure>


<h2 id="异常捕获（Try-catch）">异常捕获（Try-catch）</h2>
<ul>
<li><p>只在同步函数中使用Try-catch</p>
<p>Try-catch代码块不能用来包裹异步的代码。Try-catch代码块将冒泡到最顶层，并记录整个冒泡的路径。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>  <span class="comment">//不推荐</span>
  <span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> <span class="params">(callback)</span> {</span>
    fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, file)</span> {</span>
      <span class="keyword">if</span> (err) {
        <span class="keyword">throw</span> err;
      }
      ...
    });
  }
  <span class="comment">//推荐</span>
  <span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> <span class="params">(callback)</span> {</span>
    fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, file)</span> {</span>
      <span class="keyword">if</span> (err) {
        <span class="keyword">return</span>  callback(err);
      }
      ...
    });
  }
</pre></td></tr></table></figure>


<ul>
<li>在同步调用中使用Try-catch捕获异常</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>  <span class="comment">//不推荐</span>
  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonAsAString);

  <span class="comment">//推荐</span>
  <span class="keyword">var</span> data;
  <span class="keyword">try</span> {
    data = <span class="built_in">JSON</span>.parse(jsonAsAString);
  } <span class="keyword">catch</span> (e) {
    <span class="comment">// 处理错误 —— 最好不只是用console.log输出</span>
    console.log(e);
  }
</pre></td></tr></table></figure>


<h2 id="提升">提升</h2>
<ul>
<li>变量声明会提升到作用域顶端，但对这些变量的赋值是不会提升的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="comment">// 如我们所知，这不起作用 （没有同名的全局变量情况下）</span>
    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      console.log(notDefined); <span class="comment">// =&gt; 抛出一个引用错误</span>
    }
    
    <span class="comment">// 在引用一个变量之后创建一个变量声明一样能够正常工作</span>
    <span class="comment">// 这是由于变量会提升。注意：这里赋值`true`并没有被提升</span>
    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      console.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span>
      <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;
    }

    <span class="comment">// 解释器会将变量声明提升到作用域的顶部</span>
    <span class="comment">// 这也就意味着上例可以写成如下方式</span>
    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> declaredButNotAssigned;
      console.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span>
      declaredButNotAssigned = <span class="literal">true</span>;
    }
</pre></td></tr></table></figure>


<ul>
<li>匿名函数表达式只会提升变量定义，函数赋值语句不会提升</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      console.log(anonymous); <span class="comment">// =&gt; undefined</span>

      anonymous(); <span class="comment">// =&gt; TypeError anonymous 不是函数</span>

      <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(<span class="string">'anonymous function expression'</span>);
      };
    }
</pre></td></tr></table></figure>


<ul>
<li>命名函数表达式同样提升变量定义，而不会提升函数名称和函数体</li>
<li>Named function expressions hoist the variable name, not the function name or the function body.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      console.log(named); <span class="comment">// =&gt; undefined</span>

      named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span>

      superPower(); <span class="comment">// =&gt; ReferenceError superPower 未定义</span>

      <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span><span class="params">()</span> {</span>
        console.log(<span class="string">'Flying'</span>);
      };
    }
    
    <span class="comment">// 就算函数名称和变量名称相同，也是一样的</span>
    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      console.log(named); <span class="comment">// =&gt; undefined</span>

      named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span>

      <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span><span class="params">()</span> {</span>
        console.log(<span class="string">'named'</span>);
      }
    }
</pre></td></tr></table></figure>


<ul>
<li>函数声明会提升名称和函数体</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> {</span>
      superPower(); <span class="comment">// =&gt; Flying</span>

      <span class="function"><span class="keyword">function</span> <span class="title">superPower</span><span class="params">()</span> {</span>
        console.log(<span class="string">'Flying'</span>);
      }
    }
</pre></td></tr></table></figure>


<ul>
<li>更多信息可以查看 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" target="_blank">JavaScript Scoping &amp; Hoisting</a> ，作者为 <a href="http://www.adequatelygood.com/" target="_blank">Ben Cherry</a></li>
</ul>
<h2 id="条件表达式和相等判断">条件表达式和相等判断</h2>
<ul>
<li>使用 <code>===</code> 和 <code>!==</code> ，不要用 <code>==</code> 和 <code>!=</code></li>
<li><p>条件表达式计算时会强迫使用<code>ToBoolean</code>方法，并遵循如下规则：</p>
<ul>
<li><strong>Objects</strong> 判定为 <strong>true</strong></li>
<li><strong>Undefined</strong> 判定为 <strong>false</strong></li>
<li><strong>Null</strong> 判定为 <strong>false</strong></li>
<li><strong>Booleans</strong> 判定为 <strong>the value of the boolean</strong></li>
<li><strong>Numbers</strong> 如果为 <strong>+0, -0, or NaN</strong> 判定为 <strong>false</strong>，否则为 <strong>true</strong></li>
<li><strong>Strings</strong> 如果为 空字符串 <code>&#39;&#39;</code> 判定为 <strong>false</strong> 否则为 <strong>true</strong></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">if</span> ([<span class="number">0</span>]) {
      <span class="comment">// true</span>
      <span class="comment">// 数组也是对象，对象都判定为true</span>
    }
</pre></td></tr></table></figure>


<ul>
<li>善于简写</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (name !== <span class="string">''</span>) {
      <span class="comment">// ...stuff...</span>
    }

    <span class="comment">// 推荐</span>
    <span class="keyword">if</span> (name) {
      <span class="comment">// ...stuff...</span>
    }

    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) {
      <span class="comment">// ...stuff...</span>
    }

    <span class="comment">// 推荐</span>
    <span class="keyword">if</span> (collection.length) {
      <span class="comment">// ...stuff...</span>
    }
</pre></td></tr></table></figure>


<ul>
<li>更多信息请查看Angus Croll所著的 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank">Truth Equality and JavaScript</a> </li>
</ul>
<h2 id="代码块">代码块</h2>
<ul>
<li>在所有多行代码块时都是用大括号</li>
<li>Use braces with all multi-line blocks.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (test)
      <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">if</span> (test) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="keyword">return</span> <span class="literal">false</span>; }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
</pre></td></tr></table></figure>


<h2 id="注释">注释</h2>
<ul>
<li>使用<code>/**....*/</code>包裹多行注释，这种注释包括描述、参数及返回值的类型和值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="comment">// make() returns a new element</span>
    <span class="comment">// based on the passed in tag name</span>
    <span class="comment">//</span>
    <span class="comment">// @param &lt;String&gt; tag</span>
    <span class="comment">// @return &lt;Element&gt; element</span>
    <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">(tag)</span> {</span>

      <span class="comment">// ...stuff...</span>

      <span class="keyword">return</span> element;
    }

    <span class="comment">// 推荐</span>
    <span class="comment">/**
     * make() returns a new element
     * based on the passed in tag name
     *
     * @param &lt;String&gt; tag
     * @return &lt;Element&gt; element
     */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">(tag)</span> {</span>

      <span class="comment">// ...stuff...</span>

      <span class="keyword">return</span> element;
    }
</pre></td></tr></table></figure>


<ul>
<li>单行注释时使用<code>//</code>。每一个单行注释在需要注释的位置上面新启一行。并在注释前加一个空行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span>

    <span class="comment">// 推荐</span>
    <span class="comment">// is current tab</span>
    <span class="keyword">var</span> active = <span class="literal">true</span>;

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">getType</span><span class="params">()</span> {</span>
      console.log(<span class="string">'fetching type...'</span>);
      <span class="comment">// 设定默认值为'no type'</span>
      <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;

      <span class="keyword">return</span> type;
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">getType</span><span class="params">()</span> {</span>
      console.log(<span class="string">'fetching type...'</span>);

      <span class="comment">// 设定默认值为'no type'</span>
      <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;

      <span class="keyword">return</span> type;
    }
</pre></td></tr></table></figure>


<ul>
<li><p>在注释前增加<code>FIXME</code>或<code>TODO</code>来帮助其他开发者快速理解这里出现了一个问题或是需要提供实现。这种注释和常规的注释不同，它是可操作的。这些操作为<code>FIXME -- 需要弄清楚</code>或是<code>TODO -- 需要添加实现</code></p>
</li>
<li><p>使用 <code>// FIXME:</code> 来标注问题</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Calculator</span><span class="params">()</span> {</span>

      <span class="comment">// FIXME: 这里不应该有全局变量</span>
      total = <span class="number">0</span>;

      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
</pre></td></tr></table></figure>


<ul>
<li>使用 <code>// TODO:</code> 来标注问题的解法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Calculator</span><span class="params">()</span> {</span>

      <span class="comment">// TODO: total应该通过参数来配置</span>
      <span class="keyword">this</span>.total = <span class="number">0</span>;

      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
</pre></td></tr></table></figure>


<h2 id="空格">空格</h2>
<ul>
<li>将TAB设置成两个空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ∙∙∙∙<span class="keyword">var</span> name;
    }

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ∙<span class="keyword">var</span> name;
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ∙∙<span class="keyword">var</span> name;
    }
</pre></td></tr></table></figure>


<ul>
<li>在大括号前加个空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span>{</span>
      console.log(<span class="string">'test'</span>);
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> {</span>
      console.log(<span class="string">'test'</span>);
    }

    <span class="comment">// 不推荐</span>
    dog.set(<span class="string">'attr'</span>,{
      age: <span class="string">'1 year'</span>,
      breed: <span class="string">'Bernese Mountain Dog'</span>
    });

    <span class="comment">// 推荐</span>
    dog.set(<span class="string">'attr'</span>, {
      age: <span class="string">'1 year'</span>,
      breed: <span class="string">'Bernese Mountain Dog'</span>
    });
</pre></td></tr></table></figure>


<ul>
<li>在操作符旁边加上空格</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> x=y+<span class="number">5</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> x = y + <span class="number">5</span>;
</pre></td></tr></table></figure>


<ul>
<li>以一个换行符结束文件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    (<span class="function"><span class="keyword">function</span><span class="params">(global)</span> {</span>
      <span class="comment">// ...stuff...</span>
    })(<span class="keyword">this</span>);
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    (<span class="function"><span class="keyword">function</span><span class="params">(global)</span> {</span>
      <span class="comment">// ...stuff...</span>
    })(<span class="keyword">this</span>);↵
    ↵
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="comment">// 推荐</span>
    (<span class="function"><span class="keyword">function</span><span class="params">(global)</span> {</span>
      <span class="comment">// ...stuff...</span>
    })(<span class="keyword">this</span>);↵
</pre></td></tr></table></figure>


<ul>
<li></li>
<li>为长的链式方法调用增加缩进</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    $(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();

    <span class="comment">// 推荐</span>
    $(<span class="string">'#items'</span>)
      .find(<span class="string">'.selected'</span>)
        .highlight()
        .end()
      .find(<span class="string">'.open'</span>)
        .updateCount();

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)
        .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)
        .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)
        .call(tron.led);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>)
        .data(data)
      .enter().append(<span class="string">'svg:svg'</span>)
        .class(<span class="string">'led'</span>, <span class="literal">true</span>)
        .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>)
      .append(<span class="string">'svg:g'</span>)
        .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)
        .call(tron.led);
</pre></td></tr></table></figure>


<h2 id="逗号">逗号</h2>
<ul>
<li>以逗号启始: <strong>不</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> hero = {
        firstName: <span class="string">'Bob'</span>
      , lastName: <span class="string">'Parr'</span>
      , heroName: <span class="string">'Mr. Incredible'</span>
      , superPower: <span class="string">'strength'</span>
    };

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> hero = {
      firstName: <span class="string">'Bob'</span>,
      lastName: <span class="string">'Parr'</span>,
      heroName: <span class="string">'Mr. Incredible'</span>,
      superPower: <span class="string">'strength'</span>
    };
</pre></td></tr></table></figure>


<ul>
<li><p>在结尾加上逗号：<em>不</em>。这将在IE6/7和IE9的怪异模式中引发一些问题。而且，如果在数组中这么做，在一些ES3的实现中会增加数组的长度。这在ES5中做了修正(<a href="http://es5.github.io/#D" target="_blank">source</a>)：</p>
<blockquote>
<p>Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> hero = {
      firstName: <span class="string">'Kevin'</span>,
      lastName: <span class="string">'Flynn'</span>,
    };

    <span class="keyword">var</span> heroes = [
      <span class="string">'Batman'</span>,
      <span class="string">'Superman'</span>,
    ];

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> hero = {
      firstName: <span class="string">'Kevin'</span>,
      lastName: <span class="string">'Flynn'</span>
    };

    <span class="keyword">var</span> heroes = [
      <span class="string">'Batman'</span>,
      <span class="string">'Superman'</span>
    ];
</pre></td></tr></table></figure>


<h2 id="分号">分号</h2>
<ul>
<li>永远使用分号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>
      <span class="keyword">return</span> name
    })()

    <span class="comment">// 推荐</span>
    (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;
      <span class="keyword">return</span> name;
    })();

    <span class="comment">// 推荐</span>
    ;(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;
      <span class="keyword">return</span> name;
    })();
</pre></td></tr></table></figure>


<h2 id="类型转换和强制类型转换">类型转换和强制类型转换</h2>
<ul>
<li>在声明开头进行强制类型转换</li>
<li>字符串:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="comment">//  =&gt; this.reviewScore = 9;</span>

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;
</pre></td></tr></table></figure>


<ul>
<li>使用 <code>parseInt</code> 转换成数字并总是加上进制数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="keyword">var</span> inputValue = <span class="string">'4'</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> val = +inputValue;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> val = <span class="built_in">Number</span>(inputValue);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);
</pre></td></tr></table></figure>


<ul>
<li>如果你出于某种原因做一些非常规的需求且<code>parseInt</code>是你性能的瓶颈，必须用位操作<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank">提升性能</a>时，添加注释来解释为什么这么做、到底做了什么。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="comment">// 推荐</span>
    <span class="comment">/**
     * parseInt是性能不佳的原因
     * 位操作强制将一个String转换为Number要快得多
     */</span>
    <span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;
</pre></td></tr></table></figure>


<ul>
<li><strong>注意:</strong> 使用位操作时需要注意。所有的数字都是<a href="http://es5.github.io/#x4.3.19" target="_blank">64位浮点型</a>，但位操作经常返回32位整型（<a href="http://es5.github.io/#x11.7" target="_blank">请看</a>）。位操作会在值大于32位时发生一些问题。<a href="https://github.com/airbnb/javascript/issues/109" target="_blank">这里有一些关于此的讨论</a>。最大的有符号整型是 2,147,483,647</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span>
    <span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span>
    <span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span>
</pre></td></tr></table></figure>


<ul>
<li>布尔类型:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="keyword">var</span> age = <span class="number">0</span>;

    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> hasAge = <span class="built_in">Boolean</span>(age);

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> hasAge = !!age;
</pre></td></tr></table></figure>


<h2 id="命名约定">命名约定</h2>
<ul>
<li>避免单字母的命名。命名应该能够自解释</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">q</span><span class="params">()</span> {</span>
      <span class="comment">// ...stuff...</span>
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">()</span> {</span>
      <span class="comment">// ..stuff..</span>
    }
</pre></td></tr></table></figure>


<ul>
<li>在命名对象、函数和实例的时候使用驼峰命名法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> OBJEcttsssss = {};
    <span class="keyword">var</span> this_is_my_object = {};
    <span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">()</span> {</span>}
    <span class="keyword">var</span> u = <span class="keyword">new</span> user({
      name: <span class="string">'Bob Parr'</span>
    });

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> thisIsMyObject = {};
    <span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span><span class="params">()</span> {</span>}
    <span class="keyword">var</span> user = <span class="keyword">new</span> User({
      name: <span class="string">'Bob Parr'</span>
    });
</pre></td></tr></table></figure>


<ul>
<li>在命名构造函数和类时使用帕斯卡构造法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">user</span><span class="params">(options)</span> {</span>
      <span class="keyword">this</span>.name = options.name;
    }

    <span class="keyword">var</span> bad = <span class="keyword">new</span> user({
      name: <span class="string">'nope'</span>
    });

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">(options)</span> {</span>
      <span class="keyword">this</span>.name = options.name;
    }

    <span class="keyword">var</span> good = <span class="keyword">new</span> User({
      name: <span class="string">'yup'</span>
    });
</pre></td></tr></table></figure>


<ul>
<li>命名私有属性时添加<code>_</code>前缀</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;
    <span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;

    <span class="comment">// 推荐</span>
    <span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;
</pre></td></tr></table></figure>


<ul>
<li>当需要保存一个<code>this</code>的引用时，使用<code>_this</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(self);
      };
    }

    <span class="comment">// 不推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> that = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(that);
      };
    }

    <span class="comment">// 推荐</span>
    <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">var</span> _this = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log(_this);
      };
    }
</pre></td></tr></table></figure>


<ul>
<li>总是为函数命名，这样有助于栈的追踪</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span><span class="params">(msg)</span> {</span>
      console.log(msg);
    };

    <span class="comment">// 推荐</span>
    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(msg)</span> {</span>
      console.log(msg);
    };
</pre></td></tr></table></figure>


<h2 id="访问器">访问器</h2>
<ul>
<li>一般不需要属性的访问器函数</li>
<li>如果要创造属性的访问器函数，使用 getVal() 和 setVal(‘hello’)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    dragon.age();

    <span class="comment">// 推荐</span>
    dragon.getAge();

    <span class="comment">// 不推荐</span>
    dragon.age(<span class="number">25</span>);

    <span class="comment">// 推荐</span>
    dragon.setAge(<span class="number">25</span>);
</pre></td></tr></table></figure>


<ul>
<li>如果属性时布尔类型，使用 isVal() 或 hasVal()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    <span class="keyword">if</span> (!dragon.age()) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// 推荐</span>
    <span class="keyword">if</span> (!dragon.hasAge()) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
</pre></td></tr></table></figure>


<ul>
<li>可以创建 get() 和 set() 方法，但必须一致</li>
<li>It’s okay to create get() and set() functions, but be consistent.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Jedi</span><span class="params">(options)</span> {</span>
      options || (options = {});
      <span class="keyword">var</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;
      <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);
    }

    Jedi.prototype.set = <span class="function"><span class="keyword">function</span><span class="params">(key, val)</span> {</span>
      <span class="keyword">this</span>[key] = val;
    };

    Jedi.prototype.get = <span class="function"><span class="keyword">function</span><span class="params">(key)</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>[key];
    };
</pre></td></tr></table></figure>


<h2 id="构造函数">构造函数</h2>
<ul>
<li>给构造函数的prototype对象增加新方法，不要直接给prototype重写一个新的对象。重写prototype对象会导致无法继承：重写prototype将覆盖掉基类。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Jedi</span><span class="params">()</span> {</span>
      console.log(<span class="string">'new jedi'</span>);
    }

    <span class="comment">// 不推荐</span>
    Jedi.prototype = {
      fight: <span class="function"><span class="keyword">function</span> <span class="title">fight</span><span class="params">()</span> {</span>
        console.log(<span class="string">'fighting'</span>);
      },

      block: <span class="function"><span class="keyword">function</span> <span class="title">block</span><span class="params">()</span> {</span>
        console.log(<span class="string">'blocking'</span>);
      }
    };

    <span class="comment">// 推荐</span>
    Jedi.prototype.fight = <span class="function"><span class="keyword">function</span> <span class="title">fight</span><span class="params">()</span> {</span>
      console.log(<span class="string">'fighting'</span>);
    };

    Jedi.prototype.block = <span class="function"><span class="keyword">function</span> <span class="title">block</span><span class="params">()</span> {</span>
      console.log(<span class="string">'blocking'</span>);
    };
</pre></td></tr></table></figure>


<ul>
<li>可以为方法返回<code>this</code>方便链式调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>    <span class="comment">// 不推荐</span>
    Jedi.prototype.jump = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">this</span>.jumping = <span class="literal">true</span>;
      <span class="keyword">return</span> <span class="literal">true</span>;
    };

    Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span><span class="params">(height)</span> {</span>
      <span class="keyword">this</span>.height = height;
    };

    <span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();
    luke.jump(); <span class="comment">// =&gt; true</span>
    luke.setHeight(<span class="number">20</span>) <span class="comment">// =&gt; undefined</span>

    <span class="comment">// 推荐</span>
    Jedi.prototype.jump = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">this</span>.jumping = <span class="literal">true</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span><span class="params">(height)</span> {</span>
      <span class="keyword">this</span>.height = height;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    <span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();

    luke.jump()
      .setHeight(<span class="number">20</span>);
</pre></td></tr></table></figure>


<ul>
<li>可以重写toString()方法，只要它能正常工作且不会有副作用就行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">Jedi</span><span class="params">(options)</span> {</span>
      options || (options = {});
      <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;
    }

    Jedi.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.name;
    };

    Jedi.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="string">'Jedi - '</span> + <span class="keyword">this</span>.getName();
    };
</pre></td></tr></table></figure>


<p><strong>推荐的书籍</strong></p>
<ul>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank">JavaScript语言精粹</a> - Douglas Crockford</li>
<li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" target="_blank">JavaScript模式</a> - Stoyan Stefanov</li>
<li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" target="_blank">JavaScript设计模式</a>  - Ross Harmes and Dustin Diaz</li>
<li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" target="_blank">高性能网站建设指南</a> - Steve Souders</li>
<li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" target="_blank">编写可维护的JavaScript</a> - Nicholas C. Zakas</li>
<li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" target="_blank">JavaScript Web 富应用开发</a> - Alex MacCaw</li>
<li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" target="_blank">Pro JavaScript Techniques</a> - John Resig</li>
<li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" target="_blank">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li>
<li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" target="_blank">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li>
<li><a href="http://humanjavascript.com/" target="_blank">Human JavaScript</a> - Henrik Joreteg</li>
<li><a href="http://superherojs.com/" target="_blank">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li>
<li><a href="http://jsbooks.revolunet.com/" target="_blank">JSBooks</a></li>
<li><a href="http://manning.com/vinegar/" target="_blank">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li>
</ul>
<p><strong>推荐的博客</strong></p>
<ul>
<li><a href="http://dailyjs.com/" target="_blank">DailyJS</a></li>
<li><a href="http://javascriptweekly.com/" target="_blank">JavaScript Weekly</a></li>
<li><a href="http://javascriptweblog.wordpress.com/" target="_blank">JavaScript, JavaScript…</a></li>
<li><a href="http://weblog.bocoup.com/" target="_blank">Bocoup Weblog</a></li>
<li><a href="http://www.adequatelygood.com/" target="_blank">Adequately Good</a></li>
<li><a href="http://www.nczonline.net/" target="_blank">NCZOnline</a></li>
<li><a href="http://perfectionkills.com/" target="_blank">Perfection Kills</a></li>
<li><a href="http://benalman.com/" target="_blank">Ben Alman</a></li>
<li><a href="http://dmitry.baranovskiy.com/" target="_blank">Dmitry Baranovskiy</a></li>
<li><a href="http://dustindiaz.com/" target="_blank">Dustin Diaz</a></li>
<li><a href="http://net.tutsplus.com/?s=javascript" target="_blank">nettuts</a></li>
</ul>
<h2 id="JavaScript风格指南">JavaScript风格指南</h2>
<ul>
<li><a href="https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide" target="_blank">查看</a></li>
</ul>
<h2 id="项目贡献者">项目贡献者</h2>
<ul>
<li><a href="https://github.com/airbnb/javascript/graphs/contributors" target="_blank">查看贡献者</a></li>
</ul>
<h2 id="License">License</h2>
<p>MIT</p>
<h1 id="};">};</h1>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide" target="_blank">RisingStack/node-style-guide</a></p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建华丽UI的7条准则（上部）]]></title>
    <link href="http://lingyu.wang/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/"/>
    <id>http://lingyu.wang/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/</id>
    <published>2014-11-23T16:00:00.000Z</published>
    <updated>2014-11-24T09:13:40.330Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自Erik D. Kennedy的<a href="https://medium.com/@erikdkennedy/7-rules-for-creating-gorgeous-ui-part-1-559d4e805cda?hn=1" target="_blank">7 Rules for Creating Gorgeous UI (Part 1)</a></p>
<a id="more"></a>

<h2 id="简介">简介</h2>
<p>好吧，首先需要说明的是，这篇指南并不适合每一个人。那么它适合哪些人呢？</p>
<ul>
<li>那些要在紧要关头设计他们自己的好看的UI的<strong>开发者</strong></li>
<li>那些希望自己的作品集看起来比五边形PPT更炫酷或是那些将优秀的用户体验和漂亮的UI打包出售的<strong>用户体验（以下简称UX）设计师</strong></li>
</ul>
<p>如果你曾经上过艺术学校，或是认为自己已经是一个UI设计师，你很可能会觉着这篇指南充斥着a.) 无聊, b.) 错误, and c.) 不爽。没关系。你的所有批评都是对的。关掉页面，该干啥干啥。</p>
<p>让我来告诉你这篇指南里都有些什么。</p>
<p>首先，我是一个没有UI技能的UX设计师。我喜欢设计用户体验，但<br>我干的时间不长，直到我了解到如下这些驱动我去学界面美化的原因：</p>
<ul>
<li>我的作品集看起来很废，无法很好的反映我的工作和思想进程；</li>
<li>我的UX咨询客户更愿意去找那些不只会画方框和箭头，而懂得更多专业知识的人；</li>
<li>我是否在某些时候需要在项目初期干活？不只是帮忙扫扫地</li>
</ul>
<p>我有我自己的理由。我并不了解垃圾美学观。我是个做工程的，而最令我自豪的就是构建一些帅气的东西。</p>
<p>最后，我学到了应用程序的每学，它和任何其他创造性的活动中的一样：冰冷，难以分析。以及无耻的从他人作品中模仿。我曾在一个UI项目上花费了10个小时，但只赚了一个小时的钱。其他的9个小时都是在瞎逛式的学习。无休止的搜索Google、Pinterest和Dribbble来找可以模仿的作品。</p>
<p>这些准则就是这样总结出来的</p>
<p><strong>所以有一些话希望告诉那些书呆子们：如果做出了优秀的设计，并不是因为我参透了美感和平衡，而是因为我分析出了成果。</strong></p>
<p>这篇文章并不是一些理论，都是纯粹的应用。你不会看到任何和黄金分割相关的东西。我甚至都没有提及色彩理论。只有那些我不断失败不断练习所学到的东西。</p>
<p>可以这样说：柔道是基于几个世纪的日本无数和哲学传统发展而来的。你参与了柔道训练，并进行了实战，你就会听到很多关于能量、流动、平和以及之类的东西。</p>
<p>另一方面，马伽术是一些在20世纪30年代捷克斯洛伐克的一些强硬的犹太人，为了在街头对抗纳粹所发明的。其中没有任何艺术科研，在它的课程中，你学到的是如何通过一支笔去刺瞎别人的眼镜。</p>
<p>这里就是屏幕上的马伽术</p>
<p>这些准则包括：</p>
<ol>
<li>光来自天空</li>
<li>黑白先行</li>
<li>使用双倍的留白</li>
<li>学习如何在图像上叠加文字</li>
<li>让文字弹出——并且反流行</li>
<li>仅使用好的字体</li>
<li>像艺术家一样去偷</li>
</ol>
<p>让我们开始吧</p>
<h2 id="准则一：光来自天空">准则一：光来自天空</h2>
<p><em>阴影是用来帮助大脑用来分辨用户界面上元素的宝贵线索</em></p>
<p>这可能是在学习UI设计中<strong>最重要且常被忽略</strong>的了：光来自天空。光线时常来自于天空，如果从下方来的话会看起来很怪异。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/1.jpeg" alt="wooooo"></p>
<p>当光线来自天空，它照亮了物体的顶部并在他们下方留下阴影。物体的顶部更亮，底部更暗。</p>
<p>你不会把人的下眼睑当做特别的阴影，但当光照在上面时，瞬间就好像一个妖娆的女孩站在你的门前。</p>
<p>是的，UI也是一样。正如我们的所有五官下侧都会有较小的阴影，在我们所看到的每个UI元素下面也有阴影。<strong>屏幕是扁平的，但我们已经找到了很多方法使得他们看起来像是3D的</strong></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/2.png" alt="My favorite part of this image is the poker finger in the lower-right."></p>
<p>就拿按钮来说。即使这种相对“扁平”的按钮，它仍有一些与光线相关的细节：</p>
<ol>
<li>未按下的按钮（上图）有一个较暗的底部边缘。太阳光照不到那里；</li>
<li>未按下的按钮的<strong>顶部比底部稍微亮一些</strong>。这是因为它模拟了一个稍微弯曲的表面。就和你需要倾斜你面前的镜子才能看到里面的太阳一样，倾斜向上的表面对你反射了的太阳光多了那么一点点；</li>
<li>未按下的按钮蒙上了<strong>细微的阴影</strong>，可能你将部分进行放大才能看见</li>
<li>按下的按钮，底部依然要比顶部更暗，但它<strong>整体都变暗了</strong>——这是因为它在屏幕同意平面上，而光不再那么容易地照到它。可能有人会说了，现实生活中我们按下的按钮颜色也会较深，事实上那是因为我们的双手遮挡住了光线。</li>
</ol>
<p>这只是一个按钮，但也呈现出4个小的光线效果。那么问题来了，我们需要将这些运用到所有元素下。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/3.png" alt="iOS 6 is a little outdated, but it makes a good case study in light behavior."></p>
<p>这是iOS 6的“请勿打扰”和“通知”的设定。很漂亮不是吗？那么我们来看看它有多少光线效果。</p>
<ul>
<li>面板的顶部上有细小的阴影</li>
<li>“ON”开关的滑动轨道上也有</li>
<li>“ON”开关的滑动轨道是凹陷的，而底部反射更多的光</li>
<li>图标突出了一点，是否看到它顶部的边框更亮？这代表了一个垂直于光源的面，因此接收到了不少的光，也因此反射更多光到你眼睛</li>
<li>面板分割的缺口远离阳光的角度蒙有阴影，反之亦然</li>
</ul>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/4.png" alt="A close-up of a divider notch. From an old Hubster concept of mine."></p>
<p>以下元素通常看起来是<strong>内嵌</strong>的：</p>
<ul>
<li>文本输入框</li>
<li>按下的按钮</li>
<li>开关的滑动轨道</li>
<li>单选按钮（未被选择）（radio）</li>
<li>复选按钮（checkbox）</li>
</ul>
<p>以下元素通常看起来是<strong>外凸</strong>的：</p>
<ul>
<li>按钮（未按下）</li>
<li>开关</li>
<li>下拉控件</li>
<li>卡片</li>
<li>被选择的单选按钮的按钮部分</li>
<li>弹出窗口</li>
</ul>
<p>现在你学到了，你会发现到处都是这样。欢迎你，孩子</p>
<h3 id="等等，扁平化设计怎么办呢，Erik？">等等，扁平化设计怎么办呢，Erik？</h3>
<p>iOS7的“扁平化设计”轰动了技术社区。如字面上所说，它是平的。没有凸起或凹陷，只是纯色的线条和形状。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/5.png" alt="iOS 7 扁平设计"></p>
<p>我和后面那个家伙一样喜欢干净和简洁，但我不认为这是个长期的趋势。我们在界面上对于3D的模拟，还远远没有自然到能够放弃一切。</p>
<p><strong>很有可能在不久的将来我们就会见到半扁平UI</strong>（我推荐你能够精通这样的设计）。进一步可以称之为“扁平化的设计（flatty design）”。依然干净，依然简洁，但那些需要触碰、滑动、点击的元素会有一些阴影和线索。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/6.png" alt="OS X Yosemite—不只是扁平，而是扁平化"></p>
<p>在我写这篇文章时，Google在他们的产品之上推出了“Material Design”语言。这是一个统一的视觉语言，它的核心思想就旨在模仿现实世界。</p>
<p>从Material Design的设计图中可以看出，它展示了如何通过不同的阴影来表现元素不同的深度。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/7.png" alt="Material Design 1"></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/8.png" alt="Material Design 2"></p>
<p>这是我一直坚持做的事情。</p>
<p>它采用了细微的现实世界的线索来传达信息。<strong>关键字，细微</strong>。</p>
<p>你不能说它没有模仿现实世界，但也没有像2006年的网站上那样的纹理、渐变和光亮。</p>
<p>我认为扁平化是未来。扁平？那只是过去。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/9.png" alt="扁平设计现在似乎大热"></p>
<h2 id="规则二——黑白先行">规则二——黑白先行</h2>
<p><em>在添加颜色之前使用灰度进行设计能让最复杂元素的视觉设计也变得简单。</em></p>
<p>如今UX设计师也进行“移动先行”的设计。这就意味着，先在手机上考虑页面样式及交互，然后再扩展到高像素的Retina屏幕上</p>
<p><strong>这是个非常好的约束。它传达了一个思想。</strong>先从困难的问题开始（在较小的屏幕上可用的应用程序），然后将解决方案适配到简单的问题上（在大屏幕上可用的应用程序）。</p>
<p>还有一个类似的约束：先用黑白进行设计。在没有颜色的帮助下，以让应用在各个角度下漂亮且可用这样的困难问题作为开始。最后再添加颜色，即使如此，明确目标。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/10.png" alt="Haraldur Thorleifsson’s grayscale wireframes look as good as lesser designer’s finished sites."></p>
<p>这是一个保持应用程序看起来“简洁”的较为可靠且简单的方式。<strong>过多的颜色很容易破坏“简洁”。</strong>黑白先行使得你更加专注于留白、尺寸和布局。而这些正式“简洁”设计所关注的。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/11.png" alt="Classy grayscale."><br><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/12.jpeg" alt="Classy grayscale."><br><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/13.png" alt="Classy grayscale."></p>
<p>在某些情况下黑白先行并没有效果。那些有很强特定风格的设计——“运动的”、“浮华的”、“卡通的”，等等——需要设计师非常好的使用颜色。但<strong>大多数应用程序除了“简洁”以外都没有特定的风格。</strong>不可否认，那些设计更难。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/14.png" alt="Flashy and vibrant designs by Julien Renvoye (left) and Cosmin Capitanu (right). Harder than it looks."></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/15.png" alt="Flashy and vibrant designs by Julien Renvoye (left) and Cosmin Capitanu (right). Harder than it looks."></p>
<p>对于其他的，都可以用黑白先行</p>
<h3 id="第二步：如何上色">第二步：如何上色</h3>
<p>最简单的上色方式就是只添加一种颜色</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/16.png" alt="添加一种颜色"></p>
<p>往黑白的网页中添加一种颜色是简单而有效地吸引眼球方式</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/17.png" alt="添加一种颜色"></p>
<p>你也可以更进一步，灰度+两种颜色，或是灰度+单一色调的多种颜色</p>
<blockquote>
<p><strong>实践中的色码——等等，什么事色调？</strong></p>
<p>网页和大多数人都是用16进制RGB编码表示颜色。最好忽略这些。RGB并不是一个好的颜色设计框架。<a href="http://demosthenes.info/blog/61/An-Easy-Guide-To-HSL-Color-In-CSS3" target="_blank">HSB</a>更有用（HSB与HSV或HSL“基本上是同义的”）</p>
<p>HSB比RGB更好，以为它符合我们自然思考颜色的方式，你能从HSB值的改变中预测到颜色的变化。</p>
<p>如果这对你来说是个新闻，这里有一个对于<a href="http://demosthenes.info/blog/61/An-Easy-Guide-To-HSL-Color-In-CSS3" target="_blank">HSB颜色的介绍</a>。</p>
</blockquote>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/18.jpeg" alt="来自Smashing Magazine的单色调的金色主题"></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/19.jpeg" alt="来自Smashing Magazine的单色调的蓝色主题"></p>
<p>通过修改单一色相的<strong>饱和度</strong>和<strong>亮度</strong>，可以生成更多的颜色——深色的、浅色的、当背景的、做强调的、吸引眼球的——但它并不会在你眼前压倒一切。</p>
<p>使用来自一种或两种色相的多个颜色是在<strong>不破坏设计的前提下突出和弱化元素的最可靠的方法。</strong></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/20.png" alt="Countdown timer by Kerem Suer"></p>
<h2 id="颜色使用的一些其他的注意事项">颜色使用的一些其他的注意事项</h2>
<p>颜色是视觉设计中最复杂的部分。虽然颜色上的很多东西并不精细，而且对于你面前的设计并不适用，我还是看到了一些不错的东西：</p>
<p>一些小工具：</p>
<ul>
<li><a href="http://ianstormtaylor.com/design-tip-never-use-black/" target="_blank">永远不要使用纯黑</a> (Ian Storm Taylor)。这篇文章中说，纯粹的灰色几乎不会出现在现实世界，灰色的色调的饱和度——尤其是较暗的色调——能为你的设计添加丰富的视觉效果。此外，饱和的灰色更好的模拟了现实世界，这正是它的美之所在。</li>
<li><a href="https://color.adobe.com/" target="_blank">Adobe Color CC</a>.一个用来发现、修改和创建颜色方案的优秀工具</li>
<li><a href="https://dribbble.com/colors/BADA55" target="_blank">通过颜色搜索Dribbble</a>. 另外一个找到某一个特定颜色实践的不错方式。这很实用。如果你已经决定使用某个颜色，看看世界上最好的设计师们如何使用这个颜色。</li>
</ul>
<h2 id="规则三：使用双倍的留白">规则三：使用双倍的留白</h2>
<p><em>增加更多呼吸空间可以让你的UI看起来有设计感</em></p>
<p>我曾在规则二中说过，“黑白先行”迫使设计师在考虑配色之前先考虑留白和布局，以及这为什么好。那么，现在来聊聊留白和布局。</p>
<p>如果你曾在<a href="http://baike.baidu.com/subview/526745/15420063.htm" target="_blank">scratch</a>（一款面向少年的简易编程工具），你可能比较熟悉HTML默认情况下在页面上的布局。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/21.png" alt="页面上默认的布局"></p>
<p>基本上，一切都被堆砌在屏幕的顶端。字体比较小，行与行之间完全没有空白。段与段之间有那么一丁点的空白，但并不多。各个段落随着页面伸缩，不管是100像素，还是10000像素。</p>
<p>从美学上讲，这非常的难看。<strong>如果你希望你的UI看起来有设计感，你需要给它增加一些呼吸的空间。</strong></p>
<p>有时候需要的留白很夸张。</p>
<blockquote>
<p>留白、HTML和CSS</p>
<p>如果你，和我一样，曾经使用CSS来实现各种格式，<strong>默认情况下没有留白</strong>，现在是时候从中解脱出来了。试着默认情况下从留白开始思考——一切都以空白开始，直到你拿一个元素来替换它。</p>
<p>很有禅意对吗？我想这是一个人们这么设计的重要原因。</p>
<p><strong>从一个空白页面开始，意味着以一个只有空白的页面开始。</strong>你在一开始就考虑外边距和留白。你画的所有东西都是有意识的在删除空白。</p>
<p><strong>从一堆没样式的HTML开始意味着从内容出发。</strong>事后再考虑空白。必须正确的描述这些。</p>
</blockquote>
<p>以下是<a href="http://www.piotrkwiatkowski.co.uk/" target="_blank">Piotr Kwiatkowski</a>的一个音乐播放器的设计图</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/22.jpeg" alt="音乐播放器"></p>
<p>尤其注意左边的菜单</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/23.png" alt="左侧的菜单"></p>
<p>在两个菜单项的垂直空白是文字本身的两倍。12px的字体，上下的内边距也是一样。</p>
<p>再看一下列表的标题。在单词“PLAYLISTS”上下有15像素的留白，而且它有下划线。也就是说，在列表与列表之间相距25px。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/24.png" alt="导航条上有更多的空白。“Search all music”的文字大小只占导航条高度的20%。图标也差不多大"></p>
<p>不错，大的空白能让凌乱的界面看起来更加诱人和简单——比如下面这个论坛。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/25.png" alt="Matt Sisto设计的论坛"></p>
<p>或者维基百科。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/26.png" alt="Aurélien Salomon设计的维基百科"></p>
<p>你会发现存在很多争议说，这个重新设计的维基百科省去了使用网页的关键功能。但你必须承认，这是一个不错的学习体验。</p>
<p>增加线条之间的留白</p>
<p>增加元素之间的留白</p>
<p>增加每组元素之间的留白</p>
<p><strong>分析是什么在起作用</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自Erik D. Kennedy的<a href="https://medium.com/@erikdkennedy/7-rules-for-creating-gorgeous-ui-part-1-559d4e805cda?hn=1" target="_blank">7 Rules for Creating Gorgeous UI (Part 1)</a></p>
]]>
    
    </summary>
    
      <category term="设计" scheme="http://lingyu.wang/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Peertc和五子棋]]></title>
    <link href="http://lingyu.wang/2014/11/18/peertc-and-fivechess/"/>
    <id>http://lingyu.wang/2014/11/18/peertc-and-fivechess/</id>
    <published>2014-11-17T16:00:00.000Z</published>
    <updated>2014-11-18T09:27:46.931Z</updated>
    <content type="html"><![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc" target="_blank">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess" target="_blank">五子棋</a></p>
<a id="more"></a>

<h2 id="缘起">缘起</h2>
<p>之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：</p>
<ul>
<li>FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。</li>
<li>在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。</li>
</ul>
<p>五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用<a href="https://github.com/Operational-Transformation/ot.js" target="_blank">OT.js</a>，只能等有时间的时候去弄了。</p>
<p>FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。</p>
<h2 id="Peertc">Peertc</h2>
<p><a href="https://github.com/LingyuCoder/peertc" target="_blank">Peertc</a>是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和<a href="https://www.npmjs.org/package/ws" target="_blank">ws</a>在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。</p>
<p>至于Peertc具体如何建立点对点连接，我已经在文章<a href="http://lingyu.wang/2014/10/21/datachannel/">使用WebRTC DataChannel在浏览器间传递数据</a>中通过老姚和老刘的故事介绍过了</p>
<p>如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了</p>
<h2 id="五子棋">五子棋</h2>
<p>我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。</p>
<h3 id="实现">实现</h3>
<p>一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。</p>
<p>状态也只有4个：</p>
<ol>
<li>黑色落子</li>
<li>白色落子</li>
<li>黑色获胜</li>
<li>白色获胜</li>
</ol>
<p>状态转移：</p>
<ul>
<li>初始状态为黑色落子</li>
<li>黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子</li>
<li>白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子</li>
</ul>
<p>所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单</p>
<h3 id="AI">AI</h3>
<p>为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：</p>
<ol>
<li>这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑</li>
<li>下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中</li>
<li>连着的越多，越靠近胜利</li>
<li>放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）</li>
</ol>
<h2 id="双人对战">双人对战</h2>
<p>既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。</p>
<p>这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。</p>
<p>那么，需要哪些信令呢？</p>
<h3 id="开一局">开一局</h3>
<p>开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>selfColor = <span class="string">'black'</span>;
connector.send({
    type: <span class="string">'new'</span>,
    data: {
        color: <span class="string">'white'</span>
    }
});
</pre></td></tr></table></figure>


<h3 id="落子">落子</h3>
<p>开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>connector.send({
    type: <span class="string">'drop'</span>,
    data: {
        color: fiveChess.state,
        x: x,
        y: y
    }
});
</pre></td></tr></table></figure>


<p>这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。</p>
<h3 id="结束">结束</h3>
<p>双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>connector.send({
    type: <span class="string">'end'</span>
});
</pre></td></tr></table></figure>


<p>通过这三个信令，一个对战的五子棋就完成了</p>
<h2 id="结语">结语</h2>
<p>五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。</p>
<p>希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc" target="_blank">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess" target="_blank">五子棋</a></p>
]]>
    
    </summary>
    
      <category term="Canvas" scheme="http://lingyu.wang/tags/Canvas/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="游戏" scheme="http://lingyu.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://lingyu.wang/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用WebRTC DataChannel在浏览器间传递数据]]></title>
    <link href="http://lingyu.wang/2014/10/21/datachannel/"/>
    <id>http://lingyu.wang/2014/10/21/datachannel/</id>
    <published>2014-10-20T16:00:00.000Z</published>
    <updated>2014-10-21T12:35:05.289Z</updated>
    <content type="html"><![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>
<a id="more"></a>

<p>如果对WebRTC和DataChannel不太了解的同学，可以先阅读如下文章：</p>
<ul>
<li><a href="http://lingyu.wang/2014/05/22/webrtc-data-channels/">WebRTC的RTCDataChannel</a></li>
<li><a href="http://lingyu.wang/2014/03/18/webRTC-2/">使用WebRTC搭建前端视频聊天室——信令篇</a></li>
<li><a href="http://lingyu.wang/2014/03/15/webRTC-1/">使用WebRTC搭建前端视频聊天室——入门篇</a></li>
</ul>
<h2 id="老刘和老姚">老刘和老姚</h2>
<p>当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程：</p>
<h3 id="不如钓鱼去">不如钓鱼去</h3>
<p>一些背景：</p>
<ul>
<li>老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话</li>
<li>片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定</li>
<li>门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达</li>
</ul>
<p>现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了:</p>
<ol>
<li>门卫老大爷认识老刘和老姚</li>
<li>老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚</li>
<li>老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了</li>
<li>老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘</li>
<li>老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了</li>
</ol>
<p>老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了</p>
<h3 id="换个角度">换个角度</h3>
<p>我们把角色做一个映射：</p>
<ul>
<li>老刘：浏览器1</li>
<li>老姚：浏览器2</li>
<li>片区：不同网段</li>
<li>保安：防火墙</li>
<li>片区凭证：ICE candidate</li>
<li>物业：ICE server</li>
<li>门牌号：session description</li>
<li>门卫老大爷：server</li>
</ul>
<p>于是乎故事就变成了这样：</p>
<ol>
<li>浏览器1和浏览器2在server上注册，并保有连接</li>
<li>浏览器1从ice server获取ice candidate并发送给server，并生成包含session description的offer，发送给server</li>
<li>server发送浏览器1的offer和ice candidate给浏览器2</li>
<li>浏览器2发送包含session description的answer和ice candidate给server</li>
<li>server发送浏览器2的answer和ice candidate给浏览器1</li>
</ol>
<p>这样，就建立了一个点对点的信道，流程如下所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog%2Fimg%2F2014-10-32%2Fdatachannel-task-seq.png" alt="信令交互流程"></p>
<h2 id="礼物">礼物</h2>
<h3 id="故事">故事</h3>
<p>老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。</p>
<p>这里可以做如下类比：</p>
<ol>
<li>10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了）</li>
<li>分成10份：将文件分片，转成多个chunk</li>
<li>老姚一次只能带一斤：datachannel每次传输的数据量不宜太大（<a href="http://stackoverflow.com/questions/15435121/what-is-the-maximum-size-of-webrtc-data-channel-messages" target="_blank">找到最合适的大小</a>）</li>
</ol>
<p>这其实就是通过datachannel传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件</p>
<h3 id="分片">分片</h3>
<p>通过HTML5的File API可以将type为file的input选中的文件读取出来，并转换成data url字符串。这也就为我们提供了很方便的分片方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> reader = <span class="keyword">new</span> window.FileReader(file);
reader.readAsDataURL(file);
reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(event, text)</span> {</span>
    chunkify(event.target.result);<span class="comment">//将数据分片</span>
};
</pre></td></tr></table></figure>


<h3 id="组合">组合</h3>
<p>通过datachannel发送的分片数据，我们需要将其进行组合，由于是data url字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的data url字符串，那么我们如何将这个字符串转换成文件呢？</p>
<h4 id="方案一：直接跳转下载">方案一：直接跳转下载</h4>
<p>既然是个dataurl，我们直接将其赋值给<code>window.location.href</code>自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼</p>
<h4 id="方案二：通过a标签下载">方案二：通过a标签下载</h4>
<p>这个原理和跳转下载类似，都是使用dataurl本身的特性，通过创建一个a标签，将dataurl字符串赋值给href属性，然后使用download确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为dataurl有<a href="http://stackoverflow.com/questions/695151/data-protocol-url-size-limitations" target="_blank">大小限制</a></p>
<h4 id="方案三：blob">方案三：blob</h4>
<p>其实可以通过给a标签创建blob url的方式来进行下载，这个没有大小限制。但是我们手上是dataurl，所以需要先进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span><span class="params">(dataURI, dataTYPE)</span> {</span>
    <span class="keyword">var</span> binary = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]),
        array = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) array.push(binary.charCodeAt(i));
    <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array)], {
        type: dataTYPE
    });
}
</pre></td></tr></table></figure>


<p>获得blob后，我们就可以通过URL API来下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> a = document.createElement(<span class="string">"a"</span>);
document.body.appendChild(a);
a.style = <span class="string">"display: none"</span>;
<span class="keyword">var</span> blob = dataURItoBlob(data, <span class="string">'octet/stream'</span>);
<span class="keyword">var</span> url = window.URL.createObjectURL(blob);
a.href = url;
a.download = filename;
a.click();
!moz && window.URL.revokeObjectURL(url);
a.parentNode.removeChild(a);
</pre></td></tr></table></figure>


<p>这里有几个点：</p>
<ol>
<li>datachannel其实是可以直接传送blob的，但是只有ff支持，所以传data url</li>
<li>chrome下载是直接触发的，不会进行询问，firefox会先询问后下载，在询问过程中如果执行了<code>revokeObjectURL</code>，下载就会取消，囧</li>
</ol>
<h2 id="升级">升级</h2>
<p>如我们所知，WebRTC最有特点的地方其实是可以传输getUserMedia获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32位机上一个连接至少20M左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含datachannel的连接用于传输数据，然后在需要时升级成可以传输视频、音频。</p>
<p>看看我们之前传输的session description，它其实来自<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank">Session Description Protocol</a>。可以看到wiki上的介绍：</p>
<blockquote>
<p>The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters.</p>
</blockquote>
<p>这意味着什么呢？我们之前建立datachannel是没有加视频、音频流的，而这个流的描述是写在SDP里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得SDP，然后构建offer和answer再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的ice candidate，这里我曾经<a href="http://stackoverflow.com/questions/26469794/webrtc-add-ice-candidate-error-on-established-peerconnection" target="_blank">遇到了坑</a>，经过国外大大的点拨才明白过来。</p>
<blockquote>
<p>from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything.</p>
</blockquote>
<h2 id="Peertc">Peertc</h2>
<p>我将datachannel和websocket组合，实现了一个构建点对点连接的库Peertc，它提供非常简洁的方式来建立连接和发送数据、文件和视频/音频流，详情见<a href="https://github.com/LingyuCoder/peertc" target="_blank">github</a>。走过路过的记得star一下哦，有什么bug也非常希望能够提出来。</p>
<h2 id="最后">最后</h2>
<p>WebRTC的点对点方式能够运用在很多场景：</p>
<ul>
<li>如web qq这种Web IM工具，这就不说了</li>
<li>如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送</li>
<li>一对一在线面试、在线教育，这其实是即时通信的一个业务方向</li>
<li>视频裸（），当我没说</li>
</ul>
<p>就酱，另外打个广告及拉点搜索引擎权重：<a href="http://lingyu.wang">我的博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>
]]>
    
    </summary>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="DataChannel" scheme="http://lingyu.wang/tags/DataChannel/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp思维 —— Gulp高级技巧]]></title>
    <link href="http://lingyu.wang/2014/10/07/getting-gulpy/"/>
    <id>http://lingyu.wang/2014/10/07/getting-gulpy/</id>
    <published>2014-10-06T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:38.246Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/" target="_blank">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>
<a id="more"></a>

<h2 id="基本任务">基本任务</h2>
<p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> gulp.src(<span class="string">'./src/**/*.js'</span>)
        .pipe(uglify())
        .pipe(concat(<span class="string">'all.min.js'</span>))
        .pipe(gulp.dest(<span class="string">'build/'</span>));
});
</pre></td></tr></table></figure>


<p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p>
<h2 id="流不兼容？">流不兼容？</h2>
<p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p>
<p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-rename" target="_blank">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);
gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> fs.createReadStream(<span class="string">'app.js'</span>)
        .pipe(uglify())
        .pipe(rename(<span class="string">'bundle.min.js'</span>))
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});
</pre></td></tr></table></figure>


<p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p>
<h2 id="Vinyl文件对象">Vinyl文件对象</h2>
<p>gulp使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href="https://github.com/wearefractal/vinyl" target="_blank">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p>
<p>使用<a href="https://www.npmjs.org/package/vinyl-source-stream" target="_blank">vinyl-source-stream</a>是个不错的选择，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),
    marked = <span class="built_in">require</span>(<span class="string">'gulp-marked'</span>);
fs.createReadStream(<span class="string">'*.md'</span>)
    .pipe(source())
    .pipe(marked())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<p>另外一个例子首先通过<a href="http://browserify.org/" target="_blank">browserify</a>封装并最终将其转换为一个vinyl流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);
gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> browserify(<span class="string">'./src/app.js'</span>)
        .bundle()
        .pipe(source(‘bundle.min.js))
        .pipe(uglify())
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});
</pre></td></tr></table></figure>


<p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p>
<h3 id="gulp-dest">gulp.dest</h3>
<p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href="https://www.npmjs.org/package/mkdirp" target="_blank">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p>
<h2 id="流和buffer">流和buffer</h2>
<p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>fs.createReadStream(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
    console.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);
});
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; ...
</pre></td></tr></table></figure>


<p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>gulp.src(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
    console.log(<span class="string">'Read %d bytes of data'</span>, file.contents.length);
});
&gt; Read <span class="number">2493109</span> bytes of data
</pre></td></tr></table></figure>


<p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p>
<h2 id="Gulp默认使用buffer">Gulp默认使用buffer</h2>
<p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href="http://lisperator.net/uglifyjs/" target="_blank">UglifyJS</a>和<a href="https://github.com/google/traceur-compiler" target="_blank">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p>
<p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p>
<p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p>
<p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>gulp.src(<span class="string">'/usr/share/dict/words'</span>, {buffer: <span class="literal">false</span>}).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
    <span class="keyword">var</span> stream = file.contents;
    stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
        console.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);
    });
});
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; ...
</pre></td></tr></table></figure>


<h2 id="从流到buffer">从流到buffer</h2>
<p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-traceur" target="_blank">gulp-traceur</a>。你可以通过<a href="https://www.npmjs.org/package/gulp-buffer" target="_blank">gulp-buffer</a>来转换成buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),
    buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);
fs.createReadStream(<span class="string">'./src/app.js'</span>)
    .pipe(source(<span class="string">'app.min.js'</span>))
    .pipe(buffer())
    .pipe(uglify())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<p>或者另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),
    traceur = <span class="built_in">require</span>(<span class="string">'gulp-traceur'</span>);
gulp.src(<span class="string">'app.js'</span>, {buffer: <span class="literal">false</span>})
    .pipe(buffer())
    .pipe(traceur())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<h2 id="将buffer转换为流">将buffer转换为流</h2>
<p>你也可以使用<a href="https://www.npmjs.org/package/gulp-streamify" target="_blank">gulp-streamify</a>或<a href="https://www.npmjs.org/package/gulp-stream" target="_blank">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> wrap = <span class="built_in">require</span>(<span class="string">'gulp-wrap'</span>),
    streamify = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    gzip = <span class="built_in">require</span>(<span class="string">'gulp-gzip'</span>);
gulp.src(<span class="string">'app.js'</span>, {buffer: <span class="literal">false</span>})
    .pipe(wrap(<span class="string">'(function(){&lt;%= contents %&gt;}());'</span>))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(<span class="string">'build'</span>))
    .pipe(gzip())
    .pipe(gulp.dest(<span class="string">'build'</span>));
</pre></td></tr></table></figure>


<h2 id="不是所有事都需要插件">不是所有事都需要插件</h2>
<p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p>
<h3 id="vinyl-source-stream">vinyl-source-stream</h3>
<p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href="https://www.npmjs.org/package/gulp-browserify" target="_blank">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p>
<h3 id="文本转换">文本转换</h3>
<p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">modify</span><span class="params">(modifier)</span> {</span>
    <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span><span class="params">(file, encoding, done)</span> {</span>
        <span class="keyword">var</span> content = modifier(<span class="built_in">String</span>(file.contents));
        file.contents = <span class="keyword">new</span> Buffer(content);
        <span class="keyword">this</span>.push(file);
        done();
    });
}
</pre></td></tr></table></figure>


<p>你可以像这样使用这个插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>gulp.task(<span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> gulp.src(<span class="string">'app.js'</span>)
        .pipe(modify(version))
        .pipe(modify(swapStuff))
        .pipe(gulp.dest(<span class="string">'build'</span>));
});
<span class="function"><span class="keyword">function</span> <span class="title">version</span><span class="params">(data)</span> {</span>
    <span class="keyword">return</span> data.replace(<span class="regexp">/__VERSION__/</span>, pkg.version);
}
<span class="function"><span class="keyword">function</span> <span class="title">swapStuff</span><span class="params">(data)</span> {</span>
    <span class="keyword">return</span> data.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2, $1'</span>);
}
</pre></td></tr></table></figure>


<p>这个插件并没有完成，而且也不能处理流（<a href="https://gist.github.com/webpro/a9a9e14d291c021894b3" target="_blank">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href="https://www.npmjs.org/package/through2" target="_blank">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p>
<h2 id="任务流程">任务流程</h2>
<p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href="https://www.npmjs.org/package/orchestrator" target="_blank">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p>
<ul>
<li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li>
<li>你需要更多的动态的和（或）可重用的子任务。</li>
</ul>
<h2 id="最后的思考">最后的思考</h2>
<p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p>
<p>阅读<a href="http://substack.net/task_automation_with_npm_run" target="_blank">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p>
<p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p>
<p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href="https://twitter.com/webprolific" target="_blank">@webprolific</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/" target="_blank">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp -- 项目的愿景、过去和将来]]></title>
    <link href="http://lingyu.wang/2014/10/06/gulp-vision-history-future/"/>
    <id>http://lingyu.wang/2014/10/06/gulp-vision-history-future/</id>
    <published>2014-10-05T16:00:00.000Z</published>
    <updated>2014-11-18T07:42:12.073Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>
<a id="more"></a>

<p>下面我们就来介绍gulp背后的各个部分以及它们所起到的作用。</p>
<h2 id="流">流</h2>
<p>流是一种将多个小的变换操作进行组合，连接成管道的一种方式。你将数据丢入管道顶部，它将下落并穿过所有的变换，最后在底部得到你想要的内容。流系统的灵活性能够很好地解决文件变换需求。</p>
<p>想获得更多关于流的信息，请查阅substack的<a href="https://github.com/substack/stream-handbook" target="_blank">流操作手册</a></p>
<h2 id="Vinyl">Vinyl</h2>
<p><a href="https://github.com/wearefractal/vinyl" target="_blank">Vinyl</a>是一个用来描述文件的简单元数据对象。当你想要使用一个文件时，首先映入脑海的是文件的两个属性：<a href="https://github.com/wearefractal/vinyl/blob/master/index.js#L18-L25" target="_blank">路径和内容</a>。这两个属性就是一个Vinyl对象的主要属性。这里的文件并不一定是指你的文件系统里的文件。你在S3、FTP、Dropbox、Box、CloudThingly.io或者其他服务上的文件，一样可以使用Vinyl来描述。</p>
<h2 id="Vinyl_Adapters（Vinyl适配器）">Vinyl Adapters（Vinyl适配器）</h2>
<p>既然Vinyl提供了一个清晰的方法用来描述文件，我们现在还需要找到访问这些文件的方式。每一种文件源我们都需要一个“Vinyl适配器”。一个Vinyl适配器只需要暴露三个方法：<code>.src(globs)</code>、<code>.dest(folder)</code>、和一个<code>.watch(globs, fn)</code>。src流负责产生文件对象，而dest流负责消费这些文件对象。</p>
<p>表面上看人们已经理解了“gulp插件”(一个transform形式的流)的概念，但Vinyl适配器的理念却没有被广泛传播。除非自己开发一些适配器，否则无法得知适配器是如何引用文件源中的内容。。通过Vinyl适配器来实现gulp，并将其作为一个开发工具的想法非常奇妙。</p>
<h3 id="vinyl-fs">vinyl-fs</h3>
<p>如果你使用gulp，你已经使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank">vinyl-fs</a>模块。它是用来适配本地文件系统的适配器。</p>
<h3 id="vinyl-s3">vinyl-s3</h3>
<p>vinyl-s3尚不存在，但<a href="https://github.com/nkostelnik/gulp-s3" target="_blank">gulp-s3</a>已经实现了。它无法提供所有的功能，但它是了一个不错的权宜方案。</p>
<h2 id="Orchestrator">Orchestrator</h2>
<p>在写这篇文章时，目前的任务系统是<a href="https://github.com/orchestrator/orchestrator" target="_blank">Orchestrator</a> 0.3。Orchestrator提供了简单的方式去定义任务和依赖，并能够在依赖树为基础的前提下以最大并发数去与并发执行这些任务。Orchestrator虽然工作良好，但它复杂的依赖管理给用户带来不小的麻烦。Orchestrator为了配合gulp的理念而做了巨大的调整：更加轻量、低复杂度，以及可组合的功能性API。</p>
<p>这里简要介绍一下gulp 4带来的变化：</p>
<ol>
<li>你可以任意指定任务顺序，并行/串行的任意组合都随心所欲。只有想不到，没有做不到</li>
<li>API将非常流畅和友好</li>
<li>代码更加简洁</li>
</ol>
<p>非常感谢Blaine Bublitz在这方面积极的努力。</p>
<h2 id="错误处理">错误处理</h2>
<p>实话告诉你：gulp现在的错误处理很烂。我从不期望能从报错信息中获得一点有用的信息。使用gulp的过程中，你可能会遭遇两种错误：</p>
<h3 id="任务失败">任务失败</h3>
<p>watch时出现任务失败，内部将会一团糟，然后线程会退出，具体的退出方式要取决你如何启动这个任务。这种情况非常糟糕，完全不应该发生，在新的任务系统中将对这些进行修复。</p>
<h3 id="管道失败">管道失败</h3>
<p>标准的流在遭遇错误时仅仅会停止工作。而像linter（代码风格检测）这样的任务，问题就来了。我想看到所有的代码风格提示，而不只是第一个文件里的那些。技术上其实是因为unpipe事件。本质上看，当一个流遇到错误，它将会触发<strong>unpipe</strong>事件，这个事件将告诉其他流不再向它写入数据。目前有一些hack的解决方法如gulp-plumber，可以作为权宜之计，但我很高兴的说，我将会把这些集成到gulp核心之中去。</p>
<p>这些问题我会在下个release版本最优先解决。</p>
<h2 id="社区">社区</h2>
<p>从一个局外人的角度来看，人们都能参与到这场文件转换工具的战斗之中，实在有些疯狂。虽然外人看来可能有些无趣，但成为这个激情小组的一部分绝对令人振奋。我很自豪社区能够接纳这个工具并对人们的日常生活带来帮助。</p>
<h2 id="进展">进展</h2>
<p>想要跟踪gulp 4的进展，你可以在github上查看<a href="https://github.com/gulpjs/gulp/issues?milestone=1&amp;state=open" target="_blank">里程碑</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[koa-anywhere]]></title>
    <link href="http://lingyu.wang/2014/09/24/koa-anywhere/"/>
    <id>http://lingyu.wang/2014/09/24/koa-anywhere/</id>
    <published>2014-09-23T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.178Z</updated>
    <content type="html"><![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>
<a id="more"></a>

<h1 id="koa-anywhere">koa-anywhere</h1>
<p>通过一条命令，将当前目录变成一个静态文件服务器</p>
<p>需要Node版本：&gt;= 0.11.13</p>
<h1 id="Install">Install</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install <span class="attribute">-g</span> koa<span class="attribute">-anywhere</span>
</pre></td></tr></table></figure>


<h1 id="Usage">Usage</h1>
<p>只需一条简单的命令<code>ka</code>就可以启动一个静态文件服务器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>cd &lt;想要共享的目录&gt;
<span class="variable">$ </span>ka
</pre></td></tr></table></figure>


<h2 id="Option">Option</h2>
<h3 id="port">port</h3>
<p>通过<code>-p &lt;端口号&gt;</code>或者<code>--port &lt;端口号&gt;</code>来指定静态文件服务器的端口</p>
<p>默认端口为<code>3000</code></p>
<h3 id="deep">deep</h3>
<p>通过<code>-d &lt;层级数&gt;</code>或者<code>--deep &lt;层级数&gt;</code>来确定静态文件需要显示的文件层级，超过层级的文件不显示</p>
<p>默认层级数为<code>3</code></p>
<h3 id="silent">silent</h3>
<p>通过<code>-s</code>或者<code>--silent</code>来决定是否显示日志</p>
<p>默认为<code>false</code>，也就是显示日志</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="koa" scheme="http://lingyu.wang/tags/koa/"/>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学前端的一点总结]]></title>
    <link href="http://lingyu.wang/2014/09/22/learn-fe/"/>
    <id>http://lingyu.wang/2014/09/22/learn-fe/</id>
    <published>2014-09-21T16:00:00.000Z</published>
    <updated>2014-11-18T07:44:56.661Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>
<a id="more"></a>

<h4 id="工具">工具</h4>
<ul>
<li>chrome dev tools：前端开发调试利器，着重注意几个功能：<ul>
<li>console（废话）</li>
<li>elements:元素样式调整，很常用</li>
<li>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<ul>
<li>watch expression：通过表达式查看当前内存中的值</li>
<li>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）</li>
<li>scope variables：作用域链上的变量，非常有用</li>
</ul>
</li>
<li>network：抓包查看每个请求，非常重要，前后端联调必备</li>
<li>timeline：分析渲染、js执行等等各个阶段，性能优化利器</li>
<li>emulation：模拟移动端环境，mobile页面开发必备</li>
<li>一些插件:<ul>
<li>liveload: 修改页面后自动刷新，不用按F5</li>
<li>dimensions：直接在页面上测量的利器</li>
<li>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中</li>
<li>image tool：测量，取色</li>
<li>UC二维码：移动端调试扫码必备</li>
<li>pagespeed，YSlow：页面性能分析和优化插件</li>
<li>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录</li>
</ul>
</li>
</ul>
</li>
<li>sublime text2：编码方便，插件多，速度快，性能好<ul>
<li>emmet：提升html编码速度必备</li>
<li>sublimelinter + 各种语言的lint和hint：代码纠错</li>
<li>一些snippets：自动补全，提升开发效率</li>
</ul>
</li>
<li>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能</li>
<li>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件</li>
<li>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子</li>
<li>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备</li>
<li>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用</li>
<li>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</li>
</ul>
<h4 id="技能">技能</h4>
<p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p>
<h5 id="语言基础">语言基础</h5>
<p>JavaScript：</p>
<ul>
<li>作用域链、闭包、运行时上下文、this</li>
<li>原型链、继承</li>
<li>NodeJS基础和常用API</li>
</ul>
<p>CSS：</p>
<ul>
<li>选择器</li>
<li>浏览器兼容性及常见的hack处理</li>
<li>CSS布局的方式和原理（盒子模型、BFC、IFC等等）</li>
<li>CSS 3，如animation、gradient、等等</li>
</ul>
<p>HTML：</p>
<ul>
<li>语义化标签</li>
</ul>
<h5 id="进阶">进阶</h5>
<p>JavaScript:</p>
<ul>
<li>异步控制（Promise、ES6 generator、Async）</li>
<li>模块化的开发方式（AMD、CMD、KMD等等）</li>
<li>JavaScript解释器的一些相关知识<ul>
<li>异步IO实现</li>
<li>垃圾回收</li>
<li>事件队列</li>
</ul>
</li>
<li>常用框架使用及其原理<ul>
<li>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研</li>
<li>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦</li>
<li>underscore：优秀的工具库，方便的理解常用工具代码片段的实现</li>
<li>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</li>
</ul>
</li>
</ul>
<p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p>
<ul>
<li>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程</li>
<li>解析HTML、CSS、JavaScript时造成的阻塞</li>
<li>HTML5相关<ul>
<li>SVG及矢量图原理</li>
<li>Canvas开发及动画原理（帧动画）</li>
<li>Video和Audio</li>
</ul>
</li>
<li>flex box布局方式</li>
<li>icon fonts的使用</li>
</ul>
<p>常用NodeJs的package：</p>
<ul>
<li>koa</li>
<li>express</li>
<li>underscore</li>
<li>async</li>
<li>gulp</li>
<li>grunt</li>
<li>connect</li>
<li>request</li>
</ul>
<p>一些理念：</p>
<ul>
<li>响应式Web</li>
<li>优雅降级、渐进增强</li>
<li>don`t make me think</li>
<li>网页可用性、可访问性、其中的意义</li>
<li>SEO搜索引擎优化，了解搜索引擎的原理</li>
<li>SPA的好处和问题</li>
</ul>
<p>性能优化：</p>
<ul>
<li>减少请求数量（sprite、combo）</li>
<li>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）</li>
<li>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）</li>
<li>CSS的回流与重绘</li>
</ul>
<h5 id="项目">项目</h5>
<ul>
<li>版本管理：首推Git，用过Git都不会想用SVN了<ul>
<li>Git：本地版本管理的机制</li>
<li>SVN：远程中心的版本管理机制</li>
</ul>
</li>
<li>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<ul>
<li>Gulp：基于流构建，速度快、模块质量好</li>
<li>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高</li>
</ul>
</li>
<li>预处理和模板引擎<ul>
<li>less：语法简单，但功能有限</li>
<li>jade、ejs、velocity等模板引擎，各有各的长处</li>
<li>coffee：python工程师最爱，我没用过</li>
</ul>
</li>
<li>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<ul>
<li>本地代理：ihosts</li>
</ul>
</li>
<li>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<ul>
<li>jasmine</li>
<li>mocha</li>
</ul>
</li>
<li>生态系统<ul>
<li>npm</li>
<li>bower</li>
<li>spm</li>
</ul>
</li>
<li>搭建一个属于自己的博客<ul>
<li>git pages</li>
<li>hexo</li>
<li>jekyll</li>
</ul>
</li>
</ul>
<h5 id="未来">未来</h5>
<ul>
<li>Web Componets：面向未来的组件化开发方式<ul>
<li>HTML模板</li>
<li>Shadow DOM</li>
<li>Custom Elements</li>
<li>HTML Import</li>
</ul>
</li>
<li>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</li>
</ul>
<h5 id="其他">其他</h5>
<p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p>
<ul>
<li><strong>对于业务的思考</strong>：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务</li>
<li>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目</li>
<li>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录</li>
<li>对新技术的渴望，以及敢于尝试</li>
</ul>
<h4 id="入门书">入门书</h4>
<p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p>
<ul>
<li>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看</li>
<li>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助</li>
<li>《编写可维护的JavaScript》和：</li>
<li>《Node.js开发指南》：不错的Nodejs入门书籍</li>
<li>《深入浅出Node.js》：Nodejs进阶书籍，必备</li>
<li>《JavaScript异步编程》：理解JS异步的编程理念</li>
<li>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书</li>
<li>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西</li>
<li>《Don`t make me think》：网页设计的理念，了解用户行为，非常不错</li>
<li>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题</li>
<li>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习</li>
<li>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助</li>
<li>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识</li>
<li>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想</li>
<li>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</li>
</ul>
<h4 id="一些不错的网站">一些不错的网站</h4>
<ul>
<li><a href="https://github.com" target="_blank">github</a>：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习</li>
<li><a href="http://codepen.io/" target="_blank">codepen</a>：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件</li>
<li><a href="http://www.echojs.com/" target="_blank">echojs</a>：快速了解js新资讯的网站</li>
<li><a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>和<a href="segmentfault.com">segmentfault</a>：基本上各种问题都能在上面获得解答</li>
<li><a href="https://developers.google.com/web/fundamentals/" target="_blank">google web fundamentals</a>：每篇文章都适合仔细阅读</li>
<li><a href="http://www.staticfile.org/" target="_blank">static files</a>：开放的CDN，很好用</li>
<li><a href="http://www.iconfont.cn/" target="_blank">iconfont</a>：阿里的矢量图标库，非常不错，支持CDN而且支持项目</li>
<li><a href="http://www.html5rocks.com/" target="_blank">html5 rocks</a>: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章</li>
<li><a href="http://css-tricks.com/" target="_blank">css tricks</a>：如何活用CSS，以及了解CSS新特性，这里可以满足你</li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.general" target="_blank">JavaScript 秘密花园</a> JavaScript初学必看，非常不错</li>
<li><a href="http://www.w3cplus.com/" target="_blank">w3cplus</a>：一个前端学习的网站，里面的文章质量都挺不错的</li>
<li><a href="http://nodeschool.io/" target="_blank">node school</a>：一个不错的node学习网站</li>
<li><a href="http://pcottle.github.io/learnGitBranching/?demo" target="_blank">learn git branch</a>：一个git学习网站，交互很棒</li>
<li><a href="http://www.html-js.com/" target="_blank">前端乱炖</a>：一个前端文章分享的社区，有很多优秀文章</li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank">正则表达式</a>：一个正则表达式入门教程，非常值得一看</li>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank">阮一峰的博客</a>和<a href="http://www.zhangxinxu.com/wordpress/" target="_blank">张鑫旭的博客</a>：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源</li>
<li>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的</li>
<li>各种规范的官方网站，不懂得时候读规范</li>
</ul>
<h4 id="历程">历程</h4>
<p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和<a href="http://www.w3school.com.cn/" target="_blank">W3C School</a>上的教程，以及一些前端博客，如<a href="http://www.cnblogs.com/TomXu/" target="_blank">汤姆大叔的博客</a>。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="思考" scheme="http://lingyu.wang/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="思考总结" scheme="http://lingyu.wang/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说Generator]]></title>
    <link href="http://lingyu.wang/2014/07/29/generator/"/>
    <id>http://lingyu.wang/2014/07/29/generator/</id>
    <published>2014-07-28T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.169Z</updated>
    <content type="html"><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
<a id="more"></a>

<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>
<h1 id="Generator函数">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>
<ol>
<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
<li>创建一个generator对象，其有如下值：<ul>
<li>Scope：新建的作用域链</li>
<li>Code：generator function内部的代码</li>
<li>ExecutionContext：EC，目前值为null</li>
<li>State：”newborn”</li>
<li>Handler：默认的generator的处理器</li>
</ul>
</li>
</ol>
<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>
<h1 id="yield的行为">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
<li>从EC栈弹出当前的EC</li>
<li>返回(normal, 1中的结果值, null)</li>
</ol>
<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>
<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>
<h1 id="return行为">return行为</h1>
<p>当执行到<code>return e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
<li>将这个generator对象的状态修改为closed</li>
<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
<li>throw这个对象</li>
</ol>
<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>
<h1 id="Generator对象的私有属性">Generator对象的私有属性</h1>
<ul>
<li>prototype：Object.prototype</li>
<li>code：generator函数的函数体</li>
<li>ExecutionContext：内部代码运行使用的EC</li>
<li>Scope：作用域链</li>
<li>Handler：标准的generator句柄</li>
<li>State：newborn、executing、suspended、closed</li>
<li>Send：看内部方法部分</li>
<li>Throw：看内部方法部分</li>
<li>Close：看内部方法部分</li>
</ul>
<h1 id="外部接口">外部接口</h1>
<h2 id="next">next</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入一个undefined</li>
<li>返回结果</li>
</ol>
<p>调用私有send方法</p>
<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<p>同样是调用私有send方法，不过传入了参数</p>
<h2 id="throw">throw</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.throw，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.close，不传入任何参数</li>
<li>返回结果</li>
</ol>
<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>
<h2 id="小结">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>
<h1 id="状态定义">状态定义</h1>
<ul>
<li>newborn：Code不为null，EC为null</li>
<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
<li>closed：Code为null，EC为null</li>
</ul>
<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>
<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>
<p>当然也可以通过close方法，手动修改状态为closed</p>
<h1 id="内部方法">内部方法</h1>
<h2 id="send方法">send方法</h2>
<ol>
<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
<li>如果state为newborn<ol>
<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
<li>将这个EC压入EC栈中</li>
<li>执行generator中的代码，并返回或得到的结果</li>
</ol>
</li>
<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>
<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>
<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>
<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>
<h2 id="throw-1">throw</h2>
<ol>
<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>
<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>
<h2 id="close-1">close</h2>
<ol>
<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
<li>如果state已经是closed了，那直接return就好</li>
<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>
<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>
<h2 id="Resume(EC,_completionType,_V)">Resume(EC, completionType, V)</h2>
<ol>
<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
<li>从EC通过currentGenerator获取单签generator对象</li>
<li>设置当前作用域链为当前generator对象的作用域链</li>
<li>继续执行代码，并根据completionType做相应的处理</li>
</ol>
<h1 id="NodeJs上的不同">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>
<h2 id="资料">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank">harmony generators ES Wiki</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="Generator" scheme="http://lingyu.wang/tags/Generator/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何写一个KISSY动画插件]]></title>
    <link href="http://lingyu.wang/2014/05/31/kissy-anime-plugin/"/>
    <id>http://lingyu.wang/2014/05/31/kissy-anime-plugin/</id>
    <published>2014-05-30T16:00:00.000Z</published>
    <updated>2014-11-18T07:48:55.255Z</updated>
    <content type="html"><![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank">Github页面</a></p>
<a id="more"></a>

<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/" target="_blank">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>
<h2 id="CSS与JavaScript动画对比">CSS与JavaScript动画对比</h2>
<p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>
<h3 id="CSS动画">CSS动画</h3>
<h4 id="animation">animation</h4>
<p>CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：</p>
<ol>
<li>animation-name：动画的名称，也就是定义的keyframes关键帧的名称</li>
<li>animation-duration：一次动画的时长</li>
<li>animation-timing-funciton：缓动函数，这个后面会有详细介绍</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画的播放次数</li>
<li>animation-direction：动画时正向播放还是倒着播放</li>
<li>animation-play-state：动画的状态，暂停还是播放</li>
<li>animation-fill-mode：动画播放时间之外的状态，是否重回动画初始</li>
<li>animation：复合属性，上面属性合在一起的写法</li>
</ol>
<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>
<h4 id="transition">transition</h4>
<p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：</p>
<ol>
<li>transition-property：需要参与过渡的属性</li>
<li>transition-duration 过渡的时长</li>
<li>transition-timing-function：过渡的缓动函数</li>
<li>transition-delay：过渡的延时</li>
</ol>
<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>
<h4 id="优缺点">优缺点</h4>
<p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>
<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>
<p>另外，<a href="http://lingyu.wang/#/item">这里</a>有我曾经写过的一些CSS3动画效果</p>
<h3 id="JavaScript动画">JavaScript动画</h3>
<p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：</p>
<ol>
<li>计算当前元素样式</li>
<li>修改元素样式</li>
<li>重绘元素</li>
</ol>
<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>
<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>
<h2 id="需求分析">需求分析</h2>
<h3 id="动画属性">动画属性</h3>
<p>通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：</p>
<ol>
<li>涉及的元素（elems）</li>
<li>需要改变的样式（styles）</li>
<li>时长（duration）</li>
<li>缓动函数（easing-function）</li>
<li>播放次数（times）</li>
</ol>
<h3 id="动画控制">动画控制</h3>
<p>而控制上，我们应该实现的功能：</p>
<ol>
<li>开始（run）</li>
<li>暂停（pause）</li>
<li>暂停恢复（resume）</li>
<li>中止（stop）</li>
<li>倒放（reverse）</li>
<li>单帧（go）</li>
</ol>
<h3 id="动画能够改变的内容">动画能够改变的内容</h3>
<p>需要能够改变的内容有：</p>
<ol>
<li>CSS样式</li>
<li>滚动</li>
</ol>
<h2 id="动画对象">动画对象</h2>
<p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>
<p>所以，动画的对象大致上是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">()</span>{</span>}
Anime.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.pause = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.resume = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.stop = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.go = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
</pre></td></tr></table></figure>


<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>
<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">(elems, styles, config)</span>{</span>}
</pre></td></tr></table></figure>


<p>conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> defaultConfig = {
    callback: noop,
    duration: <span class="number">1500</span>,
    reverse: <span class="literal">false</span>,
    easing: <span class="string">"linear"</span>,
    times: <span class="number">1</span>,
    spend: <span class="number">0</span>,
    state: <span class="string">"running"</span>
};
</pre></td></tr></table></figure>


<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：</p>
<ul>
<li>running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态</li>
<li>paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态</li>
<li>ended为终止状态，可以通过run放法进行重放，转到running状态</li>
</ul>
<h2 id="动画队列">动画队列</h2>
<p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>
<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>
<p>所以，队列首先得实现相关的添加删除操作，注意去重：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> animeQueue = [];

<span class="function"><span class="keyword">function</span> <span class="title">addAnime</span><span class="params">(anime)</span> {</span>
    <span class="keyword">if</span> (S.indexOf(anime, animeQueue) === -<span class="number">1</span>) {
        animeQueue.push(anime);
        checkRunning();
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">deleteAnime</span><span class="params">(anime)</span> {</span>
    <span class="keyword">var</span> index = S.indexOf(anime, animeQueue);
    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {
        animeQueue.splice(index, <span class="number">1</span>);
        checkRunning();
    }
}
</pre></td></tr></table></figure>


<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">pulse</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> deleteIndex = [],
        i, m, tmp;
    <span class="keyword">if</span> (running) {
        S.each(animeQueue, <span class="function"><span class="keyword">function</span><span class="params">(anime, index)</span> {</span>
            <span class="keyword">if</span> (anime.state === <span class="string">"running"</span>) {
                anime.go();
            } <span class="keyword">else</span> {
                deleteIndex.push(index);
            }
        });
        <span class="keyword">for</span> (i = deleteIndex.length; i--;) {
            animeQueue.splice(deleteIndex[i], <span class="number">1</span>);
        }
        dealing = <span class="literal">false</span>;
        checkRunning();
    }
}
</pre></td></tr></table></figure>


<p>checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">checkRunning</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (animeQueue.length &gt; <span class="number">0</span>) {
        running = <span class="literal">true</span>;
        <span class="keyword">if</span> (!dealing) {
            dealing = <span class="literal">true</span>;
            requestAnimationFrame(pulse);
        }
    } <span class="keyword">else</span> {
        running = <span class="literal">false</span>;
        dealing = <span class="literal">false</span>;
    }
}
</pre></td></tr></table></figure>


<h2 id="缓动函数">缓动函数</h2>
<p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>
<h2 id="样式处理">样式处理</h2>
<p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：</p>
<ol>
<li>从元素获取样式的起始值（从什么地方开始）</li>
<li>获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）</li>
<li>计算当前时间点的中间值（经过怎样的过程）</li>
<li>向元素赋予计算出来的中间值（经过怎样的过程）</li>
</ol>
<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">getCSS</span><span class="params">(elem, style)</span> {</span>
    <span class="keyword">var</span> val;
    <span class="keyword">if</span> (hooks[style] && hooks[style].get) {
        val = hooks[style].get(elem, style);
    } <span class="keyword">else</span> {
        val = hooks._default.get(elem, style);
    }
    <span class="keyword">return</span> parseCSS(val, style);
}

<span class="function"><span class="keyword">function</span> <span class="title">parseCSS</span><span class="params">(val, style, from)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].parse) {
        <span class="keyword">return</span> hooks[style].parse(val, from);
    }
    <span class="keyword">return</span> hooks._default.parse(val, from);
}

<span class="function"><span class="keyword">function</span> <span class="title">computeCSS</span><span class="params">(style, from, to, pos)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].compute) {
        <span class="keyword">return</span> hooks[style].compute(from, to, pos);
    }
    <span class="keyword">return</span> hooks._default.compute(from, to, pos);

}

<span class="function"><span class="keyword">function</span> <span class="title">assignCSS</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].assign) {
        <span class="keyword">return</span> hooks[style].assign(elem, style, val);
    }
    <span class="keyword">return</span> hooks._default.assign(elem, style, val);
}
</pre></td></tr></table></figure>


<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>
<h2 id="特殊处理">特殊处理</h2>
<p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例</p>
<h3 id="颜色属性">颜色属性</h3>
<p>如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：</p>
<ol>
<li>HEX：<code>#fff</code>或<code>#f0f0f0</code></li>
<li>RGB：<code>rgb(245, 28, 33)</code></li>
<li>RGBA：<code>rgba(245, 28, 33, .6)</code></li>
<li>直接名称：<code>red</code>、<code>white</code>等等</li>
<li>HSL和HSLA，这里不做实现</li>
</ol>
<h4 id="获取">获取</h4>
<p>获取和一般CSS属性没差， 直接使用默认方式了</p>
<h4 id="解析">解析</h4>
<p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">parseColor</span><span class="params">(val)</span> {</span>
    val = val.replace(rClearSpace, <span class="string">""</span>).toLowerCase();
    <span class="keyword">if</span> (normalColors[val]) {
        <span class="keyword">return</span> normalColors[val];
    }
    <span class="keyword">var</span> color = [];
    <span class="keyword">var</span> tmp;
    <span class="keyword">var</span> i;
    <span class="keyword">if</span> (rHexColor.test(val)) {
        tmp = [];
        <span class="keyword">if</span> (val.length === <span class="number">4</span>) {
            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
                tmp[i] = val.charAt(i + <span class="number">1</span>);
                tmp[i] += tmp[i];
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> (val.length === <span class="number">7</span>) {
            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
                tmp[i] = val.substr(<span class="number">1</span> + i * <span class="number">2</span>, <span class="number">2</span>);
            }
        }
        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
            color[i] = <span class="built_in">parseInt</span>(tmp[i], <span class="number">16</span>);
        }
        color[<span class="number">3</span>] = <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGB))) {
        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
            color[i] = <span class="built_in">parseInt</span>(tmp[i + <span class="number">1</span>], <span class="number">10</span>);
        }
        color[<span class="number">3</span>] = <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGBA))) {
        <span class="keyword">for</span> (i = <span class="number">4</span>; i--;) {
            color[i] = <span class="built_in">Number</span>(tmp[i + <span class="number">1</span>]);
        }
    }
    <span class="keyword">return</span> color;
}
</pre></td></tr></table></figure>


<h4 id="计算">计算</h4>
<p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">computeColor</span><span class="params">(from, to, pos)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default,
        result = [],
        i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) {
        result.push(<span class="built_in">parseInt</span>(_default.compute(from[i], to[i], pos), <span class="number">10</span>));
    }
    result.push(_default.compute(from[<span class="number">3</span>], to[<span class="number">3</span>], pos));
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<h4 id="赋值">赋值</h4>
<p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">assignColor</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">if</span>(KISSY.Features.isIELessThan(<span class="number">9</span>)){
        Dom.css(elem, style, <span class="string">"rgb("</span> + val.slice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">","</span>) + <span class="string">")"</span>);
    } <span class="keyword">else</span> {
        Dom.css(elem, style, <span class="string">"rgba("</span> + val.join(<span class="string">","</span>) + <span class="string">")"</span>);
    }
}
</pre></td></tr></table></figure>


<h3 id="滚动">滚动</h3>
<h4 id="获取-1">获取</h4>
<p>滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>
<h4 id="解析-1">解析</h4>
<p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>
<h4 id="计算-1">计算</h4>
<p>计算过程也是，使用默认计算即可</p>
<h4 id="赋值-1">赋值</h4>
<p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>S.each(<span class="string">"scrollTop scrollLeft"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span><span class="params">(type)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default;
    hooks[type] = {
        assign: <span class="function"><span class="keyword">function</span><span class="params">(elem, style, val)</span> {</span>
            Dom[type](elem, val);
        },
        get: <span class="function"><span class="keyword">function</span><span class="params">(elem, style)</span> {</span>
            <span class="keyword">return</span> Dom[type](elem);
        }
    };
});
</pre></td></tr></table></figure>


<h3 id="transform">transform</h3>
<p><strong>这里只处理了2D的transform</strong></p>
<p>transform的值也有很多不同的形式：</p>
<ol>
<li>matrix</li>
<li>rotate</li>
<li>translate、translateX、translateY</li>
<li>scale、scaleX、scaleY</li>
<li>skew、skewX、skewY</li>
</ol>
<h4 id="获取-2">获取</h4>
<p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>
<h4 id="解析-2">解析</h4>
<p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> result = {
    translateX: <span class="number">0</span>,
    translateY: <span class="number">0</span>,
    rotate: <span class="number">0</span>,
    skewX: <span class="number">0</span>,
    skewY: <span class="number">0</span>,
    scaleX: <span class="number">1</span>,
    scaleY: <span class="number">1</span>
};
</pre></td></tr></table></figure>


<p>代码较长</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">decomposeMatrix</span><span class="params">(matrix)</span> {</span>
    <span class="keyword">var</span> scaleX, scaleY, skew,
        A = matrix[<span class="number">0</span>],
        B = matrix[<span class="number">1</span>],
        C = matrix[<span class="number">2</span>],
        D = matrix[<span class="number">3</span>];

    <span class="comment">// Make sure matrix is not singular</span>
    <span class="keyword">if</span> (A * D - B * C) {
        scaleX = <span class="built_in">Math</span>.sqrt(A * A + B * B);
        skew = (A * C + B * D) / (A * D - C * B);
        scaleY = (A * D - B * C) / scaleX;
        <span class="comment">// step (6)</span>
        <span class="keyword">if</span> (A * D &lt; B * C) {
            skew = -skew;
            scaleX = -scaleX;
        }
        <span class="comment">// matrix is singular and cannot be interpolated</span>
    } <span class="keyword">else</span> {
        <span class="comment">// In this case the elem shouldn't be rendered, hence scale == 0</span>
        scaleX = scaleY = skew = <span class="number">0</span>;
    }

    <span class="comment">// The recomposition order is very important</span>
    <span class="comment">// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971</span>
    <span class="keyword">return</span> {
        translateX: myParse(matrix[<span class="number">4</span>]),
        translateY: myParse(matrix[<span class="number">5</span>]),
        rotate: myParse(<span class="built_in">Math</span>.atan2(B, A) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),
        skewX: myParse(<span class="built_in">Math</span>.atan(skew) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),
        skewY: <span class="number">0</span>,
        scaleX: myParse(scaleX),
        scaleY: myParse(scaleY)
    };
}

<span class="function"><span class="keyword">function</span> <span class="title">valueStringToArray</span><span class="params">(val)</span> {</span>
    <span class="keyword">var</span> result = val.split(<span class="string">","</span>);
    result = S.map(result, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
        <span class="keyword">return</span> myParse(value);
    });
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">function</span> <span class="title">parseTransform</span><span class="params">(val)</span> {</span>
    <span class="keyword">var</span> result = {
        translateX: <span class="number">0</span>,
        translateY: <span class="number">0</span>,
        rotate: <span class="number">0</span>,
        skewX: <span class="number">0</span>,
        skewY: <span class="number">0</span>,
        scaleX: <span class="number">1</span>,
        scaleY: <span class="number">1</span>
    };
    <span class="keyword">var</span> value;
    <span class="keyword">var</span> regResult;
    <span class="keyword">var</span> i, j, m;
    <span class="keyword">var</span> name;
    <span class="keyword">var</span> strs;
    strs = val.replace(rClearSpace, <span class="string">""</span>).split(<span class="string">")"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>, m = strs.length; i &lt; m; i++) {
        <span class="keyword">if</span> (!strs[i] || strs[i] === <span class="string">"none"</span>) <span class="keyword">continue</span>;
        regResult = strs[i].split(<span class="string">"("</span>);
        name = regResult[<span class="number">0</span>];
        value = valueStringToArray(regResult[<span class="number">1</span>]);
        <span class="keyword">switch</span> (name) {
            <span class="keyword">case</span> <span class="string">"matrix"</span>:
                result = decomposeMatrix(value);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"translate"</span>:
            <span class="keyword">case</span> <span class="string">"skew"</span>:
                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;
                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || <span class="number">0</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"scale"</span>:
                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;
                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || result[name + <span class="string">"X"</span>];
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"translateX"</span>:
            <span class="keyword">case</span> <span class="string">"translateY"</span>:
            <span class="keyword">case</span> <span class="string">"scaleX"</span>:
            <span class="keyword">case</span> <span class="string">"scaleY"</span>:
            <span class="keyword">case</span> <span class="string">"skewX"</span>:
            <span class="keyword">case</span> <span class="string">"skewY"</span>:
            <span class="keyword">case</span> <span class="string">"rotate"</span>:
                result[name] = value[<span class="number">0</span>] || <span class="number">0</span>;
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">continue</span>;
        }
    }
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<p>这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>
<h4 id="计算-2">计算</h4>
<p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">computeTransform</span><span class="params">(from, to, pos)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default;
    <span class="keyword">var</span> result = {};
    S.each(to, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> {</span>
        result[key] = _default.compute(from[key], to[key], pos);
    });
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<h3 id="赋值-2">赋值</h3>
<p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">assignTransform</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">var</span> valueArray = [];
    S.each(val, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> {</span>
        <span class="keyword">if</span> ((key.indexOf(<span class="string">"scale"</span>) &gt; -<span class="number">1</span> && value === <span class="number">1</span>) || (key.indexOf(<span class="string">"scale"</span>) === -<span class="number">1</span> && value === <span class="number">0</span>)) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (key === <span class="string">"rotate"</span> || key.indexOf(<span class="string">"skew"</span>) &gt; -<span class="number">1</span>) {
            value += <span class="string">"deg"</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (key.indexOf(<span class="string">"translate"</span>) &gt; -<span class="number">1</span>) {
            value += <span class="string">"px"</span>;
        }
        valueArray.push(key + <span class="string">"("</span> + value + <span class="string">")"</span>);
    });
    Dom.css(elem, style, valueArray.join(<span class="string">" "</span>));
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank">Github页面</a></p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Kissy" scheme="http://lingyu.wang/tags/Kissy/"/>
    
      <category term="动画" scheme="http://lingyu.wang/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端综合" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebRTC的RTCDataChannel]]></title>
    <link href="http://lingyu.wang/2014/05/22/webrtc-data-channels/"/>
    <id>http://lingyu.wang/2014/05/22/webrtc-data-channels/</id>
    <published>2014-05-21T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.189Z</updated>
    <content type="html"><![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
<a id="more"></a>

<blockquote>
<p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>
<h3 id="为什么我们需要另外一个数据通道">为什么我们需要另外一个数据通道</h3>
<p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/" target="_blank">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/" target="_blank">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/" target="_blank">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>
<p>RTCDataChannel则是一个完全不同的途径：</p>
<ul>
<li>它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。</li>
<li>RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features" target="_blank">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</li>
</ul>
<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>
<h3 id="一个警告：信令、STUN和TURN">一个警告：信令、STUN和TURN</h3>
<p>尽管WebRTC允许点对点的通信，但它依然需要服务器：</p>
<ul>
<li>信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器</li>
<li>NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</li>
</ul>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>
<h3 id="功能">功能</h3>
<p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能"><br>以上来自<a href="http://www.igvita.com/" target="_blank">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank">High Performance Browser Networking</a></p>
<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：</p>
<ul>
<li>可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢</li>
<li>不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</li>
</ul>
<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>
<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>
<h3 id="配置数据通道">配置数据通道</h3>
<p>网上已经有很多RTCDataChannel的例子了：</p>
<ul>
<li><a href="http://simpl.info/dc" target="_blank">simpl.info/dc</a></li>
<li><a href="http://googlechrome.github.io/webrtc/dc1.html" target="_blank">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)</li>
<li><a href="http://pubnub.github.io/webrtc" target="_blank">pubnub.github.io/webrtc</a>(两个PubNub用户)</li>
</ul>
<p>ps：PubBub是一个实时信息通讯应用开发公司</p>
<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> RTCPeerConnection();

<span class="comment">//使用信令传输信道创建对等连接</span>
<span class="keyword">var</span> dataChannel =
  peerConnection.createDataChannel(<span class="string">"myLabel"</span>, dataChannelOptions);

dataChannel.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
  console.log(<span class="string">"Data Channel Error:"</span>, error);
};

dataChannel.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
  console.log(<span class="string">"Got Data Channel Message:"</span>, event.data);
};

dataChannel.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  dataChannel.send(<span class="string">"Hello World!"</span>);
};

dataChannel.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">"The Data Channel is Closed"</span>);
};
</pre></td></tr></table></figure>


<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> dataChannelOptions = {
  ordered: <span class="literal">false</span>, <span class="comment">//不保证到达顺序</span>
  maxRetransmitTime: <span class="number">3000</span>, <span class="comment">//最大重传时间</span>
};
</pre></td></tr></table></figure>


<p>我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960" target="_blank">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758" target="_blank">RFC 3758</a>（SCTP部分可靠性）</p>
<ul>
<li>ordered: 数据通道是否保证按序传输数据</li>
<li>maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）</li>
<li>maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）</li>
<li>protocol：允许使用一个自协议，但如果协议不支持，将会失败</li>
<li>negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道</li>
<li>id：为数据通道提供一个自己定义的ID</li>
</ul>
<h3 id="它安全吗？">它安全吗？</h3>
<p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS" target="_blank">Wireshark的维基</a></p>
<h3 id="改变你考虑数据的方式">改变你考虑数据的方式</h3>
<p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/" target="_blank">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/" target="_blank">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>
<h3 id="搭建一个文件共享应用">搭建一个文件共享应用</h3>
<p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>
<p>需要成功传输一个文件，我们需要如下几步：</p>
<ol>
<li><a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/" target="_blank">通过JavaScript的File API读取文件数据</a></li>
<li>使用RTCPeerConnection在用户间创建一个对等连接</li>
<li>使用RTCDataChannel在用户间创建一个数据通道</li>
</ol>
<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：</p>
<ul>
<li><strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。</li>
<li><strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。</li>
<li><strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</li>
</ul>
<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span><span class="params">(blob)</span> {</span>
  <span class="keyword">var</span> link = document.createElement(<span class="string">'a'</span>);
  link.href = window.URL.createObjectURL(blob);
  link.download = <span class="string">'File Name'</span>;
  link.click();
};
</pre></td></tr></table></figure>


<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/" target="_blank">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest" target="_blank">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>
<h3 id="那么我们能做什么？">那么我们能做什么？</h3>
<p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：</p>
<ul>
<li>上面已经提到了点对点的文件传输了</li>
<li>多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/" target="_blank">Banana Bread</a></li>
<li>内容交付：由<a href="https://peercdn.com/" target="_blank">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</li>
</ul>
<h3 id="改变你构建应用的方式">改变你构建应用的方式</h3>
<p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/" target="_blank">PeerJS</a>和<a href="https://github.com/pubnub/webrtc" target="_blank">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>
<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>
<h3 id="更多资讯">更多资讯</h3>
<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">Getting started with WebRTC</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank">WebRTC in the real world: STUN, TURN and signaling</a></li>
<li><a href="http://bit.ly/webrtcwebaudio" target="_blank">WebRTC resources</a></li>
<li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api" target="_blank">W3C Working Draft</a></li>
<li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04" target="_blank">IETF WebRTC Data Channel Protocol Draft</a></li>
<li><a href="http://bloggeek.me/send-file-webrtc-data-api/" target="_blank">How to send a File Using WebRTC Data API</a></li>
<li><a href="http://bloggeek.me/webrtc-data-channel-uses/" target="_blank">7 Creative Uses of WebRTC’s Data Channel</a></li>
<li><a href="https://developer.mozilla.org/en/demos/detail/bananabread" target="_blank">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
]]>
    
    </summary>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用导航计时监测渲染关键路径]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/"/>
    <id>http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:42.952Z</updated>
    <content type="html"><![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br><a id="more"></a></p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        <span class="keyword">var</span> stats = document.createElement(<span class="string">'p'</span>);
        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +
            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;
        document.body.appendChild(stats);
      }
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS的渲染阻塞]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-render-blocking-css/"/>
    <id>http://lingyu.wang/2014/05/21/google-render-blocking-css/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:45.171Z</updated>
    <content type="html"><![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
<a id="more"></a>

<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>默认情况下CSS是渲染阻塞资源</li>
<li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
<li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>
<h3 id="CSS是渲染阻塞资源">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>
<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>
<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>
<h3 id="媒体类型和媒体查询">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"other.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"(min-width: 40em)"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>
<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>
<p>让我们考虑如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"portrait.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<ol>
<li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
<li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
<li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
<li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>
<h3 id="浏览器下载">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过JavaScript增加交互性]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/"/>
    <id>http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:30.756Z</updated>
    <content type="html"><![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<a id="more"></a>

<h3 id="长话短说">长话短说</h3>
<ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span>
      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span>
      <span class="comment">// create a new element, style it, and append it to the DOM</span>
      <span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
      loadTime.style.color = <span class="string">'blue'</span>;
      document.body.appendChild(loadTime);
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span>
span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span>
<span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span>
<span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
loadTime.style.color = <span class="string">'blue'</span>;
document.body.appendChild(loadTime);
</pre></td></tr></table></figure>


<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre> <span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建对象模型]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-constructing-the-object-model/"/>
    <id>http://lingyu.wang/2014/05/20/google-constructing-the-object-model/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:34.945Z</updated>
    <content type="html"><![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br><a id="more"></a></p>
<h2 id="长话短说">长话短说</h2>
<ul>
<li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
<li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
<li>DOM和CSSOM是互相独立的数据结构</li>
<li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>
<h2 id="DOM树构建">DOM树构建</h2>
<p>比如一段如下HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>其从字节到DOM树的过程如下图所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程"></p>
<p>具体的过程分为如下几步：</p>
<ol>
<li>转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符</li>
<li>标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则</li>
<li>对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则</li>
<li>DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</li>
</ol>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构"></p>
<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>
<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程"></p>
<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>
<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>
<h2 id="CSSOM树构建">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16</span>px </span></span></span>}
<span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold </span></span></span>}
<span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red </span></span></span>}
<span class="tag">p</span> <span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none </span></span></span>}
<span class="tag">img</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> right </span></span></span>}
</pre></td></tr></table></figure>


<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>
<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM"></p>
<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM"></p>
<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>
<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>
<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理"></p>
<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渲染树的构建，布局和绘制]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/"/>
    <id>http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:47.114Z</updated>
    <content type="html"><![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
<a id="more"></a>

<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>DOM树和CSSOM树结合组成了渲染树</li>
<li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
<li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
<li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>
<h3 id="构建渲染树">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树"></p>
<p>为了构建渲染树，浏览器所做的工作大致如下：</p>
<ol>
<li>从DOM树的根节点开始，遍历每个可见的节点<ul>
<li>有些节点本身不可见（比如script、meta等等）</li>
<li>有些节点被CSS隐藏了，这些节点也会被渲染树忽略</li>
</ul>
</li>
<li>对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息</li>
<li>提交可见的节点和他们的内容和样式</li>
</ol>
<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>
<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>
<h3 id="布局阶段">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>
<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>
<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>
<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>
<h3 id="绘制阶段">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段"></p>
<ul>
<li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
<li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>
<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>
<p>这些都完成后，我们的页面终于展示在视口里了</p>
<h3 id="总结">总结</h3>
<p>我们来重温一下所有的步骤：</p>
<ol>
<li>处理HTML标记，构建DOM树</li>
<li>处理CSS标记，构建CSSOM树</li>
<li>合并DOM树和CSSOM树，构建渲染树</li>
<li>在渲染树上运行布局阶段，计算每个可见节点的几何图形</li>
<li>绘制每个独立的节点到屏幕上</li>
</ol>
<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>
<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[响应式Web设计基础]]></title>
    <link href="http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/"/>
    <id>http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/</id>
    <published>2014-05-18T16:00:00.000Z</published>
    <updated>2014-11-18T07:41:49.317Z</updated>
    <content type="html"><![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
<a id="more"></a>

<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/" target="_blank">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>
<h2 id="设置视口信息">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>
<h3 id="长话短说">长话短说</h3>
<ol>
<li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
<li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
<li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
<li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>
<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>
<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>
<h3 id="确定一个可访问的视口">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>
<h2 id="使得内容适配视口">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>
<h3 id="长话短说-1">长话短说</h3>
<ol>
<li>不要为元素设定大且固定的尺寸</li>
<li>内容的展现不应该依赖于一个特定的视口宽度</li>
<li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>
<h3 id="最佳实践-1">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>
<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>
<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>
<h2 id="为响应式使用CSS的媒体查询">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>
<h3 id="长话短说-2">长话短说</h3>
<ol>
<li>媒体查询可以根据设备特点来应用样式</li>
<li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
<li>为元素使用相对大小防止破坏布局</li>
</ol>
<h3 id="最佳实践-2">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> print </span>{
  <span class="comment">/* print style sheets go here */</span>
}

<span class="at_rule">@<span class="keyword">import</span> <span class="function">url(print.css)</span> print</span>;
</pre></td></tr></table></figure>


<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>
<h3 id="根据视口大小使用媒体查询">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> (query) </span>{
  <span class="comment">/* CSS Rules used when query matches */</span>
}
</pre></td></tr></table></figure>


<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>
<ul>
<li>min-width: 匹配所有宽度大于设定值的浏览器</li>
<li>max-width: 匹配所有宽度小于设定值的浏览器</li>
<li>min-height: 匹配所有高度大于设定值的浏览器</li>
<li>max-height: 匹配所有高度小于设定值的浏览器</li>
<li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li>
<li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li>
</ul>
<h3 id="关于min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>
<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>
<h3 id="使用相对单位">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>
<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>
<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>
<h2 id="如何选择断点">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>
<h3 id="长话短说-3">长话短说</h3>
<ol>
<li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
<li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
<li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>
<h3 id="从小到大来挑选主要断点">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>
<h3 id="必要时添加次要断点">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>
<h3 id="优化文本阅读">优化文本阅读</h3>
<p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>
<h3 id="不要完全隐藏内容">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的异步控制]]></title>
    <link href="http://lingyu.wang/2014/05/17/read-jq-src-5/"/>
    <id>http://lingyu.wang/2014/05/17/read-jq-src-5/</id>
    <published>2014-05-16T16:00:00.000Z</published>
    <updated>2014-11-18T07:49:33.684Z</updated>
    <content type="html"><![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<a id="more"></a>

<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</pre></td></tr></table></figure>


<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span>
    <span class="comment">/*用于存放运行结果*/</span>
    memory,
    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span>
    fired,
    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span>
    firing,
    <span class="comment">/*第一个被执行的回调函数*/</span>
    firingStart,
    <span class="comment">/*回调函数列表的长度*/</span>
    firingLength,
    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span>
    firingIndex,
    <span class="comment">/*保存回调函数的列表*/</span>
    list = [],
    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span>
    stack = !options.once && [],
</pre></td></tr></table></figure>


<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> {</span>
    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span>
    memory = options.memory && data;
    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span>
    fired = <span class="literal">true</span>;
    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span>
    firingIndex = firingStart || <span class="number">0</span>;
    <span class="comment">/*将起始设为0*/</span>
    firingStart = <span class="number">0</span>;
    <span class="comment">/*获取回调函数列表的总长度*/</span>
    firingLength = list.length;
    <span class="comment">/*修改状态为正在执行*/</span>
    firing = <span class="literal">true</span>;
    <span class="comment">/*依次执行回调函数*/</span>
    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {
        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span>
        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {
            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span>
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">/*修改正在执行状态为false*/</span>
    firing = <span class="literal">false</span>;
    
    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*多次执行的话，stack是个数组*/</span>
        <span class="keyword">if</span> ( stack ) {
            <span class="comment">/*从等待队列中弹出数据再次执行*/</span>
            <span class="keyword">if</span> ( stack.length ) {
                fire( stack.shift() );
            }
        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            list = [];
        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span>
        } <span class="keyword">else</span> {
            self.disable();
        }
    }
},
</pre></td></tr></table></figure>


<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>add: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">//首先保存当前列表长度</span>
        <span class="keyword">var</span> start = list.length;
        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */</span>
        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> {</span>
            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
                <span class="keyword">var</span> type = jQuery.type( arg );
                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {
                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {
                    <span class="comment">// Inspect recursively</span>
                    add( arg );
                }
            });
        })( <span class="built_in">arguments</span> );
        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span>
        <span class="keyword">if</span> ( firing ) {
            firingLength = list.length;
        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span>
        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
            <span class="keyword">var</span> index;
            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span>
            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {
                <span class="comment">/*删除掉这个函数*/</span>
                list.splice( index, <span class="number">1</span> );
                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span>
                <span class="keyword">if</span> ( firing ) {
                    <span class="keyword">if</span> ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );
},
</pre></td></tr></table></figure>


<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = [];
    firingLength = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = stack = memory = <span class="literal">undefined</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !list;
},
</pre></td></tr></table></figure>


<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    stack = <span class="literal">undefined</span>;
    <span class="keyword">if</span> ( !memory ) {
        self.disable();
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !stack;
},
</pre></td></tr></table></figure>


<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> {</span>
    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span>
    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        <span class="comment">/*如果正在出发，就放到等待队列中*/</span>
        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span>
        <span class="keyword">if</span> ( firing ) {
            stack.push( args );
        <span class="comment">/*否则直接触发*/</span>
        } <span class="keyword">else</span> {
            fire( args );
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !!fired;
}
</pre></td></tr></table></figure>


<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> tuples = [
    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],
    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],
    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]
],
</pre></td></tr></table></figure>


<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">/*针对三个操作分别进行加工*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*获取操作的回调函数列表*/</span>
    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],
        <span class="comment">/*获取操作执行后的状态*/</span>
        stateString = tuple[ <span class="number">3</span> ];

    <span class="comment">// promise[ done | fail | progress ] = list.add</span>
    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span>
    promise[ tuple[<span class="number">1</span>] ] = list.add;

    <span class="comment">// Handle state</span>
    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span>
    <span class="keyword">if</span> ( stateString ) {
        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// state = [ resolved | rejected ]</span>
            state = stateString;

        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span>
        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );
    }
    
    <span class="comment">// deferred[ resolve | reject | notify ]</span>
    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span>
    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span>
    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;
});
</pre></td></tr></table></figure>


<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>promise = {
    <span class="comment">/*获得当前状态的方法*/</span>
    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> state;
    },
    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span>
    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span>
    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
        <span class="comment">/*then的代码*/</span>
    },
    <span class="comment">// Get a promise for this deferred</span>
    <span class="comment">// If obj is provided, the promise aspect is added to the object</span>
    <span class="comment">/*获取promise对象*/</span>
    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
<span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span>
promise.pipe = promise.then;
<span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span>
<span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*上面的代码*/</span>
});
<span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span>
promise.promise( deferred );
</pre></td></tr></table></figure>


<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;
    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */</span>
    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> {</span>
        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span>
        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span>
            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span>
                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span>
                } <span class="keyword">else</span> {
                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );
                }
            });
        });
        fns = <span class="literal">null</span>;
    }).promise();
},
</pre></td></tr></table></figure>


<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> {</span>
    <span class="keyword">var</span> i = <span class="number">0</span>,
        <span class="comment">/*切分参数到数组*/</span>
        resolveValues = slice.call( <span class="built_in">arguments</span> ),
        <span class="comment">/*数组长度*/</span>
        length = resolveValues.length,

        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span>
        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,
        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        /*
        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
        */</span>
        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
                contexts[ i ] = <span class="keyword">this</span>;
                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;
                <span class="keyword">if</span> ( values === progressValues ) {
                    deferred.notifyWith( contexts, values );
                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {
                    deferred.resolveWith( contexts, values );
                }
            };
        },

        progressValues, progressContexts, resolveContexts;

    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span>
    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {
        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span>
            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                resolveValues[ i ].promise()
                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                    .fail( deferred.reject )
                    .progress( updateFunc( i, progressContexts, progressValues ) );
            } <span class="keyword">else</span> {
                --remaining;
            }
        }
    }

    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span>
    <span class="keyword">if</span> ( !remaining ) {
        deferred.resolveWith( resolveContexts, resolveValues );
    }
    <span class="comment">/*将这个管理Deferred对象返回*/</span>
    <span class="keyword">return</span> deferred.promise();
}
</pre></td></tr></table></figure>


<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="JS技术" scheme="http://lingyu.wang/categories/JS%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的事件机制——核心篇]]></title>
    <link href="http://lingyu.wang/2014/05/12/read-jq-src-3/"/>
    <id>http://lingyu.wang/2014/05/12/read-jq-src-3/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2014-11-18T07:49:29.164Z</updated>
    <content type="html"><![CDATA[<p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>
<a id="more"></a>

<h1 id="jQuery源码——事件机制">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>
<h2 id="事件管理器">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>
<h3 id="global">global</h3>
<p>存放事件是否存在</p>
<h3 id="add_(elem,_types,_handler,_data,_selector)">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>
<p>所以代码大致流程如下：</p>
<h4 id="事件创建逻辑">事件创建逻辑</h4>
<p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> handleObjIn, eventHandle, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.get( elem );
    
<span class="keyword">if</span> ( !elemData ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( handler.handler ) {
    handleObjIn = handler;
    handler = handleObjIn.handler;
    selector = handleObjIn.selector;
}
</pre></td></tr></table></figure>


<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !handler.guid ) {
    handler.guid = jQuery.guid++;
}
</pre></td></tr></table></figure>


<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(events = elemData.events) ) {
    events = elemData.events = {};
}
<span class="keyword">if</span> ( !(eventHandle = elemData.handle) ) {
    eventHandle = elemData.handle = <span class="function"><span class="keyword">function</span><span class="params">( e )</span> {</span>
        <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== strundefined && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, <span class="built_in">arguments</span> ) : <span class="literal">undefined</span>;
    };
}
</pre></td></tr></table></figure>


<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>
<h4 id="事件绑定逻辑">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];
namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();

<span class="keyword">if</span> ( !type ) {
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};

type = ( selector ? special.delegateType : special.bindType ) || type;

special = jQuery.event.special[ type ] || {};
</pre></td></tr></table></figure>


<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>handleObj = jQuery.extend({
    type: type,
    origType: origType,
    data: data,
    handler: handler,
    guid: handler.guid,
    selector: selector,
    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
    namespace: namespaces.join(<span class="string">"."</span>)
}, handleObjIn );
</pre></td></tr></table></figure>


<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>
<ol>
<li>type：事件的映射后的名称</li>
<li>origType：事件的原始名称</li>
<li>data：事件的默认数据</li>
<li>handler：回调函数</li>
<li>guid：回调函数的id</li>
<li>selector：启用事件代理时，被代理的节点的选择器</li>
<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>
<li>namespace：重组后的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(handlers = events[ type ]) ) {
    handlers = events[ type ] = [];
    handlers.delegateCount = <span class="number">0</span>;

    <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) {
        <span class="keyword">if</span> ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, <span class="literal">false</span> );
        }
    }
}
</pre></td></tr></table></figure>


<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.add ) {
    special.add.call( elem, handleObj );

    <span class="keyword">if</span> ( !handleObj.handler.guid ) {
        handleObj.handler.guid = handler.guid;
    }
}
</pre></td></tr></table></figure>


<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( selector ) {
    handlers.splice( handlers.delegateCount++, <span class="number">0</span>, handleObj );
} <span class="keyword">else</span> {
    handlers.push( handleObj );
}
</pre></td></tr></table></figure>


<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>jQuery.event.global[ type ] = <span class="literal">true</span>;
</pre></td></tr></table></figure>


<p>最后再全局中标记一下事件已存在就行了</p>
<h3 id="remove_(elem,_types,_handler,_selector,_mappedTypes)">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>
<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> j, origCount, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.hasData( elem ) && data_priv.get( elem );
<span class="keyword">if</span> ( !elemData || !(events = elemData.events) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，和上面的add一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];

namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();
</pre></td></tr></table></figure>


<p>获取事件的命名空间，和add方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !type ) {
    <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) {
        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="literal">true</span> );
    }
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
origCount = j = handlers.length;
<span class="keyword">while</span> ( j-- ) {
    <span class="comment">//详细删除代码</span>
}
</pre></td></tr></table></figure>


<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>handleObj = handlers[ j ];
<span class="keyword">if</span> ( ( mappedTypes || origType === handleObj.origType ) &&
    ( !handler || handler.guid === handleObj.guid ) &&
    ( !tmp || tmp.test( handleObj.namespace ) ) &&
    ( !selector || selector === handleObj.selector || selector === <span class="string">"**"</span> && handleObj.selector ) ) {
    handlers.splice( j, <span class="number">1</span> );

    <span class="keyword">if</span> ( handleObj.selector ) {
        handlers.delegateCount--;
    }
    <span class="keyword">if</span> ( special.remove ) {
        special.remove.call( elem, handleObj );
    }
}
</pre></td></tr></table></figure>


<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( origCount && !handlers.length ) {
    <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class="literal">false</span> ) {
        jQuery.removeEvent( elem, type, elemData.handle );
    }
    <span class="keyword">delete</span> events[ type ];
}
</pre></td></tr></table></figure>


<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) {
    <span class="keyword">delete</span> elemData.handle;
    data_priv.remove( elem, <span class="string">"events"</span> );
}
</pre></td></tr></table></figure>


<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>
<h3 id="trigger_(event,_data,_elem,_onlyHandlers)">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> i, cur, tmp, bubbleType, ontype, handle, special,
    eventPath = [ elem || document ],
    type = hasOwn.call( event, <span class="string">"type"</span> ) ? event.type : event,
    namespaces = hasOwn.call( event, <span class="string">"namespace"</span> ) ? event.namespace.split(<span class="string">"."</span>) : [];

cur = tmp = elem = elem || document;

<span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>检测是否有focus和blur事件，它们不会在这里被触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt;= <span class="number">0</span> ) {
    namespaces = type.split(<span class="string">"."</span>);
    type = namespaces.shift();
    namespaces.sort();
}
ontype = type.indexOf(<span class="string">":"</span>) &lt; <span class="number">0</span> && <span class="string">"on"</span> + type;
</pre></td></tr></table></figure>


<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>event = event[ jQuery.expando ] ?
    event :
    <span class="keyword">new</span> jQuery.Event( type, <span class="keyword">typeof</span> event === <span class="string">"object"</span> && event );

event.isTrigger = onlyHandlers ? <span class="number">2</span> : <span class="number">3</span>;
event.namespace = namespaces.join(<span class="string">"."</span>);
event.namespace_re = event.namespace ?
    <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(^|\\.)"</span> + namespaces.join(<span class="string">"\\.(?:.*\\.|)"</span>) + <span class="string">"(\\.|$)"</span> ) :
    <span class="literal">null</span>;

event.result = <span class="literal">undefined</span>;
<span class="keyword">if</span> ( !event.target ) {
    event.target = elem;
}
</pre></td></tr></table></figure>


<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>
<ol>
<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>
<li>namespace: 事件的命名空间</li>
<li>namespace_re: 一个用于匹配当前命名空间的正则</li>
<li>result: 事件运行的结果</li>
<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>
</ol>
<p>事件对象的具体实现，后面会说</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>data = data == <span class="literal">null</span> ?
    [ event ] :
    jQuery.makeArray( data, [ event ] );

special = jQuery.event.special[ type ] || {};
<span class="keyword">if</span> ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    <span class="comment">/*如果是特殊事件，需要找到对应的真实名称*/</span>
    bubbleType = special.delegateType || type;
    <span class="keyword">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
    }
    <span class="keyword">for</span> ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
    }

    <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span>
    <span class="keyword">if</span> ( tmp === (elem.ownerDocument || document) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
    }
}
</pre></td></tr></table></figure>


<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
    event.type = i &gt; <span class="number">1</span> ?
        bubbleType :
        special.bindType || type;

    handle = ( data_priv.get( cur, <span class="string">"events"</span> ) || {} )[ event.type ] && data_priv.get( cur, <span class="string">"handle"</span> );
    <span class="keyword">if</span> ( handle ) {
        handle.apply( cur, data );
    }

    handle = ontype && cur[ ontype ];
    <span class="keyword">if</span> ( handle && handle.apply && jQuery.acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        <span class="keyword">if</span> ( event.result === <span class="literal">false</span> ) {
            event.preventDefault();
        }
    }
}
event.type = type;
</pre></td></tr></table></figure>


<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !event.isDefaultPrevented() ) {
    <span class="keyword">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="literal">false</span>) &&
        jQuery.acceptData( elem ) ) {
        <span class="keyword">if</span> ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
            tmp = elem[ ontype ];
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = <span class="literal">null</span>;
            }
            jQuery.event.triggered = type;
            elem[ type ]();
            jQuery.event.triggered = <span class="literal">undefined</span>;
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = tmp;
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>运行完了，返回事件运行的结果</p>
<h3 id="dispatch_(event)">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>
<ol>
<li>事件代理的情况</li>
<li>特殊事件</li>
<li>回调终止（stopPropagation）</li>
<li>事件的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>event = jQuery.event.fix( event );

<span class="keyword">var</span> i, j, ret, matched, handleObj,
    handlerQueue = [],
    args = slice.call( <span class="built_in">arguments</span> ),
    handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="string">"events"</span> ) || {} )[ event.type ] || [],
    special = jQuery.event.special[ event.type ] || {};

args[<span class="number">0</span>] = event;
event.delegateTarget = <span class="keyword">this</span>;
</pre></td></tr></table></figure>


<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.preDispatch && special.preDispatch.call( <span class="keyword">this</span>, event ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );
</pre></td></tr></table></figure>


<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
    event.currentTarget = matched.elem;
    j = <span class="number">0</span>;
    <span class="keyword">while</span> ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
        <span class="keyword">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                    .apply( matched.elem, args );
            <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) {
                <span class="keyword">if</span> ( (event.result = ret) === <span class="literal">false</span> ) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>
<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.postDispatch ) {
    special.postDispatch.call( <span class="keyword">this</span>, event );
}
<span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>
<h3 id="handlers_(event,_handlers)">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> i, matches, sel, handleObj,
    handlerQueue = [],
    delegateCount = handlers.delegateCount,
    cur = event.target;
</pre></td></tr></table></figure>


<p>获取当前事件的目标和代理个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">//如果存在代理</span>
<span class="keyword">if</span> ( delegateCount && cur.nodeType && (!event.button || event.type !== <span class="string">"click"</span>) ) {
    <span class="comment">//从被代理元素冒泡到代理元素</span>
    <span class="keyword">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || <span class="keyword">this</span> ) {
        <span class="comment">//屏蔽disable元素的点击事件</span>
        <span class="keyword">if</span> ( cur.disabled !== <span class="literal">true</span> || event.type !== <span class="string">"click"</span> ) {
            <span class="comment">//cur元素需要执行的回调对象列表</span>
            matches = [];
            <span class="comment">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span>
            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; delegateCount; i++ ) {
                handleObj = handlers[ i ];
                sel = handleObj.selector + <span class="string">" "</span>;
                <span class="comment">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span>
                <span class="keyword">if</span> ( matches[ sel ] === <span class="literal">undefined</span> ) {
                    matches[ sel ] = handleObj.needsContext ?
                        jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= <span class="number">0</span> :
                        jQuery.find( sel, <span class="keyword">this</span>, <span class="literal">null</span>, [ cur ] ).length;
                }
                <span class="comment">//如果符合,说明cur元素需要执行这个回调,加到列表中</span>
                <span class="keyword">if</span> ( matches[ sel ] ) {
                    matches.push( handleObj );
                }
            }
            <span class="comment">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span>
            <span class="keyword">if</span> ( matches.length ) {
                handlerQueue.push({ elem: cur, handlers: matches });
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>
<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>
<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>
<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( delegateCount &lt; handlers.length ) {
    handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });
}
<span class="keyword">return</span> handlerQueue;
</pre></td></tr></table></figure>


<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>
<h2 id="总结">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>
]]></content>
    <summary type="html">
    <![CDATA[这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="JS技术" scheme="http://lingyu.wang/categories/JS%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
