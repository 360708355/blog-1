<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天镶的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://lingyu.wang/"/>
  <updated>2014-11-17T06:01:07.137Z</updated>
  <id>http://lingyu.wang/</id>
  
  <author>
    <name><![CDATA[天镶]]></name>
    <email><![CDATA[lingyucoder@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用WebRTC DataChannel在浏览器间传递数据]]></title>
    <link href="http://lingyu.wang/2014/10/21/datachannel/"/>
    <id>http://lingyu.wang/2014/10/21/datachannel/</id>
    <published>2014-10-20T16:00:00.000Z</published>
    <updated>2014-10-21T12:35:05.289Z</updated>
    <content type="html"><![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>
<a id="more"></a>

<p>如果对WebRTC和DataChannel不太了解的同学，可以先阅读如下文章：</p>
<ul>
<li><a href="http://lingyu.wang/2014/05/22/webrtc-data-channels/">WebRTC的RTCDataChannel</a></li>
<li><a href="http://lingyu.wang/2014/03/18/webRTC-2/">使用WebRTC搭建前端视频聊天室——信令篇</a></li>
<li><a href="http://lingyu.wang/2014/03/15/webRTC-1/">使用WebRTC搭建前端视频聊天室——入门篇</a></li>
</ul>
<h2 id="老刘和老姚">老刘和老姚</h2>
<p>当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程：</p>
<h3 id="不如钓鱼去">不如钓鱼去</h3>
<p>一些背景：</p>
<ul>
<li>老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话</li>
<li>片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定</li>
<li>门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达</li>
</ul>
<p>现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了:</p>
<ol>
<li>门卫老大爷认识老刘和老姚</li>
<li>老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚</li>
<li>老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了</li>
<li>老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘</li>
<li>老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了</li>
</ol>
<p>老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了</p>
<h3 id="换个角度">换个角度</h3>
<p>我们把角色做一个映射：</p>
<ul>
<li>老刘：浏览器1</li>
<li>老姚：浏览器2</li>
<li>片区：不同网段</li>
<li>保安：防火墙</li>
<li>片区凭证：ICE candidate</li>
<li>物业：ICE server</li>
<li>门牌号：session description</li>
<li>门卫老大爷：server</li>
</ul>
<p>于是乎故事就变成了这样：</p>
<ol>
<li>浏览器1和浏览器2在server上注册，并保有连接</li>
<li>浏览器1从ice server获取ice candidate并发送给server，并生成包含session description的offer，发送给server</li>
<li>server发送浏览器1的offer和ice candidate给浏览器2</li>
<li>浏览器2发送包含session description的answer和ice candidate给server</li>
<li>server发送浏览器2的answer和ice candidate给浏览器1</li>
</ol>
<p>这样，就建立了一个点对点的信道，流程如下所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog%2Fimg%2F2014-10-32%2Fdatachannel-task-seq.png" alt="信令交互流程"></p>
<h2 id="礼物">礼物</h2>
<h3 id="故事">故事</h3>
<p>老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。</p>
<p>这里可以做如下类比：</p>
<ol>
<li>10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了）</li>
<li>分成10份：将文件分片，转成多个chunk</li>
<li>老姚一次只能带一斤：datachannel每次传输的数据量不宜太大（<a href="http://stackoverflow.com/questions/15435121/what-is-the-maximum-size-of-webrtc-data-channel-messages" target="_blank">找到最合适的大小</a>）</li>
</ol>
<p>这其实就是通过datachannel传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件</p>
<h3 id="分片">分片</h3>
<p>通过HTML5的File API可以将type为file的input选中的文件读取出来，并转换成data url字符串。这也就为我们提供了很方便的分片方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> reader = <span class="keyword">new</span> window.FileReader(file);
reader.readAsDataURL(file);
reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(event, text)</span> {</span>
    chunkify(event.target.result);<span class="comment">//将数据分片</span>
};
</pre></td></tr></table></figure>


<h3 id="组合">组合</h3>
<p>通过datachannel发送的分片数据，我们需要将其进行组合，由于是data url字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的data url字符串，那么我们如何将这个字符串转换成文件呢？</p>
<h4 id="方案一：直接跳转下载">方案一：直接跳转下载</h4>
<p>既然是个dataurl，我们直接将其赋值给<code>window.location.href</code>自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼</p>
<h4 id="方案二：通过a标签下载">方案二：通过a标签下载</h4>
<p>这个原理和跳转下载类似，都是使用dataurl本身的特性，通过创建一个a标签，将dataurl字符串赋值给href属性，然后使用download确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为dataurl有<a href="http://stackoverflow.com/questions/695151/data-protocol-url-size-limitations" target="_blank">大小限制</a></p>
<h4 id="方案三：blob">方案三：blob</h4>
<p>其实可以通过给a标签创建blob url的方式来进行下载，这个没有大小限制。但是我们手上是dataurl，所以需要先进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span><span class="params">(dataURI, dataTYPE)</span> {</span>
    <span class="keyword">var</span> binary = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]),
        array = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) array.push(binary.charCodeAt(i));
    <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array)], {
        type: dataTYPE
    });
}
</pre></td></tr></table></figure>


<p>获得blob后，我们就可以通过URL API来下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> a = document.createElement(<span class="string">"a"</span>);
document.body.appendChild(a);
a.style = <span class="string">"display: none"</span>;
<span class="keyword">var</span> blob = dataURItoBlob(data, <span class="string">'octet/stream'</span>);
<span class="keyword">var</span> url = window.URL.createObjectURL(blob);
a.href = url;
a.download = filename;
a.click();
!moz && window.URL.revokeObjectURL(url);
a.parentNode.removeChild(a);
</pre></td></tr></table></figure>


<p>这里有几个点：</p>
<ol>
<li>datachannel其实是可以直接传送blob的，但是只有ff支持，所以传data url</li>
<li>chrome下载是直接触发的，不会进行询问，firefox会先询问后下载，在询问过程中如果执行了<code>revokeObjectURL</code>，下载就会取消，囧</li>
</ol>
<h2 id="升级">升级</h2>
<p>如我们所知，WebRTC最有特点的地方其实是可以传输getUserMedia获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32位机上一个连接至少20M左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含datachannel的连接用于传输数据，然后在需要时升级成可以传输视频、音频。</p>
<p>看看我们之前传输的session description，它其实来自<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank">Session Description Protocol</a>。可以看到wiki上的介绍：</p>
<blockquote>
<p>The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters.</p>
</blockquote>
<p>这意味着什么呢？我们之前建立datachannel是没有加视频、音频流的，而这个流的描述是写在SDP里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得SDP，然后构建offer和answer再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的ice candidate，这里我曾经<a href="http://stackoverflow.com/questions/26469794/webrtc-add-ice-candidate-error-on-established-peerconnection" target="_blank">遇到了坑</a>，经过国外大大的点拨才明白过来。</p>
<blockquote>
<p>from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything.</p>
</blockquote>
<h2 id="Peertc">Peertc</h2>
<p>我将datachannel和websocket组合，实现了一个构建点对点连接的库Peertc，它提供非常简洁的方式来建立连接和发送数据、文件和视频/音频流，详情见<a href="https://github.com/LingyuCoder/peertc" target="_blank">github</a>。走过路过的记得star一下哦，有什么bug也非常希望能够提出来。</p>
<h2 id="最后">最后</h2>
<p>WebRTC的点对点方式能够运用在很多场景：</p>
<ul>
<li>如web qq这种Web IM工具，这就不说了</li>
<li>如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送</li>
<li>一对一在线面试、在线教育，这其实是即时通信的一个业务方向</li>
<li>视频裸（），当我没说</li>
</ul>
<p>就酱，另外打个广告及拉点搜索引擎权重：<a href="http://lingyu.wang">我的博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>
]]>
    
    </summary>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="DataChannel" scheme="http://lingyu.wang/tags/DataChannel/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp思维 —— Gulp高级技巧]]></title>
    <link href="http://lingyu.wang/2014/10/07/getting-gulpy/"/>
    <id>http://lingyu.wang/2014/10/07/getting-gulpy/</id>
    <published>2014-10-06T16:00:00.000Z</published>
    <updated>2014-10-07T10:03:18.473Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/" target="_blank">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>
<a id="more"></a>

<h2 id="基本任务">基本任务</h2>
<p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> gulp.src(<span class="string">'./src/**/*.js'</span>)
        .pipe(uglify())
        .pipe(concat(<span class="string">'all.min.js'</span>))
        .pipe(gulp.dest(<span class="string">'build/'</span>));
});
</pre></td></tr></table></figure>


<p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p>
<h2 id="流不兼容？">流不兼容？</h2>
<p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p>
<p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-rename" target="_blank">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);
gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> fs.createReadStream(<span class="string">'app.js'</span>)
        .pipe(uglify())
        .pipe(rename(<span class="string">'bundle.min.js'</span>))
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});
</pre></td></tr></table></figure>


<p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p>
<h2 id="Vinyl文件对象">Vinyl文件对象</h2>
<p>gulp使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href="https://github.com/wearefractal/vinyl" target="_blank">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p>
<p>使用<a href="https://www.npmjs.org/package/vinyl-source-stream" target="_blank">vinyl-source-stream</a>是个不错的选择，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),
    marked = <span class="built_in">require</span>(<span class="string">'gulp-marked'</span>);
fs.createReadStream(<span class="string">'*.md'</span>)
    .pipe(source())
    .pipe(marked())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<p>另外一个例子首先通过<a href="http://browserify.org/" target="_blank">browserify</a>封装并最终将其转换为一个vinyl流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);
gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> browserify(<span class="string">'./src/app.js'</span>)
        .bundle()
        .pipe(source(‘bundle.min.js))
        .pipe(uglify())
        .pipe(gulp.dest(<span class="string">'dist/'</span>));
});
</pre></td></tr></table></figure>


<p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p>
<h3 id="gulp-dest">gulp.dest</h3>
<p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href="https://www.npmjs.org/package/mkdirp" target="_blank">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p>
<h2 id="流和buffer">流和buffer</h2>
<p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>fs.createReadStream(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
    console.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);
});
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; ...
</pre></td></tr></table></figure>


<p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>gulp.src(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
    console.log(<span class="string">'Read %d bytes of data'</span>, file.contents.length);
});
&gt; Read <span class="number">2493109</span> bytes of data
</pre></td></tr></table></figure>


<p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p>
<h2 id="Gulp默认使用buffer">Gulp默认使用buffer</h2>
<p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href="http://lisperator.net/uglifyjs/" target="_blank">UglifyJS</a>和<a href="https://github.com/google/traceur-compiler" target="_blank">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p>
<p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p>
<p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p>
<p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>gulp.src(<span class="string">'/usr/share/dict/words'</span>, {buffer: <span class="literal">false</span>}).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(file)</span> {</span>
    <span class="keyword">var</span> stream = file.contents;
    stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> {</span>
        console.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);
    });
});
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; Read <span class="number">65536</span> bytes of data
&gt; ...
</pre></td></tr></table></figure>


<h2 id="从流到buffer">从流到buffer</h2>
<p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-traceur" target="_blank">gulp-traceur</a>。你可以通过<a href="https://www.npmjs.org/package/gulp-buffer" target="_blank">gulp-buffer</a>来转换成buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),
    buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);
fs.createReadStream(<span class="string">'./src/app.js'</span>)
    .pipe(source(<span class="string">'app.min.js'</span>))
    .pipe(buffer())
    .pipe(uglify())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<p>或者另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),
    traceur = <span class="built_in">require</span>(<span class="string">'gulp-traceur'</span>);
gulp.src(<span class="string">'app.js'</span>, {buffer: <span class="literal">false</span>})
    .pipe(buffer())
    .pipe(traceur())
    .pipe(gulp.dest(<span class="string">'dist/'</span>));
</pre></td></tr></table></figure>


<h2 id="将buffer转换为流">将buffer转换为流</h2>
<p>你也可以使用<a href="https://www.npmjs.org/package/gulp-streamify" target="_blank">gulp-streamify</a>或<a href="https://www.npmjs.org/package/gulp-stream" target="_blank">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> wrap = <span class="built_in">require</span>(<span class="string">'gulp-wrap'</span>),
    streamify = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>),
    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),
    gzip = <span class="built_in">require</span>(<span class="string">'gulp-gzip'</span>);
gulp.src(<span class="string">'app.js'</span>, {buffer: <span class="literal">false</span>})
    .pipe(wrap(<span class="string">'(function(){&lt;%= contents %&gt;}());'</span>))
    .pipe(streamify(uglify()))
    .pipe(gulp.dest(<span class="string">'build'</span>))
    .pipe(gzip())
    .pipe(gulp.dest(<span class="string">'build'</span>));
</pre></td></tr></table></figure>


<h2 id="不是所有事都需要插件">不是所有事都需要插件</h2>
<p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p>
<h3 id="vinyl-source-stream">vinyl-source-stream</h3>
<p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href="https://www.npmjs.org/package/gulp-browserify" target="_blank">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p>
<h3 id="文本转换">文本转换</h3>
<p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">modify</span><span class="params">(modifier)</span> {</span>
    <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span><span class="params">(file, encoding, done)</span> {</span>
        <span class="keyword">var</span> content = modifier(<span class="built_in">String</span>(file.contents));
        file.contents = <span class="keyword">new</span> Buffer(content);
        <span class="keyword">this</span>.push(file);
        done();
    });
}
</pre></td></tr></table></figure>


<p>你可以像这样使用这个插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>gulp.task(<span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> gulp.src(<span class="string">'app.js'</span>)
        .pipe(modify(version))
        .pipe(modify(swapStuff))
        .pipe(gulp.dest(<span class="string">'build'</span>));
});
<span class="function"><span class="keyword">function</span> <span class="title">version</span><span class="params">(data)</span> {</span>
    <span class="keyword">return</span> data.replace(<span class="regexp">/__VERSION__/</span>, pkg.version);
}
<span class="function"><span class="keyword">function</span> <span class="title">swapStuff</span><span class="params">(data)</span> {</span>
    <span class="keyword">return</span> data.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2, $1'</span>);
}
</pre></td></tr></table></figure>


<p>这个插件并没有完成，而且也不能处理流（<a href="https://gist.github.com/webpro/a9a9e14d291c021894b3" target="_blank">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href="https://www.npmjs.org/package/through2" target="_blank">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p>
<h2 id="任务流程">任务流程</h2>
<p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href="https://www.npmjs.org/package/orchestrator" target="_blank">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p>
<ul>
<li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li>
<li>你需要更多的动态的和（或）可重用的子任务。</li>
</ul>
<h2 id="最后的思考">最后的思考</h2>
<p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p>
<p>阅读<a href="http://substack.net/task_automation_with_npm_run" target="_blank">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p>
<p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p>
<p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href="https://twitter.com/webprolific" target="_blank">@webprolific</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/" target="_blank">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp -- 项目的愿景、过去和将来]]></title>
    <link href="http://lingyu.wang/2014/10/06/gulp-vision-history-future/"/>
    <id>http://lingyu.wang/2014/10/06/gulp-vision-history-future/</id>
    <published>2014-10-05T16:00:00.000Z</published>
    <updated>2014-10-06T14:58:10.778Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>
<a id="more"></a>

<p>下面我们就来介绍gulp背后的各个部分以及它们所起到的作用。</p>
<h2 id="流">流</h2>
<p>流是一种将多个小的变换操作进行组合，连接成管道的一种方式。你将数据丢入管道顶部，它将下落并穿过所有的变换，最后在底部得到你想要的内容。流系统的灵活性能够很好地解决文件变换需求。</p>
<p>想获得更多关于流的信息，请查阅substack的<a href="https://github.com/substack/stream-handbook" target="_blank">流操作手册</a></p>
<h2 id="Vinyl">Vinyl</h2>
<p><a href="https://github.com/wearefractal/vinyl" target="_blank">Vinyl</a>是一个用来描述文件的简单元数据对象。当你想要使用一个文件时，首先映入脑海的是文件的两个属性：<a href="https://github.com/wearefractal/vinyl/blob/master/index.js#L18-L25" target="_blank">路径和内容</a>。这两个属性就是一个Vinyl对象的主要属性。这里的文件并不一定是指你的文件系统里的文件。你在S3、FTP、Dropbox、Box、CloudThingly.io或者其他服务上的文件，一样可以使用Vinyl来描述。</p>
<h2 id="Vinyl_Adapters（Vinyl适配器）">Vinyl Adapters（Vinyl适配器）</h2>
<p>既然Vinyl提供了一个清晰的方法用来描述文件，我们现在还需要找到访问这些文件的方式。每一种文件源我们都需要一个“Vinyl适配器”。一个Vinyl适配器只需要暴露三个方法：<code>.src(globs)</code>、<code>.dest(folder)</code>、和一个<code>.watch(globs, fn)</code>。src流负责产生文件对象，而dest流负责消费这些文件对象。</p>
<p>表面上看人们已经理解了“gulp插件”(一个transform形式的流)的概念，但Vinyl适配器的理念却没有被广泛传播。除非自己开发一些适配器，否则无法得知适配器是如何引用文件源中的内容。。通过Vinyl适配器来实现gulp，并将其作为一个开发工具的想法非常奇妙。</p>
<h3 id="vinyl-fs">vinyl-fs</h3>
<p>如果你使用gulp，你已经使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank">vinyl-fs</a>模块。它是用来适配本地文件系统的适配器。</p>
<h3 id="vinyl-s3">vinyl-s3</h3>
<p>vinyl-s3尚不存在，但<a href="https://github.com/nkostelnik/gulp-s3" target="_blank">gulp-s3</a>已经实现了。它无法提供所有的功能，但它是了一个不错的权宜方案。</p>
<h2 id="Orchestrator">Orchestrator</h2>
<p>在写这篇文章时，目前的任务系统是<a href="https://github.com/orchestrator/orchestrator" target="_blank">Orchestrator</a> 0.3。Orchestrator提供了简单的方式去定义任务和依赖，并能够在依赖树为基础的前提下以最大并发数去与并发执行这些任务。Orchestrator虽然工作良好，但它复杂的依赖管理给用户带来不小的麻烦。Orchestrator为了配合gulp的理念而做了巨大的调整：更加轻量、低复杂度，以及可组合的功能性API。</p>
<p>这里简要介绍一下gulp 4带来的变化：</p>
<ol>
<li>你可以任意指定任务顺序，并行/串行的任意组合都随心所欲。只有想不到，没有做不到</li>
<li>API将非常流畅和友好</li>
<li>代码更加简洁</li>
</ol>
<p>非常感谢Blaine Bublitz在这方面积极的努力。</p>
<h2 id="错误处理">错误处理</h2>
<p>实话告诉你：gulp现在的错误处理很烂。我从不期望能从报错信息中获得一点有用的信息。使用gulp的过程中，你可能会遭遇两种错误：</p>
<h3 id="任务失败">任务失败</h3>
<p>watch时出现任务失败，内部将会一团糟，然后线程会退出，具体的退出方式要取决你如何启动这个任务。这种情况非常糟糕，完全不应该发生，在新的任务系统中将对这些进行修复。</p>
<h3 id="管道失败">管道失败</h3>
<p>标准的流在遭遇错误时仅仅会停止工作。而像linter（代码风格检测）这样的任务，问题就来了。我想看到所有的代码风格提示，而不只是第一个文件里的那些。技术上其实是因为unpipe事件。本质上看，当一个流遇到错误，它将会触发<strong>unpipe</strong>事件，这个事件将告诉其他流不再向它写入数据。目前有一些hack的解决方法如gulp-plumber，可以作为权宜之计，但我很高兴的说，我将会把这些集成到gulp核心之中去。</p>
<p>这些问题我会在下个release版本最优先解决。</p>
<h2 id="社区">社区</h2>
<p>从一个局外人的角度来看，人们都能参与到这场文件转换工具的战斗之中，实在有些疯狂。虽然外人看来可能有些无趣，但成为这个激情小组的一部分绝对令人振奋。我很自豪社区能够接纳这个工具并对人们的日常生活带来帮助。</p>
<h2 id="进展">进展</h2>
<p>想要跟踪gulp 4的进展，你可以在github上查看<a href="https://github.com/gulpjs/gulp/issues?milestone=1&amp;state=open" target="_blank">里程碑</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[koa-anywhere]]></title>
    <link href="http://lingyu.wang/2014/09/24/koa-anywhere/"/>
    <id>http://lingyu.wang/2014/09/24/koa-anywhere/</id>
    <published>2014-09-23T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.178Z</updated>
    <content type="html"><![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>
<a id="more"></a>

<h1 id="koa-anywhere">koa-anywhere</h1>
<p>通过一条命令，将当前目录变成一个静态文件服务器</p>
<p>需要Node版本：&gt;= 0.11.13</p>
<h1 id="Install">Install</h1>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ npm install <span class="attribute">-g</span> koa<span class="attribute">-anywhere</span>
</pre></td></tr></table></figure>


<h1 id="Usage">Usage</h1>
<p>只需一条简单的命令<code>ka</code>就可以启动一个静态文件服务器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>cd &lt;想要共享的目录&gt;
<span class="variable">$ </span>ka
</pre></td></tr></table></figure>


<h2 id="Option">Option</h2>
<h3 id="port">port</h3>
<p>通过<code>-p &lt;端口号&gt;</code>或者<code>--port &lt;端口号&gt;</code>来指定静态文件服务器的端口</p>
<p>默认端口为<code>3000</code></p>
<h3 id="deep">deep</h3>
<p>通过<code>-d &lt;层级数&gt;</code>或者<code>--deep &lt;层级数&gt;</code>来确定静态文件需要显示的文件层级，超过层级的文件不显示</p>
<p>默认层级数为<code>3</code></p>
<h3 id="silent">silent</h3>
<p>通过<code>-s</code>或者<code>--silent</code>来决定是否显示日志</p>
<p>默认为<code>false</code>，也就是显示日志</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>
]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="koa" scheme="http://lingyu.wang/tags/koa/"/>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学前端的一点总结]]></title>
    <link href="http://lingyu.wang/2014/09/22/learn-fe/"/>
    <id>http://lingyu.wang/2014/09/22/learn-fe/</id>
    <published>2014-09-21T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.179Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>
<a id="more"></a>

<h4 id="工具">工具</h4>
<ul>
<li>chrome dev tools：前端开发调试利器，着重注意几个功能：<ul>
<li>console（废话）</li>
<li>elements:元素样式调整，很常用</li>
<li>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<ul>
<li>watch expression：通过表达式查看当前内存中的值</li>
<li>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）</li>
<li>scope variables：作用域链上的变量，非常有用</li>
</ul>
</li>
<li>network：抓包查看每个请求，非常重要，前后端联调必备</li>
<li>timeline：分析渲染、js执行等等各个阶段，性能优化利器</li>
<li>emulation：模拟移动端环境，mobile页面开发必备</li>
<li>一些插件:<ul>
<li>liveload: 修改页面后自动刷新，不用按F5</li>
<li>dimensions：直接在页面上测量的利器</li>
<li>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中</li>
<li>image tool：测量，取色</li>
<li>UC二维码：移动端调试扫码必备</li>
<li>pagespeed，YSlow：页面性能分析和优化插件</li>
<li>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录</li>
</ul>
</li>
</ul>
</li>
<li>sublime text2：编码方便，插件多，速度快，性能好<ul>
<li>emmet：提升html编码速度必备</li>
<li>sublimelinter + 各种语言的lint和hint：代码纠错</li>
<li>一些snippets：自动补全，提升开发效率</li>
</ul>
</li>
<li>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能</li>
<li>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件</li>
<li>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子</li>
<li>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备</li>
<li>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用</li>
<li>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</li>
</ul>
<h4 id="技能">技能</h4>
<p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p>
<h5 id="语言基础">语言基础</h5>
<p>JavaScript：</p>
<ul>
<li>作用域链、闭包、运行时上下文、this</li>
<li>原型链、继承</li>
<li>NodeJS基础和常用API</li>
</ul>
<p>CSS：</p>
<ul>
<li>选择器</li>
<li>浏览器兼容性及常见的hack处理</li>
<li>CSS布局的方式和原理（盒子模型、BFC、IFC等等）</li>
<li>CSS 3，如animation、gradient、等等</li>
</ul>
<p>HTML：</p>
<ul>
<li>语义化标签</li>
</ul>
<h5 id="进阶">进阶</h5>
<p>JavaScript:</p>
<ul>
<li>异步控制（Promise、ES6 generator、Async）</li>
<li>模块化的开发方式（AMD、CMD、KMD等等）</li>
<li>JavaScript解释器的一些相关知识<ul>
<li>异步IO实现</li>
<li>垃圾回收</li>
<li>事件队列</li>
</ul>
</li>
<li>常用框架使用及其原理<ul>
<li>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研</li>
<li>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦</li>
<li>underscore：优秀的工具库，方便的理解常用工具代码片段的实现</li>
<li>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</li>
</ul>
</li>
</ul>
<p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p>
<ul>
<li>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程</li>
<li>解析HTML、CSS、JavaScript时造成的阻塞</li>
<li>HTML5相关<ul>
<li>SVG及矢量图原理</li>
<li>Canvas开发及动画原理（帧动画）</li>
<li>Video和Audio</li>
</ul>
</li>
<li>flex box布局方式</li>
<li>icon fonts的使用</li>
</ul>
<p>常用NodeJs的package：</p>
<ul>
<li>koa</li>
<li>express</li>
<li>underscore</li>
<li>async</li>
<li>gulp</li>
<li>grunt</li>
<li>connect</li>
<li>request</li>
</ul>
<p>一些理念：</p>
<ul>
<li>响应式Web</li>
<li>优雅降级、渐进增强</li>
<li>don`t make me think</li>
<li>网页可用性、可访问性、其中的意义</li>
<li>SEO搜索引擎优化，了解搜索引擎的原理</li>
<li>SPA的好处和问题</li>
</ul>
<p>性能优化：</p>
<ul>
<li>减少请求数量（sprite、combo）</li>
<li>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）</li>
<li>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）</li>
<li>CSS的回流与重绘</li>
</ul>
<h5 id="项目">项目</h5>
<ul>
<li>版本管理：首推Git，用过Git都不会想用SVN了<ul>
<li>Git：本地版本管理的机制</li>
<li>SVN：远程中心的版本管理机制</li>
</ul>
</li>
<li>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<ul>
<li>Gulp：基于流构建，速度快、模块质量好</li>
<li>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高</li>
</ul>
</li>
<li>预处理和模板引擎<ul>
<li>less：语法简单，但功能有限</li>
<li>jade、ejs、velocity等模板引擎，各有各的长处</li>
<li>coffee：python工程师最爱，我没用过</li>
</ul>
</li>
<li>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<ul>
<li>本地代理：ihosts</li>
</ul>
</li>
<li>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<ul>
<li>jasmine</li>
<li>mocha</li>
</ul>
</li>
<li>生态系统<ul>
<li>npm</li>
<li>bower</li>
<li>spm</li>
</ul>
</li>
<li>搭建一个属于自己的博客<ul>
<li>git pages</li>
<li>hexo</li>
<li>jekyll</li>
</ul>
</li>
</ul>
<h5 id="未来">未来</h5>
<ul>
<li>Web Componets：面向未来的组件化开发方式<ul>
<li>HTML模板</li>
<li>Shadow DOM</li>
<li>Custom Elements</li>
<li>HTML Import</li>
</ul>
</li>
<li>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</li>
</ul>
<h5 id="其他">其他</h5>
<p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p>
<ul>
<li><strong>对于业务的思考</strong>：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务</li>
<li>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目</li>
<li>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录</li>
<li>对新技术的渴望，以及敢于尝试</li>
</ul>
<h4 id="入门书">入门书</h4>
<p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p>
<ul>
<li>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看</li>
<li>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助</li>
<li>《编写可维护的JavaScript》和：</li>
<li>《Node.js开发指南》：不错的Nodejs入门书籍</li>
<li>《深入浅出Node.js》：Nodejs进阶书籍，必备</li>
<li>《JavaScript异步编程》：理解JS异步的编程理念</li>
<li>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书</li>
<li>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西</li>
<li>《Don`t make me think》：网页设计的理念，了解用户行为，非常不错</li>
<li>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题</li>
<li>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习</li>
<li>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助</li>
<li>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识</li>
<li>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想</li>
<li>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</li>
</ul>
<h4 id="一些不错的网站">一些不错的网站</h4>
<ul>
<li><a href="https://github.com" target="_blank">github</a>：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习</li>
<li><a href="http://codepen.io/" target="_blank">codepen</a>：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件</li>
<li><a href="http://www.echojs.com/" target="_blank">echojs</a>：快速了解js新资讯的网站</li>
<li><a href="http://stackoverflow.com/" target="_blank">stackoverflow</a>和<a href="segmentfault.com">segmentfault</a>：基本上各种问题都能在上面获得解答</li>
<li><a href="https://developers.google.com/web/fundamentals/" target="_blank">google web fundamentals</a>：每篇文章都适合仔细阅读</li>
<li><a href="http://www.staticfile.org/" target="_blank">static files</a>：开放的CDN，很好用</li>
<li><a href="http://www.iconfont.cn/" target="_blank">iconfont</a>：阿里的矢量图标库，非常不错，支持CDN而且支持项目</li>
<li><a href="http://www.html5rocks.com/" target="_blank">html5 rocks</a>: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章</li>
<li><a href="http://css-tricks.com/" target="_blank">css tricks</a>：如何活用CSS，以及了解CSS新特性，这里可以满足你</li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.general" target="_blank">JavaScript 秘密花园</a> JavaScript初学必看，非常不错</li>
<li><a href="http://www.w3cplus.com/" target="_blank">w3cplus</a>：一个前端学习的网站，里面的文章质量都挺不错的</li>
<li><a href="http://nodeschool.io/" target="_blank">node school</a>：一个不错的node学习网站</li>
<li><a href="http://pcottle.github.io/learnGitBranching/?demo" target="_blank">learn git branch</a>：一个git学习网站，交互很棒</li>
<li><a href="http://www.html-js.com/" target="_blank">前端乱炖</a>：一个前端文章分享的社区，有很多优秀文章</li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank">正则表达式</a>：一个正则表达式入门教程，非常值得一看</li>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank">阮一峰的博客</a>和<a href="http://www.zhangxinxu.com/wordpress/" target="_blank">张鑫旭的博客</a>：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源</li>
<li>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的</li>
<li>各种规范的官方网站，不懂得时候读规范</li>
</ul>
<h4 id="历程">历程</h4>
<p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和<a href="http://www.w3school.com.cn/" target="_blank">W3C School</a>上的教程，以及一些前端博客，如<a href="http://www.cnblogs.com/TomXu/" target="_blank">汤姆大叔的博客</a>。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="思考" scheme="http://lingyu.wang/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说Generator]]></title>
    <link href="http://lingyu.wang/2014/07/29/generator/"/>
    <id>http://lingyu.wang/2014/07/29/generator/</id>
    <published>2014-07-28T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.169Z</updated>
    <content type="html"><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
<a id="more"></a>

<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>
<h1 id="Generator函数">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>
<ol>
<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
<li>创建一个generator对象，其有如下值：<ul>
<li>Scope：新建的作用域链</li>
<li>Code：generator function内部的代码</li>
<li>ExecutionContext：EC，目前值为null</li>
<li>State：”newborn”</li>
<li>Handler：默认的generator的处理器</li>
</ul>
</li>
</ol>
<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>
<h1 id="yield的行为">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
<li>从EC栈弹出当前的EC</li>
<li>返回(normal, 1中的结果值, null)</li>
</ol>
<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>
<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>
<h1 id="return行为">return行为</h1>
<p>当执行到<code>return e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
<li>将这个generator对象的状态修改为closed</li>
<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
<li>throw这个对象</li>
</ol>
<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>
<h1 id="Generator对象的私有属性">Generator对象的私有属性</h1>
<ul>
<li>prototype：Object.prototype</li>
<li>code：generator函数的函数体</li>
<li>ExecutionContext：内部代码运行使用的EC</li>
<li>Scope：作用域链</li>
<li>Handler：标准的generator句柄</li>
<li>State：newborn、executing、suspended、closed</li>
<li>Send：看内部方法部分</li>
<li>Throw：看内部方法部分</li>
<li>Close：看内部方法部分</li>
</ul>
<h1 id="外部接口">外部接口</h1>
<h2 id="next">next</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入一个undefined</li>
<li>返回结果</li>
</ol>
<p>调用私有send方法</p>
<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<p>同样是调用私有send方法，不过传入了参数</p>
<h2 id="throw">throw</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.throw，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.close，不传入任何参数</li>
<li>返回结果</li>
</ol>
<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>
<h2 id="小结">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>
<h1 id="状态定义">状态定义</h1>
<ul>
<li>newborn：Code不为null，EC为null</li>
<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
<li>closed：Code为null，EC为null</li>
</ul>
<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>
<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>
<p>当然也可以通过close方法，手动修改状态为closed</p>
<h1 id="内部方法">内部方法</h1>
<h2 id="send方法">send方法</h2>
<ol>
<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
<li>如果state为newborn<ol>
<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
<li>将这个EC压入EC栈中</li>
<li>执行generator中的代码，并返回或得到的结果</li>
</ol>
</li>
<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>
<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>
<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>
<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>
<h2 id="throw-1">throw</h2>
<ol>
<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>
<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>
<h2 id="close-1">close</h2>
<ol>
<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
<li>如果state已经是closed了，那直接return就好</li>
<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>
<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>
<h2 id="Resume(EC,_completionType,_V)">Resume(EC, completionType, V)</h2>
<ol>
<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
<li>从EC通过currentGenerator获取单签generator对象</li>
<li>设置当前作用域链为当前generator对象的作用域链</li>
<li>继续执行代码，并根据completionType做相应的处理</li>
</ol>
<h1 id="NodeJs上的不同">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>
<h2 id="资料">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank">harmony generators ES Wiki</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="Generator" scheme="http://lingyu.wang/tags/Generator/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何写一个KISSY动画插件]]></title>
    <link href="http://lingyu.wang/2014/05/31/kissy-anime-plugin/"/>
    <id>http://lingyu.wang/2014/05/31/kissy-anime-plugin/</id>
    <published>2014-05-30T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.178Z</updated>
    <content type="html"><![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank">Github页面</a></p>
<a id="more"></a>

<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/" target="_blank">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>
<h2 id="CSS与JavaScript动画对比">CSS与JavaScript动画对比</h2>
<p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>
<h3 id="CSS动画">CSS动画</h3>
<h4 id="animation">animation</h4>
<p>CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：</p>
<ol>
<li>animation-name：动画的名称，也就是定义的keyframes关键帧的名称</li>
<li>animation-duration：一次动画的时长</li>
<li>animation-timing-funciton：缓动函数，这个后面会有详细介绍</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画的播放次数</li>
<li>animation-direction：动画时正向播放还是倒着播放</li>
<li>animation-play-state：动画的状态，暂停还是播放</li>
<li>animation-fill-mode：动画播放时间之外的状态，是否重回动画初始</li>
<li>animation：复合属性，上面属性合在一起的写法</li>
</ol>
<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>
<h4 id="transition">transition</h4>
<p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：</p>
<ol>
<li>transition-property：需要参与过渡的属性</li>
<li>transition-duration 过渡的时长</li>
<li>transition-timing-function：过渡的缓动函数</li>
<li>transition-delay：过渡的延时</li>
</ol>
<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>
<h4 id="优缺点">优缺点</h4>
<p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>
<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>
<p>另外，<a href="http://lingyu.wang/#/item">这里</a>有我曾经写过的一些CSS3动画效果</p>
<h3 id="JavaScript动画">JavaScript动画</h3>
<p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：</p>
<ol>
<li>计算当前元素样式</li>
<li>修改元素样式</li>
<li>重绘元素</li>
</ol>
<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>
<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>
<h2 id="需求分析">需求分析</h2>
<h3 id="动画属性">动画属性</h3>
<p>通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：</p>
<ol>
<li>涉及的元素（elems）</li>
<li>需要改变的样式（styles）</li>
<li>时长（duration）</li>
<li>缓动函数（easing-function）</li>
<li>播放次数（times）</li>
</ol>
<h3 id="动画控制">动画控制</h3>
<p>而控制上，我们应该实现的功能：</p>
<ol>
<li>开始（run）</li>
<li>暂停（pause）</li>
<li>暂停恢复（resume）</li>
<li>中止（stop）</li>
<li>倒放（reverse）</li>
<li>单帧（go）</li>
</ol>
<h3 id="动画能够改变的内容">动画能够改变的内容</h3>
<p>需要能够改变的内容有：</p>
<ol>
<li>CSS样式</li>
<li>滚动</li>
</ol>
<h2 id="动画对象">动画对象</h2>
<p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>
<p>所以，动画的对象大致上是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">()</span>{</span>}
Anime.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.pause = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.resume = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.stop = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
Anime.prototype.go = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>};
</pre></td></tr></table></figure>


<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>
<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">(elems, styles, config)</span>{</span>}
</pre></td></tr></table></figure>


<p>conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> defaultConfig = {
    callback: noop,
    duration: <span class="number">1500</span>,
    reverse: <span class="literal">false</span>,
    easing: <span class="string">"linear"</span>,
    times: <span class="number">1</span>,
    spend: <span class="number">0</span>,
    state: <span class="string">"running"</span>
};
</pre></td></tr></table></figure>


<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：</p>
<ul>
<li>running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态</li>
<li>paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态</li>
<li>ended为终止状态，可以通过run放法进行重放，转到running状态</li>
</ul>
<h2 id="动画队列">动画队列</h2>
<p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>
<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>
<p>所以，队列首先得实现相关的添加删除操作，注意去重：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> animeQueue = [];

<span class="function"><span class="keyword">function</span> <span class="title">addAnime</span><span class="params">(anime)</span> {</span>
    <span class="keyword">if</span> (S.indexOf(anime, animeQueue) === -<span class="number">1</span>) {
        animeQueue.push(anime);
        checkRunning();
    }
}

<span class="function"><span class="keyword">function</span> <span class="title">deleteAnime</span><span class="params">(anime)</span> {</span>
    <span class="keyword">var</span> index = S.indexOf(anime, animeQueue);
    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {
        animeQueue.splice(index, <span class="number">1</span>);
        checkRunning();
    }
}
</pre></td></tr></table></figure>


<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">pulse</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> deleteIndex = [],
        i, m, tmp;
    <span class="keyword">if</span> (running) {
        S.each(animeQueue, <span class="function"><span class="keyword">function</span><span class="params">(anime, index)</span> {</span>
            <span class="keyword">if</span> (anime.state === <span class="string">"running"</span>) {
                anime.go();
            } <span class="keyword">else</span> {
                deleteIndex.push(index);
            }
        });
        <span class="keyword">for</span> (i = deleteIndex.length; i--;) {
            animeQueue.splice(deleteIndex[i], <span class="number">1</span>);
        }
        dealing = <span class="literal">false</span>;
        checkRunning();
    }
}
</pre></td></tr></table></figure>


<p>checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">checkRunning</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (animeQueue.length &gt; <span class="number">0</span>) {
        running = <span class="literal">true</span>;
        <span class="keyword">if</span> (!dealing) {
            dealing = <span class="literal">true</span>;
            requestAnimationFrame(pulse);
        }
    } <span class="keyword">else</span> {
        running = <span class="literal">false</span>;
        dealing = <span class="literal">false</span>;
    }
}
</pre></td></tr></table></figure>


<h2 id="缓动函数">缓动函数</h2>
<p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>
<h2 id="样式处理">样式处理</h2>
<p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：</p>
<ol>
<li>从元素获取样式的起始值（从什么地方开始）</li>
<li>获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）</li>
<li>计算当前时间点的中间值（经过怎样的过程）</li>
<li>向元素赋予计算出来的中间值（经过怎样的过程）</li>
</ol>
<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">getCSS</span><span class="params">(elem, style)</span> {</span>
    <span class="keyword">var</span> val;
    <span class="keyword">if</span> (hooks[style] && hooks[style].get) {
        val = hooks[style].get(elem, style);
    } <span class="keyword">else</span> {
        val = hooks._default.get(elem, style);
    }
    <span class="keyword">return</span> parseCSS(val, style);
}

<span class="function"><span class="keyword">function</span> <span class="title">parseCSS</span><span class="params">(val, style, from)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].parse) {
        <span class="keyword">return</span> hooks[style].parse(val, from);
    }
    <span class="keyword">return</span> hooks._default.parse(val, from);
}

<span class="function"><span class="keyword">function</span> <span class="title">computeCSS</span><span class="params">(style, from, to, pos)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].compute) {
        <span class="keyword">return</span> hooks[style].compute(from, to, pos);
    }
    <span class="keyword">return</span> hooks._default.compute(from, to, pos);

}

<span class="function"><span class="keyword">function</span> <span class="title">assignCSS</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">if</span> (hooks[style] && hooks[style].assign) {
        <span class="keyword">return</span> hooks[style].assign(elem, style, val);
    }
    <span class="keyword">return</span> hooks._default.assign(elem, style, val);
}
</pre></td></tr></table></figure>


<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>
<h2 id="特殊处理">特殊处理</h2>
<p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例</p>
<h3 id="颜色属性">颜色属性</h3>
<p>如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：</p>
<ol>
<li>HEX：<code>#fff</code>或<code>#f0f0f0</code></li>
<li>RGB：<code>rgb(245, 28, 33)</code></li>
<li>RGBA：<code>rgba(245, 28, 33, .6)</code></li>
<li>直接名称：<code>red</code>、<code>white</code>等等</li>
<li>HSL和HSLA，这里不做实现</li>
</ol>
<h4 id="获取">获取</h4>
<p>获取和一般CSS属性没差， 直接使用默认方式了</p>
<h4 id="解析">解析</h4>
<p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">parseColor</span><span class="params">(val)</span> {</span>
    val = val.replace(rClearSpace, <span class="string">""</span>).toLowerCase();
    <span class="keyword">if</span> (normalColors[val]) {
        <span class="keyword">return</span> normalColors[val];
    }
    <span class="keyword">var</span> color = [];
    <span class="keyword">var</span> tmp;
    <span class="keyword">var</span> i;
    <span class="keyword">if</span> (rHexColor.test(val)) {
        tmp = [];
        <span class="keyword">if</span> (val.length === <span class="number">4</span>) {
            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
                tmp[i] = val.charAt(i + <span class="number">1</span>);
                tmp[i] += tmp[i];
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> (val.length === <span class="number">7</span>) {
            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
                tmp[i] = val.substr(<span class="number">1</span> + i * <span class="number">2</span>, <span class="number">2</span>);
            }
        }
        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
            color[i] = <span class="built_in">parseInt</span>(tmp[i], <span class="number">16</span>);
        }
        color[<span class="number">3</span>] = <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGB))) {
        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {
            color[i] = <span class="built_in">parseInt</span>(tmp[i + <span class="number">1</span>], <span class="number">10</span>);
        }
        color[<span class="number">3</span>] = <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGBA))) {
        <span class="keyword">for</span> (i = <span class="number">4</span>; i--;) {
            color[i] = <span class="built_in">Number</span>(tmp[i + <span class="number">1</span>]);
        }
    }
    <span class="keyword">return</span> color;
}
</pre></td></tr></table></figure>


<h4 id="计算">计算</h4>
<p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">computeColor</span><span class="params">(from, to, pos)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default,
        result = [],
        i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) {
        result.push(<span class="built_in">parseInt</span>(_default.compute(from[i], to[i], pos), <span class="number">10</span>));
    }
    result.push(_default.compute(from[<span class="number">3</span>], to[<span class="number">3</span>], pos));
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<h4 id="赋值">赋值</h4>
<p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">assignColor</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">if</span>(KISSY.Features.isIELessThan(<span class="number">9</span>)){
        Dom.css(elem, style, <span class="string">"rgb("</span> + val.slice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">","</span>) + <span class="string">")"</span>);
    } <span class="keyword">else</span> {
        Dom.css(elem, style, <span class="string">"rgba("</span> + val.join(<span class="string">","</span>) + <span class="string">")"</span>);
    }
}
</pre></td></tr></table></figure>


<h3 id="滚动">滚动</h3>
<h4 id="获取-1">获取</h4>
<p>滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>
<h4 id="解析-1">解析</h4>
<p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>
<h4 id="计算-1">计算</h4>
<p>计算过程也是，使用默认计算即可</p>
<h4 id="赋值-1">赋值</h4>
<p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>S.each(<span class="string">"scrollTop scrollLeft"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span><span class="params">(type)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default;
    hooks[type] = {
        assign: <span class="function"><span class="keyword">function</span><span class="params">(elem, style, val)</span> {</span>
            Dom[type](elem, val);
        },
        get: <span class="function"><span class="keyword">function</span><span class="params">(elem, style)</span> {</span>
            <span class="keyword">return</span> Dom[type](elem);
        }
    };
});
</pre></td></tr></table></figure>


<h3 id="transform">transform</h3>
<p><strong>这里只处理了2D的transform</strong></p>
<p>transform的值也有很多不同的形式：</p>
<ol>
<li>matrix</li>
<li>rotate</li>
<li>translate、translateX、translateY</li>
<li>scale、scaleX、scaleY</li>
<li>skew、skewX、skewY</li>
</ol>
<h4 id="获取-2">获取</h4>
<p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>
<h4 id="解析-2">解析</h4>
<p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> result = {
    translateX: <span class="number">0</span>,
    translateY: <span class="number">0</span>,
    rotate: <span class="number">0</span>,
    skewX: <span class="number">0</span>,
    skewY: <span class="number">0</span>,
    scaleX: <span class="number">1</span>,
    scaleY: <span class="number">1</span>
};
</pre></td></tr></table></figure>


<p>代码较长</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">decomposeMatrix</span><span class="params">(matrix)</span> {</span>
    <span class="keyword">var</span> scaleX, scaleY, skew,
        A = matrix[<span class="number">0</span>],
        B = matrix[<span class="number">1</span>],
        C = matrix[<span class="number">2</span>],
        D = matrix[<span class="number">3</span>];

    <span class="comment">// Make sure matrix is not singular</span>
    <span class="keyword">if</span> (A * D - B * C) {
        scaleX = <span class="built_in">Math</span>.sqrt(A * A + B * B);
        skew = (A * C + B * D) / (A * D - C * B);
        scaleY = (A * D - B * C) / scaleX;
        <span class="comment">// step (6)</span>
        <span class="keyword">if</span> (A * D &lt; B * C) {
            skew = -skew;
            scaleX = -scaleX;
        }
        <span class="comment">// matrix is singular and cannot be interpolated</span>
    } <span class="keyword">else</span> {
        <span class="comment">// In this case the elem shouldn't be rendered, hence scale == 0</span>
        scaleX = scaleY = skew = <span class="number">0</span>;
    }

    <span class="comment">// The recomposition order is very important</span>
    <span class="comment">// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971</span>
    <span class="keyword">return</span> {
        translateX: myParse(matrix[<span class="number">4</span>]),
        translateY: myParse(matrix[<span class="number">5</span>]),
        rotate: myParse(<span class="built_in">Math</span>.atan2(B, A) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),
        skewX: myParse(<span class="built_in">Math</span>.atan(skew) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),
        skewY: <span class="number">0</span>,
        scaleX: myParse(scaleX),
        scaleY: myParse(scaleY)
    };
}

<span class="function"><span class="keyword">function</span> <span class="title">valueStringToArray</span><span class="params">(val)</span> {</span>
    <span class="keyword">var</span> result = val.split(<span class="string">","</span>);
    result = S.map(result, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
        <span class="keyword">return</span> myParse(value);
    });
    <span class="keyword">return</span> result;
}

<span class="function"><span class="keyword">function</span> <span class="title">parseTransform</span><span class="params">(val)</span> {</span>
    <span class="keyword">var</span> result = {
        translateX: <span class="number">0</span>,
        translateY: <span class="number">0</span>,
        rotate: <span class="number">0</span>,
        skewX: <span class="number">0</span>,
        skewY: <span class="number">0</span>,
        scaleX: <span class="number">1</span>,
        scaleY: <span class="number">1</span>
    };
    <span class="keyword">var</span> value;
    <span class="keyword">var</span> regResult;
    <span class="keyword">var</span> i, j, m;
    <span class="keyword">var</span> name;
    <span class="keyword">var</span> strs;
    strs = val.replace(rClearSpace, <span class="string">""</span>).split(<span class="string">")"</span>);
    <span class="keyword">for</span> (i = <span class="number">0</span>, m = strs.length; i &lt; m; i++) {
        <span class="keyword">if</span> (!strs[i] || strs[i] === <span class="string">"none"</span>) <span class="keyword">continue</span>;
        regResult = strs[i].split(<span class="string">"("</span>);
        name = regResult[<span class="number">0</span>];
        value = valueStringToArray(regResult[<span class="number">1</span>]);
        <span class="keyword">switch</span> (name) {
            <span class="keyword">case</span> <span class="string">"matrix"</span>:
                result = decomposeMatrix(value);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"translate"</span>:
            <span class="keyword">case</span> <span class="string">"skew"</span>:
                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;
                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || <span class="number">0</span>;
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"scale"</span>:
                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;
                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || result[name + <span class="string">"X"</span>];
                <span class="keyword">break</span>;
            <span class="keyword">case</span> <span class="string">"translateX"</span>:
            <span class="keyword">case</span> <span class="string">"translateY"</span>:
            <span class="keyword">case</span> <span class="string">"scaleX"</span>:
            <span class="keyword">case</span> <span class="string">"scaleY"</span>:
            <span class="keyword">case</span> <span class="string">"skewX"</span>:
            <span class="keyword">case</span> <span class="string">"skewY"</span>:
            <span class="keyword">case</span> <span class="string">"rotate"</span>:
                result[name] = value[<span class="number">0</span>] || <span class="number">0</span>;
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">continue</span>;
        }
    }
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<p>这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>
<h4 id="计算-2">计算</h4>
<p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">computeTransform</span><span class="params">(from, to, pos)</span> {</span>
    <span class="keyword">var</span> _default = hooks._default;
    <span class="keyword">var</span> result = {};
    S.each(to, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> {</span>
        result[key] = _default.compute(from[key], to[key], pos);
    });
    <span class="keyword">return</span> result;
}
</pre></td></tr></table></figure>


<h3 id="赋值-2">赋值</h3>
<p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">assignTransform</span><span class="params">(elem, style, val)</span> {</span>
    <span class="keyword">var</span> valueArray = [];
    S.each(val, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> {</span>
        <span class="keyword">if</span> ((key.indexOf(<span class="string">"scale"</span>) &gt; -<span class="number">1</span> && value === <span class="number">1</span>) || (key.indexOf(<span class="string">"scale"</span>) === -<span class="number">1</span> && value === <span class="number">0</span>)) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">if</span> (key === <span class="string">"rotate"</span> || key.indexOf(<span class="string">"skew"</span>) &gt; -<span class="number">1</span>) {
            value += <span class="string">"deg"</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (key.indexOf(<span class="string">"translate"</span>) &gt; -<span class="number">1</span>) {
            value += <span class="string">"px"</span>;
        }
        valueArray.push(key + <span class="string">"("</span> + value + <span class="string">")"</span>);
    });
    Dom.css(elem, style, valueArray.join(<span class="string">" "</span>));
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank">Github页面</a></p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Kissy" scheme="http://lingyu.wang/tags/Kissy/"/>
    
      <category term="动画" scheme="http://lingyu.wang/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebRTC的RTCDataChannel]]></title>
    <link href="http://lingyu.wang/2014/05/22/webrtc-data-channels/"/>
    <id>http://lingyu.wang/2014/05/22/webrtc-data-channels/</id>
    <published>2014-05-21T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.189Z</updated>
    <content type="html"><![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
<a id="more"></a>

<blockquote>
<p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>
<h3 id="为什么我们需要另外一个数据通道">为什么我们需要另外一个数据通道</h3>
<p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/" target="_blank">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/" target="_blank">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/" target="_blank">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>
<p>RTCDataChannel则是一个完全不同的途径：</p>
<ul>
<li>它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。</li>
<li>RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features" target="_blank">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</li>
</ul>
<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>
<h3 id="一个警告：信令、STUN和TURN">一个警告：信令、STUN和TURN</h3>
<p>尽管WebRTC允许点对点的通信，但它依然需要服务器：</p>
<ul>
<li>信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器</li>
<li>NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</li>
</ul>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>
<h3 id="功能">功能</h3>
<p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能"><br>以上来自<a href="http://www.igvita.com/" target="_blank">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank">High Performance Browser Networking</a></p>
<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：</p>
<ul>
<li>可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢</li>
<li>不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</li>
</ul>
<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>
<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>
<h3 id="配置数据通道">配置数据通道</h3>
<p>网上已经有很多RTCDataChannel的例子了：</p>
<ul>
<li><a href="http://simpl.info/dc" target="_blank">simpl.info/dc</a></li>
<li><a href="http://googlechrome.github.io/webrtc/dc1.html" target="_blank">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)</li>
<li><a href="http://pubnub.github.io/webrtc" target="_blank">pubnub.github.io/webrtc</a>(两个PubNub用户)</li>
</ul>
<p>ps：PubBub是一个实时信息通讯应用开发公司</p>
<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> RTCPeerConnection();

<span class="comment">//使用信令传输信道创建对等连接</span>
<span class="keyword">var</span> dataChannel =
  peerConnection.createDataChannel(<span class="string">"myLabel"</span>, dataChannelOptions);

dataChannel.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> {</span>
  console.log(<span class="string">"Data Channel Error:"</span>, error);
};

dataChannel.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> {</span>
  console.log(<span class="string">"Got Data Channel Message:"</span>, event.data);
};

dataChannel.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  dataChannel.send(<span class="string">"Hello World!"</span>);
};

dataChannel.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  console.log(<span class="string">"The Data Channel is Closed"</span>);
};
</pre></td></tr></table></figure>


<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> dataChannelOptions = {
  ordered: <span class="literal">false</span>, <span class="comment">//不保证到达顺序</span>
  maxRetransmitTime: <span class="number">3000</span>, <span class="comment">//最大重传时间</span>
};
</pre></td></tr></table></figure>


<p>我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960" target="_blank">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758" target="_blank">RFC 3758</a>（SCTP部分可靠性）</p>
<ul>
<li>ordered: 数据通道是否保证按序传输数据</li>
<li>maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）</li>
<li>maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）</li>
<li>protocol：允许使用一个自协议，但如果协议不支持，将会失败</li>
<li>negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道</li>
<li>id：为数据通道提供一个自己定义的ID</li>
</ul>
<h3 id="它安全吗？">它安全吗？</h3>
<p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS" target="_blank">Wireshark的维基</a></p>
<h3 id="改变你考虑数据的方式">改变你考虑数据的方式</h3>
<p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/" target="_blank">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/" target="_blank">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>
<h3 id="搭建一个文件共享应用">搭建一个文件共享应用</h3>
<p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>
<p>需要成功传输一个文件，我们需要如下几步：</p>
<ol>
<li><a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/" target="_blank">通过JavaScript的File API读取文件数据</a></li>
<li>使用RTCPeerConnection在用户间创建一个对等连接</li>
<li>使用RTCDataChannel在用户间创建一个数据通道</li>
</ol>
<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：</p>
<ul>
<li><strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。</li>
<li><strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。</li>
<li><strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</li>
</ul>
<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span><span class="params">(blob)</span> {</span>
  <span class="keyword">var</span> link = document.createElement(<span class="string">'a'</span>);
  link.href = window.URL.createObjectURL(blob);
  link.download = <span class="string">'File Name'</span>;
  link.click();
};
</pre></td></tr></table></figure>


<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/" target="_blank">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest" target="_blank">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>
<h3 id="那么我们能做什么？">那么我们能做什么？</h3>
<p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：</p>
<ul>
<li>上面已经提到了点对点的文件传输了</li>
<li>多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/" target="_blank">Banana Bread</a></li>
<li>内容交付：由<a href="https://peercdn.com/" target="_blank">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</li>
</ul>
<h3 id="改变你构建应用的方式">改变你构建应用的方式</h3>
<p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/" target="_blank">PeerJS</a>和<a href="https://github.com/pubnub/webrtc" target="_blank">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>
<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>
<h3 id="更多资讯">更多资讯</h3>
<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">Getting started with WebRTC</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank">WebRTC in the real world: STUN, TURN and signaling</a></li>
<li><a href="http://bit.ly/webrtcwebaudio" target="_blank">WebRTC resources</a></li>
<li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api" target="_blank">W3C Working Draft</a></li>
<li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04" target="_blank">IETF WebRTC Data Channel Protocol Draft</a></li>
<li><a href="http://bloggeek.me/send-file-webrtc-data-api/" target="_blank">How to send a File Using WebRTC Data API</a></li>
<li><a href="http://bloggeek.me/webrtc-data-channel-uses/" target="_blank">7 Creative Uses of WebRTC’s Data Channel</a></li>
<li><a href="https://developer.mozilla.org/en/demos/detail/bananabread" target="_blank">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
]]>
    
    </summary>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS的渲染阻塞]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-render-blocking-css/"/>
    <id>http://lingyu.wang/2014/05/21/google-render-blocking-css/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.171Z</updated>
    <content type="html"><![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
<a id="more"></a>

<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>默认情况下CSS是渲染阻塞资源</li>
<li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
<li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>
<h3 id="CSS是渲染阻塞资源">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>
<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>
<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>
<h3 id="媒体类型和媒体查询">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"other.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"(min-width: 40em)"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>
<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>
<p>让我们考虑如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"portrait.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<ol>
<li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
<li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
<li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
<li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>
<h3 id="浏览器下载">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过JavaScript增加交互性]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/"/>
    <id>http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.170Z</updated>
    <content type="html"><![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<a id="more"></a>

<h3 id="长话短说">长话短说</h3>
<ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span>
      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span>
      <span class="comment">// create a new element, style it, and append it to the DOM</span>
      <span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
      loadTime.style.color = <span class="string">'blue'</span>;
      document.body.appendChild(loadTime);
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> span = document.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];
span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span>
span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span>
<span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span>
<span class="keyword">var</span> loadTime = document.createElement(<span class="string">'div'</span>);
loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();
loadTime.style.color = <span class="string">'blue'</span>;
document.body.appendChild(loadTime);
</pre></td></tr></table></figure>


<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre> <span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用导航计时监测渲染关键路径]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/"/>
    <id>http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.170Z</updated>
    <content type="html"><![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br><a id="more"></a></p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        <span class="keyword">var</span> stats = document.createElement(<span class="string">'p'</span>);
        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +
            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;
        document.body.appendChild(stats);
      }
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建对象模型]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-constructing-the-object-model/"/>
    <id>http://lingyu.wang/2014/05/20/google-constructing-the-object-model/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.170Z</updated>
    <content type="html"><![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br><a id="more"></a></p>
<h2 id="长话短说">长话短说</h2>
<ul>
<li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
<li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
<li>DOM和CSSOM是互相独立的数据结构</li>
<li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>
<h2 id="DOM树构建">DOM树构建</h2>
<p>比如一段如下HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>其从字节到DOM树的过程如下图所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程"></p>
<p>具体的过程分为如下几步：</p>
<ol>
<li>转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符</li>
<li>标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则</li>
<li>对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则</li>
<li>DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</li>
</ol>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构"></p>
<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>
<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程"></p>
<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>
<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>
<h2 id="CSSOM树构建">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16</span>px </span></span></span>}
<span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold </span></span></span>}
<span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red </span></span></span>}
<span class="tag">p</span> <span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none </span></span></span>}
<span class="tag">img</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> right </span></span></span>}
</pre></td></tr></table></figure>


<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>
<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM"></p>
<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM"></p>
<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>
<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>
<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理"></p>
<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渲染树的构建，布局和绘制]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/"/>
    <id>http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.171Z</updated>
    <content type="html"><![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
<a id="more"></a>

<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>DOM树和CSSOM树结合组成了渲染树</li>
<li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
<li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
<li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>
<h3 id="构建渲染树">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树"></p>
<p>为了构建渲染树，浏览器所做的工作大致如下：</p>
<ol>
<li>从DOM树的根节点开始，遍历每个可见的节点<ul>
<li>有些节点本身不可见（比如script、meta等等）</li>
<li>有些节点被CSS隐藏了，这些节点也会被渲染树忽略</li>
</ul>
</li>
<li>对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息</li>
<li>提交可见的节点和他们的内容和样式</li>
</ol>
<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>
<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>
<h3 id="布局阶段">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>
<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>


<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>
<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>
<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>
<h3 id="绘制阶段">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段"></p>
<ul>
<li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
<li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>
<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>
<p>这些都完成后，我们的页面终于展示在视口里了</p>
<h3 id="总结">总结</h3>
<p>我们来重温一下所有的步骤：</p>
<ol>
<li>处理HTML标记，构建DOM树</li>
<li>处理CSS标记，构建CSSOM树</li>
<li>合并DOM树和CSSOM树，构建渲染树</li>
<li>在渲染树上运行布局阶段，计算每个可见节点的几何图形</li>
<li>绘制每个独立的节点到屏幕上</li>
</ol>
<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>
<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[响应式Web设计基础]]></title>
    <link href="http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/"/>
    <id>http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/</id>
    <published>2014-05-18T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.171Z</updated>
    <content type="html"><![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
<a id="more"></a>

<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/" target="_blank">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>
<h2 id="设置视口信息">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>
<h3 id="长话短说">长话短说</h3>
<ol>
<li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
<li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
<li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
<li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>
<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>
<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>
<h3 id="确定一个可访问的视口">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>
<h2 id="使得内容适配视口">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>
<h3 id="长话短说-1">长话短说</h3>
<ol>
<li>不要为元素设定大且固定的尺寸</li>
<li>内容的展现不应该依赖于一个特定的视口宽度</li>
<li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>
<h3 id="最佳实践-1">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>
<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>
<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>
<h2 id="为响应式使用CSS的媒体查询">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>
<h3 id="长话短说-2">长话短说</h3>
<ol>
<li>媒体查询可以根据设备特点来应用样式</li>
<li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
<li>为元素使用相对大小防止破坏布局</li>
</ol>
<h3 id="最佳实践-2">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
</pre></td></tr></table></figure>


<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> print </span>{
  <span class="comment">/* print style sheets go here */</span>
}

<span class="at_rule">@<span class="keyword">import</span> <span class="function">url(print.css)</span> print</span>;
</pre></td></tr></table></figure>


<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>
<h3 id="根据视口大小使用媒体查询">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> (query) </span>{
  <span class="comment">/* CSS Rules used when query matches */</span>
}
</pre></td></tr></table></figure>


<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>
<ul>
<li>min-width: 匹配所有宽度大于设定值的浏览器</li>
<li>max-width: 匹配所有宽度小于设定值的浏览器</li>
<li>min-height: 匹配所有高度大于设定值的浏览器</li>
<li>max-height: 匹配所有高度小于设定值的浏览器</li>
<li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li>
<li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li>
</ul>
<h3 id="关于min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>
<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>
<h3 id="使用相对单位">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>
<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>
<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>
<h2 id="如何选择断点">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>
<h3 id="长话短说-3">长话短说</h3>
<ol>
<li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
<li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
<li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>
<h3 id="从小到大来挑选主要断点">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>
<h3 id="必要时添加次要断点">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>
<h3 id="优化文本阅读">优化文本阅读</h3>
<p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>
<h3 id="不要完全隐藏内容">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的异步控制]]></title>
    <link href="http://lingyu.wang/2014/05/17/read-jq-src-5/"/>
    <id>http://lingyu.wang/2014/05/17/read-jq-src-5/</id>
    <published>2014-05-16T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.185Z</updated>
    <content type="html"><![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<a id="more"></a>

<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</pre></td></tr></table></figure>


<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span>
    <span class="comment">/*用于存放运行结果*/</span>
    memory,
    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span>
    fired,
    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span>
    firing,
    <span class="comment">/*第一个被执行的回调函数*/</span>
    firingStart,
    <span class="comment">/*回调函数列表的长度*/</span>
    firingLength,
    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span>
    firingIndex,
    <span class="comment">/*保存回调函数的列表*/</span>
    list = [],
    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span>
    stack = !options.once && [],
</pre></td></tr></table></figure>


<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> {</span>
    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span>
    memory = options.memory && data;
    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span>
    fired = <span class="literal">true</span>;
    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span>
    firingIndex = firingStart || <span class="number">0</span>;
    <span class="comment">/*将起始设为0*/</span>
    firingStart = <span class="number">0</span>;
    <span class="comment">/*获取回调函数列表的总长度*/</span>
    firingLength = list.length;
    <span class="comment">/*修改状态为正在执行*/</span>
    firing = <span class="literal">true</span>;
    <span class="comment">/*依次执行回调函数*/</span>
    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {
        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span>
        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {
            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span>
            <span class="keyword">break</span>;
        }
    }
    <span class="comment">/*修改正在执行状态为false*/</span>
    firing = <span class="literal">false</span>;
    
    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*多次执行的话，stack是个数组*/</span>
        <span class="keyword">if</span> ( stack ) {
            <span class="comment">/*从等待队列中弹出数据再次执行*/</span>
            <span class="keyword">if</span> ( stack.length ) {
                fire( stack.shift() );
            }
        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            list = [];
        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span>
        } <span class="keyword">else</span> {
            self.disable();
        }
    }
},
</pre></td></tr></table></figure>


<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>add: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">//首先保存当前列表长度</span>
        <span class="keyword">var</span> start = list.length;
        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */</span>
        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> {</span>
            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
                <span class="keyword">var</span> type = jQuery.type( arg );
                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {
                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {
                    <span class="comment">// Inspect recursively</span>
                    add( arg );
                }
            });
        })( <span class="built_in">arguments</span> );
        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span>
        <span class="keyword">if</span> ( firing ) {
            firingLength = list.length;
        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> ( list ) {
        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span>
        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> {</span>
            <span class="keyword">var</span> index;
            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span>
            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {
                <span class="comment">/*删除掉这个函数*/</span>
                list.splice( index, <span class="number">1</span> );
                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span>
                <span class="keyword">if</span> ( firing ) {
                    <span class="keyword">if</span> ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    <span class="comment">/*返回this方便链式操作*/</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );
},
</pre></td></tr></table></figure>


<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = [];
    firingLength = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
</pre></td></tr></table></figure>


<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    list = stack = memory = <span class="literal">undefined</span>;
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !list;
},
</pre></td></tr></table></figure>


<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    stack = <span class="literal">undefined</span>;
    <span class="keyword">if</span> ( !memory ) {
        self.disable();
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !stack;
},
</pre></td></tr></table></figure>


<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> {</span>
    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span>
    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        <span class="comment">/*如果正在出发，就放到等待队列中*/</span>
        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span>
        <span class="keyword">if</span> ( firing ) {
            stack.push( args );
        <span class="comment">/*否则直接触发*/</span>
        } <span class="keyword">else</span> {
            fire( args );
        }
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>;
},
fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> !!fired;
}
</pre></td></tr></table></figure>


<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> tuples = [
    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],
    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],
    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]
],
</pre></td></tr></table></figure>


<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="comment">/*针对三个操作分别进行加工*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*获取操作的回调函数列表*/</span>
    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],
        <span class="comment">/*获取操作执行后的状态*/</span>
        stateString = tuple[ <span class="number">3</span> ];

    <span class="comment">// promise[ done | fail | progress ] = list.add</span>
    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span>
    promise[ tuple[<span class="number">1</span>] ] = list.add;

    <span class="comment">// Handle state</span>
    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span>
    <span class="keyword">if</span> ( stateString ) {
        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">// state = [ resolved | rejected ]</span>
            state = stateString;

        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span>
        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );
    }
    
    <span class="comment">// deferred[ resolve | reject | notify ]</span>
    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span>
    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    };
    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span>
    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;
});
</pre></td></tr></table></figure>


<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>promise = {
    <span class="comment">/*获得当前状态的方法*/</span>
    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> state;
    },
    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span>
    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );
        <span class="keyword">return</span> <span class="keyword">this</span>;
    },
    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span>
    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
        <span class="comment">/*then的代码*/</span>
    },
    <span class="comment">// Get a promise for this deferred</span>
    <span class="comment">// If obj is provided, the promise aspect is added to the object</span>
    <span class="comment">/*获取promise对象*/</span>
    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
<span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span>
promise.pipe = promise.then;
<span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span>
<span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span>
jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
    <span class="comment">/*上面的代码*/</span>
});
<span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span>
promise.promise( deferred );
</pre></td></tr></table></figure>


<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> {</span>
    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;
    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */</span>
    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> {</span>
        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span>
        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> {</span>
            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span>
            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span>
                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span>
                } <span class="keyword">else</span> {
                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );
                }
            });
        });
        fns = <span class="literal">null</span>;
    }).promise();
},
</pre></td></tr></table></figure>


<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> {</span>
    <span class="keyword">var</span> i = <span class="number">0</span>,
        <span class="comment">/*切分参数到数组*/</span>
        resolveValues = slice.call( <span class="built_in">arguments</span> ),
        <span class="comment">/*数组长度*/</span>
        length = resolveValues.length,

        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span>
        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,
        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

        /*
        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
        */</span>
        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> {</span>
            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
                contexts[ i ] = <span class="keyword">this</span>;
                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;
                <span class="keyword">if</span> ( values === progressValues ) {
                    deferred.notifyWith( contexts, values );
                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {
                    deferred.resolveWith( contexts, values );
                }
            };
        },

        progressValues, progressContexts, resolveContexts;

    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span>
    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {
        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span>
            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                resolveValues[ i ].promise()
                    .done( updateFunc( i, resolveContexts, resolveValues ) )
                    .fail( deferred.reject )
                    .progress( updateFunc( i, progressContexts, progressValues ) );
            } <span class="keyword">else</span> {
                --remaining;
            }
        }
    }

    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span>
    <span class="keyword">if</span> ( !remaining ) {
        deferred.resolveWith( resolveContexts, resolveValues );
    }
    <span class="comment">/*将这个管理Deferred对象返回*/</span>
    <span class="keyword">return</span> deferred.promise();
}
</pre></td></tr></table></figure>


<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的事件机制——核心篇]]></title>
    <link href="http://lingyu.wang/2014/05/12/read-jq-src-3/"/>
    <id>http://lingyu.wang/2014/05/12/read-jq-src-3/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.184Z</updated>
    <content type="html"><![CDATA[<p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>
<a id="more"></a>

<h1 id="jQuery源码——事件机制">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>
<h2 id="事件管理器">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>
<h3 id="global">global</h3>
<p>存放事件是否存在</p>
<h3 id="add_(elem,_types,_handler,_data,_selector)">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>
<p>所以代码大致流程如下：</p>
<h4 id="事件创建逻辑">事件创建逻辑</h4>
<p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> handleObjIn, eventHandle, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.get( elem );
    
<span class="keyword">if</span> ( !elemData ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( handler.handler ) {
    handleObjIn = handler;
    handler = handleObjIn.handler;
    selector = handleObjIn.selector;
}
</pre></td></tr></table></figure>


<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !handler.guid ) {
    handler.guid = jQuery.guid++;
}
</pre></td></tr></table></figure>


<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(events = elemData.events) ) {
    events = elemData.events = {};
}
<span class="keyword">if</span> ( !(eventHandle = elemData.handle) ) {
    eventHandle = elemData.handle = <span class="function"><span class="keyword">function</span><span class="params">( e )</span> {</span>
        <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== strundefined && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, <span class="built_in">arguments</span> ) : <span class="literal">undefined</span>;
    };
}
</pre></td></tr></table></figure>


<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>
<h4 id="事件绑定逻辑">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];
namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();

<span class="keyword">if</span> ( !type ) {
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};

type = ( selector ? special.delegateType : special.bindType ) || type;

special = jQuery.event.special[ type ] || {};
</pre></td></tr></table></figure>


<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>handleObj = jQuery.extend({
    type: type,
    origType: origType,
    data: data,
    handler: handler,
    guid: handler.guid,
    selector: selector,
    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
    namespace: namespaces.join(<span class="string">"."</span>)
}, handleObjIn );
</pre></td></tr></table></figure>


<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>
<ol>
<li>type：事件的映射后的名称</li>
<li>origType：事件的原始名称</li>
<li>data：事件的默认数据</li>
<li>handler：回调函数</li>
<li>guid：回调函数的id</li>
<li>selector：启用事件代理时，被代理的节点的选择器</li>
<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>
<li>namespace：重组后的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(handlers = events[ type ]) ) {
    handlers = events[ type ] = [];
    handlers.delegateCount = <span class="number">0</span>;

    <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) {
        <span class="keyword">if</span> ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, <span class="literal">false</span> );
        }
    }
}
</pre></td></tr></table></figure>


<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.add ) {
    special.add.call( elem, handleObj );

    <span class="keyword">if</span> ( !handleObj.handler.guid ) {
        handleObj.handler.guid = handler.guid;
    }
}
</pre></td></tr></table></figure>


<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( selector ) {
    handlers.splice( handlers.delegateCount++, <span class="number">0</span>, handleObj );
} <span class="keyword">else</span> {
    handlers.push( handleObj );
}
</pre></td></tr></table></figure>


<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>jQuery.event.global[ type ] = <span class="literal">true</span>;
</pre></td></tr></table></figure>


<p>最后再全局中标记一下事件已存在就行了</p>
<h3 id="remove_(elem,_types,_handler,_selector,_mappedTypes)">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>
<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> j, origCount, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.hasData( elem ) && data_priv.get( elem );
<span class="keyword">if</span> ( !elemData || !(events = elemData.events) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，和上面的add一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];

namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();
</pre></td></tr></table></figure>


<p>获取事件的命名空间，和add方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !type ) {
    <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) {
        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="literal">true</span> );
    }
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
origCount = j = handlers.length;
<span class="keyword">while</span> ( j-- ) {
    <span class="comment">//详细删除代码</span>
}
</pre></td></tr></table></figure>


<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>handleObj = handlers[ j ];
<span class="keyword">if</span> ( ( mappedTypes || origType === handleObj.origType ) &&
    ( !handler || handler.guid === handleObj.guid ) &&
    ( !tmp || tmp.test( handleObj.namespace ) ) &&
    ( !selector || selector === handleObj.selector || selector === <span class="string">"**"</span> && handleObj.selector ) ) {
    handlers.splice( j, <span class="number">1</span> );

    <span class="keyword">if</span> ( handleObj.selector ) {
        handlers.delegateCount--;
    }
    <span class="keyword">if</span> ( special.remove ) {
        special.remove.call( elem, handleObj );
    }
}
</pre></td></tr></table></figure>


<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( origCount && !handlers.length ) {
    <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class="literal">false</span> ) {
        jQuery.removeEvent( elem, type, elemData.handle );
    }
    <span class="keyword">delete</span> events[ type ];
}
</pre></td></tr></table></figure>


<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) {
    <span class="keyword">delete</span> elemData.handle;
    data_priv.remove( elem, <span class="string">"events"</span> );
}
</pre></td></tr></table></figure>


<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>
<h3 id="trigger_(event,_data,_elem,_onlyHandlers)">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> i, cur, tmp, bubbleType, ontype, handle, special,
    eventPath = [ elem || document ],
    type = hasOwn.call( event, <span class="string">"type"</span> ) ? event.type : event,
    namespaces = hasOwn.call( event, <span class="string">"namespace"</span> ) ? event.namespace.split(<span class="string">"."</span>) : [];

cur = tmp = elem = elem || document;

<span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>检测是否有focus和blur事件，它们不会在这里被触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt;= <span class="number">0</span> ) {
    namespaces = type.split(<span class="string">"."</span>);
    type = namespaces.shift();
    namespaces.sort();
}
ontype = type.indexOf(<span class="string">":"</span>) &lt; <span class="number">0</span> && <span class="string">"on"</span> + type;
</pre></td></tr></table></figure>


<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>event = event[ jQuery.expando ] ?
    event :
    <span class="keyword">new</span> jQuery.Event( type, <span class="keyword">typeof</span> event === <span class="string">"object"</span> && event );

event.isTrigger = onlyHandlers ? <span class="number">2</span> : <span class="number">3</span>;
event.namespace = namespaces.join(<span class="string">"."</span>);
event.namespace_re = event.namespace ?
    <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(^|\\.)"</span> + namespaces.join(<span class="string">"\\.(?:.*\\.|)"</span>) + <span class="string">"(\\.|$)"</span> ) :
    <span class="literal">null</span>;

event.result = <span class="literal">undefined</span>;
<span class="keyword">if</span> ( !event.target ) {
    event.target = elem;
}
</pre></td></tr></table></figure>


<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>
<ol>
<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>
<li>namespace: 事件的命名空间</li>
<li>namespace_re: 一个用于匹配当前命名空间的正则</li>
<li>result: 事件运行的结果</li>
<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>
</ol>
<p>事件对象的具体实现，后面会说</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>data = data == <span class="literal">null</span> ?
    [ event ] :
    jQuery.makeArray( data, [ event ] );

special = jQuery.event.special[ type ] || {};
<span class="keyword">if</span> ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    <span class="comment">/*如果是特殊事件，需要找到对应的真实名称*/</span>
    bubbleType = special.delegateType || type;
    <span class="keyword">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
    }
    <span class="keyword">for</span> ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
    }

    <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span>
    <span class="keyword">if</span> ( tmp === (elem.ownerDocument || document) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
    }
}
</pre></td></tr></table></figure>


<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
    event.type = i &gt; <span class="number">1</span> ?
        bubbleType :
        special.bindType || type;

    handle = ( data_priv.get( cur, <span class="string">"events"</span> ) || {} )[ event.type ] && data_priv.get( cur, <span class="string">"handle"</span> );
    <span class="keyword">if</span> ( handle ) {
        handle.apply( cur, data );
    }

    handle = ontype && cur[ ontype ];
    <span class="keyword">if</span> ( handle && handle.apply && jQuery.acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        <span class="keyword">if</span> ( event.result === <span class="literal">false</span> ) {
            event.preventDefault();
        }
    }
}
event.type = type;
</pre></td></tr></table></figure>


<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !event.isDefaultPrevented() ) {
    <span class="keyword">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="literal">false</span>) &&
        jQuery.acceptData( elem ) ) {
        <span class="keyword">if</span> ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
            tmp = elem[ ontype ];
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = <span class="literal">null</span>;
            }
            jQuery.event.triggered = type;
            elem[ type ]();
            jQuery.event.triggered = <span class="literal">undefined</span>;
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = tmp;
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>运行完了，返回事件运行的结果</p>
<h3 id="dispatch_(event)">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>
<ol>
<li>事件代理的情况</li>
<li>特殊事件</li>
<li>回调终止（stopPropagation）</li>
<li>事件的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>event = jQuery.event.fix( event );

<span class="keyword">var</span> i, j, ret, matched, handleObj,
    handlerQueue = [],
    args = slice.call( <span class="built_in">arguments</span> ),
    handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="string">"events"</span> ) || {} )[ event.type ] || [],
    special = jQuery.event.special[ event.type ] || {};

args[<span class="number">0</span>] = event;
event.delegateTarget = <span class="keyword">this</span>;
</pre></td></tr></table></figure>


<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.preDispatch && special.preDispatch.call( <span class="keyword">this</span>, event ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );
</pre></td></tr></table></figure>


<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
    event.currentTarget = matched.elem;
    j = <span class="number">0</span>;
    <span class="keyword">while</span> ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
        <span class="keyword">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                    .apply( matched.elem, args );
            <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) {
                <span class="keyword">if</span> ( (event.result = ret) === <span class="literal">false</span> ) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>
<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.postDispatch ) {
    special.postDispatch.call( <span class="keyword">this</span>, event );
}
<span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>
<h3 id="handlers_(event,_handlers)">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> i, matches, sel, handleObj,
    handlerQueue = [],
    delegateCount = handlers.delegateCount,
    cur = event.target;
</pre></td></tr></table></figure>


<p>获取当前事件的目标和代理个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">//如果存在代理</span>
<span class="keyword">if</span> ( delegateCount && cur.nodeType && (!event.button || event.type !== <span class="string">"click"</span>) ) {
    <span class="comment">//从被代理元素冒泡到代理元素</span>
    <span class="keyword">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || <span class="keyword">this</span> ) {
        <span class="comment">//屏蔽disable元素的点击事件</span>
        <span class="keyword">if</span> ( cur.disabled !== <span class="literal">true</span> || event.type !== <span class="string">"click"</span> ) {
            <span class="comment">//cur元素需要执行的回调对象列表</span>
            matches = [];
            <span class="comment">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span>
            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; delegateCount; i++ ) {
                handleObj = handlers[ i ];
                sel = handleObj.selector + <span class="string">" "</span>;
                <span class="comment">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span>
                <span class="keyword">if</span> ( matches[ sel ] === <span class="literal">undefined</span> ) {
                    matches[ sel ] = handleObj.needsContext ?
                        jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= <span class="number">0</span> :
                        jQuery.find( sel, <span class="keyword">this</span>, <span class="literal">null</span>, [ cur ] ).length;
                }
                <span class="comment">//如果符合,说明cur元素需要执行这个回调,加到列表中</span>
                <span class="keyword">if</span> ( matches[ sel ] ) {
                    matches.push( handleObj );
                }
            }
            <span class="comment">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span>
            <span class="keyword">if</span> ( matches.length ) {
                handlerQueue.push({ elem: cur, handlers: matches });
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>
<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>
<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>
<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( delegateCount &lt; handlers.length ) {
    handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });
}
<span class="keyword">return</span> handlerQueue;
</pre></td></tr></table></figure>


<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>
<h2 id="总结">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>
]]></content>
    <summary type="html">
    <![CDATA[这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的事件机制——事件对象、兼容、接口]]></title>
    <link href="http://lingyu.wang/2014/05/12/read-jq-src-4/"/>
    <id>http://lingyu.wang/2014/05/12/read-jq-src-4/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.185Z</updated>
    <content type="html"><![CDATA[<p>这篇主要介绍了jQuery中事件管理器的事件对象、兼容实现以及在jQuery对象上暴露的接口</p>
<a id="more"></a>


<p>接上一篇 <a href="http://lingyu.wang/#/art/blog/2014/05/12/read-jq-src-3">jQuery的事件机制——核心篇</a></p>
<h2 id="事件对象">事件对象</h2>
<p>jq中使用自己创立的对象传递给回调函数，这里解析一下这个事件对象：</p>
<h3 id="构造函数">构造函数</h3>
<p>jq的事件对象的构造函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery.Event = <span class="function"><span class="keyword">function</span><span class="params">( src, props )</span> {</span>
    <span class="comment">//内部的代码</span>
};
</pre></td></tr></table></figure>


<p>接下来接下下内部代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*兼容不使用new的情况*/</span>
<span class="keyword">if</span> ( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> jQuery.Event) ) {
    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.Event( src, props );
}
</pre></td></tr></table></figure>


<p>用于防止出现没有使用new直接调用构造函数的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">if</span> ( src && src.type ) {
    <span class="keyword">this</span>.originalEvent = src;
    <span class="keyword">this</span>.type = src.type;

    <span class="comment">// Events bubbling up the document may have been marked as prevented</span>
    <span class="comment">// by a handler lower down the tree; reflect the correct value.</span>
    <span class="keyword">this</span>.isDefaultPrevented = src.defaultPrevented ||
            <span class="comment">// Support: Android &lt; 4.0</span>
            src.defaultPrevented === <span class="literal">undefined</span> &&
            src.getPreventDefault && src.getPreventDefault() ?
        returnTrue :
        returnFalse;

<span class="comment">// Event type</span>
} <span class="keyword">else</span> {
    <span class="keyword">this</span>.type = src;
}
</pre></td></tr></table></figure>


<p>这里根据传入的是事件对象还是事件名称分别进行处理，当传入原生事件对象时，使用originalEvent指向原生事件对象，并获取它的事件名称。另外还要判断事件是否已经屏蔽默认行为了。如果传入的是字符串，直接写入到事件名称中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*通过extend添加额外属性*/</span>
<span class="keyword">if</span> ( props ) {
    jQuery.extend( <span class="keyword">this</span>, props );
}
</pre></td></tr></table></figure>


<p>事件对象可以添加一些其他属性，这里添加的属性通过props传入，直接extend就好</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">/*创建时间*/</span>
<span class="keyword">this</span>.timeStamp = src && src.timeStamp || jQuery.now();

<span class="comment">/*jq事件对象标记*/</span>
<span class="keyword">this</span>[ jQuery.expando ] = <span class="literal">true</span>;
</pre></td></tr></table></figure>


<p>一个创建时的时间戳，不知道干嘛用的，至于版本号标记，主要是用来判断对象是原生事件对象还是jq自己的事件对象</p>
<h3 id="原型上的方法">原型上的方法</h3>
<p>事件对象实际上是jq新建的对象，对原生事件对象进行了一层包裹，那么应该提供一些方法操作原生事件对象。我们操作原生事件对象无外乎preventDefault和stopPropagation，这里就是做了一层封装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,
</pre></td></tr></table></figure>


<p>默认情况下，不会阻止默认行为，事件不会被终止。这里ImmediatePropagtaionStop其实和PropagationStop没什么区别</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>preventDefault: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;

    <span class="keyword">this</span>.isDefaultPrevented = returnTrue;

    <span class="keyword">if</span> ( e && e.preventDefault ) {
        e.preventDefault();
    }
},
</pre></td></tr></table></figure>


<p>阻止默认行为，先在jq的事件对象上做个标记，然后调用原生事件的preventDefault方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>stopPropagation: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;

    <span class="keyword">this</span>.isPropagationStopped = returnTrue;

    <span class="keyword">if</span> ( e && e.stopPropagation ) {
        e.stopPropagation();
    }
},
stopImmediatePropagation: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.isImmediatePropagationStopped = returnTrue;
    <span class="keyword">this</span>.stopPropagation();
}
</pre></td></tr></table></figure>


<p>终止事件执行，同样是先在事件对象上做个标记，然后调用原生事件的pstopPropagation方法，可以看到，两个方法没什么区别</p>
<h2 id="事件对象在事件机制中的使用">事件对象在事件机制中的使用</h2>
<p>jq不嫌麻烦自己弄了个事件对象进行包装，就是为了屏蔽浏览器之间事件对象上的差异。这里jq事件对象需要根据事件的类型，来构建兼容的事件对象，同样是使用钩子的形式，调用这些钩子的地方，在事件管理器的fix方法</p>
<h3 id="fix方法">fix方法</h3>
<p>fix方法就是将原生事件对象加工为jq自己的事件对象，内部都是用钩子来加对不同类型的事件进行加工</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( event[ jQuery.expando ] ) {
    <span class="keyword">return</span> event;
}
</pre></td></tr></table></figure>


<p>jq事件对象上有jq版本标记，如果标记已存在，说明是jq时间爱你对象，没必要加工了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="keyword">var</span> i, prop, copy,
    <span class="comment">/*获取事件的名称*/</span>
    type = event.type,
    <span class="comment">/*将原生事件对象缓存*/</span>
    originalEvent = event,
    <span class="comment">/*获取事件对象对应的钩子*/</span>
    fixHook = <span class="keyword">this</span>.fixHooks[ type ];

<span class="comment">/*如果没有钩子，需要判断这个对象类型是鼠标事件还是键盘事件*/</span>
<span class="keyword">if</span> ( !fixHook ) {
    <span class="keyword">this</span>.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? <span class="keyword">this</span>.mouseHooks :
        rkeyEvent.test( type ) ? <span class="keyword">this</span>.keyHooks :
        {};
}
</pre></td></tr></table></figure>


<p>这里会获取特殊事件的钩子，如果没有钩子，那需要判断事件是鼠标事件还是按键事件，这俩都需要特别处理。另外也会做缓存，获取到钩子后写入到fixHooks中，下次同样类型的事件就能直接获取钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/*获取鼠标事件或键盘事件应当拷贝的相关属性的列表*/</span>
copy = fixHook.props ? <span class="keyword">this</span>.props.concat( fixHook.props ) : <span class="keyword">this</span>.props;

<span class="comment">/*新建一个包装了原生事件对象的jq事件对象*/</span>
event = <span class="keyword">new</span> jQuery.Event( originalEvent );
<span class="comment">/*将这些需要拷贝的属性全部拷贝到jq事件对象中*/</span>
i = copy.length;
<span class="keyword">while</span> ( i-- ) {
    prop = copy[ i ];
    event[ prop ] = originalEvent[ prop ];
}
</pre></td></tr></table></figure>


<p>鼠标类型事件和按键类型时间都有自己的一些属性，当然还有些公有属性，这里需要获取事件应当从原生事件中拷贝值名称的列表。获取到列表后新建一个jq事件对象进行拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !event.target ) {
    event.target = document;
}
<span class="keyword">if</span> ( event.target.nodeType === <span class="number">3</span> ) {
    event.target = event.target.parentNode;
}
</pre></td></tr></table></figure>


<p>这里修复了一些事件target不正确的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">return</span> fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
</pre></td></tr></table></figure>


<p>最后再通过filter钩子做一下最后的加工处理。处理完成之后，返回jq的事件对象</p>
<h3 id="鼠标事件和键盘事件的处理">鼠标事件和键盘事件的处理</h3>
<p>fix中都是调用钩子来获得元素列表和filter最后处理，在事件管理器中定义了鼠标事件和键盘事件需要的属性</p>
<h4 id="公有属性">公有属性</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>props: <span class="string">"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which"</span>.split(<span class="string">" "</span>),
</pre></td></tr></table></figure>


<p>这些是鼠标和键盘事件公有的属性</p>
<h4 id="键盘事件">键盘事件</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>keyHooks: {
    props: <span class="string">"char charCode key keyCode"</span>.split(<span class="string">" "</span>),
    filter: <span class="function"><span class="keyword">function</span><span class="params">( event, original )</span> {</span>

        <span class="comment">// Add which for key events</span>
        <span class="keyword">if</span> ( event.which == <span class="literal">null</span> ) {
            event.which = original.charCode != <span class="literal">null</span> ? original.charCode : original.keyCode;
        }

        <span class="keyword">return</span> event;
    }
},
</pre></td></tr></table></figure>


<p>这里是键盘钩子，定义了键盘事件特有属性以及其filter，filter主要是将如charCode、keyCode等进行统一，创建出符合W3C标准的which</p>
<h4 id="鼠标事件">鼠标事件</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>mouseHooks: {
    props: <span class="string">"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement"</span>.split(<span class="string">" "</span>),
    filter: <span class="function"><span class="keyword">function</span><span class="params">( event, original )</span> {</span>
        <span class="keyword">var</span> eventDoc, doc, body,
            button = original.button;
        <span class="keyword">if</span> ( event.pageX == <span class="literal">null</span> && original.clientX != <span class="literal">null</span> ) {
            eventDoc = event.target.ownerDocument || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;
            event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || <span class="number">0</span> ) - ( doc && doc.clientLeft || body && body.clientLeft || <span class="number">0</span> );
            event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || <span class="number">0</span> ) - ( doc && doc.clientTop  || body && body.clientTop  || <span class="number">0</span> );
        }
        <span class="keyword">if</span> ( !event.which && button !== <span class="literal">undefined</span> ) {
            event.which = ( button & <span class="number">1</span> ? <span class="number">1</span> : ( button & <span class="number">2</span> ? <span class="number">3</span> : ( button & <span class="number">4</span> ? <span class="number">2</span> : <span class="number">0</span> ) ) );
        }
        <span class="keyword">return</span> event;
    }
},
</pre></td></tr></table></figure>


<p>同样的方式，定义了鼠标事件特有的属性，另外做了一个兼容，做出了pageX、pageY、which等属性</p>
<h2 id="特殊事件">特殊事件</h2>
<p>上一篇讲了jq事件核心，可以看到针对特殊事件，基本上每个地方都需要通过钩子特殊处理，那么有哪些特殊事件呢？这些在事件管理器的special里都有：</p>
<h3 id="load">load</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>load: {
    <span class="comment">// Prevent triggered image.load events from bubbling to window.load</span>
    noBubble: <span class="literal">true</span>
},
</pre></td></tr></table></figure>


<p>load事件不冒泡，需要注意</p>
<h3 id="focus和blur">focus和blur</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>focus: {
    <span class="comment">// Fire native event if possible so blur/focus sequence is correct</span>
    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> ( <span class="keyword">this</span> !== safeActiveElement() && <span class="keyword">this</span>.focus ) {
            <span class="keyword">this</span>.focus();
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    },
    delegateType: <span class="string">"focusin"</span>
},
blur: {
    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> ( <span class="keyword">this</span> === safeActiveElement() && <span class="keyword">this</span>.blur ) {
            <span class="keyword">this</span>.blur();
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    },
    delegateType: <span class="string">"focusout"</span>
},
</pre></td></tr></table></figure>


<p>focus和blur事件，这俩有自己的trigger钩子，另外其使用代理时名称也不同。事实上focus和blur除了trigger钩子，还有在事件注册和事件删除时的setup和teardown钩子，可以看到代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !support.focusinBubbles ) {
    jQuery.each({ focus: <span class="string">"focusin"</span>, blur: <span class="string">"focusout"</span> }, <span class="function"><span class="keyword">function</span><span class="params">( orig, fix )</span> {</span>
        <span class="comment">// Attach a single capturing handler on the document while someone wants focusin/focusout</span>
        <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span><span class="params">( event )</span> {</span>
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), <span class="literal">true</span> );
            };
        jQuery.event.special[ fix ] = {
            setup: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> doc = <span class="keyword">this</span>.ownerDocument || <span class="keyword">this</span>,
                    attaches = data_priv.access( doc, fix );
                <span class="keyword">if</span> ( !attaches ) {
                    doc.addEventListener( orig, handler, <span class="literal">true</span> );
                }
                data_priv.access( doc, fix, ( attaches || <span class="number">0</span> ) + <span class="number">1</span> );
            },
            teardown: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> doc = <span class="keyword">this</span>.ownerDocument || <span class="keyword">this</span>,
                    attaches = data_priv.access( doc, fix ) - <span class="number">1</span>;

                <span class="keyword">if</span> ( !attaches ) {
                    doc.removeEventListener( orig, handler, <span class="literal">true</span> );
                    data_priv.remove( doc, fix );

                } <span class="keyword">else</span> {
                    data_priv.access( doc, fix, attaches );
                }
            }
        };
    });
}
</pre></td></tr></table></figure>


<h3 id="click">click</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>click: {
    <span class="comment">// For checkbox, fire native event so checked state will be right</span>
    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> ( <span class="keyword">this</span>.type === <span class="string">"checkbox"</span> && <span class="keyword">this</span>.click && jQuery.nodeName( <span class="keyword">this</span>, <span class="string">"input"</span> ) ) {
            <span class="keyword">this</span>.click();
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    },
    <span class="comment">/*浏览器兼容，如果元素是a标签，那么不触发原生click事件*/</span>
    <span class="comment">// For cross-browser consistency, don't fire native .click() on links</span>
    _default: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> {</span>
        <span class="keyword">return</span> jQuery.nodeName( event.target, <span class="string">"a"</span> );
    }
},
</pre></td></tr></table></figure>


<p>点击时间爱你，在checkbox上有钩子，调用其原生api。另外，当元素为a标签时，不触发原生click事件</p>
<h3 id="beforeunload">beforeunload</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>beforeunload: {
    postDispatch: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> {</span>

        <span class="comment">// Support: Firefox 20+</span>
        <span class="comment">// Firefox doesn't alert if the returnValue field is not set.</span>
        <span class="keyword">if</span> ( event.result !== <span class="literal">undefined</span> ) {
            event.originalEvent.returnValue = event.result;
        }
    }
}
</pre></td></tr></table></figure>


<p>beforeunlaod事件在ff中最后结果可能不同，需要做兼容</p>
<h3 id="mouseenter和mouseleave">mouseenter和mouseleave</h3>
<p>mouseover和mouseout的问题在于，他们只监听最外层的大容器，而大容器中是由很多子元素的。如果鼠标在子元素上，而离开了大容器，mouseout事件也会触发。</p>
<p>比如一个列式菜单，最上层菜单上有一些选项，鼠标悬停在选项上，右侧会出现该选项下的子选项。如果在菜单上使用mouseover和mouseout来绑定事件，当鼠标移动到子选项时，实际上移出了容器，会触发mouseout事件，菜单就被隐藏了…</p>
<p>jq通过新建两个事件mouseenter和mouseleave来防止这种情况发生</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>jQuery.each({
    mouseenter: <span class="string">"mouseover"</span>,
    mouseleave: <span class="string">"mouseout"</span>
}, <span class="function"><span class="keyword">function</span><span class="params">( orig, fix )</span> {</span>
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> {</span>
            <span class="keyword">var</span> ret,
                target = <span class="keyword">this</span>,
                related = event.relatedTarget,
                handleObj = event.handleObj;

            <span class="comment">// For mousenter/leave call the handler if related is outside the target.</span>
            <span class="comment">// NB: No relatedTarget if the mouse left/entered the browser window</span>
            <span class="keyword">if</span> ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
                event.type = fix;
            }
            <span class="keyword">return</span> ret;
        }
    };
});
</pre></td></tr></table></figure>


<p>可以看到，这里可以看到，使用contains判断当前元素是否被包含在容器中，如果包含将不会执行回调函数</p>
<h2 id="jQuery对象上的方法">jQuery对象上的方法</h2>
<p>我们需要一系列的方法将事件用于jQuery对象之上，依旧是在fn上扩展，有如下一些方法：</p>
<ol>
<li>on： 绑定事件添加回调</li>
<li>one：绑定知识性一次的事件</li>
<li>off：移除事件</li>
<li>trigger：对每一个元素触发事件</li>
<li>triggerHandler：对jq对象中的第一个元素触发事件</li>
</ol>
<h3 id="on_(types,_selector,_data,_fn,_/*内部使用*/one)">on (types, selector, data, fn, /*内部使用*/one)</h3>
<p>jq使用on方法在元素时行绑定事件，这里types可以是一个<code>event1 event2</code>这样的字符串，同时绑定多个事件公用相同的回调函数fn。另外，当types为对象时，键为事件名称，值为回调函数，也可以一次绑定多个事件。这是一个多接口方法，需要根据传入的参数判断如何处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">if</span> ( <span class="keyword">typeof</span> types === <span class="string">"object"</span> ) {
    <span class="comment">// ( types-Object, selector, data )</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector !== <span class="string">"string"</span> ) {
        <span class="comment">// ( types-Object, data )</span>
        data = data || selector;
        selector = <span class="literal">undefined</span>;
    }
    <span class="comment">/*一次绑定多个事件*/</span>
    <span class="keyword">for</span> ( type <span class="keyword">in</span> types ) {
        <span class="keyword">this</span>.on( type, selector, data, types[ type ], one );
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>


<p>可以看到，这里就是处理types为对象的情况，这里实际上根据types中的每个键值对，递归调用了on方法进行单个绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="comment">/*可以不提供数据*/</span>
<span class="keyword">if</span> ( data == <span class="literal">null</span> && fn == <span class="literal">null</span> ) {
    <span class="comment">// ( types, fn )</span>
    <span class="comment">//情况1</span>
    fn = selector;
    data = selector = <span class="literal">undefined</span>;
} <span class="keyword">else</span> <span class="keyword">if</span> ( fn == <span class="literal">null</span> ) {
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector === <span class="string">"string"</span> ) {
        <span class="comment">// ( types, selector, fn )</span>
        <span class="comment">//情况2</span>
        fn = data;
        data = <span class="literal">undefined</span>;
    } <span class="keyword">else</span> {
        <span class="comment">// ( types, data, fn )</span>
        <span class="comment">//情况3</span>
        fn = data;
        data = selector;
        selector = <span class="literal">undefined</span>;
    }
}
<span class="keyword">if</span> ( fn === <span class="literal">false</span> ) {
    fn = returnFalse;
} <span class="keyword">else</span> <span class="keyword">if</span> ( !fn ) {
    <span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>


<p>这里处理了三种情况：</p>
<ol>
<li>只有事件名称和回调函数</li>
<li>有事件名称，代理选择器和回调函数</li>
<li>有事件名称，事件数据和回调函数</li>
</ol>
<p>如果没有回调函数，需要给与一个默认的回调函数，这个默认回调函数直接<code>return false</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span> ( one === <span class="number">1</span> ) {
    origFn = fn;
    fn = <span class="function"><span class="keyword">function</span><span class="params">( event )</span> {</span>
        <span class="comment">// Can use an empty set, since event contains the info</span>
        jQuery().off( event );
        <span class="keyword">return</span> origFn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );
    };
    <span class="comment">// Use same guid so caller can remove using origFn</span>
    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
}
</pre></td></tr></table></figure>


<p>我们可以绑定一次性事件，实现骑士很简单，通过闭包对事件回调函数做一个包装，在其被运行之前，调用off移除掉事件就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    jQuery.event.add( <span class="keyword">this</span>, types, fn, data, selector );
});
</pre></td></tr></table></figure>


<p>最后，确定好了配置，最后在jq对象中的每个元素上调用通过事件管理器的add方法添加事件回调函数</p>
<h3 id="one_(_types,_selector,_data,_fn_)">one ( types, selector, data, fn )</h3>
<p>绑定一次性事件，上面的on已经做了实现，这里只不过是调用一下接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>one: <span class="function"><span class="keyword">function</span><span class="params">( types, selector, data, fn )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.on( types, selector, data, fn, <span class="number">1</span> );
},
</pre></td></tr></table></figure>


<h3 id="off_(_types,_selector,_fn_)">off ( types, selector, fn )</h3>
<p>同样是个多接口函数，在只有事件名称时，直接删除整个事件。如果有确定回调函数，那么删除对应时间的对应回调函数。需要注意代理的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span> ( types && types.preventDefault && types.handleObj ) {
    <span class="comment">// ( event )  dispatched jQuery.Event</span>
    handleObj = types.handleObj;
    jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + <span class="string">"."</span> + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
    );
    <span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>


<p>这里处理的是参数是事件对象的情况，这种情况会在使用one绑定事件回调执行后自动删除时发生。获取事件对象其中的属性，递归调用off删除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">if</span> ( <span class="keyword">typeof</span> types === <span class="string">"object"</span> ) {
    <span class="comment">// ( types-object [, selector] )</span>
    <span class="keyword">for</span> ( type <span class="keyword">in</span> types ) {
        <span class="keyword">this</span>.off( type, selector, types[ type ] );
    }
    <span class="keyword">return</span> <span class="keyword">this</span>;
}
</pre></td></tr></table></figure>


<p>如果typs是事件名称到回调函数的键值对，那么对其中的每个键和值，分别进行删除，递归调用off删除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">if</span> ( selector === <span class="literal">false</span> || <span class="keyword">typeof</span> selector === <span class="string">"function"</span> ) {
    <span class="comment">// ( types [, fn] )</span>
    fn = selector;
    selector = <span class="literal">undefined</span>;
}
<span class="keyword">if</span> ( fn === <span class="literal">false</span> ) {
    fn = returnFalse;
}
</pre></td></tr></table></figure>


<p>这里处理了只有事件名称和回调函数的接口情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    jQuery.event.remove( <span class="keyword">this</span>, types, fn, selector );
});
</pre></td></tr></table></figure>


<p>最后，对jq对象中的每个元素移除事件中的回调函数就好</p>
<h3 id="trigger_(type,_data)_和_triggerHandler_(type,_data)">trigger (type, data) 和 triggerHandler (type, data)</h3>
<p>没啥说的，都是直接用的事件管理器的trigger方法。只不过前者对每个元素调用一次，后者只对第一个元素调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/*对jq对象中的每个元素触发事件*/</span>
trigger: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        jQuery.event.trigger( type, data, <span class="keyword">this</span> );
    });
},
<span class="comment">/*对jq对象中的第一个元素触发事件*/</span>
triggerHandler: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> {</span>
    <span class="keyword">var</span> elem = <span class="keyword">this</span>[<span class="number">0</span>];
    <span class="keyword">if</span> ( elem ) {
        <span class="keyword">return</span> jQuery.event.trigger( type, data, elem, <span class="literal">true</span> );
    }
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>这一篇直接看的话，肯定会不知所云…最好能结合上一篇一起看，上一篇介绍了事件机制的核心方法，这一篇主要是jq事件对象和一些兼容性问题的解决方法（主要是钩子）。jq的钩子方式很不错，在写框架对付兼容性问题时可以多多使用</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇主要介绍了jQuery中事件管理器的事件对象、兼容实现以及在jQuery对象上暴露的接口</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的数据缓存]]></title>
    <link href="http://lingyu.wang/2014/05/10/read-jq-src-2/"/>
    <id>http://lingyu.wang/2014/05/10/read-jq-src-2/</id>
    <published>2014-05-09T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.184Z</updated>
    <content type="html"><![CDATA[<p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>
<a id="more"></a>

<h2 id="jQuery的数据缓存简介">jQuery的数据缓存简介</h2>
<p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>
<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>
<h2 id="jq中数据缓存的限制">jq中数据缓存的限制</h2>
<p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery.acceptData = <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="keyword">return</span> owner.nodeType === <span class="number">1</span> || owner.nodeType === <span class="number">9</span> || !( +owner.nodeType );
};
</pre></td></tr></table></figure>


<h2 id="数据对象">数据对象</h2>
<p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Data</span><span class="params">()</span> {</span>
    <span class="comment">/*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/</span>
    <span class="built_in">Object</span>.defineProperty( <span class="keyword">this</span>.cache = {}, <span class="number">0</span>, {
        get: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">return</span> {};
        }
    });
    <span class="comment">/*为这个数据对象添上jQuery版本号+随机数的版本号*/</span>
    <span class="keyword">this</span>.expando = jQuery.expando + <span class="built_in">Math</span>.random();
}
</pre></td></tr></table></figure>


<h3 id="静态方法和属性">静态方法和属性</h3>
<h4 id="uid">uid</h4>
<p>数据对象的id，自增</p>
<h4 id="accepts">accepts</h4>
<p>判断是否能够接受数据，直接指向之前的acceptData</p>
<h3 id="核心方法">核心方法</h3>
<h4 id="key_(owner)">key (owner)</h4>
<p>owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>
<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>
<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>
<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>
<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>key: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="comment">/*如果这个所有者不能接收数据，返回0*/</span>
    <span class="keyword">if</span> ( !Data.accepts( owner ) ) {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    <span class="keyword">var</span> descriptor = {},
        <span class="comment">/*获取这个所有者已经有这个版本的数据的id*/</span>
        unlock = owner[ <span class="keyword">this</span>.expando ];
    <span class="comment">/*如果这个所有者没有对应的数据对象，那么创建一个*/</span>
    <span class="keyword">if</span> ( !unlock ) {
        <span class="comment">/*自增的uid*/</span>
        unlock = Data.uid++;
        <span class="comment">/*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/</span>
        <span class="keyword">try</span> {
            descriptor[ <span class="keyword">this</span>.expando ] = { value: unlock };
            <span class="built_in">Object</span>.defineProperties( owner, descriptor );
        <span class="comment">/*如果不能使用Object.defineProperites，那么直接使用extend*/</span>
        } <span class="keyword">catch</span> ( e ) {
            descriptor[ <span class="keyword">this</span>.expando ] = unlock;
            jQuery.extend( owner, descriptor );
        }
    }
    <span class="comment">/*在cache中创建对象的数据空间*/</span>
    <span class="keyword">if</span> ( !<span class="keyword">this</span>.cache[ unlock ] ) {
        <span class="keyword">this</span>.cache[ unlock ] = {};
    }
    <span class="comment">/*返回这个新的id*/</span>
    <span class="keyword">return</span> unlock;
},
</pre></td></tr></table></figure>


<h4 id="set_(owner,_data,_value)">set (owner, data, value)</h4>
<p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>
<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>
<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>
<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">/*加入数据（往cache中加数据）*/</span>
set: <span class="function"><span class="keyword">function</span><span class="params">( owner, data, value )</span> {</span>
    <span class="keyword">var</span> prop,
        <span class="comment">/*首先获得这个所有者的id（没有就新建一个）*/</span>
        unlock = <span class="keyword">this</span>.key( owner ),
        <span class="comment">/*获得这个数据对象对应的cache内的空间*/</span>
        cache = <span class="keyword">this</span>.cache[ unlock ];

    <span class="comment">/*如果数据时string直接写进去*/</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> data === <span class="string">"string"</span> ) {
        cache[ data ] = value;

    <span class="comment">/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/</span>
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> ( jQuery.isEmptyObject( cache ) ) {
            jQuery.extend( <span class="keyword">this</span>.cache[ unlock ], data );
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> ( prop <span class="keyword">in</span> data ) {
                cache[ prop ] = data[ prop ];
            }
        }
    }
    <span class="keyword">return</span> cache;
},
</pre></td></tr></table></figure>


<h4 id="get_(owner,_key)">get (owner, key)</h4>
<p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>
<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">/*获取数据（从cache中取数据）*/</span>
get: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> {</span>
    <span class="comment">/*通过owner获取id，从cache中获取在对应的完整缓存对象*/</span>
    <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache[ <span class="keyword">this</span>.key( owner ) ];
    <span class="comment">/*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/</span>
    <span class="keyword">return</span> key === <span class="literal">undefined</span> ?
        cache : cache[ key ];
},
</pre></td></tr></table></figure>


<h4 id="access_(owner,_key,_value)">access (owner, key, value)</h4>
<p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>
<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：</p>
<ol>
<li>如果没有key和value，那么使用get方法获取整个数据空间对象</li>
<li>如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值</li>
<li>如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中</li>
<li>如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>access: <span class="function"><span class="keyword">function</span><span class="params">( owner, key, value )</span> {</span>
    <span class="keyword">var</span> stored;
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ||
            ((key && <span class="keyword">typeof</span> key === <span class="string">"string"</span>) && value === <span class="literal">undefined</span>) ) {

        stored = <span class="keyword">this</span>.get( owner, key );

        <span class="keyword">return</span> stored !== <span class="literal">undefined</span> ?
            stored : <span class="keyword">this</span>.get( owner, jQuery.camelCase(key) );
    }

    <span class="keyword">this</span>.set( owner, key, value );

    <span class="keyword">return</span> value !== <span class="literal">undefined</span> ? value : key;
},
</pre></td></tr></table></figure>


<h4 id="remove_(owner,_key)">remove (owner, key)</h4>
<p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>
<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="comment">/*从owner移除属性 */</span>
remove: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> {</span>
    <span class="keyword">var</span> i, name, camel,
        unlock = <span class="keyword">this</span>.key( owner ),
        cache = <span class="keyword">this</span>.cache[ unlock ];
    <span class="comment">/*如果没有key，移除整个owner所拥有的缓存*/</span>
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {
        <span class="keyword">this</span>.cache[ unlock ] = {};
    } <span class="keyword">else</span> {
        <span class="comment">// Support array or space separated string of keys</span>
        <span class="comment">/*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/</span>
        <span class="keyword">if</span> ( jQuery.isArray( key ) ) {
            name = key.concat( key.map( jQuery.camelCase ) );
        } <span class="keyword">else</span> {
            <span class="comment">/*如果key不是数组，将key转成驼峰*/</span>
            camel = jQuery.camelCase( key );
            <span class="comment">/*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/</span>
            <span class="keyword">if</span> ( key <span class="keyword">in</span> cache ) {
                name = [ key, camel ];
            } <span class="keyword">else</span> {
                <span class="comment">/*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/</span>
                name = camel;
                <span class="comment">/*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/</span>
                name = name <span class="keyword">in</span> cache ?
                    [ name ] : ( name.match( rnotwhite ) || [] );
            }
        }
        <span class="comment">/*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/</span>
        i = name.length;
        <span class="keyword">while</span> ( i-- ) {
            <span class="keyword">delete</span> cache[ name[ i ] ];
        }
    }
},
</pre></td></tr></table></figure>


<h4 id="hasData_(owner)">hasData (owner)</h4>
<p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/*判断是否存在数据*/</span>
hasData: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="comment">/*判断缓存对象是否是空对象*/</span>
    <span class="keyword">return</span> !jQuery.isEmptyObject(
        <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ] || {}
    );
},
</pre></td></tr></table></figure>


<h4 id="discard_(owner)">discard (owner)</h4>
<p>移除掉owner的所有缓存，直接在cache上用delete删</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*移除整个缓存对象*/</span>
discard: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="keyword">if</span> ( owner[ <span class="keyword">this</span>.expando ] ) {
        <span class="keyword">delete</span> <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ];
    }
}
</pre></td></tr></table></figure>


<h3 id="数据对象创建">数据对象创建</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*私有数据对象*/</span>
<span class="keyword">var</span> data_priv = <span class="keyword">new</span> Data();
<span class="comment">/*公有数据对象*/</span>
<span class="keyword">var</span> data_user = <span class="keyword">new</span> Data();
</pre></td></tr></table></figure>


<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>
<h2 id="jQuery对数据对象操作接口">jQuery对数据对象操作接口</h2>
<h3 id="dataAttr方法">dataAttr方法</h3>
<p>事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>function dataAttr( elem, key, <span class="built_in">data</span> ) {
    <span class="built_in">var</span> name;

    <span class="comment">/*如果没有data，而元素为element类型*/</span>
    <span class="keyword">if</span> ( <span class="built_in">data</span> <span class="subst">===</span> undefined <span class="subst">&&</span> elem<span class="built_in">.</span>nodeType <span class="subst">===</span> <span class="number">1</span> ) {

        <span class="comment">/*从data-xxx属性中获取数据*/</span>
        name <span class="subst">=</span> <span class="string">"data-"</span> <span class="subst">+</span> key<span class="built_in">.</span>replace( rmultiDash, <span class="string">"-$1"</span> )<span class="built_in">.</span>toLowerCase();
        <span class="built_in">data</span> <span class="subst">=</span> elem<span class="built_in">.</span>getAttribute( name );
        <span class="comment">/*如果对象是字符串，分别尝试转成true、false、null，如果使用{}包裹，当做JSON解析*/</span>
        <span class="keyword">if</span> ( typeof <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"string"</span> ) {
            try {
                <span class="built_in">data</span> <span class="subst">=</span> <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"true"</span> <span class="subst">?</span> <span class="literal">true</span> :
                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"false"</span> <span class="subst">?</span> <span class="literal">false</span> :
                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"null"</span> <span class="subst">?</span> <span class="built_in">null</span> :
                    <span class="comment">// Only convert to a number if it doesn't change the string</span>
                    <span class="subst">+</span><span class="built_in">data</span> <span class="subst">+</span> <span class="string">""</span> <span class="subst">===</span> <span class="built_in">data</span> <span class="subst">?</span> <span class="subst">+</span><span class="built_in">data</span> :
                    rbrace<span class="built_in">.</span>test( <span class="built_in">data</span> ) <span class="subst">?</span> jQuery<span class="built_in">.</span>parseJSON( <span class="built_in">data</span> ) :
                    <span class="built_in">data</span>;
            } catch( e ) {}

            <span class="comment">/*写入到公共数据对象中*/</span>
            data_user<span class="built_in">.</span><span class="built_in">set</span>( elem, key, <span class="built_in">data</span> );
        } <span class="keyword">else</span> {
            <span class="built_in">data</span> <span class="subst">=</span> undefined;
        }
    }
    <span class="keyword">return</span> <span class="built_in">data</span>;
}
</pre></td></tr></table></figure>


<h3 id="静态方法">静态方法</h3>
<p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>
<h4 id="hasData_(elem)">hasData (elem)</h4>
<p>判断元素是否含有数据，这里会检测公有数据和私有数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>hasData: <span class="function"><span class="keyword">function</span><span class="params">( elem )</span> {</span>
    <span class="keyword">return</span> data_user.hasData( elem ) || data_priv.hasData( elem );
},
</pre></td></tr></table></figure>


<h4 id="data_(elem,_name,_data)">data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
    <span class="keyword">return</span> data_user.access( elem, name, data );
},
</pre></td></tr></table></figure>


<h4 id="removeData_(elem,_name)">removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
    data_user.remove( elem, name );
},
</pre></td></tr></table></figure>


<h4 id="_data_(elem,_name,_data)">_data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>_data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
    <span class="keyword">return</span> data_priv.access( elem, name, data );
},
</pre></td></tr></table></figure>


<h4 id="_removeData_(elem,_name)">_removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>_removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
    data_priv.remove( elem, name );
}
</pre></td></tr></table></figure>


<h3 id="在jq对象上添加数据对象操作方法">在jq对象上添加数据对象操作方法</h3>
<p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>
<h4 id="data_(key,_value)">data (key, value)</h4>
<p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：</p>
<ol>
<li>如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象</li>
<li>如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象</li>
<li>否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre>data: <span class="function"><span class="keyword">function</span><span class="params">( key, value )</span> {</span>
    <span class="keyword">var</span> i, name, data,
        elem = <span class="keyword">this</span>[ <span class="number">0</span> ],
        attrs = elem && elem.attributes;

    
    <span class="comment">/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/</span>
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {
        <span class="comment">/*jq对象中有节点*/</span>
        <span class="keyword">if</span> ( <span class="keyword">this</span>.length ) {
            <span class="comment">/*第一个节点的数据*/</span>
            data = data_user.get( elem );
            <span class="comment">/*如果节点为element类型且私有数据中没有标记hasDataAttrs
            将节点中的所有data-类型的属性写入到公共数据中
            然后在私有数据中设定hasDataAttrs为true*/</span>
            <span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> && !data_priv.get( elem, <span class="string">"hasDataAttrs"</span> ) ) {
                i = attrs.length;
                <span class="keyword">while</span> ( i-- ) {
                    name = attrs[ i ].name;

                    <span class="keyword">if</span> ( name.indexOf( <span class="string">"data-"</span> ) === <span class="number">0</span> ) {
                        name = jQuery.camelCase( name.slice(<span class="number">5</span>) );
                        dataAttr( elem, name, data[ name ] );
                    }
                }
                data_priv.set( elem, <span class="string">"hasDataAttrs"</span>, <span class="literal">true</span> );
            }
        }

        <span class="keyword">return</span> data;
    }

    <span class="comment">/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> key === <span class="string">"object"</span> ) {
        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            data_user.set( <span class="keyword">this</span>, key );
        });
    }
    <span class="comment">/*通过access判断*/</span>
    <span class="keyword">return</span> access( <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
        <span class="keyword">var</span> data,
            <span class="comment">/*生成驼峰的key*/</span>
            camelKey = jQuery.camelCase( key );
        <span class="comment">/*如果jq对象中有元素，且没有value，说明调用get获取数据*/</span>
        <span class="keyword">if</span> ( elem && value === <span class="literal">undefined</span> ) {
            <span class="comment">/*直接使用key获取*/</span>
            data = data_user.get( elem, key );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }
            <span class="comment">/*如果直接用key未能获取导数据，尝试驼峰格式的key*/</span>
            data = data_user.get( elem, camelKey );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }

            <span class="comment">/*如果还是无法获取，尝试从data-属性获取*/</span>
            data = dataAttr( elem, camelKey, <span class="literal">undefined</span> );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }

            <span class="comment">/*我们尝试了所有情况，但还是没有数据，返回undefined*/</span>
            <span class="keyword">return</span>;
        }

        <span class="comment">/*写入数据*/</span>
        <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">/*通过驼峰形式key获取公共数据*/</span>
            <span class="keyword">var</span> data = data_user.get( <span class="keyword">this</span>, camelKey );
            <span class="comment">/*往驼峰形式key中写入公共数据*/</span>
            data_user.set( <span class="keyword">this</span>, camelKey, value );

            <span class="comment">/*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/</span>
            <span class="keyword">if</span> ( key.indexOf(<span class="string">"-"</span>) !== -<span class="number">1</span> && data !== <span class="literal">undefined</span> ) {
                data_user.set( <span class="keyword">this</span>, key, value );
            }
        });
    }, <span class="literal">null</span>, value, <span class="built_in">arguments</span>.length &gt; <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">true</span> );
},
</pre></td></tr></table></figure>


<h4 id="removeData_(key)">removeData (key)</h4>
<p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*从公共数据中移除包含key（或key中元素）的键值对*/</span>
removeData: <span class="function"><span class="keyword">function</span><span class="params">( key )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        data_user.remove( <span class="keyword">this</span>, key );
    });
}
</pre></td></tr></table></figure>


<h2 id="为动画服务的queue和dequeue">为动画服务的queue和dequeue</h2>
<p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>
<h3 id="静态方法-1">静态方法</h3>
<h4 id="queue_(elem,_type,_data)">queue (elem, type, data)</h4>
<p>逻辑不复杂，也分读写两种情况。以<code>type + &quot;queue&quot;</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>
<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>
<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">/*压入或读取一组数据*/</span>
queue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type, data )</span> {</span>
    <span class="keyword">var</span> queue;

    <span class="keyword">if</span> ( elem ) {
        <span class="comment">/*重命名一下type，默认叫fxqueue*/</span>
        type = ( type || <span class="string">"fx"</span> ) + <span class="string">"queue"</span>;
        <span class="comment">/*从私有数据中获得已有的queue数据*/</span>
        queue = data_priv.get( elem, type );

        <span class="comment">/*如果存在data，需要写入数据*/</span>
        <span class="keyword">if</span> ( data ) {
            <span class="comment">/*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/</span>
            <span class="keyword">if</span> ( !queue || jQuery.isArray( data ) ) {
                queue = data_priv.access( elem, type, jQuery.makeArray(data) );
            <span class="comment">/*之前有数据，直接把data连在数据数组后头*/</span>
            } <span class="keyword">else</span> {
                queue.push( data );
            }
        }
        <span class="keyword">return</span> queue || [];
    }
},
</pre></td></tr></table></figure>


<h4 id="dequeue_(elem,_type)">dequeue (elem, type)</h4>
<p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>
<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="comment">/*运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉*/</span>
dequeue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> {</span>
    <span class="comment">/*获取type，默认为fx*/</span>
    type = type || <span class="string">"fx"</span>;
    <span class="comment">/*获取一组数据*/</span>
    <span class="keyword">var</span> queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        <span class="comment">/*获取状态*/</span>
        fn = queue.shift(),
        <span class="comment">/*获取元素的钩子*/</span>
        hooks = jQuery._queueHooks( elem, type ),
        next = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            jQuery.dequeue( elem, type );
        };

    <span class="comment">/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/</span>
    <span class="keyword">if</span> ( fn === <span class="string">"inprogress"</span> ) {
        fn = queue.shift();
        startLength--;
    }
    <span class="keyword">if</span> ( fn ) {

        <span class="comment">/*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/</span>
        <span class="keyword">if</span> ( type === <span class="string">"fx"</span> ) {
            queue.unshift( <span class="string">"inprogress"</span> );
        }

        <span class="comment">/*删除掉钩子中的停止函数*/</span>
        <span class="keyword">delete</span> hooks.stop;
        <span class="comment">/*在这个函数上调用，并提供钩子*/</span>
        fn.call( elem, next, hooks );
    }
    <span class="comment">/*如果队列已经空了，那么调用empty删除掉这个键值对*/</span>
    <span class="keyword">if</span> ( !startLength && hooks ) {
        hooks.empty.fire();
    }
},
</pre></td></tr></table></figure>


<h4 id="_queueHooks_(elem,_type)">_queueHooks (elem, type)</h4>
<p>提供默认钩子的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>_queueHooks: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> {</span>
    <span class="keyword">var</span> key = type + <span class="string">"queueHooks"</span>;
    <span class="keyword">return</span> data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: jQuery.Callbacks(<span class="string">"once memory"</span>).add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            data_priv.remove( elem, [ type + <span class="string">"queue"</span>, key ] );
        })
    });
}
</pre></td></tr></table></figure>


<h3 id="jq对象上的queue和dequeue">jq对象上的queue和dequeue</h3>
<h4 id="queue_(type,_data)">queue (type, data)</h4>
<p>对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>queue: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> {</span>
        <span class="keyword">var</span> setter = <span class="number">2</span>;

        <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {
            data = type;
            type = <span class="string">"fx"</span>;
            setter--;
        }

        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length &lt; setter ) {
            <span class="keyword">return</span> jQuery.queue( <span class="keyword">this</span>[<span class="number">0</span>], type );
        }

        <span class="keyword">return</span> data === <span class="literal">undefined</span> ?
            <span class="keyword">this</span> :
            <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> queue = jQuery.queue( <span class="keyword">this</span>, type, data );

                <span class="comment">// ensure a hooks for this queue</span>
                jQuery._queueHooks( <span class="keyword">this</span>, type );

                <span class="keyword">if</span> ( type === <span class="string">"fx"</span> && queue[<span class="number">0</span>] !== <span class="string">"inprogress"</span> ) {
                    jQuery.dequeue( <span class="keyword">this</span>, type );
                }
            });
    },
</pre></td></tr></table></figure>


<h4 id="dequeue_(type)">dequeue (type)</h4>
<p>对jq对象中每个DOM元素执行dequeue操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/</span>
dequeue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        jQuery.dequeue( <span class="keyword">this</span>, type );
    });
},
</pre></td></tr></table></figure>


<h4 id="clearQueue_(type)">clearQueue (type)</h4>
<p>清除jq对象中每个DOM的type对应的数据列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*清除对应的类型的操作列表*/</span>
clearQueue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.queue( type || <span class="string">"fx"</span>, [] );
},
</pre></td></tr></table></figure>


<h4 id="promise_(type,_obj)">promise (type, obj)</h4>
<p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="comment">/*创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象*/</span>
promise: <span class="function"><span class="keyword">function</span><span class="params">( type, obj )</span> {</span>
    <span class="keyword">var</span> tmp,
        count = <span class="number">1</span>,
        defer = jQuery.Deferred(),
        elements = <span class="keyword">this</span>,
        i = <span class="keyword">this</span>.length,
        resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">if</span> ( !( --count ) ) {
                defer.resolveWith( elements, [ elements ] );
            }
        };

    <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {
        obj = type;
        type = <span class="literal">undefined</span>;
    }
    type = type || <span class="string">"fx"</span>;
    
    <span class="keyword">while</span> ( i-- ) {
        tmp = data_priv.get( elements[ i ], type + <span class="string">"queueHooks"</span> );
        <span class="keyword">if</span> ( tmp && tmp.empty ) {
            count++;
            tmp.empty.add( resolve );
        }
    }
    resolve();
    <span class="keyword">return</span> defer.promise( obj );
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的核心方法和类型判断]]></title>
    <link href="http://lingyu.wang/2014/05/08/read-jq-src-1/"/>
    <id>http://lingyu.wang/2014/05/08/read-jq-src-1/</id>
    <published>2014-05-07T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.183Z</updated>
    <content type="html"><![CDATA[<p>这几天闭关读源码，jQuery读了一半了，sizzle，基础方法，promise等等都详细的看了一下，由于东西比较多，先记录第一部分，jQuery的一些核心方法以及jQuery中的类型判断，读的是jQuery-2.1.0</p>
<a id="more"></a>

<h2 id="一些方法的缓存">一些方法的缓存</h2>
<p>上来先做了一下commonjs的判断和兼容</p>
<p>之后将一些数组上和对象上的常用方法进行了缓存。另外还缓存了一个class2type对象和support对象，class2type对象将在后面的类型判断处详细介绍。而support用来保存嗅探到的浏览器特性是否支持</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="comment">/*缓存一些常用方法和对象*/</span>
<span class="keyword">var</span> arr = [];
<span class="comment">/*切分数组*/</span>
<span class="keyword">var</span> slice = arr.slice;
<span class="comment">/*数组合并*/</span>
<span class="keyword">var</span> concat = arr.concat;
<span class="comment">/*添加到尾部*/</span>
<span class="keyword">var</span> push = arr.push;
<span class="comment">/*查找位置*/</span>
<span class="keyword">var</span> indexOf = arr.indexOf;
<span class="comment">/*判断变量类型*/</span>
<span class="keyword">var</span> class2type = {};
<span class="comment">/*对象的toString方法，用于判断变量类型*/</span>
<span class="keyword">var</span> toString = class2type.toString;
<span class="comment">/*对象的hasOwnProperty，判断属性是否在对象中*/</span>
<span class="keyword">var</span> hasOwn = class2type.hasOwnProperty;
<span class="comment">/*字符串的trime方法*/</span>
<span class="keyword">var</span> trim = <span class="string">""</span>.trim;
<span class="comment">/*方法支持程度*/</span>
<span class="keyword">var</span> support = {};
</pre></td></tr></table></figure>


<p>之后创建了jQuery方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery = <span class="function"><span class="keyword">function</span><span class="params">( selector, context )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );
}
</pre></td></tr></table></figure>


<p>可以看到，其使用<code>new jQuery.fn.init</code>创建了一个jq对象并返回了，jq对象的详细实现应该在init方法中</p>
<p>当然还有一些像缓存document，版本号，匹配<code>-ms-</code>和<code>-[\da-z]</code>这样的正则表达式，还有一个将字符串转大写的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">var</span>
    document = window.document,

    version = <span class="string">"2.1.0"</span>,

    jQuery = <span class="function"><span class="keyword">function</span><span class="params">( selector, context )</span> {</span>
        <span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span>
        <span class="comment">// Need init if jQuery is called (just allow error to be thrown if not included)</span>
        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );
    },

    rmsPrefix = <span class="regexp">/^-ms-/</span>,
    rdashAlpha = <span class="regexp">/-([\da-z])/gi</span>,

    fcamelCase = <span class="function"><span class="keyword">function</span><span class="params">( all, letter )</span> {</span>
        <span class="keyword">return</span> letter.toUpperCase();
    };
</pre></td></tr></table></figure>


<h2 id="在jQuery对象上扩展方法">在jQuery对象上扩展方法</h2>
<p>紧接着是一系列在jq对象上扩展的方法：<br>可以看到在jq对象上扩展方法实际上就是在jQuery的prototype上扩展方法<br>这里定义了一系列在jQuery对象中操作元素集合的方法</p>
<h4 id="constructor">constructor</h4>
<p>重新将constructor指向jQuery，防止constructor指向Object</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>constructor: jQuery,
</pre></td></tr></table></figure>


<h4 id="selector">selector</h4>
<p>每个jQuery对象都与一个selector字符串，可以用它来检测jQuery对象，默认为空字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>selector: <span class="string">""</span>,
</pre></td></tr></table></figure>


<h4 id="length">length</h4>
<p>jQuery对象其实可以看做一个包含了很多dom元素和一系列扩展方法的类数组对象，其中必然会有一个length属性说明一共有多少dom元素，经常用来判断jq对象是否含有结果集</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>length: <span class="number">0</span>,
</pre></td></tr></table></figure>


<h4 id="toArray">toArray</h4>
<p>类数组对象转真正数组的方法，内部和我们将arguments或NodeList等于一样，使用slice实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>toArray: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> slice.call( <span class="keyword">this</span> );
},
</pre></td></tr></table></figure>


<h4 id="get_(num)">get (num)</h4>
<p>从jq对象中获取下标为num的元素，如果num为负数，则获取倒数第num个，也就是下表为<code>length + num</code>的元素。如果num不存在，将这个jq对象转换成真数组并返回（同样使用的slice方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>get: <span class="function"><span class="keyword">function</span><span class="params">( num )</span> {</span>
    <span class="keyword">return</span> num != <span class="literal">null</span> ?

        <span class="comment">// Return a 'clean' array</span>
        ( num &lt; <span class="number">0</span> ? <span class="keyword">this</span>[ num + <span class="keyword">this</span>.length ] : <span class="keyword">this</span>[ num ] ) :

        <span class="comment">// Return just the object</span>
        slice.call( <span class="keyword">this</span> );
},
</pre></td></tr></table></figure>


<h4 id="pushStack_(elems)">pushStack (elems)</h4>
<p>这是一个很重要的方法，后面很多地方会用到</p>
<p>这个方法实际上是创建一个新的jq对象，其结果集为elems中的dom节点，将现有的jq对象放在新创建对象的prevObject中，这样就能在新jq对象中查找到现有的jq对象了，设定一下context后返回新对象的引用</p>
<p>这种链式创建jq对象的方式可以理解为jq对象的一个链表(栈)，而我们永远拥有表头指针，使用end方法时，表头指针所指向的jq对象就会移除出链表。这也是jQuery那样链式操作的关键所在</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>pushStack: <span class="function"><span class="keyword">function</span><span class="params">( elems )</span> {</span>

    <span class="comment">/*创建一个新jq对象用来保存结果集*/</span>
    <span class="keyword">var</span> ret = jQuery.merge( <span class="keyword">this</span>.constructor(), elems );

    <span class="comment">/*将之前的jq对象压栈*/</span>
    ret.prevObject = <span class="keyword">this</span>;
    <span class="comment">/*context相同*/</span>
    ret.context = <span class="keyword">this</span>.context;

    <span class="comment">/*返回新创建的jq对象的引用*/</span>
    <span class="keyword">return</span> ret;
},
</pre></td></tr></table></figure>


<h4 id="each_(callback,_args)">each (callback, args)</h4>
<p>这个方法相信使用过jq的人都很熟悉了，对当前jq对象中的每个元素调用callback方法，并可选的为callback传入args参数。内部有一个很强大的兼容各种参数的each方法，后续会有介绍，这里直接使用它了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>each: <span class="function"><span class="keyword">function</span><span class="params">( callback, args )</span> {</span>
    <span class="keyword">return</span> jQuery.each( <span class="keyword">this</span>, callback, args );
},
</pre></td></tr></table></figure>


<h4 id="map_(callback)">map (callback)</h4>
<p>这个方法和上面类似，不过是map方法，所以会生成一组结果，这一组结果会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>
<h4 id="slice">slice</h4>
<p>其实内部就是直接调用了<code>[].slice</code>切分jq对象获得dom节点数组，不同的是，这个获得的dom节点数组会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>map: <span class="function"><span class="keyword">function</span><span class="params">( callback )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.pushStack( jQuery.map(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span><span class="params">( elem, i )</span> {</span>
        <span class="keyword">return</span> callback.call( elem, i, elem );
    }));
},
</pre></td></tr></table></figure>


<h4 id="first和last">first和last</h4>
<p>这俩比较简单，获取jq对象的dom节点集中的第一个和最后一个，均使用eq方法实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>first: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.eq( <span class="number">0</span> );
},

last: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.eq( -<span class="number">1</span> );
},
</pre></td></tr></table></figure>


<h4 id="eq_(i)">eq (i)</h4>
<p>获取jq对象dom节点集的第i个元素，需要注意的是处理正数和负数的情况，正数为第i个，负数为倒数第i个，也就是第<code>length+i</code>个</p>
<p>这个方法也会将生成的结果用pushStack方法在jq链上创建新的jq对象来包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>eq: <span class="function"><span class="keyword">function</span><span class="params">( i )</span> {</span>
    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,
        j = +i + ( i &lt; <span class="number">0</span> ? len : <span class="number">0</span> );
    <span class="keyword">return</span> <span class="keyword">this</span>.pushStack( j &gt;= <span class="number">0</span> && j &lt; len ? [ <span class="keyword">this</span>[j] ] : [] );
},
</pre></td></tr></table></figure>


<h4 id="end">end</h4>
<p>操作jq链，获得之前的jq对象。这里有个判定，如果之前没有对象了，新建一个空的jq对象并返回。把jq链看做一个栈的话，实际上就是弾栈操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>end: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.prevObject || <span class="keyword">this</span>.constructor(<span class="literal">null</span>);
},
</pre></td></tr></table></figure>


<h4 id="push、sort、splice">push、sort、splice</h4>
<p>这些方法仅作内部使用，直接使用数组的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>push: push,
sort: arr.sort,
splice: arr.splice
</pre></td></tr></table></figure>


<h2 id="对象扩展方法jQuery-extend">对象扩展方法jQuery.extend</h2>
<p>编写jq插件的开发者肯定不会对这个方法陌生</p>
<p>jq使用这个方法实现的混入模式，思想还是将遍历一个对象中的所有值，复制到一个已有的对象中</p>
<p>另外jq这个函数实现了深拷贝，其实也就是递归调用extend方法，这里用了很多的jQuery自己实现的类型判断</p>
<p>深拷贝需要注意数组和原生对象的情况，他们创建的容器是不相同的（<code>[]</code>和<code>{}</code>）</p>
<p>另外它使用了一个options来进行缓存，防止出现循环引用导致的无限递归情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre>jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,
        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || {},
        i = <span class="number">1</span>,
        length = <span class="built_in">arguments</span>.length,
        deep = <span class="literal">false</span>;

    <span class="comment">/*做接口的重载*/</span>
    <span class="comment">// Handle a deep copy situation</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">"boolean"</span> ) {
        deep = target;

        <span class="comment">// skip the boolean and the target</span>
        target = <span class="built_in">arguments</span>[ i ] || {};
        i++;
    }

    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">"object"</span> && !jQuery.isFunction(target) ) {
        target = {};
    }

    <span class="comment">// extend jQuery itself if only one argument is passed</span>
    <span class="keyword">if</span> ( i === length ) {
        target = <span class="keyword">this</span>;
        i--;
    }

    <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
        <span class="comment">// Only deal with non-null/undefined values</span>
        <span class="keyword">if</span> ( (options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span> ) {
            <span class="comment">// Extend the base object</span>
            <span class="keyword">for</span> ( name <span class="keyword">in</span> options ) {
                src = target[ name ];
                copy = options[ name ];

                <span class="comment">// Prevent never-ending loop</span>
                <span class="comment">/*看copy中是否已经存在需要复制的对象，防止死循环*/</span>
                <span class="keyword">if</span> ( target === copy ) {
                    <span class="keyword">continue</span>;
                }
                <span class="comment">/*如果深拷贝，将递归复制*/</span>
                <span class="comment">// Recurse if we're merging plain objects or arrays</span>
                <span class="keyword">if</span> ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    <span class="comment">/*数组和对象分开判断，容器不一样*/</span>
                    <span class="keyword">if</span> ( copyIsArray ) {
                        copyIsArray = <span class="literal">false</span>;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } <span class="keyword">else</span> {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    <span class="comment">// Never move original objects, clone them</span>
                    <span class="comment">/*递归拷贝*/</span>
                    target[ name ] = jQuery.extend( deep, clone, copy );

                <span class="comment">// Don't bring in undefined values</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    <span class="comment">// Return the modified object</span>
    <span class="keyword">return</span> target;
};
</pre></td></tr></table></figure>


<h2 id="在jQuery上扩展的一些内部方法和静态方法">在jQuery上扩展的一些内部方法和静态方法</h2>
<p>有了<code>jQuery.extend</code>，我们就可以使用它在jQuery对象上申明一些静态方法或属性了，基本上每个模块都会通过这种方式申明一些内部方法和静态方法</p>
<h4 id="expando">expando</h4>
<p>用于随机生成一个jq的版本号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>expando: <span class="string">"jQuery"</span> + ( version + <span class="built_in">Math</span>.random() ).replace( <span class="regexp">/\D/g</span>, <span class="string">""</span> ),
</pre></td></tr></table></figure>


<h4 id="isReady">isReady</h4>
<p>假设jQuery已经准备好了，当然我们有一个$().ready方法，判断dom是否加载完成，这些后面promise那块会说</p>
<h4 id="error">error</h4>
<p>没啥好说的，甩个异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>error: <span class="function"><span class="keyword">function</span><span class="params">( msg )</span> {</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( msg );
},
</pre></td></tr></table></figure>


<h4 id="noop">noop</h4>
<p>一个空函数，不知道干啥用的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>noop: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>},
</pre></td></tr></table></figure>


<h4 id="isFunction_(obj)">isFunction (obj)</h4>
<p>判断参数是否是函数，使用了jQuery.type进行判断，内部实际上用的是<code>typeof obj === &#39;function&#39;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>isFunction: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;
},
</pre></td></tr></table></figure>


<h4 id="isArray_(obj)">isArray (obj)</h4>
<p>判断参数是否是数组，由于是2.1.0版本，不兼容ie6-7，所以直接使用了<code>Array.isArray</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>isArray: <span class="built_in">Array</span>.isArray,
</pre></td></tr></table></figure>


<h4 id="isWindow_(obj)">isWindow (obj)</h4>
<p>判断是否是window对象，这个使用window对象的<code>window.window === window</code>进行判断，但司徒正美说这种方式还是有缺陷的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>isWindow: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="keyword">return</span> obj != <span class="literal">null</span> && obj === obj.window;
},
</pre></td></tr></table></figure>


<h4 id="isNumberic_(obj)">isNumberic (obj)</h4>
<p>这个是判断参数能否转换为数字，先通过parseFloat对参数进行转换，然后判断，很巧妙</p>
<p>这里用到了parseFloat返回NaN、任何数与NaN计算都是NaN、NaN和0比返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>isNumeric: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="comment">// parseFloat NaNs numeric-cast false positives (null|true|false|"")</span>
    <span class="comment">// ...but misinterprets leading-number strings, particularly hex literals ("0x...")</span>
    <span class="comment">// subtraction forces infinities to NaN</span>
    <span class="keyword">return</span> obj - <span class="built_in">parseFloat</span>( obj ) &gt;= <span class="number">0</span>;
},
</pre></td></tr></table></figure>


<h4 id="isPlainObject_(obj)">isPlainObject (obj)</h4>
<p>判断是否是原生对象。如果不是对象，或者是DOM对象，或者是window直接排除。看它原型上是否有isPrototypeOf方法，如果有，则是原生对象，否则不是。需要注意一点的是，在ff20-时查看constructor会报错，所以用了try catch包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>isPlainObject: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="comment">// Not plain objects:</span>
    <span class="comment">// - Any object or value whose internal [[Class]] property is not "[object Object]"</span>
    <span class="comment">// - DOM nodes</span>
    <span class="comment">// - window</span>
    <span class="keyword">if</span> ( jQuery.type( obj ) !== <span class="string">"object"</span> || obj.nodeType || jQuery.isWindow( obj ) ) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// Support: Firefox &lt;20</span>
    <span class="comment">// The try/catch suppresses exceptions thrown when attempting to access</span>
    <span class="comment">// the "constructor" property of certain host objects, ie. |window.location|</span>
    <span class="comment">// https://bugzilla.mozilla.org/show_bug.cgi?id=814622</span>
    <span class="keyword">try</span> {
        <span class="keyword">if</span> ( obj.constructor &&
                !hasOwn.call( obj.constructor.prototype, <span class="string">"isPrototypeOf"</span> ) ) {
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
    } <span class="keyword">catch</span> ( e ) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="comment">// If the function hasn't returned already, we're confident that</span>
    <span class="comment">// |obj| is a plain object, created by {} or constructed with new Object</span>
    <span class="keyword">return</span> <span class="literal">true</span>;
},
</pre></td></tr></table></figure>


<h4 id="isEmptyObject_(obj)">isEmptyObject (obj)</h4>
<p>是否是空对象，判断方法是遍历这个对象，只要有能遍历到的键值对，返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>isEmptyObject: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="keyword">var</span> name;
    <span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
},
</pre></td></tr></table></figure>


<h4 id="type_(obj)">type (obj)</h4>
<p>确定元素类型的方法，这个方法使用了class2type中存储的累心结果进行判断</p>
<p>首先判断<code>obj==null</code>，obj如果是undefined和null，都会在这里被拦截，直接转成字符串返回就可以了</p>
<p>然后判断如果obj是对象，那就需要通过class2type来判断了，class2type中汇总了一些常用的对象映射。如果class2type中没有找到，返回object。如果是函数，直接返回函数就行了</p>
<p>后面会有如何创建这个class2type缓存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>type: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> {</span>
    <span class="keyword">if</span> ( obj == <span class="literal">null</span> ) {
        <span class="keyword">return</span> obj + <span class="string">""</span>;
    }
    <span class="comment">// Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)</span>
    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?
        class2type[ toString.call(obj) ] || <span class="string">"object"</span> :
        <span class="keyword">typeof</span> obj;
},
</pre></td></tr></table></figure>


<h4 id="globalEval_(code)">globalEval (code)</h4>
<p>执行code中的代码，首先通过indexOf查找代码中是否有<code>use strict</code>，如果有，那么使用在document中创建script节点的方法执行代码，否则直接用js本身的eval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>globalEval: <span class="function"><span class="keyword">function</span><span class="params">( code )</span> {</span>
    <span class="keyword">var</span> script,
        indirect = <span class="built_in">eval</span>;

    code = jQuery.trim( code );

    <span class="keyword">if</span> ( code ) {
        <span class="comment">// If the code includes a valid, prologue position</span>
        <span class="comment">// strict mode pragma, execute code by injecting a</span>
        <span class="comment">// script tag into the document.</span>
        <span class="keyword">if</span> ( code.indexOf(<span class="string">"use strict"</span>) === <span class="number">1</span> ) {
            script = document.createElement(<span class="string">"script"</span>);
            script.text = code;
            document.head.appendChild( script ).parentNode.removeChild( script );
        } <span class="keyword">else</span> {
        <span class="comment">// Otherwise, avoid the DOM node creation, insertion</span>
        <span class="comment">// and removal by using an indirect global eval</span>
            indirect( code );
        }
    }
},
</pre></td></tr></table></figure>


<h4 id="camelCase">camelCase</h4>
<p>将一个带连字符的字符串转驼峰形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>camelCase: <span class="function"><span class="keyword">function</span><span class="params">( string )</span> {</span>
    <span class="keyword">return</span> string.replace( rmsPrefix, <span class="string">"ms-"</span> ).replace( rdashAlpha, fcamelCase );
},
</pre></td></tr></table></figure>


<h4 id="nodeName">nodeName</h4>
<p>判断一个元素的标签名是否和传入的参数匹配，如果没有传入参数，返回元素的标签名…直接用元素的nodeName属性获得标签名，比较时注意一下全转成小写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>nodeName: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
    <span class="keyword">return</span> elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
},
</pre></td></tr></table></figure>


<h4 id="each">each</h4>
<p>来了，用于遍历的each方法，其有一个有参数的情况</p>
<p>在遍历时需要判断对象是类数组（注意是类数组）还是对象，类数组的话直接使用for循环，而对象使用for in。剩下就是在有无参数时候的不同调用方法了，有参数使用apply传入相应参数，如果没有使用call，传入下标和具体的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>each: <span class="function"><span class="keyword">function</span><span class="params">( obj, callback, args )</span> {</span>
    <span class="keyword">var</span> value,
        i = <span class="number">0</span>,
        length = obj.length,
        isArray = isArraylike( obj );
    <span class="comment">/*有参数的情况下*/</span>
    <span class="keyword">if</span> ( args ) {
        <span class="comment">/*数组或类数组对象*/</span>
        <span class="keyword">if</span> ( isArray ) {
            <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
                value = callback.apply( obj[ i ], args );

                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {
                    <span class="keyword">break</span>;
                }
            }
        <span class="comment">/*普通对象*/</span>
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) {
                value = callback.apply( obj[ i ], args );

                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {
                    <span class="keyword">break</span>;
                }
            }
        }
    <span class="comment">/*无参数的情况下，把当前元素和下标（键）当做参数传递*/</span>
    <span class="comment">// A special, fast, case for the most common use of each</span>
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> ( isArray ) {
            <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
                value = callback.call( obj[ i ], i, obj[ i ] );

                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {
                    <span class="keyword">break</span>;
                }
            }
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) {
                value = callback.call( obj[ i ], i, obj[ i ] );

                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {
                    <span class="keyword">break</span>;
                }
            }
        }
    }

    <span class="keyword">return</span> obj;
},
</pre></td></tr></table></figure>


<h4 id="trim">trim</h4>
<p>去掉字符串的首尾空白，由于不兼容老版本IE，直接用字符串的trim了，没有用正则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>trim: <span class="function"><span class="keyword">function</span><span class="params">( text )</span> {</span>
    <span class="keyword">return</span> text == <span class="literal">null</span> ? <span class="string">""</span> : trim.call( text );
},
</pre></td></tr></table></figure>


<h4 id="makeArray">makeArray</h4>
<p>讲一个类数组转化为数组，如果是数组直接push，如果不是真数组，使用merge，后面会介绍merge方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>makeArray: <span class="function"><span class="keyword">function</span><span class="params">( arr, results )</span> {</span>
    <span class="keyword">var</span> ret = results || [];

    <span class="keyword">if</span> ( arr != <span class="literal">null</span> ) {
        <span class="keyword">if</span> ( isArraylike( <span class="built_in">Object</span>(arr) ) ) {
            jQuery.merge( ret,
                <span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?
                [ arr ] : arr
            );
        } <span class="keyword">else</span> {
            push.call( ret, arr );
        }
    }

    <span class="keyword">return</span> ret;
},
</pre></td></tr></table></figure>


<h4 id="inArray">inArray</h4>
<p>使用indexOf判断元素是否在数组内部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>inArray: <span class="function"><span class="keyword">function</span><span class="params">( elem, arr, i )</span> {</span>
    <span class="keyword">return</span> arr == <span class="literal">null</span> ? -<span class="number">1</span> : indexOf.call( arr, elem, i );
},
</pre></td></tr></table></figure>


<h4 id="merge">merge</h4>
<p>通过遍历的方式将两个类数组合并</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>merge: <span class="function"><span class="keyword">function</span><span class="params">( first, second )</span> {</span>
    <span class="keyword">var</span> len = +second.length,
        j = <span class="number">0</span>,
        i = first.length;

    <span class="keyword">for</span> ( ; j &lt; len; j++ ) {
        first[ i++ ] = second[ j ];
    }

    first.length = i;

    <span class="keyword">return</span> first;
},
</pre></td></tr></table></figure>


<h4 id="grep_(elems,_callback,_invert)">grep (elems, callback, invert)</h4>
<p>将元素丢到callback中判断是否符合条件，返回所有符合条件的元素。invert为true时，返回所有不符合条件的元素</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>grep: <span class="function"><span class="keyword">function</span><span class="params">( elems, callback, invert )</span> {</span>
    var callbackInverse,
        matches = <span class="matrix">[]</span>,
        i = <span class="number">0</span>,
        <span class="built_in">length</span> = <span class="transposed_variable">elems.</span><span class="built_in">length</span>,
        callbackExpect = !invert;

    <span class="comment">// Go through the array, only saving the items</span>
    <span class="comment">// that pass the validator function</span>
    <span class="keyword">for</span> ( ; i &lt; <span class="built_in">length</span>; i++ ) {
        callbackInverse = !callback( elems<span class="matrix">[ i ]</span>, i );
        <span class="keyword">if</span> ( callbackInverse !== callbackExpect ) {
            <span class="transposed_variable">matches.</span>push( elems<span class="matrix">[ i ]</span> );
        }
    }

    <span class="keyword">return</span> matches;
},
</pre></td></tr></table></figure>


<h4 id="map_(elems,_callback,_arg)">map (elems, callback, arg)</h4>
<p>jq自己实现的map操作，由于jq自身是个类数组，于是乎模拟数组实现了一系列操作，map就是其中一个</p>
<p>对数组、类数组、对象进行遍历map操作，结果放在一个数组中并返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>map: <span class="function"><span class="keyword">function</span><span class="params">( elems, callback, arg )</span> {</span>
    <span class="keyword">var</span> value,
        i = <span class="number">0</span>,
        length = elems.length,
        isArray = isArraylike( elems ),
        ret = [];

    <span class="comment">// Go through the array, translating each of the items to their new values</span>
    <span class="comment">/*数组或类数组*/</span>
    <span class="keyword">if</span> ( isArray ) {
        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {
            value = callback( elems[ i ], i, arg );

            <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {
                ret.push( value );
            }
        }

    <span class="comment">// Go through every key on the object,</span>
    <span class="comment">/*对象*/</span>
    } <span class="keyword">else</span> {
        <span class="keyword">for</span> ( i <span class="keyword">in</span> elems ) {
            value = callback( elems[ i ], i, arg );

            <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {
                ret.push( value );
            }
        }
    }

    <span class="comment">// Flatten any nested arrays</span>
    <span class="keyword">return</span> concat.apply( [], ret );
},
</pre></td></tr></table></figure>


<h4 id="guid">guid</h4>
<p>一个全局的guid，用于生成独立id，每次被使用后自增</p>
<h4 id="proxy">proxy</h4>
<p>使用闭包的方式将对象绑定到函数的作用域链顶端，curry化的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>proxy: <span class="function"><span class="keyword">function</span><span class="params">( fn, context )</span> {</span>
    <span class="keyword">var</span> tmp, args, proxy;

    <span class="keyword">if</span> ( <span class="keyword">typeof</span> context === <span class="string">"string"</span> ) {
        tmp = fn[ context ];
        context = fn;
        fn = tmp;
    }

    <span class="comment">// Quick check to determine if target is callable, in the spec</span>
    <span class="comment">// this throws a TypeError, but we will just return undefined.</span>
    <span class="comment">/*必须是函数*/</span>
    <span class="keyword">if</span> ( !jQuery.isFunction( fn ) ) {
        <span class="keyword">return</span> <span class="literal">undefined</span>;
    }

    <span class="comment">// Simulated bind</span>
    <span class="comment">/*提取出参数*/</span>
    args = slice.call( <span class="built_in">arguments</span>, <span class="number">2</span> );
    <span class="comment">/*创建闭包，这个闭包使用了当前作用域的这些对象*/</span>
    proxy = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> fn.apply( context || <span class="keyword">this</span>, args.concat( slice.call( <span class="built_in">arguments</span> ) ) );
    };

    <span class="comment">// Set the guid of unique handler to the same of original handler, so it can be removed</span>
    <span class="comment">/*给代理增加一个自增的guid*/</span>
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    <span class="comment">/*返回代理*/</span>
    <span class="keyword">return</span> proxy;
},
</pre></td></tr></table></figure>


<h4 id="其他">其他</h4>
<p>没啥好说的，看名字就知道了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>now: <span class="built_in">Date</span>.now,

support: support
</pre></td></tr></table></figure>


<h2 id="类型判断">类型判断</h2>
<h4 id="生成class2type">生成class2type</h4>
<p>首先是生成class2type，使用了比较巧妙的方法，对一个字符串进行切分，然后使用<code>jQuery.each</code>方法来建立class2type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span><span class="params">(i, name)</span> {</span>
    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();
});
</pre></td></tr></table></figure>


<h4 id="判断类数组">判断类数组</h4>
<p>判断是否是类数组对象，主要是根据是否含有大于等于0的length属性判断，含有length属性也可能是function，表明参数个数，也可能是window，需要排除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">isArraylike</span><span class="params">( obj )</span> {</span>
    <span class="keyword">var</span> length = obj.length,
        type = jQuery.type( obj );

    <span class="keyword">if</span> ( type === <span class="string">"function"</span> || jQuery.isWindow( obj ) ) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">if</span> ( obj.nodeType === <span class="number">1</span> && length ) {
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> type === <span class="string">"array"</span> || length === <span class="number">0</span> ||
        <span class="keyword">typeof</span> length === <span class="string">"number"</span> && length &gt; <span class="number">0</span> && ( length - <span class="number">1</span> ) <span class="keyword">in</span> obj;
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>这一部分主要是申明了extend方法和一些在jq对象上的核心函数，以及相当多的类型判断相关</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天闭关读源码，jQuery读了一半了，sizzle，基础方法，promise等等都详细的看了一下，由于东西比较多，先记录第一部分，jQuery的一些核心方法以及jQuery中的类型判断，读的是jQuery-2.1.0</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google的HTML/CSS样式指南]]></title>
    <link href="http://lingyu.wang/2014/05/04/google-style-guide/"/>
    <id>http://lingyu.wang/2014/05/04/google-style-guide/</id>
    <published>2014-05-03T16:00:00.000Z</published>
    <updated>2014-09-25T15:03:52.172Z</updated>
    <content type="html"><![CDATA[<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>
<a id="more"></a>

<h2 id="通用样式规范">通用样式规范</h2>
<h3 id="使用相对协议">使用相对协议</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="HTML文件中一个tab两个空格">HTML文件中一个tab两个空格</h3>
<p>老调重弹，不要混合使用tab和空格</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Fantastic
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Great
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

.example {
  color: blue;
}
</pre></td></tr></table></figure>


<h3 id="仅使用小写">仅使用小写</h3>
<p>所有代码应该使用小写，比如HTML元素的名称、属性、属性值（除了text/CDATA）。CSS的选择器、属性、属性值等等</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">A</span> <span class="attribute">HREF</span>=<span class="value">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">A</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"google.png"</span> <span class="attribute">alt</span>=<span class="value">"Google"</span>&gt;</span>
</pre></td></tr></table></figure>




<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>&lt;!<span class="tag">--</span> 不推荐使用 <span class="tag">--</span>&gt;
<span class="tag">color</span>: <span class="id">#E5E5E5</span>;

&lt;!<span class="tag">--</span> 推荐使用 <span class="tag">--</span>&gt;
<span class="tag">color</span>: <span class="id">#e5e5e5</span>;
</pre></td></tr></table></figure>


<h3 id="不要有后缀的空格">不要有后缀的空格</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>What?_

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>Yes please.
</pre></td></tr></table></figure>


<h3 id="使用UTF-8编码">使用UTF-8编码</h3>
<p>保证编辑器的编码字符集为UTF-8，同时在文档中添加<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p>
<h3 id="在必要的时候，在合适的地方添加注释">在必要的时候，在合适的地方添加注释</h3>
<p>用注释来表明元素的范围以及它的用途</p>
<h3 id="仅使用TODO来添加todo任务">仅使用TODO来添加todo任务</h3>
<h2 id="HTML样式规范">HTML样式规范</h2>
<h3 id="使用HTML5文档类型">使用HTML5文档类型</h3>
<p>使用<code>&lt;!DOCTYPE html&gt;</code>来声明文档类型，建议使用<code>text/html</code>来定义HTML文件的MIME类型，不要使用<code>application/xhtml+xml</code>来定义。在编写HTML时，空元素可以不必闭合，如<code>&lt;br&gt;</code>不必写成<code>&lt;br/&gt;</code></p>
<h3 id="使用HTML验证器进行验证">使用HTML验证器进行验证</h3>
<p>尽量使用HTML验证器验证过的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">article</span>&gt;</span>This is only a test.

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">article</span>&gt;</span>This is only a test.<span class="tag">&lt;/<span class="title">article</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="根据用途使用元素">根据用途使用元素</h3>
<p>使用元素时应当根据元素的作用来选择适当的标签，<code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>用来表示头，<code>&lt;p&gt;</code>元素表示段落，<code>&lt;a&gt;</code>元素表示超链接等等。根据用途使用元素对可访问性，重用和代码效率等有很重要的帮助</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">onclick</span>=<span class="value">"goToRecommendations();"</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="title">div</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"recommendations/"</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="对于多媒体元素，提供替换文本（alt）">对于多媒体元素，提供替换文本（alt）</h3>
<p>对于多媒体元素，像图片，视频，动画对象如canvas等等，应该为其提供有意义的替换文本（alt），同时尽可能为视频和音频提供副本（不同格式）和字幕</p>
<p>这同样关乎到可访问性，当盲人用户需要通过image等获得信息时，可以转而通过alt中的文字来获得信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"spreadsheet.png"</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"spreadsheet.png"</span> <span class="attribute">alt</span>=<span class="value">"Spreadsheet screenshot."</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="将结构、表现、行为三者分离">将结构、表现、行为三者分离</h3>
<p>严格将结构（标记），表现（样式）和行为（脚本）进行分离解耦，使他们之间相互独立</p>
<p>具体做法就是将HTML文档和模板中仅包含HTML，样式妨碍CSS中，而行为相关代码放在脚本中</p>
<p>这样更易于网页的维护和重用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"base.css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"grid.css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span>
<span class="tag">&lt;<span class="title">h1</span> <span class="attribute">style</span>=<span class="value">"font-size: 1em;"</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>I’ve read about this on a few sites but now I’m sure:
  <span class="tag">&lt;<span class="title">u</span>&gt;</span>HTML is stupid!!1<span class="tag">&lt;/<span class="title">u</span>&gt;</span>
<span class="tag">&lt;<span class="title">center</span>&gt;</span>I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!<span class="tag">&lt;/<span class="title">center</span>&gt;</span>
  
<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"default.css"</span>&gt;</span>
<span class="tag">&lt;<span class="title">h1</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
<span class="tag">&lt;<span class="title">p</span>&gt;</span>It’s awesome!
</pre></td></tr></table></figure>


<h3 id="避免引用实体">避免引用实体</h3>
<p>可以直接使用UTF-8等字符集中的字符替代实体，除了一些在HTML中有特殊意义的字符（如<code>&lt;</code>和<code>&amp;</code>）需要使用实体代替以外，尽量不要使用实体</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
The currency symbol for the Euro is &ldquo;&eur;&rdquo;.

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
The currency symbol for the Euro is “€”.
</pre></td></tr></table></figure>


<h3 id="省略可选标签">省略可选标签</h3>
<p>出于降低文档大小和代码可读性考虑，可以将可选标签省略。HTML5定义了一套<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-omission" target="_blank">可选标签规范</a>，标明哪些元素时可选的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
  <span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Spending money, spending bytes<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Sic.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">title</span>&gt;</span>Saving money, saving bytes<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>Qed.
</pre></td></tr></table></figure>


<h3 id="省略样式表和脚本的type属性">省略样式表和脚本的type属性</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"//www.google.com/css/maia.css"</span>
  <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span>
  <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"//www.google.com/css/maia.css"</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="块级元素占用一行且合理缩进">块级元素占用一行且合理缩进</h3>
<p>每个块级元素，列表项、表格元素单独占用一行，并为每个子元素提供适当的缩进（两个空格）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">blockquote</span>&gt;</span>
  <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">em</span>&gt;</span>Space<span class="tag">&lt;/<span class="title">em</span>&gt;</span>, the final frontier.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;/<span class="title">blockquote</span>&gt;</span>
<span class="tag">&lt;<span class="title">ul</span>&gt;</span>
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Moe
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Larry
  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Curly
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">table</span>&gt;</span>
  <span class="tag">&lt;<span class="title">thead</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">th</span> <span class="attribute">scope</span>=<span class="value">"col"</span>&gt;</span>Income
      <span class="tag">&lt;<span class="title">th</span> <span class="attribute">scope</span>=<span class="value">"col"</span>&gt;</span>Taxes
  <span class="tag">&lt;<span class="title">tbody</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
      <span class="tag">&lt;<span class="title">td</span>&gt;</span>$ 5.00
      <span class="tag">&lt;<span class="title">td</span>&gt;</span>$ 4.50
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>
</pre></td></tr></table></figure>


<h3 id="属性值使用双引号包裹">属性值使用双引号包裹</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">&lt;!-- 不推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">'maia-button maia-button-secondary'</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="title">a</span>&gt;</span>

<span class="comment">&lt;!-- 推荐使用 --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"maia-button maia-button-secondary"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</pre></td></tr></table></figure>


<h2 id="CSS样式规范">CSS样式规范</h2>
<h3 id="使用验证过的CSS代码">使用验证过的CSS代码</h3>
<p>除非CSS验证器有bug或需要专有语法，否则使用验证过的CSS代码</p>
<h3 id="使用有意义的ID和类命名">使用有意义的ID和类命名</h3>
<p>命名应当反映出元素的用途。详细命名规则可以看<a href="http://nec.netease.com/standard/css-name.html" target="_blank">NEC的CSS命名规则</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="id">#yee-1901</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.button-green</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.clear</span> <span class="rules">{<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="id">#gallery</span> <span class="rules">{<span class="rule">}</span></span>
<span class="id">#login</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.video</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.aux</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.alt</span> <span class="rules">{<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="使用简短但不失描述性的ID和类命名">使用简短但不失描述性的ID和类命名</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="id">#navigation</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.atr</span> <span class="rules">{<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="id">#nav</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.author</span> <span class="rules">{<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="避免在元素选择器之后使用使用ID和类选择器">避免在元素选择器之后使用使用ID和类选择器</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="tag">ul</span><span class="id">#example</span> <span class="rules">{<span class="rule">}</span></span>
<span class="tag">div</span><span class="class">.error</span> <span class="rules">{<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="id">#example</span> <span class="rules">{<span class="rule">}</span></span>
<span class="class">.error</span> <span class="rules">{<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="尽可能对属性进行合并">尽可能对属性进行合并</h3>
<p>很多属性（padding、margin、background、font、border等等）都是可以合并的，尽可能合并他们</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>/* 不推荐使用 */
border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;

/* 推荐使用 */
border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
</pre></td></tr></table></figure>


<h3 id="属性值为0时不要携带单位">属性值为0时不要携带单位</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="tag">margin</span>: 0;
<span class="tag">padding</span>: 0;
</pre></td></tr></table></figure>


<h3 id="小数的整数部分为0时，省略整数部分">小数的整数部分为0时，省略整数部分</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="tag">font-size</span>: <span class="class">.8em</span>;
</pre></td></tr></table></figure>


<h3 id="颜色为16进制表示时进行缩写">颜色为16进制表示时进行缩写</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="tag">color</span>: <span class="id">#eebbcc</span>;

<span class="comment">/* 推荐使用 */</span>
<span class="tag">color</span>: <span class="id">#ebc</span>;
</pre></td></tr></table></figure>


<h3 id="ID和类命名添加前缀表示命名空间">ID和类命名添加前缀表示命名空间</h3>
<p>同NEC的命名方式，或者通过模块名来定义前缀</p>
<h2 id="CSS格式规范">CSS格式规范</h2>
<h3 id="CSS属性申明顺序">CSS属性申明顺序</h3>
<p>可以按照字典序进行排序，方便查找，但同一属性的不同实现声明在一起，且按照私有实现在前，W3C标准在后的顺序排列</p>
<p>ps：属性顺序排列有另一种说法是：定位相关（position、float、display、top、left、right、bottom、z-index等）在前，随后是盒子模型相关（width、height、padding、margin、border等等），随后是背景相关（background，background-image等等），然后是文字相关（colr，line-height、font等等），然后是一些其他属性（border-radius，opacity等等），最后是动画属性（transition、animation等）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">background</span>: <span class="tag">fuchsia</span>;
<span class="tag">border</span>: 1<span class="tag">px</span> <span class="tag">solid</span>;
<span class="tag">-moz-border-radius</span>: 4<span class="tag">px</span>;
<span class="tag">-webkit-border-radius</span>: 4<span class="tag">px</span>;
<span class="tag">border-radius</span>: 4<span class="tag">px</span>;
<span class="tag">color</span>: <span class="tag">black</span>;
<span class="tag">text-align</span>: <span class="tag">center</span>;
<span class="tag">text-indent</span>: 2<span class="tag">em</span>;
</pre></td></tr></table></figure>


<h3 id="代码块缩进">代码块缩进</h3>
<p>所有申明都应该有适当的缩进，就算<code>@media</code>媒体查询也不例外</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="at_rule">@<span class="keyword">media</span> screen, projection </span>{

  <span class="tag">html</span> <span class="rules">{
    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;
    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#444</span></span></span>;
  <span class="rule">}</span></span>

}
</pre></td></tr></table></figure>


<h3 id="所有属性之后都加上分号">所有属性之后都加上分号</h3>
<p>虽然最后一个属性可以不加分号，但建议都加上</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="class">.test</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>px
</span></span></span>}

<span class="comment">/* 推荐使用 */</span>
<span class="class">.test</span> <span class="rules">{
  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;
  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="属性名后加上个空格">属性名后加上个空格</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="tag">h3</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value">bold</span></span>;
<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="tag">h3</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="选择器群组各占一行">选择器群组各占一行</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="tag">a</span><span class="pseudo">:focus</span>, <span class="tag">a</span><span class="pseudo">:active</span> <span class="rules">{
  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">1</span>px</span></span>;
<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="tag">h1</span>,
<span class="tag">h2</span>,
<span class="tag">h3</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> normal</span></span>;
  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1.2</span></span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="在两个不同的声明中添加回车来区分">在两个不同的声明中添加回车来区分</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="tag">html</span> <span class="rules">{
  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;
<span class="rule">}</span></span>

<span class="tag">body</span> <span class="rules">{
  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50</span>%</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="在CSS中省略引号，只在必要时候使用单引号">在CSS中省略引号，只在必要时候使用单引号</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="comment">/* 不推荐使用 */</span>
<span class="at_rule">@<span class="keyword">import</span> <span class="function">url(<span class="string">"//www.google.com/css/maia.css"</span>)</span></span>;

<span class="tag">html</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">"open sans"</span>, arial, sans-serif</span></span>;
<span class="rule">}</span></span>

<span class="comment">/* 推荐使用 */</span>
<span class="at_rule">@<span class="keyword">import</span> <span class="function">url(//www.google.com/css/maia.css)</span></span>;

<span class="tag">html</span> <span class="rules">{
  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'open sans'</span>, arial, sans-serif</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h3 id="通过注释分割代码">通过注释分割代码</h3>
<p>通过注释将代码分割成多个分组，注释之后另起一行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/* Header */</span>

<span class="id">#adw-header</span> <span class="rules">{<span class="rule">}</span></span>

<span class="comment">/* Footer */</span>

<span class="id">#adw-footer</span> <span class="rules">{<span class="rule">}</span></span>

<span class="comment">/* Gallery */</span>

<span class="class">.adw-gallery</span> <span class="rules">{<span class="rule">}</span></span>
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>大致上粗略的看了一遍Google的HTML和CSS规范，概括的细节还是比较多的。从中也能看出Google对文档大小的重视，基本上都是能省则省，能用一个字符绝不用两个。其很多地方还是非常值得参考的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
