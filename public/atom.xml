<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天镶的博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://lingyu.wang/"/>
  <updated>2014-09-22T17:00:53.768Z</updated>
  <id>http://lingyu.wang/</id>
  
  <author>
    <name><![CDATA[天镶]]></name>
    <email><![CDATA[lingyucoder@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[细说Generator]]></title>
    <link href="http://lingyu.wang/2014/07/29/generator/"/>
    <id>http://lingyu.wang/2014/07/29/generator/</id>
    <published>2014-07-28T16:00:00.000Z</published>
    <updated>2014-09-18T14:52:57.000Z</updated>
    <content type="html"><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
<a id="more"></a>

<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis" target="_blank" rel="external">JavaScript一些基础知识简介</a></p>
<h1 id="Generator函数">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>
<ol>
<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
<li>创建一个generator对象，其有如下值：<ul>
<li>Scope：新建的作用域链</li>
<li>Code：generator function内部的代码</li>
<li>ExecutionContext：EC，目前值为null</li>
<li>State：”newborn”</li>
<li>Handler：默认的generator的处理器</li>
</ul>
</li>
</ol>
<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>
<h1 id="yield的行为">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
<li>从EC栈弹出当前的EC</li>
<li>返回(normal, 1中的结果值, null)</li>
</ol>
<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>
<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>
<h1 id="return行为">return行为</h1>
<p>当执行到<code>return e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
<li>将这个generator对象的状态修改为closed</li>
<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
<li>throw这个对象</li>
</ol>
<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>
<h1 id="Generator对象的私有属性">Generator对象的私有属性</h1>
<ul>
<li>prototype：Object.prototype</li>
<li>code：generator函数的函数体</li>
<li>ExecutionContext：内部代码运行使用的EC</li>
<li>Scope：作用域链</li>
<li>Handler：标准的generator句柄</li>
<li>State：newborn、executing、suspended、closed</li>
<li>Send：看内部方法部分</li>
<li>Throw：看内部方法部分</li>
<li>Close：看内部方法部分</li>
</ul>
<h1 id="外部接口">外部接口</h1>
<h2 id="next">next</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入一个undefined</li>
<li>返回结果</li>
</ol>
<p>调用私有send方法</p>
<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<p>同样是调用私有send方法，不过传入了参数</p>
<h2 id="throw">throw</h2>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.throw，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.close，不传入任何参数</li>
<li>返回结果</li>
</ol>
<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>
<h2 id="小结">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>
<h1 id="状态定义">状态定义</h1>
<ul>
<li>newborn：Code不为null，EC为null</li>
<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
<li>closed：Code为null，EC为null</li>
</ul>
<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>
<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>
<p>当然也可以通过close方法，手动修改状态为closed</p>
<h1 id="内部方法">内部方法</h1>
<h2 id="send方法">send方法</h2>
<ol>
<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
<li>如果state为newborn<ol>
<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
<li>将这个EC压入EC栈中</li>
<li>执行generator中的代码，并返回或得到的结果</li>
</ol>
</li>
<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>
<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>
<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>
<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>
<h2 id="throw-1">throw</h2>
<ol>
<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>
<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>
<h2 id="close-1">close</h2>
<ol>
<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
<li>如果state已经是closed了，那直接return就好</li>
<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>
<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>
<h2 id="Resume(EC,_completionType,_V)">Resume(EC, completionType, V)</h2>
<ol>
<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
<li>从EC通过currentGenerator获取单签generator对象</li>
<li>设置当前作用域链为当前generator对象的作用域链</li>
<li>继续执行代码，并根据completionType做相应的处理</li>
</ol>
<h1 id="NodeJs上的不同">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>
<h2 id="资料">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="external">harmony generators ES Wiki</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="Generator" scheme="http://lingyu.wang/tags/Generator/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何写一个KISSY动画插件]]></title>
    <link href="http://lingyu.wang/2014/05/31/kissy-anime-plugin/"/>
    <id>http://lingyu.wang/2014/05/31/kissy-anime-plugin/</id>
    <published>2014-05-30T16:00:00.000Z</published>
    <updated>2014-09-18T14:58:16.000Z</updated>
    <content type="html"><![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank" rel="external">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank" rel="external">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank" rel="external">Github页面</a></p>
<a id="more"></a>

<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/" target="_blank" rel="external">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>
<h2 id="CSS与JavaScript动画对比">CSS与JavaScript动画对比</h2>
<p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>
<h3 id="CSS动画">CSS动画</h3>
<h4 id="animation">animation</h4>
<p>CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：</p>
<ol>
<li>animation-name：动画的名称，也就是定义的keyframes关键帧的名称</li>
<li>animation-duration：一次动画的时长</li>
<li>animation-timing-funciton：缓动函数，这个后面会有详细介绍</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画的播放次数</li>
<li>animation-direction：动画时正向播放还是倒着播放</li>
<li>animation-play-state：动画的状态，暂停还是播放</li>
<li>animation-fill-mode：动画播放时间之外的状态，是否重回动画初始</li>
<li>animation：复合属性，上面属性合在一起的写法</li>
</ol>
<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>
<h4 id="transition">transition</h4>
<p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：</p>
<ol>
<li>transition-property：需要参与过渡的属性</li>
<li>transition-duration 过渡的时长</li>
<li>transition-timing-function：过渡的缓动函数</li>
<li>transition-delay：过渡的延时</li>
</ol>
<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>
<h4 id="优缺点">优缺点</h4>
<p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>
<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>
<p>另外，<a href="http://lingyu.wang/#/item" target="_blank" rel="external">这里</a>有我曾经写过的一些CSS3动画效果</p>
<h3 id="JavaScript动画">JavaScript动画</h3>
<p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：</p>
<ol>
<li>计算当前元素样式</li>
<li>修改元素样式</li>
<li>重绘元素</li>
</ol>
<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>
<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>
<h2 id="需求分析">需求分析</h2>
<h3 id="动画属性">动画属性</h3>
<p>通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：</p>
<ol>
<li>涉及的元素（elems）</li>
<li>需要改变的样式（styles）</li>
<li>时长（duration）</li>
<li>缓动函数（easing-function）</li>
<li>播放次数（times）</li>
</ol>
<h3 id="动画控制">动画控制</h3>
<p>而控制上，我们应该实现的功能：</p>
<ol>
<li>开始（run）</li>
<li>暂停（pause）</li>
<li>暂停恢复（resume）</li>
<li>中止（stop）</li>
<li>倒放（reverse）</li>
<li>单帧（go）</li>
</ol>
<h3 id="动画能够改变的内容">动画能够改变的内容</h3>
<p>需要能够改变的内容有：</p>
<ol>
<li>CSS样式</li>
<li>滚动</li>
</ol>
<h2 id="动画对象">动画对象</h2>
<p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>
<p>所以，动画的对象大致上是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">()</span></span>{}</div><div class="line">Anime.prototype.run = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">Anime.prototype.pause = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">Anime.prototype.resume = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">Anime.prototype.stop = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">Anime.prototype.go = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div></pre></td></tr></table></figure>

<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>
<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span><span class="params">(elems, styles, config)</span></span>{}</div></pre></td></tr></table></figure>

<p>conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> defaultConfig = {</div><div class="line">    callback: noop,</div><div class="line">    duration: <span class="number">1500</span>,</div><div class="line">    reverse: <span class="literal">false</span>,</div><div class="line">    easing: <span class="string">"linear"</span>,</div><div class="line">    times: <span class="number">1</span>,</div><div class="line">    spend: <span class="number">0</span>,</div><div class="line">    state: <span class="string">"running"</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：</p>
<ul>
<li>running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态</li>
<li>paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态</li>
<li>ended为终止状态，可以通过run放法进行重放，转到running状态</li>
</ul>
<h2 id="动画队列">动画队列</h2>
<p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>
<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>
<p>所以，队列首先得实现相关的添加删除操作，注意去重：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> animeQueue = [];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAnime</span><span class="params">(anime)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (S.indexOf(anime, animeQueue) === -<span class="number">1</span>) {</div><div class="line">        animeQueue.push(anime);</div><div class="line">        checkRunning();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteAnime</span><span class="params">(anime)</span> </span>{</div><div class="line">    <span class="keyword">var</span> index = S.indexOf(anime, animeQueue);</div><div class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) {</div><div class="line">        animeQueue.splice(index, <span class="number">1</span>);</div><div class="line">        checkRunning();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pulse</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> deleteIndex = [],</div><div class="line">        i, m, tmp;</div><div class="line">    <span class="keyword">if</span> (running) {</div><div class="line">        S.each(animeQueue, <span class="function"><span class="keyword">function</span><span class="params">(anime, index)</span> </span>{</div><div class="line">            <span class="keyword">if</span> (anime.state === <span class="string">"running"</span>) {</div><div class="line">                anime.go();</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                deleteIndex.push(index);</div><div class="line">            }</div><div class="line">        });</div><div class="line">        <span class="keyword">for</span> (i = deleteIndex.length; i--;) {</div><div class="line">            animeQueue.splice(deleteIndex[i], <span class="number">1</span>);</div><div class="line">        }</div><div class="line">        dealing = <span class="literal">false</span>;</div><div class="line">        checkRunning();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRunning</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> (animeQueue.length &gt; <span class="number">0</span>) {</div><div class="line">        running = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">if</span> (!dealing) {</div><div class="line">            dealing = <span class="literal">true</span>;</div><div class="line">            requestAnimationFrame(pulse);</div><div class="line">        }</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        running = <span class="literal">false</span>;</div><div class="line">        dealing = <span class="literal">false</span>;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="缓动函数">缓动函数</h2>
<p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>
<h2 id="样式处理">样式处理</h2>
<p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：</p>
<ol>
<li>从元素获取样式的起始值（从什么地方开始）</li>
<li>获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）</li>
<li>计算当前时间点的中间值（经过怎样的过程）</li>
<li>向元素赋予计算出来的中间值（经过怎样的过程）</li>
</ol>
<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCSS</span><span class="params">(elem, style)</span> </span>{</div><div class="line">    <span class="keyword">var</span> val;</div><div class="line">    <span class="keyword">if</span> (hooks[style] && hooks[style].get) {</div><div class="line">        val = hooks[style].get(elem, style);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        val = hooks._default.get(elem, style);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> parseCSS(val, style);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSS</span><span class="params">(val, style, from)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (hooks[style] && hooks[style].parse) {</div><div class="line">        <span class="keyword">return</span> hooks[style].parse(val, from);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> hooks._default.parse(val, from);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeCSS</span><span class="params">(style, from, to, pos)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (hooks[style] && hooks[style].compute) {</div><div class="line">        <span class="keyword">return</span> hooks[style].compute(from, to, pos);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> hooks._default.compute(from, to, pos);</div><div class="line"></div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignCSS</span><span class="params">(elem, style, val)</span> </span>{</div><div class="line">    <span class="keyword">if</span> (hooks[style] && hooks[style].assign) {</div><div class="line">        <span class="keyword">return</span> hooks[style].assign(elem, style, val);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> hooks._default.assign(elem, style, val);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>
<h2 id="特殊处理">特殊处理</h2>
<p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例</p>
<h3 id="颜色属性">颜色属性</h3>
<p>如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：</p>
<ol>
<li>HEX：<code>#fff</code>或<code>#f0f0f0</code></li>
<li>RGB：<code>rgb(245, 28, 33)</code></li>
<li>RGBA：<code>rgba(245, 28, 33, .6)</code></li>
<li>直接名称：<code>red</code>、<code>white</code>等等</li>
<li>HSL和HSLA，这里不做实现</li>
</ol>
<h4 id="获取">获取</h4>
<p>获取和一般CSS属性没差， 直接使用默认方式了</p>
<h4 id="解析">解析</h4>
<p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseColor</span><span class="params">(val)</span> </span>{</div><div class="line">    val = val.replace(rClearSpace, <span class="string">""</span>).toLowerCase();</div><div class="line">    <span class="keyword">if</span> (normalColors[val]) {</div><div class="line">        <span class="keyword">return</span> normalColors[val];</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> color = [];</div><div class="line">    <span class="keyword">var</span> tmp;</div><div class="line">    <span class="keyword">var</span> i;</div><div class="line">    <span class="keyword">if</span> (rHexColor.test(val)) {</div><div class="line">        tmp = [];</div><div class="line">        <span class="keyword">if</span> (val.length === <span class="number">4</span>) {</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {</div><div class="line">                tmp[i] = val.charAt(i + <span class="number">1</span>);</div><div class="line">                tmp[i] += tmp[i];</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (val.length === <span class="number">7</span>) {</div><div class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {</div><div class="line">                tmp[i] = val.substr(<span class="number">1</span> + i * <span class="number">2</span>, <span class="number">2</span>);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {</div><div class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i], <span class="number">16</span>);</div><div class="line">        }</div><div class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGB))) {</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) {</div><div class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i + <span class="number">1</span>], <span class="number">10</span>);</div><div class="line">        }</div><div class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</div><div class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGBA))) {</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i--;) {</div><div class="line">            color[i] = <span class="built_in">Number</span>(tmp[i + <span class="number">1</span>]);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="计算">计算</h4>
<p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeColor</span><span class="params">(from, to, pos)</span> </span>{</div><div class="line">    <span class="keyword">var</span> _default = hooks._default,</div><div class="line">        result = [],</div><div class="line">        i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) {</div><div class="line">        result.push(<span class="built_in">parseInt</span>(_default.compute(from[i], to[i], pos), <span class="number">10</span>));</div><div class="line">    }</div><div class="line">    result.push(_default.compute(from[<span class="number">3</span>], to[<span class="number">3</span>], pos));</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<h4 id="赋值">赋值</h4>
<p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignColor</span><span class="params">(elem, style, val)</span> </span>{</div><div class="line">    <span class="keyword">if</span>(KISSY.Features.isIELessThan(<span class="number">9</span>)){</div><div class="line">        Dom.css(elem, style, <span class="string">"rgb("</span> + val.slice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">","</span>) + <span class="string">")"</span>);</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        Dom.css(elem, style, <span class="string">"rgba("</span> + val.join(<span class="string">","</span>) + <span class="string">")"</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="滚动">滚动</h3>
<h4 id="获取-1">获取</h4>
<p>滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>
<h4 id="解析-1">解析</h4>
<p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>
<h4 id="计算-1">计算</h4>
<p>计算过程也是，使用默认计算即可</p>
<h4 id="赋值-1">赋值</h4>
<p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">S.each(<span class="string">"scrollTop scrollLeft"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span><span class="params">(type)</span> </span>{</div><div class="line">    <span class="keyword">var</span> _default = hooks._default;</div><div class="line">    hooks[type] = {</div><div class="line">        assign: <span class="function"><span class="keyword">function</span><span class="params">(elem, style, val)</span> </span>{</div><div class="line">            Dom[type](elem, val);</div><div class="line">        },</div><div class="line">        get: <span class="function"><span class="keyword">function</span><span class="params">(elem, style)</span> </span>{</div><div class="line">            <span class="keyword">return</span> Dom[type](elem);</div><div class="line">        }</div><div class="line">    };</div><div class="line">});</div></pre></td></tr></table></figure>

<h3 id="transform">transform</h3>
<p><strong>这里只处理了2D的transform</strong></p>
<p>transform的值也有很多不同的形式：</p>
<ol>
<li>matrix</li>
<li>rotate</li>
<li>translate、translateX、translateY</li>
<li>scale、scaleX、scaleY</li>
<li>skew、skewX、skewY</li>
</ol>
<h4 id="获取-2">获取</h4>
<p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>
<h4 id="解析-2">解析</h4>
<p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = {</div><div class="line">    translateX: <span class="number">0</span>,</div><div class="line">    translateY: <span class="number">0</span>,</div><div class="line">    rotate: <span class="number">0</span>,</div><div class="line">    skewX: <span class="number">0</span>,</div><div class="line">    skewY: <span class="number">0</span>,</div><div class="line">    scaleX: <span class="number">1</span>,</div><div class="line">    scaleY: <span class="number">1</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>代码较长</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decomposeMatrix</span><span class="params">(matrix)</span> </span>{</div><div class="line">    <span class="keyword">var</span> scaleX, scaleY, skew,</div><div class="line">        A = matrix[<span class="number">0</span>],</div><div class="line">        B = matrix[<span class="number">1</span>],</div><div class="line">        C = matrix[<span class="number">2</span>],</div><div class="line">        D = matrix[<span class="number">3</span>];</div><div class="line"></div><div class="line">    <span class="comment">// Make sure matrix is not singular</span></div><div class="line">    <span class="keyword">if</span> (A * D - B * C) {</div><div class="line">        scaleX = <span class="built_in">Math</span>.sqrt(A * A + B * B);</div><div class="line">        skew = (A * C + B * D) / (A * D - C * B);</div><div class="line">        scaleY = (A * D - B * C) / scaleX;</div><div class="line">        <span class="comment">// step (6)</span></div><div class="line">        <span class="keyword">if</span> (A * D &lt; B * C) {</div><div class="line">            skew = -skew;</div><div class="line">            scaleX = -scaleX;</div><div class="line">        }</div><div class="line">        <span class="comment">// matrix is singular and cannot be interpolated</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// In this case the elem shouldn't be rendered, hence scale == 0</span></div><div class="line">        scaleX = scaleY = skew = <span class="number">0</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// The recomposition order is very important</span></div><div class="line">    <span class="comment">// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971</span></div><div class="line">    <span class="keyword">return</span> {</div><div class="line">        translateX: myParse(matrix[<span class="number">4</span>]),</div><div class="line">        translateY: myParse(matrix[<span class="number">5</span>]),</div><div class="line">        rotate: myParse(<span class="built_in">Math</span>.atan2(B, A) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</div><div class="line">        skewX: myParse(<span class="built_in">Math</span>.atan(skew) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</div><div class="line">        skewY: <span class="number">0</span>,</div><div class="line">        scaleX: myParse(scaleX),</div><div class="line">        scaleY: myParse(scaleY)</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueStringToArray</span><span class="params">(val)</span> </span>{</div><div class="line">    <span class="keyword">var</span> result = val.split(<span class="string">","</span>);</div><div class="line">    result = S.map(result, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>{</div><div class="line">        <span class="keyword">return</span> myParse(value);</div><div class="line">    });</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTransform</span><span class="params">(val)</span> </span>{</div><div class="line">    <span class="keyword">var</span> result = {</div><div class="line">        translateX: <span class="number">0</span>,</div><div class="line">        translateY: <span class="number">0</span>,</div><div class="line">        rotate: <span class="number">0</span>,</div><div class="line">        skewX: <span class="number">0</span>,</div><div class="line">        skewY: <span class="number">0</span>,</div><div class="line">        scaleX: <span class="number">1</span>,</div><div class="line">        scaleY: <span class="number">1</span></div><div class="line">    };</div><div class="line">    <span class="keyword">var</span> value;</div><div class="line">    <span class="keyword">var</span> regResult;</div><div class="line">    <span class="keyword">var</span> i, j, m;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">var</span> strs;</div><div class="line">    strs = val.replace(rClearSpace, <span class="string">""</span>).split(<span class="string">")"</span>);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, m = strs.length; i &lt; m; i++) {</div><div class="line">        <span class="keyword">if</span> (!strs[i] || strs[i] === <span class="string">"none"</span>) <span class="keyword">continue</span>;</div><div class="line">        regResult = strs[i].split(<span class="string">"("</span>);</div><div class="line">        name = regResult[<span class="number">0</span>];</div><div class="line">        value = valueStringToArray(regResult[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">switch</span> (name) {</div><div class="line">            <span class="keyword">case</span> <span class="string">"matrix"</span>:</div><div class="line">                result = decomposeMatrix(value);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"translate"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"skew"</span>:</div><div class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</div><div class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || <span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"scale"</span>:</div><div class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</div><div class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || result[name + <span class="string">"X"</span>];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> <span class="string">"translateX"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"translateY"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"scaleX"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"scaleY"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"skewX"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"skewY"</span>:</div><div class="line">            <span class="keyword">case</span> <span class="string">"rotate"</span>:</div><div class="line">                result[name] = value[<span class="number">0</span>] || <span class="number">0</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>
<h4 id="计算-2">计算</h4>
<p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeTransform</span><span class="params">(from, to, pos)</span> </span>{</div><div class="line">    <span class="keyword">var</span> _default = hooks._default;</div><div class="line">    <span class="keyword">var</span> result = {};</div><div class="line">    S.each(to, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> </span>{</div><div class="line">        result[key] = _default.compute(from[key], to[key], pos);</div><div class="line">    });</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="赋值-2">赋值</h3>
<p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignTransform</span><span class="params">(elem, style, val)</span> </span>{</div><div class="line">    <span class="keyword">var</span> valueArray = [];</div><div class="line">    S.each(val, <span class="function"><span class="keyword">function</span><span class="params">(value, key)</span> </span>{</div><div class="line">        <span class="keyword">if</span> ((key.indexOf(<span class="string">"scale"</span>) &gt; -<span class="number">1</span> && value === <span class="number">1</span>) || (key.indexOf(<span class="string">"scale"</span>) === -<span class="number">1</span> && value === <span class="number">0</span>)) {</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> (key === <span class="string">"rotate"</span> || key.indexOf(<span class="string">"skew"</span>) &gt; -<span class="number">1</span>) {</div><div class="line">            value += <span class="string">"deg"</span>;</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (key.indexOf(<span class="string">"translate"</span>) &gt; -<span class="number">1</span>) {</div><div class="line">            value += <span class="string">"px"</span>;</div><div class="line">        }</div><div class="line">        valueArray.push(key + <span class="string">"("</span> + value + <span class="string">")"</span>);</div><div class="line">    });</div><div class="line">    Dom.css(elem, style, valueArray.join(<span class="string">" "</span>));</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank" rel="external">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank" rel="external">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank" rel="external">Github页面</a></p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Kissy" scheme="http://lingyu.wang/tags/Kissy/"/>
    
      <category term="动画" scheme="http://lingyu.wang/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebRTC的RTCDataChannel]]></title>
    <link href="http://lingyu.wang/2014/05/22/webrtc-data-channels/"/>
    <id>http://lingyu.wang/2014/05/22/webrtc-data-channels/</id>
    <published>2014-05-21T16:00:00.000Z</published>
    <updated>2014-09-18T15:03:50.000Z</updated>
    <content type="html"><![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
<a id="more"></a>

<blockquote>
<p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>
<h3 id="为什么我们需要另外一个数据通道">为什么我们需要另外一个数据通道</h3>
<p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/" target="_blank" rel="external">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/" target="_blank" rel="external">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/" target="_blank" rel="external">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>
<p>RTCDataChannel则是一个完全不同的途径：</p>
<ul>
<li>它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。</li>
<li>RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features" target="_blank" rel="external">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</li>
</ul>
<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>
<h3 id="一个警告：信令、STUN和TURN">一个警告：信令、STUN和TURN</h3>
<p>尽管WebRTC允许点对点的通信，但它依然需要服务器：</p>
<ul>
<li>信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器</li>
<li>NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</li>
</ul>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>
<h3 id="功能">功能</h3>
<p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能"><br>以上来自<a href="http://www.igvita.com/" target="_blank" rel="external">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank" rel="external">High Performance Browser Networking</a></p>
<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：</p>
<ul>
<li>可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢</li>
<li>不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</li>
</ul>
<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>
<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>
<h3 id="配置数据通道">配置数据通道</h3>
<p>网上已经有很多RTCDataChannel的例子了：</p>
<ul>
<li><a href="http://simpl.info/dc" target="_blank" rel="external">simpl.info/dc</a></li>
<li><a href="http://googlechrome.github.io/webrtc/dc1.html" target="_blank" rel="external">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)</li>
<li><a href="http://pubnub.github.io/webrtc" target="_blank" rel="external">pubnub.github.io/webrtc</a>(两个PubNub用户)</li>
</ul>
<p>ps：PubBub是一个实时信息通讯应用开发公司</p>
<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> RTCPeerConnection();</div><div class="line"></div><div class="line"><span class="comment">//使用信令传输信道创建对等连接</span></div><div class="line"><span class="keyword">var</span> dataChannel =</div><div class="line">  peerConnection.createDataChannel(<span class="string">"myLabel"</span>, dataChannelOptions);</div><div class="line"></div><div class="line">dataChannel.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Data Channel Error:"</span>, error);</div><div class="line">};</div><div class="line"></div><div class="line">dataChannel.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Got Data Channel Message:"</span>, event.data);</div><div class="line">};</div><div class="line"></div><div class="line">dataChannel.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">  dataChannel.send(<span class="string">"Hello World!"</span>);</div><div class="line">};</div><div class="line"></div><div class="line">dataChannel.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"The Data Channel is Closed"</span>);</div><div class="line">};</div></pre></td></tr></table></figure>

<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dataChannelOptions = {</div><div class="line">  ordered: <span class="literal">false</span>, <span class="comment">//不保证到达顺序</span></div><div class="line">  maxRetransmitTime: <span class="number">3000</span>, <span class="comment">//最大重传时间</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960" target="_blank" rel="external">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758" target="_blank" rel="external">RFC 3758</a>（SCTP部分可靠性）</p>
<ul>
<li>ordered: 数据通道是否保证按序传输数据</li>
<li>maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）</li>
<li>maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）</li>
<li>protocol：允许使用一个自协议，但如果协议不支持，将会失败</li>
<li>negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道</li>
<li>id：为数据通道提供一个自己定义的ID</li>
</ul>
<h3 id="它安全吗？">它安全吗？</h3>
<p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank" rel="external">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS" target="_blank" rel="external">Wireshark的维基</a></p>
<h3 id="改变你考虑数据的方式">改变你考虑数据的方式</h3>
<p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/" target="_blank" rel="external">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/" target="_blank" rel="external">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>
<h3 id="搭建一个文件共享应用">搭建一个文件共享应用</h3>
<p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>
<p>需要成功传输一个文件，我们需要如下几步：</p>
<ol>
<li><a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/" target="_blank" rel="external">通过JavaScript的File API读取文件数据</a></li>
<li>使用RTCPeerConnection在用户间创建一个对等连接</li>
<li>使用RTCDataChannel在用户间创建一个数据通道</li>
</ol>
<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：</p>
<ul>
<li><strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。</li>
<li><strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。</li>
<li><strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</li>
</ul>
<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span><span class="params">(blob)</span> </span>{</div><div class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</div><div class="line">  link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">  link.download = <span class="string">'File Name'</span>;</div><div class="line">  link.click();</div><div class="line">};</div></pre></td></tr></table></figure>

<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/" target="_blank" rel="external">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest" target="_blank" rel="external">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>
<h3 id="那么我们能做什么？">那么我们能做什么？</h3>
<p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：</p>
<ul>
<li>上面已经提到了点对点的文件传输了</li>
<li>多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/" target="_blank" rel="external">Banana Bread</a></li>
<li>内容交付：由<a href="https://peercdn.com/" target="_blank" rel="external">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</li>
</ul>
<h3 id="改变你构建应用的方式">改变你构建应用的方式</h3>
<p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/" target="_blank" rel="external">PeerJS</a>和<a href="https://github.com/pubnub/webrtc" target="_blank" rel="external">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>
<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>
<h3 id="更多资讯">更多资讯</h3>
<ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Getting started with WebRTC</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN and signaling</a></li>
<li><a href="http://bit.ly/webrtcwebaudio" target="_blank" rel="external">WebRTC resources</a></li>
<li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api" target="_blank" rel="external">W3C Working Draft</a></li>
<li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04" target="_blank" rel="external">IETF WebRTC Data Channel Protocol Draft</a></li>
<li><a href="http://bloggeek.me/send-file-webrtc-data-api/" target="_blank" rel="external">How to send a File Using WebRTC Data API</a></li>
<li><a href="http://bloggeek.me/webrtc-data-channel-uses/" target="_blank" rel="external">7 Creative Uses of WebRTC’s Data Channel</a></li>
<li><a href="https://developer.mozilla.org/en/demos/detail/bananabread" target="_blank" rel="external">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
]]>
    
    </summary>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用导航计时监测渲染关键路径]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/"/>
    <id>http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-18T14:53:48.000Z</updated>
    <content type="html"><![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br><a id="more"></a></p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">var</span> t = <span class="built_in">window</span>.performance.timing,</div><div class="line">          interactive = t.domInteractive - t.domLoading,</div><div class="line">          dcl = t.domContentLoadedEventStart - t.domLoading,</div><div class="line">          complete = t.domComplete - t.domLoading;</div><div class="line">        <span class="keyword">var</span> stats = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</div><div class="line">        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +</div><div class="line">            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;</div><div class="line">        <span class="built_in">document</span>.body.appendChild(stats);</div><div class="line">      }</div><div class="line">    <span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过JavaScript增加交互性]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/"/>
    <id>http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-18T14:53:25.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<a id="more"></a>

<h3 id="长话短说">长话短说</h3>
<ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span></div><div class="line">      <span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</div><div class="line">      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span></div><div class="line">      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span></div><div class="line">      <span class="comment">// create a new element, style it, and append it to the DOM</span></div><div class="line">      <span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">      loadTime.style.color = <span class="string">'blue'</span>;</div><div class="line">      <span class="built_in">document</span>.body.appendChild(loadTime);</div><div class="line">    <span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</div><div class="line">span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span></div><div class="line">span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span></div><div class="line"><span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span></div><div class="line"><span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">loadTime.style.color = <span class="string">'blue'</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(loadTime);</div></pre></td></tr></table></figure>

<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS的渲染阻塞]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-render-blocking-css/"/>
    <id>http://lingyu.wang/2014/05/21/google-render-blocking-css/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2014-09-18T14:53:57.000Z</updated>
    <content type="html"><![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
<a id="more"></a>

<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>默认情况下CSS是渲染阻塞资源</li>
<li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
<li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>
<h3 id="CSS是渲染阻塞资源">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>
<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>
<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>
<h3 id="媒体类型和媒体查询">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"other.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"(min-width: 40em)"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>
<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>
<p>让我们考虑如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"portrait.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></div></pre></td></tr></table></figure>

<ol>
<li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
<li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
<li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
<li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>
<h3 id="浏览器下载">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建对象模型]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-constructing-the-object-model/"/>
    <id>http://lingyu.wang/2014/05/20/google-constructing-the-object-model/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-09-18T14:53:34.000Z</updated>
    <content type="html"><![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br><a id="more"></a></p>
<h2 id="长话短说">长话短说</h2>
<ul>
<li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
<li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
<li>DOM和CSSOM是互相独立的数据结构</li>
<li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>
<h2 id="DOM树构建">DOM树构建</h2>
<p>比如一段如下HTML</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>其从字节到DOM树的过程如下图所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程"></p>
<p>具体的过程分为如下几步：</p>
<ol>
<li>转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符</li>
<li>标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则</li>
<li>对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则</li>
<li>DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</li>
</ol>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构"></p>
<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>
<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程"></p>
<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>
<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>
<h2 id="CSSOM树构建">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">body</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span> </span></span></span>}</div><div class="line"><span class="tag">p</span> <span class="rules">{ <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold </span></span></span>}</div><div class="line"><span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red </span></span></span>}</div><div class="line"><span class="tag">p</span> <span class="tag">span</span> <span class="rules">{ <span class="rule"><span class="attribute">display</span>:<span class="value"> none </span></span></span>}</div><div class="line"><span class="tag">img</span> <span class="rules">{ <span class="rule"><span class="attribute">float</span>:<span class="value"> right </span></span></span>}</div></pre></td></tr></table></figure>

<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>
<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM"></p>
<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM"></p>
<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>
<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>
<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理"></p>
<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>浏览器渲染页面之前会构建DOM树和CSSOM树<br>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渲染树的构建，布局和绘制]]></title>
    <link href="http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/"/>
    <id>http://lingyu.wang/2014/05/20/google-render-tree-construction-layout-and-paint/</id>
    <published>2014-05-19T16:00:00.000Z</published>
    <updated>2014-09-18T14:54:02.000Z</updated>
    <content type="html"><![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
<a id="more"></a>

<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>
<h3 id="长话短说">长话短说</h3>
<ul>
<li>DOM树和CSSOM树结合组成了渲染树</li>
<li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
<li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
<li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>
<h3 id="构建渲染树">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树"></p>
<p>为了构建渲染树，浏览器所做的工作大致如下：</p>
<ol>
<li>从DOM树的根节点开始，遍历每个可见的节点<ul>
<li>有些节点本身不可见（比如script、meta等等）</li>
<li>有些节点被CSS隐藏了，这些节点也会被渲染树忽略</li>
</ul>
</li>
<li>对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息</li>
<li>提交可见的节点和他们的内容和样式</li>
</ol>
<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>
<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>
<h3 id="布局阶段">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>
<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critial Path: Hello world!<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"width: 50%"</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>
<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>
<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>
<h3 id="绘制阶段">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段"></p>
<ul>
<li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
<li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>
<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>
<p>这些都完成后，我们的页面终于展示在视口里了</p>
<h3 id="总结">总结</h3>
<p>我们来重温一下所有的步骤：</p>
<ol>
<li>处理HTML标记，构建DOM树</li>
<li>处理CSS标记，构建CSSOM树</li>
<li>合并DOM树和CSSOM树，构建渲染树</li>
<li>在渲染树上运行布局阶段，计算每个可见节点的几何图形</li>
<li>绘制每个独立的节点到屏幕上</li>
</ol>
<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>
<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[响应式Web设计基础]]></title>
    <link href="http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/"/>
    <id>http://lingyu.wang/2014/05/19/google-responsive-design-fundamentals/</id>
    <published>2014-05-18T16:00:00.000Z</published>
    <updated>2014-09-18T14:54:15.000Z</updated>
    <content type="html"><![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank" rel="external">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
<a id="more"></a>

<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/" target="_blank" rel="external">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>
<h2 id="设置视口信息">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>
<h3 id="长话短说">长话短说</h3>
<ol>
<li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
<li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
<li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
<li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>
<h3 id="最佳实践">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>
<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>
<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>
<h3 id="确定一个可访问的视口">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>
<h2 id="使得内容适配视口">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>
<h3 id="长话短说-1">长话短说</h3>
<ol>
<li>不要为元素设定大且固定的尺寸</li>
<li>内容的展现不应该依赖于一个特定的视口宽度</li>
<li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>
<h3 id="最佳实践-1">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>
<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>
<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>
<h2 id="为响应式使用CSS的媒体查询">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>
<h3 id="长话短说-2">长话短说</h3>
<ol>
<li>媒体查询可以根据设备特点来应用样式</li>
<li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
<li>为元素使用相对大小防止破坏布局</li>
</ol>
<h3 id="最佳实践-2">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></div></pre></td></tr></table></figure>

<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">media</span> print </span>{</div><div class="line">  <span class="comment">/* print style sheets go here */</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(print.css) print</span>;</div></pre></td></tr></table></figure>

<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>
<h3 id="根据视口大小使用媒体查询">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">media</span> (query) </span>{</div><div class="line">  <span class="comment">/* CSS Rules used when query matches */</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>
<ul>
<li>min-width: 匹配所有宽度大于设定值的浏览器</li>
<li>max-width: 匹配所有宽度小于设定值的浏览器</li>
<li>min-height: 匹配所有高度大于设定值的浏览器</li>
<li>max-height: 匹配所有高度小于设定值的浏览器</li>
<li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li>
<li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li>
</ul>
<h3 id="关于min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>
<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>
<h3 id="使用相对单位">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>
<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>
<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>
<h2 id="如何选择断点">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>
<h3 id="长话短说-3">长话短说</h3>
<ol>
<li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
<li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
<li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>
<h3 id="从小到大来挑选主要断点">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>
<h3 id="必要时添加次要断点">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>
<h3 id="优化文本阅读">优化文本阅读</h3>
<p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>
<h3 id="不要完全隐藏内容">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/" target="_blank" rel="external">Responsive Web Design Fundamentals</a></p>
<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的异步控制]]></title>
    <link href="http://lingyu.wang/2014/05/17/read-jq-src-5/"/>
    <id>http://lingyu.wang/2014/05/17/read-jq-src-5/</id>
    <published>2014-05-16T16:00:00.000Z</published>
    <updated>2014-09-18T15:01:15.000Z</updated>
    <content type="html"><![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<a id="more"></a>

<h2 id="简介">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
<h2 id="jQuery-Callbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态</p>
<h3 id="配置选项">配置选项</h3>
<p>创建一个回调函数列表可能会用到如下参数：</p>
<ol>
<li>options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置</li>
<li>once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次</li>
<li>memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果</li>
<li>unique：决定了回调函数列表中的函数能否重复</li>
<li>stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</li>
</ol>
<p>接下来看看构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</div><div class="line">    ( optionsCache[ options ] || createOptions( options ) ) :</div><div class="line">    jQuery.extend( {}, options );</div></pre></td></tr></table></figure>

<p>options可以是字符串，如<code>&quot;once memory&quot;</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>
<h3 id="私有变量">私有变量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="comment">// Last fire value (for non-forgettable lists)</span></div><div class="line">    <span class="comment">/*用于存放运行结果*/</span></div><div class="line">    memory,</div><div class="line">    <span class="comment">/*标志所有回调函数列表是否被触发过*/</span></div><div class="line">    fired,</div><div class="line">    <span class="comment">/*标志当前正在执行回调函数列表中的函数*/</span></div><div class="line">    firing,</div><div class="line">    <span class="comment">/*第一个被执行的回调函数*/</span></div><div class="line">    firingStart,</div><div class="line">    <span class="comment">/*回调函数列表的长度*/</span></div><div class="line">    firingLength,</div><div class="line">    <span class="comment">/*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/</span></div><div class="line">    firingIndex,</div><div class="line">    <span class="comment">/*保存回调函数的列表*/</span></div><div class="line">    list = [],</div><div class="line">    <span class="comment">/*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/</span></div><div class="line">    stack = !options.once && [],</div></pre></td></tr></table></figure>

<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>
<h3 id="触发函数fire">触发函数fire</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">fire = <span class="function"><span class="keyword">function</span><span class="params">( data )</span> </span>{</div><div class="line">    <span class="comment">/*如果使用了memory配置，data会先被保存在memory中*/</span></div><div class="line">    memory = options.memory && data;</div><div class="line">    <span class="comment">/*表明这个回调函数列表已经被触发过了*/</span></div><div class="line">    fired = <span class="literal">true</span>;</div><div class="line">    <span class="comment">/*确定当前执行的回调函数在回调函数列表中的位置*/</span></div><div class="line">    firingIndex = firingStart || <span class="number">0</span>;</div><div class="line">    <span class="comment">/*将起始设为0*/</span></div><div class="line">    firingStart = <span class="number">0</span>;</div><div class="line">    <span class="comment">/*获取回调函数列表的总长度*/</span></div><div class="line">    firingLength = list.length;</div><div class="line">    <span class="comment">/*修改状态为正在执行*/</span></div><div class="line">    firing = <span class="literal">true</span>;</div><div class="line">    <span class="comment">/*依次执行回调函数*/</span></div><div class="line">    <span class="keyword">for</span> ( ; list && firingIndex &lt; firingLength; firingIndex++ ) {</div><div class="line">        <span class="comment">/*如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空*/</span></div><div class="line">        <span class="keyword">if</span> ( list[ firingIndex ].apply( data[ <span class="number">0</span> ], data[ <span class="number">1</span> ] ) === <span class="literal">false</span> && options.stopOnFalse ) {</div><div class="line">            memory = <span class="literal">false</span>; <span class="comment">// To prevent further calls using add</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*修改正在执行状态为false*/</span></div><div class="line">    firing = <span class="literal">false</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/</span></div><div class="line">    <span class="keyword">if</span> ( list ) {</div><div class="line">        <span class="comment">/*多次执行的话，stack是个数组*/</span></div><div class="line">        <span class="keyword">if</span> ( stack ) {</div><div class="line">            <span class="comment">/*从等待队列中弹出数据再次执行*/</span></div><div class="line">            <span class="keyword">if</span> ( stack.length ) {</div><div class="line">                fire( stack.shift() );</div><div class="line">            }</div><div class="line">        <span class="comment">/*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/</span></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {</div><div class="line">            list = [];</div><div class="line">        <span class="comment">/*否则说明函数没有正常执行完成，将回调函数列表设为无效*/</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            self.disable();</div><div class="line">        }</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<p>这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用</p>
<h3 id="实例">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>
<h4 id="add">add</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">add: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> ( list ) {</div><div class="line">        <span class="comment">//首先保存当前列表长度</span></div><div class="line">        <span class="keyword">var</span> start = list.length;</div><div class="line">        <span class="comment">/*使用jQuery.each方法遍历深度遍历arguments：</span></div><div class="line">        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重</div><div class="line">        2. 如果值为对象那么遍历这个对象进行添加 */</div><div class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">( args )</span> </span>{</div><div class="line">            jQuery.each( args, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> </span>{</div><div class="line">                <span class="keyword">var</span> type = jQuery.type( arg );</div><div class="line">                <span class="keyword">if</span> ( type === <span class="string">"function"</span> ) {</div><div class="line">                    <span class="keyword">if</span> ( !options.unique || !self.has( arg ) ) {</div><div class="line">                    list.push( arg );</div><div class="line">                    }</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> ( arg && arg.length && type !== <span class="string">"string"</span> ) {</div><div class="line">                    <span class="comment">// Inspect recursively</span></div><div class="line">                    add( arg );</div><div class="line">                }</div><div class="line">            });</div><div class="line">        })( <span class="built_in">arguments</span> );</div><div class="line">        <span class="comment">/*如果正在执行回调函数列表，那么需要维护一下长度*/</span></div><div class="line">        <span class="keyword">if</span> ( firing ) {</div><div class="line">            firingLength = list.length;</div><div class="line">        <span class="comment">/*如果memory中已经有值，执行所有新增加的回调函数*/</span></div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> ( memory ) {</div><div class="line">            firingStart = start;</div><div class="line">            fire( memory );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*返回this方便链式操作*/</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<p>这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>
<h4 id="remove">remove</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">remove: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">if</span> ( list ) {</div><div class="line">        <span class="comment">/*遍历arguments，对每个函数分执行删除操作*/</span></div><div class="line">        jQuery.each( <span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span><span class="params">( _, arg )</span> </span>{</div><div class="line">            <span class="keyword">var</span> index;</div><div class="line">            <span class="comment">/*通过jQuery.inArray获取函数在回调函数列表中的位置*/</span></div><div class="line">            <span class="keyword">while</span> ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -<span class="number">1</span> ) {</div><div class="line">                <span class="comment">/*删除掉这个函数*/</span></div><div class="line">                list.splice( index, <span class="number">1</span> );</div><div class="line">                <span class="comment">/*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/</span></div><div class="line">                <span class="keyword">if</span> ( firing ) {</div><div class="line">                    <span class="keyword">if</span> ( index &lt;= firingLength ) {</div><div class="line">                        firingLength--;</div><div class="line">                    }</div><div class="line">                    <span class="keyword">if</span> ( index &lt;= firingIndex ) {</div><div class="line">                        firingIndex--;</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line">    <span class="comment">/*返回this方便链式操作*/</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<p>这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>
<h4 id="has_(fn)">has (fn)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">has: <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> </span>{</div><div class="line">    <span class="keyword">return</span> fn ? jQuery.inArray( fn, list ) &gt; -<span class="number">1</span> : !!( list && list.length );</div><div class="line">},</div></pre></td></tr></table></figure>

<p>判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：</p>
<ol>
<li>若有fn，直接用inArray判定</li>
<li>若无fn，直接判断列表是否有长度不为0的list列表</li>
</ol>
<h4 id="empty">empty</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">empty: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    list = [];</div><div class="line">    firingLength = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<p>清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>
<h4 id="disable和disabled">disable和disabled</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    list = stack = memory = <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div><div class="line">disabled: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> !list;</div><div class="line">},</div></pre></td></tr></table></figure>

<p>将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>
<h4 id="lock和locked">lock和locked</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">lock: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    stack = <span class="literal">undefined</span>;</div><div class="line">    <span class="keyword">if</span> ( !memory ) {</div><div class="line">        self.disable();</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div><div class="line">locked: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> !stack;</div><div class="line">},</div></pre></td></tr></table></figure>

<p>lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>
<h4 id="fireWith和fire">fireWith和fire</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">fireWith: <span class="function"><span class="keyword">function</span><span class="params">( context, args )</span> </span>{</div><div class="line">    <span class="comment">/*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/</span></div><div class="line">    <span class="keyword">if</span> ( list && ( !fired || stack ) ) {</div><div class="line">        args = args || [];</div><div class="line">        args = [ context, args.slice ? args.slice() : args ];</div><div class="line">        <span class="comment">/*如果正在出发，就放到等待队列中*/</span></div><div class="line">        <span class="comment">/*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/</span></div><div class="line">        <span class="keyword">if</span> ( firing ) {</div><div class="line">            stack.push( args );</div><div class="line">        <span class="comment">/*否则直接触发*/</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            fire( args );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div><div class="line">fire: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    self.fireWith( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">},</div><div class="line">fired: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> !!fired;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>
<p>fired没啥好说的，判断回调函数列表是否被触发过</p>
<h3 id="小结">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>
<h2 id="Deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>
<h3 id="构造函数">构造函数</h3>
<h4 id="三个状态，三个操作，三个列表">三个状态，三个操作，三个列表</h4>
<p>Deferred有三个状态：</p>
<ol>
<li>pending</li>
<li>resolved</li>
<li>rejected</li>
</ol>
<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>
<p>事实上，每个操作对应着一系列的回调函数，看一下定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tuples = [</div><div class="line">    [ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],</div><div class="line">    [ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],</div><div class="line">    [ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]</div><div class="line">],</div></pre></td></tr></table></figure>

<p>可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：</p>
<ol>
<li>resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved</li>
<li>reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected</li>
<li>notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</li>
</ol>
<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*针对三个操作分别进行加工*/</span></div><div class="line">jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> </span>{</div><div class="line">    <span class="comment">/*获取操作的回调函数列表*/</span></div><div class="line">    <span class="keyword">var</span> list = tuple[ <span class="number">2</span> ],</div><div class="line">        <span class="comment">/*获取操作执行后的状态*/</span></div><div class="line">        stateString = tuple[ <span class="number">3</span> ];</div><div class="line"></div><div class="line">    <span class="comment">// promise[ done | fail | progress ] = list.add</span></div><div class="line">    <span class="comment">/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/</span></div><div class="line">    promise[ tuple[<span class="number">1</span>] ] = list.add;</div><div class="line"></div><div class="line">    <span class="comment">// Handle state</span></div><div class="line">    <span class="comment">/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/</span></div><div class="line">    <span class="keyword">if</span> ( stateString ) {</div><div class="line">        list.add(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            <span class="comment">// state = [ resolved | rejected ]</span></div><div class="line">            state = stateString;</div><div class="line"></div><div class="line">        <span class="comment">// [ reject_list | resolve_list ].disable; progress_list.lock</span></div><div class="line">        }, tuples[ i ^ <span class="number">1</span> ][ <span class="number">2</span> ].disable, tuples[ <span class="number">2</span> ][ <span class="number">2</span> ].lock );</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">// deferred[ resolve | reject | notify ]</span></div><div class="line">    <span class="comment">/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/</span></div><div class="line">    deferred[ tuple[<span class="number">0</span>] ] = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    };</div><div class="line">    <span class="comment">/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/</span></div><div class="line">    deferred[ tuple[<span class="number">0</span>] + <span class="string">"With"</span> ] = list.fireWith;</div><div class="line">});</div></pre></td></tr></table></figure>

<p>上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法：</p>
<ol>
<li>resolve</li>
<li>reject</li>
<li>notify</li>
<li>resolveWith</li>
<li>rejectWith</li>
<li>notifyWith</li>
</ol>
<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>
<p>同时，这里还会为promise增加三个方法：</p>
<ol>
<li>done</li>
<li>fail</li>
<li>progress</li>
</ol>
<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>
<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>
<h3 id="promise对象">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">promise = {</div><div class="line">    <span class="comment">/*获得当前状态的方法*/</span></div><div class="line">    state: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">    },</div><div class="line">    <span class="comment">/*无论执行成功与否，都执行参数中的回调*/</span></div><div class="line">    always: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        deferred.done( <span class="built_in">arguments</span> ).fail( <span class="built_in">arguments</span> );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    },</div><div class="line">    <span class="comment">/*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/</span></div><div class="line">    then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> </span>{</div><div class="line">        <span class="comment">/*then的代码*/</span></div><div class="line">    },</div><div class="line">    <span class="comment">// Get a promise for this deferred</span></div><div class="line">    <span class="comment">// If obj is provided, the promise aspect is added to the object</span></div><div class="line">    <span class="comment">/*获取promise对象*/</span></div><div class="line">    promise: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">        <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend( obj, promise ) : promise;</div><div class="line">    }</div><div class="line">},</div><div class="line">deferred = {};</div><div class="line"><span class="comment">/*pipe方法，实际上就是then，为了符合标准罢了*/</span></div><div class="line">promise.pipe = promise.then;</div><div class="line"><span class="comment">/*这里为Promise添加了done、fail、progress方法*/</span></div><div class="line"><span class="comment">/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/</span></div><div class="line">jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> </span>{</div><div class="line">    <span class="comment">/*上面的代码*/</span></div><div class="line">});</div><div class="line"><span class="comment">/*将Promise对象的所有方法拷贝给Deferred对象*/</span></div><div class="line">promise.promise( deferred );</div></pre></td></tr></table></figure>

<p>这里可以看到，promise对象提供了几个接口：</p>
<ol>
<li>state：获取当前Deferred对象的状态</li>
<li>always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行</li>
<li>then：使用done、fail、progress分别绑定函数，代码较多，后面再讲</li>
<li>promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象</li>
<li>pipe：就是then，别名而已</li>
<li>done，fail，progress：上面介绍过，不赘述了</li>
</ol>
<h4 id="Promise和Deferred的区别">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>
<h4 id="then和pipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">then: <span class="function"><span class="keyword">function</span><span class="params">( <span class="comment">/* fnDone, fnFail, fnProgress */</span> )</span> </span>{</div><div class="line">    <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;</div><div class="line">    <span class="comment">/*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链</span></div><div class="line">    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发</div><div class="line">    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表</div><div class="line">    */</div><div class="line">    <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span><span class="params">( newDefer )</span> </span>{</div><div class="line">        <span class="comment">/*对于上面三种，分别将函数加入到对应的回调函数列表中*/</span></div><div class="line">        jQuery.each( tuples, <span class="function"><span class="keyword">function</span><span class="params">( i, tuple )</span> </span>{</div><div class="line">            <span class="keyword">var</span> fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];</div><div class="line">            <span class="comment">/*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/</span></div><div class="line">            deferred[ tuple[<span class="number">1</span>] ](<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                <span class="keyword">var</span> returned = fn && fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">                <span class="comment">/*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/</span></div><div class="line">                <span class="keyword">if</span> ( returned && jQuery.isFunction( returned.promise ) ) {</div><div class="line">                    returned.promise()</div><div class="line">                        .done( newDefer.resolve )</div><div class="line">                        .fail( newDefer.reject )</div><div class="line">                        .progress( newDefer.notify );</div><div class="line">                <span class="comment">/*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/</span></div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    newDefer[ tuple[ <span class="number">0</span> ] + <span class="string">"With"</span> ]( <span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [ returned ] : <span class="built_in">arguments</span> );</div><div class="line">                }</div><div class="line">            });</div><div class="line">        });</div><div class="line">        fns = <span class="literal">null</span>;</div><div class="line">    }).promise();</div><div class="line">},</div></pre></td></tr></table></figure>

<p>这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>
<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>
<h3 id="小结-1">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>
<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">when: <span class="function"><span class="keyword">function</span><span class="params">( subordinate <span class="comment">/* , ..., subordinateN */</span> )</span> </span>{</div><div class="line">    <span class="keyword">var</span> i = <span class="number">0</span>,</div><div class="line">        <span class="comment">/*切分参数到数组*/</span></div><div class="line">        resolveValues = slice.call( <span class="built_in">arguments</span> ),</div><div class="line">        <span class="comment">/*数组长度*/</span></div><div class="line">        length = resolveValues.length,</div><div class="line"></div><div class="line">        <span class="comment">/* 未完成的需要监听的Deferred对象的个数 */</span></div><div class="line">        remaining = length !== <span class="number">1</span> || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : <span class="number">0</span>,</div><div class="line">        <span class="comment">/*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/</span></div><div class="line">        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</div><div class="line"></div><div class="line">        /*</div><div class="line">        使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。</div><div class="line"></div><div class="line">        如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify</div><div class="line">        */</div><div class="line">        updateFunc = <span class="function"><span class="keyword">function</span><span class="params">( i, contexts, values )</span> </span>{</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">( value )</span> </span>{</div><div class="line">                contexts[ i ] = <span class="keyword">this</span>;</div><div class="line">                values[ i ] = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ? slice.call( <span class="built_in">arguments</span> ) : value;</div><div class="line">                <span class="keyword">if</span> ( values === progressValues ) {</div><div class="line">                    deferred.notifyWith( contexts, values );</div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> ( !( --remaining ) ) {</div><div class="line">                    deferred.resolveWith( contexts, values );</div><div class="line">                }</div><div class="line">            };</div><div class="line">        },</div><div class="line"></div><div class="line">        progressValues, progressContexts, resolveContexts;</div><div class="line"></div><div class="line">    <span class="comment">/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/</span></div><div class="line">    <span class="keyword">if</span> ( length &gt; <span class="number">1</span> ) {</div><div class="line">        progressValues = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</div><div class="line">        progressContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</div><div class="line">        resolveContexts = <span class="keyword">new</span> <span class="built_in">Array</span>( length );</div><div class="line">        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">            <span class="comment">/*这里只处理Deferred/Promise，其他不考虑*/</span></div><div class="line">            <span class="keyword">if</span> ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {</div><div class="line">                resolveValues[ i ].promise()</div><div class="line">                    .done( updateFunc( i, resolveContexts, resolveValues ) )</div><div class="line">                    .fail( deferred.reject )</div><div class="line">                    .progress( updateFunc( i, progressContexts, progressValues ) );</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                --remaining;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/</span></div><div class="line">    <span class="keyword">if</span> ( !remaining ) {</div><div class="line">        deferred.resolveWith( resolveContexts, resolveValues );</div><div class="line">    }</div><div class="line">    <span class="comment">/*将这个管理Deferred对象返回*/</span></div><div class="line">    <span class="keyword">return</span> deferred.promise();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>
<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>
<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>
<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>
<h2 id="总结">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的事件机制——事件对象、兼容、接口]]></title>
    <link href="http://lingyu.wang/2014/05/12/read-jq-src-4/"/>
    <id>http://lingyu.wang/2014/05/12/read-jq-src-4/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2014-09-18T15:01:02.000Z</updated>
    <content type="html"><![CDATA[<p>这篇主要介绍了jQuery中事件管理器的事件对象、兼容实现以及在jQuery对象上暴露的接口</p>
<a id="more"></a>


<p>接上一篇 <a href="http://lingyu.wang/#/art/blog/2014/05/12/read-jq-src-3" target="_blank" rel="external">jQuery的事件机制——核心篇</a></p>
<h2 id="事件对象">事件对象</h2>
<p>jq中使用自己创立的对象传递给回调函数，这里解析一下这个事件对象：</p>
<h3 id="构造函数">构造函数</h3>
<p>jq的事件对象的构造函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery.Event = <span class="function"><span class="keyword">function</span><span class="params">( src, props )</span> </span>{</div><div class="line">    <span class="comment">//内部的代码</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>接下来接下下内部代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*兼容不使用new的情况*/</span></div><div class="line"><span class="keyword">if</span> ( !(<span class="keyword">this</span> <span class="keyword">instanceof</span> jQuery.Event) ) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.Event( src, props );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>用于防止出现没有使用new直接调用构造函数的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( src && src.type ) {</div><div class="line">    <span class="keyword">this</span>.originalEvent = src;</div><div class="line">    <span class="keyword">this</span>.type = src.type;</div><div class="line"></div><div class="line">    <span class="comment">// Events bubbling up the document may have been marked as prevented</span></div><div class="line">    <span class="comment">// by a handler lower down the tree; reflect the correct value.</span></div><div class="line">    <span class="keyword">this</span>.isDefaultPrevented = src.defaultPrevented ||</div><div class="line">            <span class="comment">// Support: Android &lt; 4.0</span></div><div class="line">            src.defaultPrevented === <span class="literal">undefined</span> &&</div><div class="line">            src.getPreventDefault && src.getPreventDefault() ?</div><div class="line">        returnTrue :</div><div class="line">        returnFalse;</div><div class="line"></div><div class="line"><span class="comment">// Event type</span></div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    <span class="keyword">this</span>.type = src;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里根据传入的是事件对象还是事件名称分别进行处理，当传入原生事件对象时，使用originalEvent指向原生事件对象，并获取它的事件名称。另外还要判断事件是否已经屏蔽默认行为了。如果传入的是字符串，直接写入到事件名称中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*通过extend添加额外属性*/</span></div><div class="line"><span class="keyword">if</span> ( props ) {</div><div class="line">    jQuery.extend( <span class="keyword">this</span>, props );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>事件对象可以添加一些其他属性，这里添加的属性通过props传入，直接extend就好</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建时间*/</span></div><div class="line"><span class="keyword">this</span>.timeStamp = src && src.timeStamp || jQuery.now();</div><div class="line"></div><div class="line"><span class="comment">/*jq事件对象标记*/</span></div><div class="line"><span class="keyword">this</span>[ jQuery.expando ] = <span class="literal">true</span>;</div></pre></td></tr></table></figure>

<p>一个创建时的时间戳，不知道干嘛用的，至于版本号标记，主要是用来判断对象是原生事件对象还是jq自己的事件对象</p>
<h3 id="原型上的方法">原型上的方法</h3>
<p>事件对象实际上是jq新建的对象，对原生事件对象进行了一层包裹，那么应该提供一些方法操作原生事件对象。我们操作原生事件对象无外乎preventDefault和stopPropagation，这里就是做了一层封装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isDefaultPrevented: returnFalse,</div><div class="line">isPropagationStopped: returnFalse,</div><div class="line">isImmediatePropagationStopped: returnFalse,</div></pre></td></tr></table></figure>

<p>默认情况下，不会阻止默认行为，事件不会被终止。这里ImmediatePropagtaionStop其实和PropagationStop没什么区别</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">preventDefault: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.isDefaultPrevented = returnTrue;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( e && e.preventDefault ) {</div><div class="line">        e.preventDefault();</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<p>阻止默认行为，先在jq的事件对象上做个标记，然后调用原生事件的preventDefault方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">stopPropagation: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> e = <span class="keyword">this</span>.originalEvent;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.isPropagationStopped = returnTrue;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( e && e.stopPropagation ) {</div><div class="line">        e.stopPropagation();</div><div class="line">    }</div><div class="line">},</div><div class="line">stopImmediatePropagation: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.isImmediatePropagationStopped = returnTrue;</div><div class="line">    <span class="keyword">this</span>.stopPropagation();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>终止事件执行，同样是先在事件对象上做个标记，然后调用原生事件的pstopPropagation方法，可以看到，两个方法没什么区别</p>
<h2 id="事件对象在事件机制中的使用">事件对象在事件机制中的使用</h2>
<p>jq不嫌麻烦自己弄了个事件对象进行包装，就是为了屏蔽浏览器之间事件对象上的差异。这里jq事件对象需要根据事件的类型，来构建兼容的事件对象，同样是使用钩子的形式，调用这些钩子的地方，在事件管理器的fix方法</p>
<h3 id="fix方法">fix方法</h3>
<p>fix方法就是将原生事件对象加工为jq自己的事件对象，内部都是用钩子来加对不同类型的事件进行加工</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( event[ jQuery.expando ] ) {</div><div class="line">    <span class="keyword">return</span> event;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>jq事件对象上有jq版本标记，如果标记已存在，说明是jq时间爱你对象，没必要加工了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, prop, copy,</div><div class="line">    <span class="comment">/*获取事件的名称*/</span></div><div class="line">    type = event.type,</div><div class="line">    <span class="comment">/*将原生事件对象缓存*/</span></div><div class="line">    originalEvent = event,</div><div class="line">    <span class="comment">/*获取事件对象对应的钩子*/</span></div><div class="line">    fixHook = <span class="keyword">this</span>.fixHooks[ type ];</div><div class="line"></div><div class="line"><span class="comment">/*如果没有钩子，需要判断这个对象类型是鼠标事件还是键盘事件*/</span></div><div class="line"><span class="keyword">if</span> ( !fixHook ) {</div><div class="line">    <span class="keyword">this</span>.fixHooks[ type ] = fixHook =</div><div class="line">        rmouseEvent.test( type ) ? <span class="keyword">this</span>.mouseHooks :</div><div class="line">        rkeyEvent.test( type ) ? <span class="keyword">this</span>.keyHooks :</div><div class="line">        {};</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里会获取特殊事件的钩子，如果没有钩子，那需要判断事件是鼠标事件还是按键事件，这俩都需要特别处理。另外也会做缓存，获取到钩子后写入到fixHooks中，下次同样类型的事件就能直接获取钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*获取鼠标事件或键盘事件应当拷贝的相关属性的列表*/</span></div><div class="line">copy = fixHook.props ? <span class="keyword">this</span>.props.concat( fixHook.props ) : <span class="keyword">this</span>.props;</div><div class="line"></div><div class="line"><span class="comment">/*新建一个包装了原生事件对象的jq事件对象*/</span></div><div class="line">event = <span class="keyword">new</span> jQuery.Event( originalEvent );</div><div class="line"><span class="comment">/*将这些需要拷贝的属性全部拷贝到jq事件对象中*/</span></div><div class="line">i = copy.length;</div><div class="line"><span class="keyword">while</span> ( i-- ) {</div><div class="line">    prop = copy[ i ];</div><div class="line">    event[ prop ] = originalEvent[ prop ];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>鼠标类型事件和按键类型时间都有自己的一些属性，当然还有些公有属性，这里需要获取事件应当从原生事件中拷贝值名称的列表。获取到列表后新建一个jq事件对象进行拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !event.target ) {</div><div class="line">    event.target = <span class="built_in">document</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ( event.target.nodeType === <span class="number">3</span> ) {</div><div class="line">    event.target = event.target.parentNode;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里修复了一些事件target不正确的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> fixHook.filter ? fixHook.filter( event, originalEvent ) : event;</div></pre></td></tr></table></figure>

<p>最后再通过filter钩子做一下最后的加工处理。处理完成之后，返回jq的事件对象</p>
<h3 id="鼠标事件和键盘事件的处理">鼠标事件和键盘事件的处理</h3>
<p>fix中都是调用钩子来获得元素列表和filter最后处理，在事件管理器中定义了鼠标事件和键盘事件需要的属性</p>
<h4 id="公有属性">公有属性</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">props: <span class="string">"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which"</span>.split(<span class="string">" "</span>),</div></pre></td></tr></table></figure>

<p>这些是鼠标和键盘事件公有的属性</p>
<h4 id="键盘事件">键盘事件</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">keyHooks: {</div><div class="line">    props: <span class="string">"char charCode key keyCode"</span>.split(<span class="string">" "</span>),</div><div class="line">    filter: <span class="function"><span class="keyword">function</span><span class="params">( event, original )</span> </span>{</div><div class="line"></div><div class="line">        <span class="comment">// Add which for key events</span></div><div class="line">        <span class="keyword">if</span> ( event.which == <span class="literal">null</span> ) {</div><div class="line">            event.which = original.charCode != <span class="literal">null</span> ? original.charCode : original.keyCode;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> event;</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<p>这里是键盘钩子，定义了键盘事件特有属性以及其filter，filter主要是将如charCode、keyCode等进行统一，创建出符合W3C标准的which</p>
<h4 id="鼠标事件">鼠标事件</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">mouseHooks: {</div><div class="line">    props: <span class="string">"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement"</span>.split(<span class="string">" "</span>),</div><div class="line">    filter: <span class="function"><span class="keyword">function</span><span class="params">( event, original )</span> </span>{</div><div class="line">        <span class="keyword">var</span> eventDoc, doc, body,</div><div class="line">            button = original.button;</div><div class="line">        <span class="keyword">if</span> ( event.pageX == <span class="literal">null</span> && original.clientX != <span class="literal">null</span> ) {</div><div class="line">            eventDoc = event.target.ownerDocument || <span class="built_in">document</span>;</div><div class="line">            doc = eventDoc.documentElement;</div><div class="line">            body = eventDoc.body;</div><div class="line">            event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || <span class="number">0</span> ) - ( doc && doc.clientLeft || body && body.clientLeft || <span class="number">0</span> );</div><div class="line">            event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || <span class="number">0</span> ) - ( doc && doc.clientTop  || body && body.clientTop  || <span class="number">0</span> );</div><div class="line">        }</div><div class="line">        <span class="keyword">if</span> ( !event.which && button !== <span class="literal">undefined</span> ) {</div><div class="line">            event.which = ( button & <span class="number">1</span> ? <span class="number">1</span> : ( button & <span class="number">2</span> ? <span class="number">3</span> : ( button & <span class="number">4</span> ? <span class="number">2</span> : <span class="number">0</span> ) ) );</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> event;</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<p>同样的方式，定义了鼠标事件特有的属性，另外做了一个兼容，做出了pageX、pageY、which等属性</p>
<h2 id="特殊事件">特殊事件</h2>
<p>上一篇讲了jq事件核心，可以看到针对特殊事件，基本上每个地方都需要通过钩子特殊处理，那么有哪些特殊事件呢？这些在事件管理器的special里都有：</p>
<h3 id="load">load</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">load: {</div><div class="line">    <span class="comment">// Prevent triggered image.load events from bubbling to window.load</span></div><div class="line">    noBubble: <span class="literal">true</span></div><div class="line">},</div></pre></td></tr></table></figure>

<p>load事件不冒泡，需要注意</p>
<h3 id="focus和blur">focus和blur</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">focus: {</div><div class="line">    <span class="comment">// Fire native event if possible so blur/focus sequence is correct</span></div><div class="line">    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span> !== safeActiveElement() && <span class="keyword">this</span>.focus ) {</div><div class="line">            <span class="keyword">this</span>.focus();</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        }</div><div class="line">    },</div><div class="line">    delegateType: <span class="string">"focusin"</span></div><div class="line">},</div><div class="line">blur: {</div><div class="line">    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span> === safeActiveElement() && <span class="keyword">this</span>.blur ) {</div><div class="line">            <span class="keyword">this</span>.blur();</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        }</div><div class="line">    },</div><div class="line">    delegateType: <span class="string">"focusout"</span></div><div class="line">},</div></pre></td></tr></table></figure>

<p>focus和blur事件，这俩有自己的trigger钩子，另外其使用代理时名称也不同。事实上focus和blur除了trigger钩子，还有在事件注册和事件删除时的setup和teardown钩子，可以看到代码如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !support.focusinBubbles ) {</div><div class="line">    jQuery.each({ focus: <span class="string">"focusin"</span>, blur: <span class="string">"focusout"</span> }, <span class="function"><span class="keyword">function</span><span class="params">( orig, fix )</span> </span>{</div><div class="line">        <span class="comment">// Attach a single capturing handler on the document while someone wants focusin/focusout</span></div><div class="line">        <span class="keyword">var</span> handler = <span class="function"><span class="keyword">function</span><span class="params">( event )</span> </span>{</div><div class="line">                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), <span class="literal">true</span> );</div><div class="line">            };</div><div class="line">        jQuery.event.special[ fix ] = {</div><div class="line">            setup: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                <span class="keyword">var</span> doc = <span class="keyword">this</span>.ownerDocument || <span class="keyword">this</span>,</div><div class="line">                    attaches = data_priv.access( doc, fix );</div><div class="line">                <span class="keyword">if</span> ( !attaches ) {</div><div class="line">                    doc.addEventListener( orig, handler, <span class="literal">true</span> );</div><div class="line">                }</div><div class="line">                data_priv.access( doc, fix, ( attaches || <span class="number">0</span> ) + <span class="number">1</span> );</div><div class="line">            },</div><div class="line">            teardown: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                <span class="keyword">var</span> doc = <span class="keyword">this</span>.ownerDocument || <span class="keyword">this</span>,</div><div class="line">                    attaches = data_priv.access( doc, fix ) - <span class="number">1</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( !attaches ) {</div><div class="line">                    doc.removeEventListener( orig, handler, <span class="literal">true</span> );</div><div class="line">                    data_priv.remove( doc, fix );</div><div class="line"></div><div class="line">                } <span class="keyword">else</span> {</div><div class="line">                    data_priv.access( doc, fix, attaches );</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="click">click</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">click: {</div><div class="line">    <span class="comment">// For checkbox, fire native event so checked state will be right</span></div><div class="line">    trigger: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>.type === <span class="string">"checkbox"</span> && <span class="keyword">this</span>.click && jQuery.nodeName( <span class="keyword">this</span>, <span class="string">"input"</span> ) ) {</div><div class="line">            <span class="keyword">this</span>.click();</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        }</div><div class="line">    },</div><div class="line">    <span class="comment">/*浏览器兼容，如果元素是a标签，那么不触发原生click事件*/</span></div><div class="line">    <span class="comment">// For cross-browser consistency, don't fire native .click() on links</span></div><div class="line">    _default: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> </span>{</div><div class="line">        <span class="keyword">return</span> jQuery.nodeName( event.target, <span class="string">"a"</span> );</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<p>点击时间爱你，在checkbox上有钩子，调用其原生api。另外，当元素为a标签时，不触发原生click事件</p>
<h3 id="beforeunload">beforeunload</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">beforeunload: {</div><div class="line">    postDispatch: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> </span>{</div><div class="line"></div><div class="line">        <span class="comment">// Support: Firefox 20+</span></div><div class="line">        <span class="comment">// Firefox doesn't alert if the returnValue field is not set.</span></div><div class="line">        <span class="keyword">if</span> ( event.result !== <span class="literal">undefined</span> ) {</div><div class="line">            event.originalEvent.returnValue = event.result;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>beforeunlaod事件在ff中最后结果可能不同，需要做兼容</p>
<h3 id="mouseenter和mouseleave">mouseenter和mouseleave</h3>
<p>mouseover和mouseout的问题在于，他们只监听最外层的大容器，而大容器中是由很多子元素的。如果鼠标在子元素上，而离开了大容器，mouseout事件也会触发。</p>
<p>比如一个列式菜单，最上层菜单上有一些选项，鼠标悬停在选项上，右侧会出现该选项下的子选项。如果在菜单上使用mouseover和mouseout来绑定事件，当鼠标移动到子选项时，实际上移出了容器，会触发mouseout事件，菜单就被隐藏了…</p>
<p>jq通过新建两个事件mouseenter和mouseleave来防止这种情况发生</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">jQuery.each({</div><div class="line">    mouseenter: <span class="string">"mouseover"</span>,</div><div class="line">    mouseleave: <span class="string">"mouseout"</span></div><div class="line">}, <span class="function"><span class="keyword">function</span><span class="params">( orig, fix )</span> </span>{</div><div class="line">    jQuery.event.special[ orig ] = {</div><div class="line">        delegateType: fix,</div><div class="line">        bindType: fix,</div><div class="line"></div><div class="line">        handle: <span class="function"><span class="keyword">function</span><span class="params">( event )</span> </span>{</div><div class="line">            <span class="keyword">var</span> ret,</div><div class="line">                target = <span class="keyword">this</span>,</div><div class="line">                related = event.relatedTarget,</div><div class="line">                handleObj = event.handleObj;</div><div class="line"></div><div class="line">            <span class="comment">// For mousenter/leave call the handler if related is outside the target.</span></div><div class="line">            <span class="comment">// NB: No relatedTarget if the mouse left/entered the browser window</span></div><div class="line">            <span class="keyword">if</span> ( !related || (related !== target && !jQuery.contains( target, related )) ) {</div><div class="line">                event.type = handleObj.origType;</div><div class="line">                ret = handleObj.handler.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">                event.type = fix;</div><div class="line">            }</div><div class="line">            <span class="keyword">return</span> ret;</div><div class="line">        }</div><div class="line">    };</div><div class="line">});</div></pre></td></tr></table></figure>

<p>可以看到，这里可以看到，使用contains判断当前元素是否被包含在容器中，如果包含将不会执行回调函数</p>
<h2 id="jQuery对象上的方法">jQuery对象上的方法</h2>
<p>我们需要一系列的方法将事件用于jQuery对象之上，依旧是在fn上扩展，有如下一些方法：</p>
<ol>
<li>on： 绑定事件添加回调</li>
<li>one：绑定知识性一次的事件</li>
<li>off：移除事件</li>
<li>trigger：对每一个元素触发事件</li>
<li>triggerHandler：对jq对象中的第一个元素触发事件</li>
</ol>
<h3 id="on_(types,_selector,_data,_fn,_/*内部使用*/one)">on (types, selector, data, fn, /*内部使用*/one)</h3>
<p>jq使用on方法在元素时行绑定事件，这里types可以是一个<code>event1 event2</code>这样的字符串，同时绑定多个事件公用相同的回调函数fn。另外，当types为对象时，键为事件名称，值为回调函数，也可以一次绑定多个事件。这是一个多接口方法，需要根据传入的参数判断如何处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> types === <span class="string">"object"</span> ) {</div><div class="line">    <span class="comment">// ( types-Object, selector, data )</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector !== <span class="string">"string"</span> ) {</div><div class="line">        <span class="comment">// ( types-Object, data )</span></div><div class="line">        data = data || selector;</div><div class="line">        selector = <span class="literal">undefined</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">/*一次绑定多个事件*/</span></div><div class="line">    <span class="keyword">for</span> ( type <span class="keyword">in</span> types ) {</div><div class="line">        <span class="keyword">this</span>.on( type, selector, data, types[ type ], one );</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，这里就是处理types为对象的情况，这里实际上根据types中的每个键值对，递归调用了on方法进行单个绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*可以不提供数据*/</span></div><div class="line"><span class="keyword">if</span> ( data == <span class="literal">null</span> && fn == <span class="literal">null</span> ) {</div><div class="line">    <span class="comment">// ( types, fn )</span></div><div class="line">    <span class="comment">//情况1</span></div><div class="line">    fn = selector;</div><div class="line">    data = selector = <span class="literal">undefined</span>;</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ( fn == <span class="literal">null</span> ) {</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> selector === <span class="string">"string"</span> ) {</div><div class="line">        <span class="comment">// ( types, selector, fn )</span></div><div class="line">        <span class="comment">//情况2</span></div><div class="line">        fn = data;</div><div class="line">        data = <span class="literal">undefined</span>;</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// ( types, data, fn )</span></div><div class="line">        <span class="comment">//情况3</span></div><div class="line">        fn = data;</div><div class="line">        data = selector;</div><div class="line">        selector = <span class="literal">undefined</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ( fn === <span class="literal">false</span> ) {</div><div class="line">    fn = returnFalse;</div><div class="line">} <span class="keyword">else</span> <span class="keyword">if</span> ( !fn ) {</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理了三种情况：</p>
<ol>
<li>只有事件名称和回调函数</li>
<li>有事件名称，代理选择器和回调函数</li>
<li>有事件名称，事件数据和回调函数</li>
</ol>
<p>如果没有回调函数，需要给与一个默认的回调函数，这个默认回调函数直接<code>return false</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( one === <span class="number">1</span> ) {</div><div class="line">    origFn = fn;</div><div class="line">    fn = <span class="function"><span class="keyword">function</span><span class="params">( event )</span> </span>{</div><div class="line">        <span class="comment">// Can use an empty set, since event contains the info</span></div><div class="line">        jQuery().off( event );</div><div class="line">        <span class="keyword">return</span> origFn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> );</div><div class="line">    };</div><div class="line">    <span class="comment">// Use same guid so caller can remove using origFn</span></div><div class="line">    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以绑定一次性事件，实现骑士很简单，通过闭包对事件回调函数做一个包装，在其被运行之前，调用off移除掉事件就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.each( <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    jQuery.event.add( <span class="keyword">this</span>, types, fn, data, selector );</div><div class="line">});</div></pre></td></tr></table></figure>

<p>最后，确定好了配置，最后在jq对象中的每个元素上调用通过事件管理器的add方法添加事件回调函数</p>
<h3 id="one_(_types,_selector,_data,_fn_)">one ( types, selector, data, fn )</h3>
<p>绑定一次性事件，上面的on已经做了实现，这里只不过是调用一下接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">one: <span class="function"><span class="keyword">function</span><span class="params">( types, selector, data, fn )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.on( types, selector, data, fn, <span class="number">1</span> );</div><div class="line">},</div></pre></td></tr></table></figure>

<h3 id="off_(_types,_selector,_fn_)">off ( types, selector, fn )</h3>
<p>同样是个多接口函数，在只有事件名称时，直接删除整个事件。如果有确定回调函数，那么删除对应时间的对应回调函数。需要注意代理的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( types && types.preventDefault && types.handleObj ) {</div><div class="line">    <span class="comment">// ( event )  dispatched jQuery.Event</span></div><div class="line">    handleObj = types.handleObj;</div><div class="line">    jQuery( types.delegateTarget ).off(</div><div class="line">        handleObj.namespace ? handleObj.origType + <span class="string">"."</span> + handleObj.namespace : handleObj.origType,</div><div class="line">        handleObj.selector,</div><div class="line">        handleObj.handler</div><div class="line">    );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理的是参数是事件对象的情况，这种情况会在使用one绑定事件回调执行后自动删除时发生。获取事件对象其中的属性，递归调用off删除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> types === <span class="string">"object"</span> ) {</div><div class="line">    <span class="comment">// ( types-object [, selector] )</span></div><div class="line">    <span class="keyword">for</span> ( type <span class="keyword">in</span> types ) {</div><div class="line">        <span class="keyword">this</span>.off( type, selector, types[ type ] );</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果typs是事件名称到回调函数的键值对，那么对其中的每个键和值，分别进行删除，递归调用off删除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( selector === <span class="literal">false</span> || <span class="keyword">typeof</span> selector === <span class="string">"function"</span> ) {</div><div class="line">    <span class="comment">// ( types [, fn] )</span></div><div class="line">    fn = selector;</div><div class="line">    selector = <span class="literal">undefined</span>;</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ( fn === <span class="literal">false</span> ) {</div><div class="line">    fn = returnFalse;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理了只有事件名称和回调函数的接口情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    jQuery.event.remove( <span class="keyword">this</span>, types, fn, selector );</div><div class="line">});</div></pre></td></tr></table></figure>

<p>最后，对jq对象中的每个元素移除事件中的回调函数就好</p>
<h3 id="trigger_(type,_data)_和_triggerHandler_(type,_data)">trigger (type, data) 和 triggerHandler (type, data)</h3>
<p>没啥说的，都是直接用的事件管理器的trigger方法。只不过前者对每个元素调用一次，后者只对第一个元素调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*对jq对象中的每个元素触发事件*/</span></div><div class="line">trigger: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        jQuery.event.trigger( type, data, <span class="keyword">this</span> );</div><div class="line">    });</div><div class="line">},</div><div class="line"><span class="comment">/*对jq对象中的第一个元素触发事件*/</span></div><div class="line">triggerHandler: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> </span>{</div><div class="line">    <span class="keyword">var</span> elem = <span class="keyword">this</span>[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> ( elem ) {</div><div class="line">        <span class="keyword">return</span> jQuery.event.trigger( type, data, elem, <span class="literal">true</span> );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>这一篇直接看的话，肯定会不知所云…最好能结合上一篇一起看，上一篇介绍了事件机制的核心方法，这一篇主要是jq事件对象和一些兼容性问题的解决方法（主要是钩子）。jq的钩子方式很不错，在写框架对付兼容性问题时可以多多使用</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇主要介绍了jQuery中事件管理器的事件对象、兼容实现以及在jQuery对象上暴露的接口</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的事件机制——核心篇]]></title>
    <link href="http://lingyu.wang/2014/05/12/read-jq-src-3/"/>
    <id>http://lingyu.wang/2014/05/12/read-jq-src-3/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2014-09-18T15:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>
<a id="more"></a>

<h1 id="jQuery源码——事件机制">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>
<h2 id="事件管理器">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>
<h3 id="global">global</h3>
<p>存放事件是否存在</p>
<h3 id="add_(elem,_types,_handler,_data,_selector)">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>
<p>所以代码大致流程如下：</p>
<h4 id="事件创建逻辑">事件创建逻辑</h4>
<p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handleObjIn, eventHandle, tmp,</div><div class="line">    events, t, handleObj,</div><div class="line">    special, handlers, type, namespaces, origType,</div><div class="line">    elemData = data_priv.get( elem );</div><div class="line">    </div><div class="line"><span class="keyword">if</span> ( !elemData ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( handler.handler ) {</div><div class="line">    handleObjIn = handler;</div><div class="line">    handler = handleObjIn.handler;</div><div class="line">    selector = handleObjIn.selector;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !handler.guid ) {</div><div class="line">    handler.guid = jQuery.guid++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !(events = elemData.events) ) {</div><div class="line">    events = elemData.events = {};</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ( !(eventHandle = elemData.handle) ) {</div><div class="line">    eventHandle = elemData.handle = <span class="function"><span class="keyword">function</span><span class="params">( e )</span> </span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== strundefined && jQuery.event.triggered !== e.type ?</div><div class="line">            jQuery.event.dispatch.apply( elem, <span class="built_in">arguments</span> ) : <span class="literal">undefined</span>;</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>
<h4 id="事件绑定逻辑">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];</div><div class="line">t = types.length;</div><div class="line"><span class="keyword">while</span> ( t-- ) {</div><div class="line">    <span class="comment">//后面的代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tmp = rtypenamespace.exec( types[t] ) || [];</div><div class="line">type = origType = tmp[<span class="number">1</span>];</div><div class="line">namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( !type ) {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line"></div><div class="line">type = ( selector ? special.delegateType : special.bindType ) || type;</div><div class="line"></div><div class="line">special = jQuery.event.special[ type ] || {};</div></pre></td></tr></table></figure>

<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">handleObj = jQuery.extend({</div><div class="line">    type: type,</div><div class="line">    origType: origType,</div><div class="line">    data: data,</div><div class="line">    handler: handler,</div><div class="line">    guid: handler.guid,</div><div class="line">    selector: selector,</div><div class="line">    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),</div><div class="line">    namespace: namespaces.join(<span class="string">"."</span>)</div><div class="line">}, handleObjIn );</div></pre></td></tr></table></figure>

<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>
<ol>
<li>type：事件的映射后的名称</li>
<li>origType：事件的原始名称</li>
<li>data：事件的默认数据</li>
<li>handler：回调函数</li>
<li>guid：回调函数的id</li>
<li>selector：启用事件代理时，被代理的节点的选择器</li>
<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>
<li>namespace：重组后的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !(handlers = events[ type ]) ) {</div><div class="line">    handlers = events[ type ] = [];</div><div class="line">    handlers.delegateCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) {</div><div class="line">        <span class="keyword">if</span> ( elem.addEventListener ) {</div><div class="line">            elem.addEventListener( type, eventHandle, <span class="literal">false</span> );</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.add ) {</div><div class="line">    special.add.call( elem, handleObj );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( !handleObj.handler.guid ) {</div><div class="line">        handleObj.handler.guid = handler.guid;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( selector ) {</div><div class="line">    handlers.splice( handlers.delegateCount++, <span class="number">0</span>, handleObj );</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    handlers.push( handleObj );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jQuery.event.global[ type ] = <span class="literal">true</span>;</div></pre></td></tr></table></figure>

<p>最后再全局中标记一下事件已存在就行了</p>
<h3 id="remove_(elem,_types,_handler,_selector,_mappedTypes)">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>
<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> j, origCount, tmp,</div><div class="line">    events, t, handleObj,</div><div class="line">    special, handlers, type, namespaces, origType,</div><div class="line">    elemData = data_priv.hasData( elem ) && data_priv.get( elem );</div><div class="line"><span class="keyword">if</span> ( !elemData || !(events = elemData.events) ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];</div><div class="line">t = types.length;</div><div class="line"><span class="keyword">while</span> ( t-- ) {</div><div class="line">    <span class="comment">//后面的代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况1，和上面的add一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmp = rtypenamespace.exec( types[t] ) || [];</div><div class="line">type = origType = tmp[<span class="number">1</span>];</div><div class="line"></div><div class="line">namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();</div></pre></td></tr></table></figure>

<p>获取事件的命名空间，和add方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !type ) {</div><div class="line">    <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) {</div><div class="line">        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="literal">true</span> );</div><div class="line">    }</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line">type = ( selector ? special.delegateType : special.bindType ) || type;</div><div class="line">handlers = events[ type ] || [];</div><div class="line">origCount = j = handlers.length;</div><div class="line"><span class="keyword">while</span> ( j-- ) {</div><div class="line">    <span class="comment">//详细删除代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">handleObj = handlers[ j ];</div><div class="line"><span class="keyword">if</span> ( ( mappedTypes || origType === handleObj.origType ) &&</div><div class="line">    ( !handler || handler.guid === handleObj.guid ) &&</div><div class="line">    ( !tmp || tmp.test( handleObj.namespace ) ) &&</div><div class="line">    ( !selector || selector === handleObj.selector || selector === <span class="string">"**"</span> && handleObj.selector ) ) {</div><div class="line">    handlers.splice( j, <span class="number">1</span> );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( handleObj.selector ) {</div><div class="line">        handlers.delegateCount--;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> ( special.remove ) {</div><div class="line">        special.remove.call( elem, handleObj );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( origCount && !handlers.length ) {</div><div class="line">    <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class="literal">false</span> ) {</div><div class="line">        jQuery.removeEvent( elem, type, elemData.handle );</div><div class="line">    }</div><div class="line">    <span class="keyword">delete</span> events[ type ];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) {</div><div class="line">    <span class="keyword">delete</span> elemData.handle;</div><div class="line">    data_priv.remove( elem, <span class="string">"events"</span> );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>
<h3 id="trigger_(event,_data,_elem,_onlyHandlers)">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, cur, tmp, bubbleType, ontype, handle, special,</div><div class="line">    eventPath = [ elem || <span class="built_in">document</span> ],</div><div class="line">    type = hasOwn.call( event, <span class="string">"type"</span> ) ? event.type : event,</div><div class="line">    namespaces = hasOwn.call( event, <span class="string">"namespace"</span> ) ? event.namespace.split(<span class="string">"."</span>) : [];</div><div class="line"></div><div class="line">cur = tmp = elem = elem || <span class="built_in">document</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>检测是否有focus和blur事件，它们不会在这里被触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt;= <span class="number">0</span> ) {</div><div class="line">    namespaces = type.split(<span class="string">"."</span>);</div><div class="line">    type = namespaces.shift();</div><div class="line">    namespaces.sort();</div><div class="line">}</div><div class="line">ontype = type.indexOf(<span class="string">":"</span>) &lt; <span class="number">0</span> && <span class="string">"on"</span> + type;</div></pre></td></tr></table></figure>

<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">event = event[ jQuery.expando ] ?</div><div class="line">    event :</div><div class="line">    <span class="keyword">new</span> jQuery.Event( type, <span class="keyword">typeof</span> event === <span class="string">"object"</span> && event );</div><div class="line"></div><div class="line">event.isTrigger = onlyHandlers ? <span class="number">2</span> : <span class="number">3</span>;</div><div class="line">event.namespace = namespaces.join(<span class="string">"."</span>);</div><div class="line">event.namespace_re = event.namespace ?</div><div class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(^|\\.)"</span> + namespaces.join(<span class="string">"\\.(?:.*\\.|)"</span>) + <span class="string">"(\\.|$)"</span> ) :</div><div class="line">    <span class="literal">null</span>;</div><div class="line"></div><div class="line">event.result = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">if</span> ( !event.target ) {</div><div class="line">    event.target = elem;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>
<ol>
<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>
<li>namespace: 事件的命名空间</li>
<li>namespace_re: 一个用于匹配当前命名空间的正则</li>
<li>result: 事件运行的结果</li>
<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>
</ol>
<p>事件对象的具体实现，后面会说</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">data = data == <span class="literal">null</span> ?</div><div class="line">    [ event ] :</div><div class="line">    jQuery.makeArray( data, [ event ] );</div><div class="line"></div><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line"><span class="keyword">if</span> ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === <span class="literal">false</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {</div><div class="line">    <span class="comment">/*如果是特殊事件，需要找到对应的真实名称*/</span></div><div class="line">    bubbleType = special.delegateType || type;</div><div class="line">    <span class="keyword">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {</div><div class="line">        cur = cur.parentNode;</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> ( ; cur; cur = cur.parentNode ) {</div><div class="line">        eventPath.push( cur );</div><div class="line">        tmp = cur;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span></div><div class="line">    <span class="keyword">if</span> ( tmp === (elem.ownerDocument || <span class="built_in">document</span>) ) {</div><div class="line">        eventPath.push( tmp.defaultView || tmp.parentWindow || <span class="built_in">window</span> );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {</div><div class="line">    event.type = i &gt; <span class="number">1</span> ?</div><div class="line">        bubbleType :</div><div class="line">        special.bindType || type;</div><div class="line"></div><div class="line">    handle = ( data_priv.get( cur, <span class="string">"events"</span> ) || {} )[ event.type ] && data_priv.get( cur, <span class="string">"handle"</span> );</div><div class="line">    <span class="keyword">if</span> ( handle ) {</div><div class="line">        handle.apply( cur, data );</div><div class="line">    }</div><div class="line"></div><div class="line">    handle = ontype && cur[ ontype ];</div><div class="line">    <span class="keyword">if</span> ( handle && handle.apply && jQuery.acceptData( cur ) ) {</div><div class="line">        event.result = handle.apply( cur, data );</div><div class="line">        <span class="keyword">if</span> ( event.result === <span class="literal">false</span> ) {</div><div class="line">            event.preventDefault();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">event.type = type;</div></pre></td></tr></table></figure>

<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !onlyHandlers && !event.isDefaultPrevented() ) {</div><div class="line">    <span class="keyword">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="literal">false</span>) &&</div><div class="line">        jQuery.acceptData( elem ) ) {</div><div class="line">        <span class="keyword">if</span> ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {</div><div class="line">            tmp = elem[ ontype ];</div><div class="line">            <span class="keyword">if</span> ( tmp ) {</div><div class="line">                elem[ ontype ] = <span class="literal">null</span>;</div><div class="line">            }</div><div class="line">            jQuery.event.triggered = type;</div><div class="line">            elem[ type ]();</div><div class="line">            jQuery.event.triggered = <span class="literal">undefined</span>;</div><div class="line">            <span class="keyword">if</span> ( tmp ) {</div><div class="line">                elem[ ontype ] = tmp;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> event.result;</div></pre></td></tr></table></figure>

<p>运行完了，返回事件运行的结果</p>
<h3 id="dispatch_(event)">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>
<ol>
<li>事件代理的情况</li>
<li>特殊事件</li>
<li>回调终止（stopPropagation）</li>
<li>事件的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">event = jQuery.event.fix( event );</div><div class="line"></div><div class="line"><span class="keyword">var</span> i, j, ret, matched, handleObj,</div><div class="line">    handlerQueue = [],</div><div class="line">    args = slice.call( <span class="built_in">arguments</span> ),</div><div class="line">    handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="string">"events"</span> ) || {} )[ event.type ] || [],</div><div class="line">    special = jQuery.event.special[ event.type ] || {};</div><div class="line"></div><div class="line">args[<span class="number">0</span>] = event;</div><div class="line">event.delegateTarget = <span class="keyword">this</span>;</div></pre></td></tr></table></figure>

<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.preDispatch && special.preDispatch.call( <span class="keyword">this</span>, event ) === <span class="literal">false</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );</div></pre></td></tr></table></figure>

<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {</div><div class="line">    event.currentTarget = matched.elem;</div><div class="line">    j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {</div><div class="line">        <span class="keyword">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {</div><div class="line">            event.handleObj = handleObj;</div><div class="line">            event.data = handleObj.data;</div><div class="line">            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )</div><div class="line">                    .apply( matched.elem, args );</div><div class="line">            <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) {</div><div class="line">                <span class="keyword">if</span> ( (event.result = ret) === <span class="literal">false</span> ) {</div><div class="line">                    event.preventDefault();</div><div class="line">                    event.stopPropagation();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>
<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.postDispatch ) {</div><div class="line">    special.postDispatch.call( <span class="keyword">this</span>, event );</div><div class="line">}</div><div class="line"><span class="keyword">return</span> event.result;</div></pre></td></tr></table></figure>

<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>
<h3 id="handlers_(event,_handlers)">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, matches, sel, handleObj,</div><div class="line">    handlerQueue = [],</div><div class="line">    delegateCount = handlers.delegateCount,</div><div class="line">    cur = event.target;</div></pre></td></tr></table></figure>

<p>获取当前事件的目标和代理个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果存在代理</span></div><div class="line"><span class="keyword">if</span> ( delegateCount && cur.nodeType && (!event.button || event.type !== <span class="string">"click"</span>) ) {</div><div class="line">    <span class="comment">//从被代理元素冒泡到代理元素</span></div><div class="line">    <span class="keyword">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || <span class="keyword">this</span> ) {</div><div class="line">        <span class="comment">//屏蔽disable元素的点击事件</span></div><div class="line">        <span class="keyword">if</span> ( cur.disabled !== <span class="literal">true</span> || event.type !== <span class="string">"click"</span> ) {</div><div class="line">            <span class="comment">//cur元素需要执行的回调对象列表</span></div><div class="line">            matches = [];</div><div class="line">            <span class="comment">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span></div><div class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; delegateCount; i++ ) {</div><div class="line">                handleObj = handlers[ i ];</div><div class="line">                sel = handleObj.selector + <span class="string">" "</span>;</div><div class="line">                <span class="comment">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span></div><div class="line">                <span class="keyword">if</span> ( matches[ sel ] === <span class="literal">undefined</span> ) {</div><div class="line">                    matches[ sel ] = handleObj.needsContext ?</div><div class="line">                        jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= <span class="number">0</span> :</div><div class="line">                        jQuery.find( sel, <span class="keyword">this</span>, <span class="literal">null</span>, [ cur ] ).length;</div><div class="line">                }</div><div class="line">                <span class="comment">//如果符合,说明cur元素需要执行这个回调,加到列表中</span></div><div class="line">                <span class="keyword">if</span> ( matches[ sel ] ) {</div><div class="line">                    matches.push( handleObj );</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span></div><div class="line">            <span class="keyword">if</span> ( matches.length ) {</div><div class="line">                handlerQueue.push({ elem: cur, handlers: matches });</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>
<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>
<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>
<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( delegateCount &lt; handlers.length ) {</div><div class="line">    handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });</div><div class="line">}</div><div class="line"><span class="keyword">return</span> handlerQueue;</div></pre></td></tr></table></figure>

<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>
<h2 id="总结">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>
]]></content>
    <summary type="html">
    <![CDATA[这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的数据缓存]]></title>
    <link href="http://lingyu.wang/2014/05/10/read-jq-src-2/"/>
    <id>http://lingyu.wang/2014/05/10/read-jq-src-2/</id>
    <published>2014-05-09T16:00:00.000Z</published>
    <updated>2014-09-18T15:00:38.000Z</updated>
    <content type="html"><![CDATA[<p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>
<a id="more"></a>

<h2 id="jQuery的数据缓存简介">jQuery的数据缓存简介</h2>
<p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>
<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>
<h2 id="jq中数据缓存的限制">jq中数据缓存的限制</h2>
<p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery.acceptData = <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> </span>{</div><div class="line">    <span class="keyword">return</span> owner.nodeType === <span class="number">1</span> || owner.nodeType === <span class="number">9</span> || !( +owner.nodeType );</div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="数据对象">数据对象</h2>
<p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Data</span><span class="params">()</span> </span>{</div><div class="line">    <span class="comment">/*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty( <span class="keyword">this</span>.cache = {}, <span class="number">0</span>, {</div><div class="line">        get: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            <span class="keyword">return</span> {};</div><div class="line">        }</div><div class="line">    });</div><div class="line">    <span class="comment">/*为这个数据对象添上jQuery版本号+随机数的版本号*/</span></div><div class="line">    <span class="keyword">this</span>.expando = jQuery.expando + <span class="built_in">Math</span>.random();</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="静态方法和属性">静态方法和属性</h3>
<h4 id="uid">uid</h4>
<p>数据对象的id，自增</p>
<h4 id="accepts">accepts</h4>
<p>判断是否能够接受数据，直接指向之前的acceptData</p>
<h3 id="核心方法">核心方法</h3>
<h4 id="key_(owner)">key (owner)</h4>
<p>owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>
<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>
<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>
<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>
<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">key: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> </span>{</div><div class="line">    <span class="comment">/*如果这个所有者不能接收数据，返回0*/</span></div><div class="line">    <span class="keyword">if</span> ( !Data.accepts( owner ) ) {</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">var</span> descriptor = {},</div><div class="line">        <span class="comment">/*获取这个所有者已经有这个版本的数据的id*/</span></div><div class="line">        unlock = owner[ <span class="keyword">this</span>.expando ];</div><div class="line">    <span class="comment">/*如果这个所有者没有对应的数据对象，那么创建一个*/</span></div><div class="line">    <span class="keyword">if</span> ( !unlock ) {</div><div class="line">        <span class="comment">/*自增的uid*/</span></div><div class="line">        unlock = Data.uid++;</div><div class="line">        <span class="comment">/*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/</span></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            descriptor[ <span class="keyword">this</span>.expando ] = { value: unlock };</div><div class="line">            <span class="built_in">Object</span>.defineProperties( owner, descriptor );</div><div class="line">        <span class="comment">/*如果不能使用Object.defineProperites，那么直接使用extend*/</span></div><div class="line">        } <span class="keyword">catch</span> ( e ) {</div><div class="line">            descriptor[ <span class="keyword">this</span>.expando ] = unlock;</div><div class="line">            jQuery.extend( owner, descriptor );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*在cache中创建对象的数据空间*/</span></div><div class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.cache[ unlock ] ) {</div><div class="line">        <span class="keyword">this</span>.cache[ unlock ] = {};</div><div class="line">    }</div><div class="line">    <span class="comment">/*返回这个新的id*/</span></div><div class="line">    <span class="keyword">return</span> unlock;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="set_(owner,_data,_value)">set (owner, data, value)</h4>
<p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>
<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>
<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>
<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*加入数据（往cache中加数据）*/</span></div><div class="line">set: <span class="function"><span class="keyword">function</span><span class="params">( owner, data, value )</span> </span>{</div><div class="line">    <span class="keyword">var</span> prop,</div><div class="line">        <span class="comment">/*首先获得这个所有者的id（没有就新建一个）*/</span></div><div class="line">        unlock = <span class="keyword">this</span>.key( owner ),</div><div class="line">        <span class="comment">/*获得这个数据对象对应的cache内的空间*/</span></div><div class="line">        cache = <span class="keyword">this</span>.cache[ unlock ];</div><div class="line"></div><div class="line">    <span class="comment">/*如果数据时string直接写进去*/</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> data === <span class="string">"string"</span> ) {</div><div class="line">        cache[ data ] = value;</div><div class="line"></div><div class="line">    <span class="comment">/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> ( jQuery.isEmptyObject( cache ) ) {</div><div class="line">            jQuery.extend( <span class="keyword">this</span>.cache[ unlock ], data );</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> ( prop <span class="keyword">in</span> data ) {</div><div class="line">                cache[ prop ] = data[ prop ];</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> cache;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="get_(owner,_key)">get (owner, key)</h4>
<p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>
<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*获取数据（从cache中取数据）*/</span></div><div class="line">get: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> </span>{</div><div class="line">    <span class="comment">/*通过owner获取id，从cache中获取在对应的完整缓存对象*/</span></div><div class="line">    <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache[ <span class="keyword">this</span>.key( owner ) ];</div><div class="line">    <span class="comment">/*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/</span></div><div class="line">    <span class="keyword">return</span> key === <span class="literal">undefined</span> ?</div><div class="line">        cache : cache[ key ];</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="access_(owner,_key,_value)">access (owner, key, value)</h4>
<p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>
<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：</p>
<ol>
<li>如果没有key和value，那么使用get方法获取整个数据空间对象</li>
<li>如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值</li>
<li>如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中</li>
<li>如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">access: <span class="function"><span class="keyword">function</span><span class="params">( owner, key, value )</span> </span>{</div><div class="line">    <span class="keyword">var</span> stored;</div><div class="line">    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ||</div><div class="line">            ((key && <span class="keyword">typeof</span> key === <span class="string">"string"</span>) && value === <span class="literal">undefined</span>) ) {</div><div class="line"></div><div class="line">        stored = <span class="keyword">this</span>.get( owner, key );</div><div class="line"></div><div class="line">        <span class="keyword">return</span> stored !== <span class="literal">undefined</span> ?</div><div class="line">            stored : <span class="keyword">this</span>.get( owner, jQuery.camelCase(key) );</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.set( owner, key, value );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> value !== <span class="literal">undefined</span> ? value : key;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="remove_(owner,_key)">remove (owner, key)</h4>
<p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>
<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*从owner移除属性 */</span></div><div class="line">remove: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> </span>{</div><div class="line">    <span class="keyword">var</span> i, name, camel,</div><div class="line">        unlock = <span class="keyword">this</span>.key( owner ),</div><div class="line">        cache = <span class="keyword">this</span>.cache[ unlock ];</div><div class="line">    <span class="comment">/*如果没有key，移除整个owner所拥有的缓存*/</span></div><div class="line">    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {</div><div class="line">        <span class="keyword">this</span>.cache[ unlock ] = {};</div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// Support array or space separated string of keys</span></div><div class="line">        <span class="comment">/*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/</span></div><div class="line">        <span class="keyword">if</span> ( jQuery.isArray( key ) ) {</div><div class="line">            name = key.concat( key.map( jQuery.camelCase ) );</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">/*如果key不是数组，将key转成驼峰*/</span></div><div class="line">            camel = jQuery.camelCase( key );</div><div class="line">            <span class="comment">/*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/</span></div><div class="line">            <span class="keyword">if</span> ( key <span class="keyword">in</span> cache ) {</div><div class="line">                name = [ key, camel ];</div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                <span class="comment">/*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/</span></div><div class="line">                name = camel;</div><div class="line">                <span class="comment">/*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/</span></div><div class="line">                name = name <span class="keyword">in</span> cache ?</div><div class="line">                    [ name ] : ( name.match( rnotwhite ) || [] );</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">/*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/</span></div><div class="line">        i = name.length;</div><div class="line">        <span class="keyword">while</span> ( i-- ) {</div><div class="line">            <span class="keyword">delete</span> cache[ name[ i ] ];</div><div class="line">        }</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="hasData_(owner)">hasData (owner)</h4>
<p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*判断是否存在数据*/</span></div><div class="line">hasData: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> </span>{</div><div class="line">    <span class="comment">/*判断缓存对象是否是空对象*/</span></div><div class="line">    <span class="keyword">return</span> !jQuery.isEmptyObject(</div><div class="line">        <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ] || {}</div><div class="line">    );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="discard_(owner)">discard (owner)</h4>
<p>移除掉owner的所有缓存，直接在cache上用delete删</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*移除整个缓存对象*/</span></div><div class="line">discard: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> </span>{</div><div class="line">    <span class="keyword">if</span> ( owner[ <span class="keyword">this</span>.expando ] ) {</div><div class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="数据对象创建">数据对象创建</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*私有数据对象*/</span></div><div class="line"><span class="keyword">var</span> data_priv = <span class="keyword">new</span> Data();</div><div class="line"><span class="comment">/*公有数据对象*/</span></div><div class="line"><span class="keyword">var</span> data_user = <span class="keyword">new</span> Data();</div></pre></td></tr></table></figure>

<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>
<h2 id="jQuery对数据对象操作接口">jQuery对数据对象操作接口</h2>
<h3 id="dataAttr方法">dataAttr方法</h3>
<p>事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function dataAttr( elem, key, <span class="built_in">data</span> ) {</div><div class="line">    <span class="built_in">var</span> name;</div><div class="line"></div><div class="line">    <span class="comment">/*如果没有data，而元素为element类型*/</span></div><div class="line">    <span class="keyword">if</span> ( <span class="built_in">data</span> <span class="subst">===</span> undefined <span class="subst">&&</span> elem<span class="built_in">.</span>nodeType <span class="subst">===</span> <span class="number">1</span> ) {</div><div class="line"></div><div class="line">        <span class="comment">/*从data-xxx属性中获取数据*/</span></div><div class="line">        name <span class="subst">=</span> <span class="string">"data-"</span> <span class="subst">+</span> key<span class="built_in">.</span>replace( rmultiDash, <span class="string">"-$1"</span> )<span class="built_in">.</span>toLowerCase();</div><div class="line">        <span class="built_in">data</span> <span class="subst">=</span> elem<span class="built_in">.</span>getAttribute( name );</div><div class="line">        <span class="comment">/*如果对象是字符串，分别尝试转成true、false、null，如果使用{}包裹，当做JSON解析*/</span></div><div class="line">        <span class="keyword">if</span> ( typeof <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"string"</span> ) {</div><div class="line">            try {</div><div class="line">                <span class="built_in">data</span> <span class="subst">=</span> <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"true"</span> <span class="subst">?</span> <span class="literal">true</span> :</div><div class="line">                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"false"</span> <span class="subst">?</span> <span class="literal">false</span> :</div><div class="line">                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"null"</span> <span class="subst">?</span> <span class="built_in">null</span> :</div><div class="line">                    <span class="comment">// Only convert to a number if it doesn't change the string</span></div><div class="line">                    <span class="subst">+</span><span class="built_in">data</span> <span class="subst">+</span> <span class="string">""</span> <span class="subst">===</span> <span class="built_in">data</span> <span class="subst">?</span> <span class="subst">+</span><span class="built_in">data</span> :</div><div class="line">                    rbrace<span class="built_in">.</span>test( <span class="built_in">data</span> ) <span class="subst">?</span> jQuery<span class="built_in">.</span>parseJSON( <span class="built_in">data</span> ) :</div><div class="line">                    <span class="built_in">data</span>;</div><div class="line">            } catch( e ) {}</div><div class="line"></div><div class="line">            <span class="comment">/*写入到公共数据对象中*/</span></div><div class="line">            data_user<span class="built_in">.</span><span class="built_in">set</span>( elem, key, <span class="built_in">data</span> );</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="built_in">data</span> <span class="subst">=</span> undefined;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="built_in">data</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="静态方法">静态方法</h3>
<p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>
<h4 id="hasData_(elem)">hasData (elem)</h4>
<p>判断元素是否含有数据，这里会检测公有数据和私有数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hasData: <span class="function"><span class="keyword">function</span><span class="params">( elem )</span> </span>{</div><div class="line">    <span class="keyword">return</span> data_user.hasData( elem ) || data_priv.hasData( elem );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="data_(elem,_name,_data)">data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> </span>{</div><div class="line">    <span class="keyword">return</span> data_user.access( elem, name, data );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="removeData_(elem,_name)">removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> </span>{</div><div class="line">    data_user.remove( elem, name );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="_data_(elem,_name,_data)">_data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> </span>{</div><div class="line">    <span class="keyword">return</span> data_priv.access( elem, name, data );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="_removeData_(elem,_name)">_removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> </span>{</div><div class="line">    data_priv.remove( elem, name );</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="在jq对象上添加数据对象操作方法">在jq对象上添加数据对象操作方法</h3>
<p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>
<h4 id="data_(key,_value)">data (key, value)</h4>
<p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：</p>
<ol>
<li>如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象</li>
<li>如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象</li>
<li>否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">data: <span class="function"><span class="keyword">function</span><span class="params">( key, value )</span> </span>{</div><div class="line">    <span class="keyword">var</span> i, name, data,</div><div class="line">        elem = <span class="keyword">this</span>[ <span class="number">0</span> ],</div><div class="line">        attrs = elem && elem.attributes;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="comment">/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/</span></div><div class="line">    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {</div><div class="line">        <span class="comment">/*jq对象中有节点*/</span></div><div class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>.length ) {</div><div class="line">            <span class="comment">/*第一个节点的数据*/</span></div><div class="line">            data = data_user.get( elem );</div><div class="line">            <span class="comment">/*如果节点为element类型且私有数据中没有标记hasDataAttrs</span></div><div class="line">            将节点中的所有data-类型的属性写入到公共数据中</div><div class="line">            然后在私有数据中设定hasDataAttrs为true*/</div><div class="line">            <span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> && !data_priv.get( elem, <span class="string">"hasDataAttrs"</span> ) ) {</div><div class="line">                i = attrs.length;</div><div class="line">                <span class="keyword">while</span> ( i-- ) {</div><div class="line">                    name = attrs[ i ].name;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ( name.indexOf( <span class="string">"data-"</span> ) === <span class="number">0</span> ) {</div><div class="line">                        name = jQuery.camelCase( name.slice(<span class="number">5</span>) );</div><div class="line">                        dataAttr( elem, name, data[ name ] );</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                data_priv.set( elem, <span class="string">"hasDataAttrs"</span>, <span class="literal">true</span> );</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> key === <span class="string">"object"</span> ) {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            data_user.set( <span class="keyword">this</span>, key );</div><div class="line">        });</div><div class="line">    }</div><div class="line">    <span class="comment">/*通过access判断*/</span></div><div class="line">    <span class="keyword">return</span> access( <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span><span class="params">( value )</span> </span>{</div><div class="line">        <span class="keyword">var</span> data,</div><div class="line">            <span class="comment">/*生成驼峰的key*/</span></div><div class="line">            camelKey = jQuery.camelCase( key );</div><div class="line">        <span class="comment">/*如果jq对象中有元素，且没有value，说明调用get获取数据*/</span></div><div class="line">        <span class="keyword">if</span> ( elem && value === <span class="literal">undefined</span> ) {</div><div class="line">            <span class="comment">/*直接使用key获取*/</span></div><div class="line">            data = data_user.get( elem, key );</div><div class="line">            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {</div><div class="line">                <span class="keyword">return</span> data;</div><div class="line">            }</div><div class="line">            <span class="comment">/*如果直接用key未能获取导数据，尝试驼峰格式的key*/</span></div><div class="line">            data = data_user.get( elem, camelKey );</div><div class="line">            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {</div><div class="line">                <span class="keyword">return</span> data;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*如果还是无法获取，尝试从data-属性获取*/</span></div><div class="line">            data = dataAttr( elem, camelKey, <span class="literal">undefined</span> );</div><div class="line">            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {</div><div class="line">                <span class="keyword">return</span> data;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*我们尝试了所有情况，但还是没有数据，返回undefined*/</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/*写入数据*/</span></div><div class="line">        <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            <span class="comment">/*通过驼峰形式key获取公共数据*/</span></div><div class="line">            <span class="keyword">var</span> data = data_user.get( <span class="keyword">this</span>, camelKey );</div><div class="line">            <span class="comment">/*往驼峰形式key中写入公共数据*/</span></div><div class="line">            data_user.set( <span class="keyword">this</span>, camelKey, value );</div><div class="line"></div><div class="line">            <span class="comment">/*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/</span></div><div class="line">            <span class="keyword">if</span> ( key.indexOf(<span class="string">"-"</span>) !== -<span class="number">1</span> && data !== <span class="literal">undefined</span> ) {</div><div class="line">                data_user.set( <span class="keyword">this</span>, key, value );</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }, <span class="literal">null</span>, value, <span class="built_in">arguments</span>.length &gt; <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">true</span> );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="removeData_(key)">removeData (key)</h4>
<p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*从公共数据中移除包含key（或key中元素）的键值对*/</span></div><div class="line">removeData: <span class="function"><span class="keyword">function</span><span class="params">( key )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        data_user.remove( <span class="keyword">this</span>, key );</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="为动画服务的queue和dequeue">为动画服务的queue和dequeue</h2>
<p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>
<h3 id="静态方法-1">静态方法</h3>
<h4 id="queue_(elem,_type,_data)">queue (elem, type, data)</h4>
<p>逻辑不复杂，也分读写两种情况。以<code>type + &quot;queue&quot;</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>
<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>
<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*压入或读取一组数据*/</span></div><div class="line">queue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type, data )</span> </span>{</div><div class="line">    <span class="keyword">var</span> queue;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( elem ) {</div><div class="line">        <span class="comment">/*重命名一下type，默认叫fxqueue*/</span></div><div class="line">        type = ( type || <span class="string">"fx"</span> ) + <span class="string">"queue"</span>;</div><div class="line">        <span class="comment">/*从私有数据中获得已有的queue数据*/</span></div><div class="line">        queue = data_priv.get( elem, type );</div><div class="line"></div><div class="line">        <span class="comment">/*如果存在data，需要写入数据*/</span></div><div class="line">        <span class="keyword">if</span> ( data ) {</div><div class="line">            <span class="comment">/*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/</span></div><div class="line">            <span class="keyword">if</span> ( !queue || jQuery.isArray( data ) ) {</div><div class="line">                queue = data_priv.access( elem, type, jQuery.makeArray(data) );</div><div class="line">            <span class="comment">/*之前有数据，直接把data连在数据数组后头*/</span></div><div class="line">            } <span class="keyword">else</span> {</div><div class="line">                queue.push( data );</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> queue || [];</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="dequeue_(elem,_type)">dequeue (elem, type)</h4>
<p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>
<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉*/</span></div><div class="line">dequeue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> </span>{</div><div class="line">    <span class="comment">/*获取type，默认为fx*/</span></div><div class="line">    type = type || <span class="string">"fx"</span>;</div><div class="line">    <span class="comment">/*获取一组数据*/</span></div><div class="line">    <span class="keyword">var</span> queue = jQuery.queue( elem, type ),</div><div class="line">        startLength = queue.length,</div><div class="line">        <span class="comment">/*获取状态*/</span></div><div class="line">        fn = queue.shift(),</div><div class="line">        <span class="comment">/*获取元素的钩子*/</span></div><div class="line">        hooks = jQuery._queueHooks( elem, type ),</div><div class="line">        next = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            jQuery.dequeue( elem, type );</div><div class="line">        };</div><div class="line"></div><div class="line">    <span class="comment">/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/</span></div><div class="line">    <span class="keyword">if</span> ( fn === <span class="string">"inprogress"</span> ) {</div><div class="line">        fn = queue.shift();</div><div class="line">        startLength--;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> ( fn ) {</div><div class="line"></div><div class="line">        <span class="comment">/*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/</span></div><div class="line">        <span class="keyword">if</span> ( type === <span class="string">"fx"</span> ) {</div><div class="line">            queue.unshift( <span class="string">"inprogress"</span> );</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/*删除掉钩子中的停止函数*/</span></div><div class="line">        <span class="keyword">delete</span> hooks.stop;</div><div class="line">        <span class="comment">/*在这个函数上调用，并提供钩子*/</span></div><div class="line">        fn.call( elem, next, hooks );</div><div class="line">    }</div><div class="line">    <span class="comment">/*如果队列已经空了，那么调用empty删除掉这个键值对*/</span></div><div class="line">    <span class="keyword">if</span> ( !startLength && hooks ) {</div><div class="line">        hooks.empty.fire();</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="_queueHooks_(elem,_type)">_queueHooks (elem, type)</h4>
<p>提供默认钩子的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_queueHooks: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> </span>{</div><div class="line">    <span class="keyword">var</span> key = type + <span class="string">"queueHooks"</span>;</div><div class="line">    <span class="keyword">return</span> data_priv.get( elem, key ) || data_priv.access( elem, key, {</div><div class="line">        empty: jQuery.Callbacks(<span class="string">"once memory"</span>).add(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            data_priv.remove( elem, [ type + <span class="string">"queue"</span>, key ] );</div><div class="line">        })</div><div class="line">    });</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="jq对象上的queue和dequeue">jq对象上的queue和dequeue</h3>
<h4 id="queue_(type,_data)">queue (type, data)</h4>
<p>对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">queue: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> </span>{</div><div class="line">        <span class="keyword">var</span> setter = <span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {</div><div class="line">            data = type;</div><div class="line">            type = <span class="string">"fx"</span>;</div><div class="line">            setter--;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length &lt; setter ) {</div><div class="line">            <span class="keyword">return</span> jQuery.queue( <span class="keyword">this</span>[<span class="number">0</span>], type );</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">return</span> data === <span class="literal">undefined</span> ?</div><div class="line">            <span class="keyword">this</span> :</div><div class="line">            <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">                <span class="keyword">var</span> queue = jQuery.queue( <span class="keyword">this</span>, type, data );</div><div class="line"></div><div class="line">                <span class="comment">// ensure a hooks for this queue</span></div><div class="line">                jQuery._queueHooks( <span class="keyword">this</span>, type );</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( type === <span class="string">"fx"</span> && queue[<span class="number">0</span>] !== <span class="string">"inprogress"</span> ) {</div><div class="line">                    jQuery.dequeue( <span class="keyword">this</span>, type );</div><div class="line">                }</div><div class="line">            });</div><div class="line">    },</div></pre></td></tr></table></figure>

<h4 id="dequeue_(type)">dequeue (type)</h4>
<p>对jq对象中每个DOM元素执行dequeue操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/</span></div><div class="line">dequeue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        jQuery.dequeue( <span class="keyword">this</span>, type );</div><div class="line">    });</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="clearQueue_(type)">clearQueue (type)</h4>
<p>清除jq对象中每个DOM的type对应的数据列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*清除对应的类型的操作列表*/</span></div><div class="line">clearQueue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue( type || <span class="string">"fx"</span>, [] );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="promise_(type,_obj)">promise (type, obj)</h4>
<p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象*/</span></div><div class="line">promise: <span class="function"><span class="keyword">function</span><span class="params">( type, obj )</span> </span>{</div><div class="line">    <span class="keyword">var</span> tmp,</div><div class="line">        count = <span class="number">1</span>,</div><div class="line">        defer = jQuery.Deferred(),</div><div class="line">        elements = <span class="keyword">this</span>,</div><div class="line">        i = <span class="keyword">this</span>.length,</div><div class="line">        resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">            <span class="keyword">if</span> ( !( --count ) ) {</div><div class="line">                defer.resolveWith( elements, [ elements ] );</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {</div><div class="line">        obj = type;</div><div class="line">        type = <span class="literal">undefined</span>;</div><div class="line">    }</div><div class="line">    type = type || <span class="string">"fx"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> ( i-- ) {</div><div class="line">        tmp = data_priv.get( elements[ i ], type + <span class="string">"queueHooks"</span> );</div><div class="line">        <span class="keyword">if</span> ( tmp && tmp.empty ) {</div><div class="line">            count++;</div><div class="line">            tmp.empty.add( resolve );</div><div class="line">        }</div><div class="line">    }</div><div class="line">    resolve();</div><div class="line">    <span class="keyword">return</span> defer.promise( obj );</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery的核心方法和类型判断]]></title>
    <link href="http://lingyu.wang/2014/05/08/read-jq-src-1/"/>
    <id>http://lingyu.wang/2014/05/08/read-jq-src-1/</id>
    <published>2014-05-07T16:00:00.000Z</published>
    <updated>2014-09-18T15:00:24.000Z</updated>
    <content type="html"><![CDATA[<p>这几天闭关读源码，jQuery读了一半了，sizzle，基础方法，promise等等都详细的看了一下，由于东西比较多，先记录第一部分，jQuery的一些核心方法以及jQuery中的类型判断，读的是jQuery-2.1.0</p>
<a id="more"></a>

<h2 id="一些方法的缓存">一些方法的缓存</h2>
<p>上来先做了一下commonjs的判断和兼容</p>
<p>之后将一些数组上和对象上的常用方法进行了缓存。另外还缓存了一个class2type对象和support对象，class2type对象将在后面的类型判断处详细介绍。而support用来保存嗅探到的浏览器特性是否支持</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*缓存一些常用方法和对象*/</span></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line"><span class="comment">/*切分数组*/</span></div><div class="line"><span class="keyword">var</span> slice = arr.slice;</div><div class="line"><span class="comment">/*数组合并*/</span></div><div class="line"><span class="keyword">var</span> concat = arr.concat;</div><div class="line"><span class="comment">/*添加到尾部*/</span></div><div class="line"><span class="keyword">var</span> push = arr.push;</div><div class="line"><span class="comment">/*查找位置*/</span></div><div class="line"><span class="keyword">var</span> indexOf = arr.indexOf;</div><div class="line"><span class="comment">/*判断变量类型*/</span></div><div class="line"><span class="keyword">var</span> class2type = {};</div><div class="line"><span class="comment">/*对象的toString方法，用于判断变量类型*/</span></div><div class="line"><span class="keyword">var</span> toString = class2type.toString;</div><div class="line"><span class="comment">/*对象的hasOwnProperty，判断属性是否在对象中*/</span></div><div class="line"><span class="keyword">var</span> hasOwn = class2type.hasOwnProperty;</div><div class="line"><span class="comment">/*字符串的trime方法*/</span></div><div class="line"><span class="keyword">var</span> trim = <span class="string">""</span>.trim;</div><div class="line"><span class="comment">/*方法支持程度*/</span></div><div class="line"><span class="keyword">var</span> support = {};</div></pre></td></tr></table></figure>

<p>之后创建了jQuery方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery = <span class="function"><span class="keyword">function</span><span class="params">( selector, context )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>可以看到，其使用<code>new jQuery.fn.init</code>创建了一个jq对象并返回了，jq对象的详细实现应该在init方法中</p>
<p>当然还有一些像缓存document，版本号，匹配<code>-ms-</code>和<code>-[\da-z]</code>这样的正则表达式，还有一个将字符串转大写的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span></div><div class="line">    <span class="built_in">document</span> = <span class="built_in">window</span>.document,</div><div class="line"></div><div class="line">    version = <span class="string">"2.1.0"</span>,</div><div class="line"></div><div class="line">    jQuery = <span class="function"><span class="keyword">function</span><span class="params">( selector, context )</span> </span>{</div><div class="line">        <span class="comment">// The jQuery object is actually just the init constructor 'enhanced'</span></div><div class="line">        <span class="comment">// Need init if jQuery is called (just allow error to be thrown if not included)</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</div><div class="line">    },</div><div class="line"></div><div class="line">    rmsPrefix = <span class="regexp">/^-ms-/</span>,</div><div class="line">    rdashAlpha = <span class="regexp">/-([\da-z])/gi</span>,</div><div class="line"></div><div class="line">    fcamelCase = <span class="function"><span class="keyword">function</span><span class="params">( all, letter )</span> </span>{</div><div class="line">        <span class="keyword">return</span> letter.toUpperCase();</div><div class="line">    };</div></pre></td></tr></table></figure>

<h2 id="在jQuery对象上扩展方法">在jQuery对象上扩展方法</h2>
<p>紧接着是一系列在jq对象上扩展的方法：<br>可以看到在jq对象上扩展方法实际上就是在jQuery的prototype上扩展方法<br>这里定义了一系列在jQuery对象中操作元素集合的方法</p>
<h4 id="constructor">constructor</h4>
<p>重新将constructor指向jQuery，防止constructor指向Object</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor: jQuery,</div></pre></td></tr></table></figure>

<h4 id="selector">selector</h4>
<p>每个jQuery对象都与一个selector字符串，可以用它来检测jQuery对象，默认为空字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selector: <span class="string">""</span>,</div></pre></td></tr></table></figure>

<h4 id="length">length</h4>
<p>jQuery对象其实可以看做一个包含了很多dom元素和一系列扩展方法的类数组对象，其中必然会有一个length属性说明一共有多少dom元素，经常用来判断jq对象是否含有结果集</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length: <span class="number">0</span>,</div></pre></td></tr></table></figure>

<h4 id="toArray">toArray</h4>
<p>类数组对象转真正数组的方法，内部和我们将arguments或NodeList等于一样，使用slice实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">toArray: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> slice.call( <span class="keyword">this</span> );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="get_(num)">get (num)</h4>
<p>从jq对象中获取下标为num的元素，如果num为负数，则获取倒数第num个，也就是下表为<code>length + num</code>的元素。如果num不存在，将这个jq对象转换成真数组并返回（同样使用的slice方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">get: <span class="function"><span class="keyword">function</span><span class="params">( num )</span> </span>{</div><div class="line">    <span class="keyword">return</span> num != <span class="literal">null</span> ?</div><div class="line"></div><div class="line">        <span class="comment">// Return a 'clean' array</span></div><div class="line">        ( num &lt; <span class="number">0</span> ? <span class="keyword">this</span>[ num + <span class="keyword">this</span>.length ] : <span class="keyword">this</span>[ num ] ) :</div><div class="line"></div><div class="line">        <span class="comment">// Return just the object</span></div><div class="line">        slice.call( <span class="keyword">this</span> );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="pushStack_(elems)">pushStack (elems)</h4>
<p>这是一个很重要的方法，后面很多地方会用到</p>
<p>这个方法实际上是创建一个新的jq对象，其结果集为elems中的dom节点，将现有的jq对象放在新创建对象的prevObject中，这样就能在新jq对象中查找到现有的jq对象了，设定一下context后返回新对象的引用</p>
<p>这种链式创建jq对象的方式可以理解为jq对象的一个链表(栈)，而我们永远拥有表头指针，使用end方法时，表头指针所指向的jq对象就会移除出链表。这也是jQuery那样链式操作的关键所在</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">pushStack: <span class="function"><span class="keyword">function</span><span class="params">( elems )</span> </span>{</div><div class="line"></div><div class="line">    <span class="comment">/*创建一个新jq对象用来保存结果集*/</span></div><div class="line">    <span class="keyword">var</span> ret = jQuery.merge( <span class="keyword">this</span>.constructor(), elems );</div><div class="line"></div><div class="line">    <span class="comment">/*将之前的jq对象压栈*/</span></div><div class="line">    ret.prevObject = <span class="keyword">this</span>;</div><div class="line">    <span class="comment">/*context相同*/</span></div><div class="line">    ret.context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">    <span class="comment">/*返回新创建的jq对象的引用*/</span></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="each_(callback,_args)">each (callback, args)</h4>
<p>这个方法相信使用过jq的人都很熟悉了，对当前jq对象中的每个元素调用callback方法，并可选的为callback传入args参数。内部有一个很强大的兼容各种参数的each方法，后续会有介绍，这里直接使用它了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">each: <span class="function"><span class="keyword">function</span><span class="params">( callback, args )</span> </span>{</div><div class="line">    <span class="keyword">return</span> jQuery.each( <span class="keyword">this</span>, callback, args );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="map_(callback)">map (callback)</h4>
<p>这个方法和上面类似，不过是map方法，所以会生成一组结果，这一组结果会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>
<h4 id="slice">slice</h4>
<p>其实内部就是直接调用了<code>[].slice</code>切分jq对象获得dom节点数组，不同的是，这个获得的dom节点数组会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map: <span class="function"><span class="keyword">function</span><span class="params">( callback )</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pushStack( jQuery.map(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span><span class="params">( elem, i )</span> </span>{</div><div class="line">        <span class="keyword">return</span> callback.call( elem, i, elem );</div><div class="line">    }));</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="first和last">first和last</h4>
<p>这俩比较简单，获取jq对象的dom节点集中的第一个和最后一个，均使用eq方法实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">first: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.eq( <span class="number">0</span> );</div><div class="line">},</div><div class="line"></div><div class="line">last: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.eq( -<span class="number">1</span> );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="eq_(i)">eq (i)</h4>
<p>获取jq对象dom节点集的第i个元素，需要注意的是处理正数和负数的情况，正数为第i个，负数为倒数第i个，也就是第<code>length+i</code>个</p>
<p>这个方法也会将生成的结果用pushStack方法在jq链上创建新的jq对象来包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eq: <span class="function"><span class="keyword">function</span><span class="params">( i )</span> </span>{</div><div class="line">    <span class="keyword">var</span> len = <span class="keyword">this</span>.length,</div><div class="line">        j = +i + ( i &lt; <span class="number">0</span> ? len : <span class="number">0</span> );</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pushStack( j &gt;= <span class="number">0</span> && j &lt; len ? [ <span class="keyword">this</span>[j] ] : [] );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="end">end</h4>
<p>操作jq链，获得之前的jq对象。这里有个判定，如果之前没有对象了，新建一个空的jq对象并返回。把jq链看做一个栈的话，实际上就是弾栈操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">end: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prevObject || <span class="keyword">this</span>.constructor(<span class="literal">null</span>);</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="push、sort、splice">push、sort、splice</h4>
<p>这些方法仅作内部使用，直接使用数组的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">push: push,</div><div class="line">sort: arr.sort,</div><div class="line">splice: arr.splice</div></pre></td></tr></table></figure>

<h2 id="对象扩展方法jQuery-extend">对象扩展方法jQuery.extend</h2>
<p>编写jq插件的开发者肯定不会对这个方法陌生</p>
<p>jq使用这个方法实现的混入模式，思想还是将遍历一个对象中的所有值，复制到一个已有的对象中</p>
<p>另外jq这个函数实现了深拷贝，其实也就是递归调用extend方法，这里用了很多的jQuery自己实现的类型判断</p>
<p>深拷贝需要注意数组和原生对象的情况，他们创建的容器是不相同的（<code>[]</code>和<code>{}</code>）</p>
<p>另外它使用了一个options来进行缓存，防止出现循环引用导致的无限递归情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</div><div class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || {},</div><div class="line">        i = <span class="number">1</span>,</div><div class="line">        length = <span class="built_in">arguments</span>.length,</div><div class="line">        deep = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/*做接口的重载*/</span></div><div class="line">    <span class="comment">// Handle a deep copy situation</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">"boolean"</span> ) {</div><div class="line">        deep = target;</div><div class="line"></div><div class="line">        <span class="comment">// skip the boolean and the target</span></div><div class="line">        target = <span class="built_in">arguments</span>[ i ] || {};</div><div class="line">        i++;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">"object"</span> && !jQuery.isFunction(target) ) {</div><div class="line">        target = {};</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// extend jQuery itself if only one argument is passed</span></div><div class="line">    <span class="keyword">if</span> ( i === length ) {</div><div class="line">        target = <span class="keyword">this</span>;</div><div class="line">        i--;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">        <span class="comment">// Only deal with non-null/undefined values</span></div><div class="line">        <span class="keyword">if</span> ( (options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span> ) {</div><div class="line">            <span class="comment">// Extend the base object</span></div><div class="line">            <span class="keyword">for</span> ( name <span class="keyword">in</span> options ) {</div><div class="line">                src = target[ name ];</div><div class="line">                copy = options[ name ];</div><div class="line"></div><div class="line">                <span class="comment">// Prevent never-ending loop</span></div><div class="line">                <span class="comment">/*看copy中是否已经存在需要复制的对象，防止死循环*/</span></div><div class="line">                <span class="keyword">if</span> ( target === copy ) {</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                }</div><div class="line">                <span class="comment">/*如果深拷贝，将递归复制*/</span></div><div class="line">                <span class="comment">// Recurse if we're merging plain objects or arrays</span></div><div class="line">                <span class="keyword">if</span> ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {</div><div class="line">                    <span class="comment">/*数组和对象分开判断，容器不一样*/</span></div><div class="line">                    <span class="keyword">if</span> ( copyIsArray ) {</div><div class="line">                        copyIsArray = <span class="literal">false</span>;</div><div class="line">                        clone = src && jQuery.isArray(src) ? src : [];</div><div class="line"></div><div class="line">                    } <span class="keyword">else</span> {</div><div class="line">                        clone = src && jQuery.isPlainObject(src) ? src : {};</div><div class="line">                    }</div><div class="line"></div><div class="line">                    <span class="comment">// Never move original objects, clone them</span></div><div class="line">                    <span class="comment">/*递归拷贝*/</span></div><div class="line">                    target[ name ] = jQuery.extend( deep, clone, copy );</div><div class="line"></div><div class="line">                <span class="comment">// Don't bring in undefined values</span></div><div class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) {</div><div class="line">                    target[ name ] = copy;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return the modified object</span></div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="在jQuery上扩展的一些内部方法和静态方法">在jQuery上扩展的一些内部方法和静态方法</h2>
<p>有了<code>jQuery.extend</code>，我们就可以使用它在jQuery对象上申明一些静态方法或属性了，基本上每个模块都会通过这种方式申明一些内部方法和静态方法</p>
<h4 id="expando">expando</h4>
<p>用于随机生成一个jq的版本号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expando: <span class="string">"jQuery"</span> + ( version + <span class="built_in">Math</span>.random() ).replace( <span class="regexp">/\D/g</span>, <span class="string">""</span> ),</div></pre></td></tr></table></figure>

<h4 id="isReady">isReady</h4>
<p>假设jQuery已经准备好了，当然我们有一个$().ready方法，判断dom是否加载完成，这些后面promise那块会说</p>
<h4 id="error">error</h4>
<p>没啥好说的，甩个异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">error: <span class="function"><span class="keyword">function</span><span class="params">( msg )</span> </span>{</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( msg );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="noop">noop</h4>
<p>一个空函数，不知道干啥用的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">noop: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{},</div></pre></td></tr></table></figure>

<h4 id="isFunction_(obj)">isFunction (obj)</h4>
<p>判断参数是否是函数，使用了jQuery.type进行判断，内部实际上用的是<code>typeof obj === &#39;function&#39;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isFunction: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="keyword">return</span> jQuery.type(obj) === <span class="string">"function"</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="isArray_(obj)">isArray (obj)</h4>
<p>判断参数是否是数组，由于是2.1.0版本，不兼容ie6-7，所以直接使用了<code>Array.isArray</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isArray: <span class="built_in">Array</span>.isArray,</div></pre></td></tr></table></figure>

<h4 id="isWindow_(obj)">isWindow (obj)</h4>
<p>判断是否是window对象，这个使用window对象的<code>window.window === window</code>进行判断，但司徒正美说这种方式还是有缺陷的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isWindow: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="keyword">return</span> obj != <span class="literal">null</span> && obj === obj.window;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="isNumberic_(obj)">isNumberic (obj)</h4>
<p>这个是判断参数能否转换为数字，先通过parseFloat对参数进行转换，然后判断，很巧妙</p>
<p>这里用到了parseFloat返回NaN、任何数与NaN计算都是NaN、NaN和0比返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">isNumeric: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="comment">// parseFloat NaNs numeric-cast false positives (null|true|false|"")</span></div><div class="line">    <span class="comment">// ...but misinterprets leading-number strings, particularly hex literals ("0x...")</span></div><div class="line">    <span class="comment">// subtraction forces infinities to NaN</span></div><div class="line">    <span class="keyword">return</span> obj - <span class="built_in">parseFloat</span>( obj ) &gt;= <span class="number">0</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="isPlainObject_(obj)">isPlainObject (obj)</h4>
<p>判断是否是原生对象。如果不是对象，或者是DOM对象，或者是window直接排除。看它原型上是否有isPrototypeOf方法，如果有，则是原生对象，否则不是。需要注意一点的是，在ff20-时查看constructor会报错，所以用了try catch包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">isPlainObject: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="comment">// Not plain objects:</span></div><div class="line">    <span class="comment">// - Any object or value whose internal [[Class]] property is not "[object Object]"</span></div><div class="line">    <span class="comment">// - DOM nodes</span></div><div class="line">    <span class="comment">// - window</span></div><div class="line">    <span class="keyword">if</span> ( jQuery.type( obj ) !== <span class="string">"object"</span> || obj.nodeType || jQuery.isWindow( obj ) ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Support: Firefox &lt;20</span></div><div class="line">    <span class="comment">// The try/catch suppresses exceptions thrown when attempting to access</span></div><div class="line">    <span class="comment">// the "constructor" property of certain host objects, ie. |window.location|</span></div><div class="line">    <span class="comment">// https://bugzilla.mozilla.org/show_bug.cgi?id=814622</span></div><div class="line">    <span class="keyword">try</span> {</div><div class="line">        <span class="keyword">if</span> ( obj.constructor &&</div><div class="line">                !hasOwn.call( obj.constructor.prototype, <span class="string">"isPrototypeOf"</span> ) ) {</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        }</div><div class="line">    } <span class="keyword">catch</span> ( e ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// If the function hasn't returned already, we're confident that</span></div><div class="line">    <span class="comment">// |obj| is a plain object, created by {} or constructed with new Object</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="isEmptyObject_(obj)">isEmptyObject (obj)</h4>
<p>是否是空对象，判断方法是遍历这个对象，只要有能遍历到的键值对，返回false</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">isEmptyObject: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="type_(obj)">type (obj)</h4>
<p>确定元素类型的方法，这个方法使用了class2type中存储的累心结果进行判断</p>
<p>首先判断<code>obj==null</code>，obj如果是undefined和null，都会在这里被拦截，直接转成字符串返回就可以了</p>
<p>然后判断如果obj是对象，那就需要通过class2type来判断了，class2type中汇总了一些常用的对象映射。如果class2type中没有找到，返回object。如果是函数，直接返回函数就行了</p>
<p>后面会有如何创建这个class2type缓存</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">type: <span class="function"><span class="keyword">function</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="keyword">if</span> ( obj == <span class="literal">null</span> ) {</div><div class="line">        <span class="keyword">return</span> obj + <span class="string">""</span>;</div><div class="line">    }</div><div class="line">    <span class="comment">// Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"object"</span> || <span class="keyword">typeof</span> obj === <span class="string">"function"</span> ?</div><div class="line">        class2type[ toString.call(obj) ] || <span class="string">"object"</span> :</div><div class="line">        <span class="keyword">typeof</span> obj;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="globalEval_(code)">globalEval (code)</h4>
<p>执行code中的代码，首先通过indexOf查找代码中是否有<code>use strict</code>，如果有，那么使用在document中创建script节点的方法执行代码，否则直接用js本身的eval</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">globalEval: <span class="function"><span class="keyword">function</span><span class="params">( code )</span> </span>{</div><div class="line">    <span class="keyword">var</span> script,</div><div class="line">        indirect = <span class="built_in">eval</span>;</div><div class="line"></div><div class="line">    code = jQuery.trim( code );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( code ) {</div><div class="line">        <span class="comment">// If the code includes a valid, prologue position</span></div><div class="line">        <span class="comment">// strict mode pragma, execute code by injecting a</span></div><div class="line">        <span class="comment">// script tag into the document.</span></div><div class="line">        <span class="keyword">if</span> ( code.indexOf(<span class="string">"use strict"</span>) === <span class="number">1</span> ) {</div><div class="line">            script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</div><div class="line">            script.text = code;</div><div class="line">            <span class="built_in">document</span>.head.appendChild( script ).parentNode.removeChild( script );</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">        <span class="comment">// Otherwise, avoid the DOM node creation, insertion</span></div><div class="line">        <span class="comment">// and removal by using an indirect global eval</span></div><div class="line">            indirect( code );</div><div class="line">        }</div><div class="line">    }</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="camelCase">camelCase</h4>
<p>将一个带连字符的字符串转驼峰形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">camelCase: <span class="function"><span class="keyword">function</span><span class="params">( string )</span> </span>{</div><div class="line">    <span class="keyword">return</span> string.replace( rmsPrefix, <span class="string">"ms-"</span> ).replace( rdashAlpha, fcamelCase );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="nodeName">nodeName</h4>
<p>判断一个元素的标签名是否和传入的参数匹配，如果没有传入参数，返回元素的标签名…直接用元素的nodeName属性获得标签名，比较时注意一下全转成小写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nodeName: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> </span>{</div><div class="line">    <span class="keyword">return</span> elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="each">each</h4>
<p>来了，用于遍历的each方法，其有一个有参数的情况</p>
<p>在遍历时需要判断对象是类数组（注意是类数组）还是对象，类数组的话直接使用for循环，而对象使用for in。剩下就是在有无参数时候的不同调用方法了，有参数使用apply传入相应参数，如果没有使用call，传入下标和具体的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">each: <span class="function"><span class="keyword">function</span><span class="params">( obj, callback, args )</span> </span>{</div><div class="line">    <span class="keyword">var</span> value,</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        length = obj.length,</div><div class="line">        isArray = isArraylike( obj );</div><div class="line">    <span class="comment">/*有参数的情况下*/</span></div><div class="line">    <span class="keyword">if</span> ( args ) {</div><div class="line">        <span class="comment">/*数组或类数组对象*/</span></div><div class="line">        <span class="keyword">if</span> ( isArray ) {</div><div class="line">            <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">                value = callback.apply( obj[ i ], args );</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        <span class="comment">/*普通对象*/</span></div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) {</div><div class="line">                value = callback.apply( obj[ i ], args );</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    <span class="comment">/*无参数的情况下，把当前元素和下标（键）当做参数传递*/</span></div><div class="line">    <span class="comment">// A special, fast, case for the most common use of each</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">if</span> ( isArray ) {</div><div class="line">            <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">                value = callback.call( obj[ i ], i, obj[ i ] );</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) {</div><div class="line">                value = callback.call( obj[ i ], i, obj[ i ] );</div><div class="line"></div><div class="line">                <span class="keyword">if</span> ( value === <span class="literal">false</span> ) {</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="trim">trim</h4>
<p>去掉字符串的首尾空白，由于不兼容老版本IE，直接用字符串的trim了，没有用正则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">trim: <span class="function"><span class="keyword">function</span><span class="params">( text )</span> </span>{</div><div class="line">    <span class="keyword">return</span> text == <span class="literal">null</span> ? <span class="string">""</span> : trim.call( text );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="makeArray">makeArray</h4>
<p>讲一个类数组转化为数组，如果是数组直接push，如果不是真数组，使用merge，后面会介绍merge方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">makeArray: <span class="function"><span class="keyword">function</span><span class="params">( arr, results )</span> </span>{</div><div class="line">    <span class="keyword">var</span> ret = results || [];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( arr != <span class="literal">null</span> ) {</div><div class="line">        <span class="keyword">if</span> ( isArraylike( <span class="built_in">Object</span>(arr) ) ) {</div><div class="line">            jQuery.merge( ret,</div><div class="line">                <span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?</div><div class="line">                [ arr ] : arr</div><div class="line">            );</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            push.call( ret, arr );</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="inArray">inArray</h4>
<p>使用indexOf判断元素是否在数组内部</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inArray: <span class="function"><span class="keyword">function</span><span class="params">( elem, arr, i )</span> </span>{</div><div class="line">    <span class="keyword">return</span> arr == <span class="literal">null</span> ? -<span class="number">1</span> : indexOf.call( arr, elem, i );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="merge">merge</h4>
<p>通过遍历的方式将两个类数组合并</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">merge: <span class="function"><span class="keyword">function</span><span class="params">( first, second )</span> </span>{</div><div class="line">    <span class="keyword">var</span> len = +second.length,</div><div class="line">        j = <span class="number">0</span>,</div><div class="line">        i = first.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> ( ; j &lt; len; j++ ) {</div><div class="line">        first[ i++ ] = second[ j ];</div><div class="line">    }</div><div class="line"></div><div class="line">    first.length = i;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="grep_(elems,_callback,_invert)">grep (elems, callback, invert)</h4>
<p>将元素丢到callback中判断是否符合条件，返回所有符合条件的元素。invert为true时，返回所有不符合条件的元素</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">grep: <span class="function"><span class="keyword">function</span><span class="params">( elems, callback, invert )</span> </span>{</div><div class="line">    <span class="keyword">var</span> callbackInverse,</div><div class="line">        matches = [],</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        length = elems.length,</div><div class="line">        callbackExpect = !invert;</div><div class="line"></div><div class="line">    <span class="comment">// Go through the array, only saving the items</span></div><div class="line">    <span class="comment">// that pass the validator function</span></div><div class="line">    <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">        callbackInverse = !<span class="keyword">callback</span>( elems[ i ], i );</div><div class="line">        <span class="keyword">if</span> ( callbackInverse !== callbackExpect ) {</div><div class="line">            matches.push( elems[ i ] );</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> matches;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="map_(elems,_callback,_arg)">map (elems, callback, arg)</h4>
<p>jq自己实现的map操作，由于jq自身是个类数组，于是乎模拟数组实现了一系列操作，map就是其中一个</p>
<p>对数组、类数组、对象进行遍历map操作，结果放在一个数组中并返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">map: <span class="function"><span class="keyword">function</span><span class="params">( elems, callback, arg )</span> </span>{</div><div class="line">    <span class="keyword">var</span> value,</div><div class="line">        i = <span class="number">0</span>,</div><div class="line">        length = elems.length,</div><div class="line">        isArray = isArraylike( elems ),</div><div class="line">        ret = [];</div><div class="line"></div><div class="line">    <span class="comment">// Go through the array, translating each of the items to their new values</span></div><div class="line">    <span class="comment">/*数组或类数组*/</span></div><div class="line">    <span class="keyword">if</span> ( isArray ) {</div><div class="line">        <span class="keyword">for</span> ( ; i &lt; length; i++ ) {</div><div class="line">            value = callback( elems[ i ], i, arg );</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {</div><div class="line">                ret.push( value );</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="comment">// Go through every key on the object,</span></div><div class="line">    <span class="comment">/*对象*/</span></div><div class="line">    } <span class="keyword">else</span> {</div><div class="line">        <span class="keyword">for</span> ( i <span class="keyword">in</span> elems ) {</div><div class="line">            value = callback( elems[ i ], i, arg );</div><div class="line"></div><div class="line">            <span class="keyword">if</span> ( value != <span class="literal">null</span> ) {</div><div class="line">                ret.push( value );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Flatten any nested arrays</span></div><div class="line">    <span class="keyword">return</span> concat.apply( [], ret );</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="guid">guid</h4>
<p>一个全局的guid，用于生成独立id，每次被使用后自增</p>
<h4 id="proxy">proxy</h4>
<p>使用闭包的方式将对象绑定到函数的作用域链顶端，curry化的实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">proxy: <span class="function"><span class="keyword">function</span><span class="params">( fn, context )</span> </span>{</div><div class="line">    <span class="keyword">var</span> tmp, args, proxy;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> context === <span class="string">"string"</span> ) {</div><div class="line">        tmp = fn[ context ];</div><div class="line">        context = fn;</div><div class="line">        fn = tmp;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Quick check to determine if target is callable, in the spec</span></div><div class="line">    <span class="comment">// this throws a TypeError, but we will just return undefined.</span></div><div class="line">    <span class="comment">/*必须是函数*/</span></div><div class="line">    <span class="keyword">if</span> ( !jQuery.isFunction( fn ) ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Simulated bind</span></div><div class="line">    <span class="comment">/*提取出参数*/</span></div><div class="line">    args = slice.call( <span class="built_in">arguments</span>, <span class="number">2</span> );</div><div class="line">    <span class="comment">/*创建闭包，这个闭包使用了当前作用域的这些对象*/</span></div><div class="line">    proxy = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</div><div class="line">        <span class="keyword">return</span> fn.apply( context || <span class="keyword">this</span>, args.concat( slice.call( <span class="built_in">arguments</span> ) ) );</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">// Set the guid of unique handler to the same of original handler, so it can be removed</span></div><div class="line">    <span class="comment">/*给代理增加一个自增的guid*/</span></div><div class="line">    proxy.guid = fn.guid = fn.guid || jQuery.guid++;</div><div class="line">    <span class="comment">/*返回代理*/</span></div><div class="line">    <span class="keyword">return</span> proxy;</div><div class="line">},</div></pre></td></tr></table></figure>

<h4 id="其他">其他</h4>
<p>没啥好说的，看名字就知道了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">now: <span class="built_in">Date</span>.now,</div><div class="line"></div><div class="line">support: support</div></pre></td></tr></table></figure>

<h2 id="类型判断">类型判断</h2>
<h4 id="生成class2type">生成class2type</h4>
<p>首先是生成class2type，使用了比较巧妙的方法，对一个字符串进行切分，然后使用<code>jQuery.each</code>方法来建立class2type</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span><span class="params">(i, name)</span> </span>{</div><div class="line">    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</div><div class="line">});</div></pre></td></tr></table></figure>

<h4 id="判断类数组">判断类数组</h4>
<p>判断是否是类数组对象，主要是根据是否含有大于等于0的length属性判断，含有length属性也可能是function，表明参数个数，也可能是window，需要排除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArraylike</span><span class="params">( obj )</span> </span>{</div><div class="line">    <span class="keyword">var</span> length = obj.length,</div><div class="line">        type = jQuery.type( obj );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( type === <span class="string">"function"</span> || jQuery.isWindow( obj ) ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( obj.nodeType === <span class="number">1</span> && length ) {</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">return</span> type === <span class="string">"array"</span> || length === <span class="number">0</span> ||</div><div class="line">        <span class="keyword">typeof</span> length === <span class="string">"number"</span> && length &gt; <span class="number">0</span> && ( length - <span class="number">1</span> ) <span class="keyword">in</span> obj;</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>这一部分主要是申明了extend方法和一些在jq对象上的核心函数，以及相当多的类型判断相关</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天闭关读源码，jQuery读了一半了，sizzle，基础方法，promise等等都详细的看了一下，由于东西比较多，先记录第一部分，jQuery的一些核心方法以及jQuery中的类型判断，读的是jQuery-2.1.0</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="源码阅读" scheme="http://lingyu.wang/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Google的HTML/CSS样式指南]]></title>
    <link href="http://lingyu.wang/2014/05/04/google-style-guide/"/>
    <id>http://lingyu.wang/2014/05/04/google-style-guide/</id>
    <published>2014-05-03T16:00:00.000Z</published>
    <updated>2014-09-18T14:54:20.000Z</updated>
    <content type="html"><![CDATA[<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>
<a id="more"></a>

<h2 id="通用样式规范">通用样式规范</h2>
<h3 id="使用相对协议">使用相对协议</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="HTML文件中一个tab两个空格">HTML文件中一个tab两个空格</h3>
<p>老调重弹，不要混合使用tab和空格</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Fantastic</div><div class="line">  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Great</div><div class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></div><div class="line"></div><div class="line">.example {</div><div class="line">  color: blue;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="仅使用小写">仅使用小写</h3>
<p>所有代码应该使用小写，比如HTML元素的名称、属性、属性值（除了text/CDATA）。CSS的选择器、属性、属性值等等</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">A</span> <span class="attribute">HREF</span>=<span class="value">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="title">A</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"google.png"</span> <span class="attribute">alt</span>=<span class="value">"Google"</span>&gt;</span></div></pre></td></tr></table></figure>



<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!<span class="tag">--</span> 不推荐使用 <span class="tag">--</span>&gt;</div><div class="line"><span class="tag">color</span>: <span class="id">#E5E5E5</span>;</div><div class="line"></div><div class="line">&lt;!<span class="tag">--</span> 推荐使用 <span class="tag">--</span>&gt;</div><div class="line"><span class="tag">color</span>: <span class="id">#e5e5e5</span>;</div></pre></td></tr></table></figure>

<h3 id="不要有后缀的空格">不要有后缀的空格</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>What?_</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Yes please.</div></pre></td></tr></table></figure>

<h3 id="使用UTF-8编码">使用UTF-8编码</h3>
<p>保证编辑器的编码字符集为UTF-8，同时在文档中添加<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p>
<h3 id="在必要的时候，在合适的地方添加注释">在必要的时候，在合适的地方添加注释</h3>
<p>用注释来表明元素的范围以及它的用途</p>
<h3 id="仅使用TODO来添加todo任务">仅使用TODO来添加todo任务</h3>
<h2 id="HTML样式规范">HTML样式规范</h2>
<h3 id="使用HTML5文档类型">使用HTML5文档类型</h3>
<p>使用<code>&lt;!DOCTYPE html&gt;</code>来声明文档类型，建议使用<code>text/html</code>来定义HTML文件的MIME类型，不要使用<code>application/xhtml+xml</code>来定义。在编写HTML时，空元素可以不必闭合，如<code>&lt;br&gt;</code>不必写成<code>&lt;br/&gt;</code></p>
<h3 id="使用HTML验证器进行验证">使用HTML验证器进行验证</h3>
<p>尽量使用HTML验证器验证过的代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">article</span>&gt;</span>This is only a test.</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">article</span>&gt;</span>This is only a test.<span class="tag">&lt;/<span class="title">article</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="根据用途使用元素">根据用途使用元素</h3>
<p>使用元素时应当根据元素的作用来选择适当的标签，<code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>用来表示头，<code>&lt;p&gt;</code>元素表示段落，<code>&lt;a&gt;</code>元素表示超链接等等。根据用途使用元素对可访问性，重用和代码效率等有很重要的帮助</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">onclick</span>=<span class="value">"goToRecommendations();"</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"recommendations/"</span>&gt;</span>All recommendations<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="对于多媒体元素，提供替换文本（alt）">对于多媒体元素，提供替换文本（alt）</h3>
<p>对于多媒体元素，像图片，视频，动画对象如canvas等等，应该为其提供有意义的替换文本（alt），同时尽可能为视频和音频提供副本（不同格式）和字幕</p>
<p>这同样关乎到可访问性，当盲人用户需要通过image等获得信息时，可以转而通过alt中的文字来获得信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"spreadsheet.png"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"spreadsheet.png"</span> <span class="attribute">alt</span>=<span class="value">"Spreadsheet screenshot."</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="将结构、表现、行为三者分离">将结构、表现、行为三者分离</h3>
<p>严格将结构（标记），表现（样式）和行为（脚本）进行分离解耦，使他们之间相互独立</p>
<p>具体做法就是将HTML文档和模板中仅包含HTML，样式妨碍CSS中，而行为相关代码放在脚本中</p>
<p>这样更易于网页的维护和重用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"base.css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"grid.css"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">h1</span> <span class="attribute">style</span>=<span class="value">"font-size: 1em;"</span>&gt;</span>HTML sucks<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>I’ve read about this on a few sites but now I’m sure:</div><div class="line">  <span class="tag">&lt;<span class="title">u</span>&gt;</span>HTML is stupid!!1<span class="tag">&lt;/<span class="title">u</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">center</span>&gt;</span>I can’t believe there’s no way to control the styling of</div><div class="line">  my website without doing everything all over again!<span class="tag">&lt;/<span class="title">center</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"default.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>My first CSS-only redesign<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>I’ve read about this on a few sites but today I’m actually</div><div class="line">  doing it: separating concerns and avoiding anything in the HTML of</div><div class="line">  my website that is presentational.</div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>It’s awesome!</div></pre></td></tr></table></figure>

<h3 id="避免引用实体">避免引用实体</h3>
<p>可以直接使用UTF-8等字符集中的字符替代实体，除了一些在HTML中有特殊意义的字符（如<code>&lt;</code>和<code>&amp;</code>）需要使用实体代替以外，尽量不要使用实体</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line">The currency symbol for the Euro is &ldquo;&eur;&rdquo;.</div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line">The currency symbol for the Euro is “€”.</div></pre></td></tr></table></figure>

<h3 id="省略可选标签">省略可选标签</h3>
<p>出于降低文档大小和代码可读性考虑，可以将可选标签省略。HTML5定义了一套<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-omission" target="_blank" rel="external">可选标签规范</a>，标明哪些元素时可选的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Spending money, spending bytes<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Sic.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span>Saving money, saving bytes<span class="tag">&lt;/<span class="title">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Qed.</div></pre></td></tr></table></figure>

<h3 id="省略样式表和脚本的type属性">省略样式表和脚本的type属性</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"//www.google.com/css/maia.css"</span></span></div><div class="line">  <span class="attribute">type</span>=<span class="value">"text/css"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span></span></div><div class="line">  <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;<span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"//www.google.com/css/maia.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"//www.google.com/js/gweb/analytics/autotrack.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="块级元素占用一行且合理缩进">块级元素占用一行且合理缩进</h3>
<p>每个块级元素，列表项、表格元素单独占用一行，并为每个子元素提供适当的缩进（两个空格）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">blockquote</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">em</span>&gt;</span>Space<span class="tag">&lt;/<span class="title">em</span>&gt;</span>, the final frontier.<span class="tag">&lt;/<span class="title">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">blockquote</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Moe</div><div class="line">  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Larry</div><div class="line">  <span class="tag">&lt;<span class="title">li</span>&gt;</span>Curly</div><div class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">thead</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">tr</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">th</span> <span class="attribute">scope</span>=<span class="value">"col"</span>&gt;</span>Income</div><div class="line">      <span class="tag">&lt;<span class="title">th</span> <span class="attribute">scope</span>=<span class="value">"col"</span>&gt;</span>Taxes</div><div class="line">  <span class="tag">&lt;<span class="title">tbody</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">tr</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="title">td</span>&gt;</span>$ 5.00</div><div class="line">      <span class="tag">&lt;<span class="title">td</span>&gt;</span>$ 4.50</div><div class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></div></pre></td></tr></table></figure>

<h3 id="属性值使用双引号包裹">属性值使用双引号包裹</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">'maia-button maia-button-secondary'</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 推荐使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"maia-button maia-button-secondary"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<h2 id="CSS样式规范">CSS样式规范</h2>
<h3 id="使用验证过的CSS代码">使用验证过的CSS代码</h3>
<p>除非CSS验证器有bug或需要专有语法，否则使用验证过的CSS代码</p>
<h3 id="使用有意义的ID和类命名">使用有意义的ID和类命名</h3>
<p>命名应当反映出元素的用途。详细命名规则可以看<a href="http://nec.netease.com/standard/css-name.html" target="_blank" rel="external">NEC的CSS命名规则</a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="id">#yee-1901</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.button-green</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.clear</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="id">#gallery</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="id">#login</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.video</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.aux</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.alt</span> <span class="rules">{<span class="rule">}</span></span></div></pre></td></tr></table></figure>

<h3 id="使用简短但不失描述性的ID和类命名">使用简短但不失描述性的ID和类命名</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="id">#navigation</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.atr</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="id">#nav</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.author</span> <span class="rules">{<span class="rule">}</span></span></div></pre></td></tr></table></figure>

<h3 id="避免在元素选择器之后使用使用ID和类选择器">避免在元素选择器之后使用使用ID和类选择器</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="tag">ul</span><span class="id">#example</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="tag">div</span><span class="class">.error</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="id">#example</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"><span class="class">.error</span> <span class="rules">{<span class="rule">}</span></span></div></pre></td></tr></table></figure>

<h3 id="尽可能对属性进行合并">尽可能对属性进行合并</h3>
<p>很多属性（padding、margin、background、font、border等等）都是可以合并的，尽可能合并他们</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* 不推荐使用 */</div><div class="line">border-top-style: none;</div><div class="line">font-family: palatino, georgia, serif;</div><div class="line">font-size: 100%;</div><div class="line">line-height: 1.6;</div><div class="line">padding-bottom: 2em;</div><div class="line">padding-left: 1em;</div><div class="line">padding-right: 1em;</div><div class="line">padding-top: 0;</div><div class="line"></div><div class="line">/* 推荐使用 */</div><div class="line">border-top: 0;</div><div class="line">font: 100%/1.6 palatino, georgia, serif;</div><div class="line">padding: 0 1em 2em;</div></pre></td></tr></table></figure>

<h3 id="属性值为0时不要携带单位">属性值为0时不要携带单位</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">margin</span>: 0;</div><div class="line"><span class="tag">padding</span>: 0;</div></pre></td></tr></table></figure>

<h3 id="小数的整数部分为0时，省略整数部分">小数的整数部分为0时，省略整数部分</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">font-size</span>: <span class="class">.8em</span>;</div></pre></td></tr></table></figure>

<h3 id="颜色为16进制表示时进行缩写">颜色为16进制表示时进行缩写</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="tag">color</span>: <span class="id">#eebbcc</span>;</div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="tag">color</span>: <span class="id">#ebc</span>;</div></pre></td></tr></table></figure>

<h3 id="ID和类命名添加前缀表示命名空间">ID和类命名添加前缀表示命名空间</h3>
<p>同NEC的命名方式，或者通过模块名来定义前缀</p>
<h2 id="CSS格式规范">CSS格式规范</h2>
<h3 id="CSS属性申明顺序">CSS属性申明顺序</h3>
<p>可以按照字典序进行排序，方便查找，但同一属性的不同实现声明在一起，且按照私有实现在前，W3C标准在后的顺序排列</p>
<p>ps：属性顺序排列有另一种说法是：定位相关（position、float、display、top、left、right、bottom、z-index等）在前，随后是盒子模型相关（width、height、padding、margin、border等等），随后是背景相关（background，background-image等等），然后是文字相关（colr，line-height、font等等），然后是一些其他属性（border-radius，opacity等等），最后是动画属性（transition、animation等）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">background</span>: <span class="tag">fuchsia</span>;</div><div class="line"><span class="tag">border</span>: 1<span class="tag">px</span> <span class="tag">solid</span>;</div><div class="line"><span class="tag">-moz-border-radius</span>: 4<span class="tag">px</span>;</div><div class="line"><span class="tag">-webkit-border-radius</span>: 4<span class="tag">px</span>;</div><div class="line"><span class="tag">border-radius</span>: 4<span class="tag">px</span>;</div><div class="line"><span class="tag">color</span>: <span class="tag">black</span>;</div><div class="line"><span class="tag">text-align</span>: <span class="tag">center</span>;</div><div class="line"><span class="tag">text-indent</span>: 2<span class="tag">em</span>;</div></pre></td></tr></table></figure>

<h3 id="代码块缩进">代码块缩进</h3>
<p>所有申明都应该有适当的缩进，就算<code>@media</code>媒体查询也不例外</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="at_rule">@<span class="keyword">media</span> screen, projection </span>{</div><div class="line"></div><div class="line">  <span class="tag">html</span> <span class="rules">{</span></div><div class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</div><div class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#444</span></span></span>;</div><div class="line">  <span class="rule">}</span></div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="所有属性之后都加上分号">所有属性之后都加上分号</h3>
<p>虽然最后一个属性可以不加分号，但建议都加上</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="class">.test</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="class">.test</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100px</span></span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<h3 id="属性名后加上个空格">属性名后加上个空格</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="tag">h3</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value">bold</span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="tag">h3</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> bold</span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<h3 id="选择器群组各占一行">选择器群组各占一行</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="tag">a</span><span class="pseudo">:focus</span>, <span class="tag">a</span><span class="pseudo">:active</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>; <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">1px</span></span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="tag">h1</span>,</div><div class="line"><span class="tag">h2</span>,</div><div class="line"><span class="tag">h3</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">font-weight</span>:<span class="value"> normal</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">1.2</span></span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<h3 id="在两个不同的声明中添加回车来区分">在两个不同的声明中添加回车来区分</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">html</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="tag">body</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> auto</span></span>;</div><div class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50%</span></span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<h3 id="在CSS中省略引号，只在必要时候使用单引号">在CSS中省略引号，只在必要时候使用单引号</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐使用 */</span></div><div class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(<span class="string">"//www.google.com/css/maia.css"</span>)</span>;</div><div class="line"></div><div class="line"><span class="tag">html</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">"open sans"</span>, arial, sans-serif</span></span>;</div><div class="line"><span class="rule">}</span></div><div class="line"></div><div class="line"><span class="comment">/* 推荐使用 */</span></div><div class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(//www.google.com/css/maia.css)</span>;</div><div class="line"></div><div class="line"><span class="tag">html</span> <span class="rules">{</span></div><div class="line">  <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'open sans'</span>, arial, sans-serif</span></span>;</div><div class="line"><span class="rule">}</span></div></pre></td></tr></table></figure>

<h3 id="通过注释分割代码">通过注释分割代码</h3>
<p>通过注释将代码分割成多个分组，注释之后另起一行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Header */</span></div><div class="line"></div><div class="line"><span class="id">#adw-header</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Footer */</span></div><div class="line"></div><div class="line"><span class="id">#adw-footer</span> <span class="rules">{<span class="rule">}</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Gallery */</span></div><div class="line"></div><div class="line"><span class="class">.adw-gallery</span> <span class="rules">{<span class="rule">}</span></span></div></pre></td></tr></table></figure>

<h2 id="总结">总结</h2>
<p>大致上粗略的看了一遍Google的HTML和CSS规范，概括的细节还是比较多的。从中也能看出Google对文档大小的重视，基本上都是能省则省，能用一个字符绝不用两个。其很多地方还是非常值得参考的</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的MV*模式]]></title>
    <link href="http://lingyu.wang/2014/05/03/javascript-mvc/"/>
    <id>http://lingyu.wang/2014/05/03/javascript-mvc/</id>
    <published>2014-05-02T16:00:00.000Z</published>
    <updated>2014-09-18T14:55:53.000Z</updated>
    <content type="html"><![CDATA[<p>虽然在做J2EE的时候就已经对MVC有一定的了解，但平常经常听到的MVVM和MVP模式却完全无法理解是什么意思，《JavaScript设计模式》一书中对MVC、MVP、MVVM做了一个详尽的解释，这里记录了一下上面的知识并做了一个简述，正好在学Angular，这些知识结合Angular一起也更加清晰具体了</p>
<a id="more"></a>

<p>虽然在做J2EE的时候就已经对MVC有一定的了解，但平常经常听到的MVVM和MVP模式却完全无法理解是什么意思，《JavaScript设计模式》一书中对MVC、MVP、MVVM做了一个详尽的解释，这里记录了一下上面的知识并做了一个简述，正好在学Angular，这些知识结合Angular一起也更加清晰具体了</p>
<h2 id="MVC">MVC</h2>
<p>MVC是一种架构设计模式，它将应用分割成业务数据（Model）、用户界面（View）、控制逻辑（Controller）三个部分，其架构图大致是这个样子：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvc.png" alt="MVC架构图"></p>
<h3 id="Model（模型）">Model（模型）</h3>
<p>Model管理应用程序的数据，Model主要与业务数据相关，其不涉及控制层和表示层逻辑。当Model改变时，它会通过Observer模式（Publish/Subscribe）通知观察它的View，一个Model可以有多个观察它的View。</p>
<h4 id="Model与View和Controller的关系">Model与View和Controller的关系</h4>
<p>Model本身不涉及View和Controller的逻辑，它只在乎业务数据模型，并提供相应的接口对其内部数据进行CRUD操作</p>
<h3 id="View（视图）">View（视图）</h3>
<p>视图用于将Model中的业务数据进行展示。在Smalltalk的MVC中，视图通常是绘制和维护位图，而在浏览器中，View通常是负责DOM元素的操作。</p>
<h4 id="View与Model的关系">View与Model的关系</h4>
<p>当一个Model改变时，它会通知所有观察这个Model的View，而这个View在收到通知之后，根据Model中的数据进行相应的更新。</p>
<h4 id="View与Controller的关系">View与Controller的关系</h4>
<p>用于也可以和View（视图）进行交互，包括读取和编辑Model的数据，但由于View是表示层，但一般不使用View直接对Model中的数据进行修改，这个修改过程通常交给Controller来做。View在与用户交互时，在用户操作之后，View不会去了解下一步做什么，而是将用户操作交给Controller来做决定</p>
<h4 id="视图与模板">视图与模板</h4>
<p>使用structs+JSP的开发者（或是Express+jade之类的），容易误以为JSP这样的模板就是View视图，但实际上模板只是部分（也可能是全部）View的声明方式，通过模板的规范来生成View，但不代表View的全部。比如Angular中，使用带指令（如<code>ng-hide</code>,<code>ng-show</code>,<code>ng-repeat</code>）的模板来生成DOM节点，其属于View，但实际上如果在Angular中根据scope的属性方法来修改DOM节点（如<code>$scope.$watch</code>），这也属于View范畴</p>
<h3 id="Controller（控制器）">Controller（控制器）</h3>
<p>Controller中介于Model和View之间，当用户与View进行交互，操作了View之后，它负责更新Model</p>
<h4 id="Controller与Model">Controller与Model</h4>
<p>Controller根据View与用户的交互，来直接对Model进行操作。</p>
<h4 id="Controller与View">Controller与View</h4>
<p>事实上可以理解为Controller为View的策略模式的一个实现。View只是负责与用户交互，其具体应该做的工作交给Controller来决定</p>
<h3 id="MVC模式总结">MVC模式总结</h3>
<p>MVC将应用程序功能模块化，分离出Model、View和Controller三个部分，互相解耦，使得整体维护更加容易。MVC依赖Observer模式（或是Publish/Subscribe实现）来实现它的核心通信</p>
<hr>
<h2 id="MVP">MVP</h2>
<p>MVP模式（模型-视图-表示器）是MVC设计模式的一种衍生模式，专注于改进表示逻辑。MVP中的P为Presenter（表示器），它包含用于View的用户界面业务逻辑的组件，与MVC中不同的是，在Model进行改变之后，它不会直接通知View，而是将修改封装为事件（Events）来通知Presenter，Persenter来与View通信，具体的架构图如下所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvp.png" alt="MVP模式架构图"></p>
<h3 id="Presenter（表示器）">Presenter（表示器）</h3>
<p>Presenter与Controller相同的是，其依旧介于Model和View之间，但不同的地方在于，在MVC中，Model在改变后会直接通知View而不会经过Controller，在MVP中，Model会将其改变封装成一个事件（或是主题），通过Publish/Subscribe模式来传递给Presenter，然后Presenter将更新交给View</p>
<h4 id="Presenter与View的关系">Presenter与View的关系</h4>
<p>Presenter与View的关系与MVC中Controller与View的关系大体相同，但增加了将Model的修改交给View的职责，数据通过调用View的接口来传递</p>
<h4 id="Presenter与Model的关系">Presenter与Model的关系</h4>
<p>Presenter与Modle是一个典型的Pubsub，Presenter作为Subscriber，其订阅了Model的修改事件（主题）。而Model作为Publisher在其数据进行修改后，触发这个事件</p>
<h3 id="MVP模式总结">MVP模式总结</h3>
<p>MVP通过将MVC的Model和View的关系进行改变，使得Model和View进一步解耦，这样Presenter所担任的工作也就相对于MVC中的仅对Model进行更新而有所增加。各个组件直接的数据通信也更易于通过Presenter进行把控</p>
<hr>
<h2 id="MVVM">MVVM</h2>
<p>MVVM模式(模型-视图-视图模型)是一种基于MVC和MVP的架构模式，它试图更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离。它采用了MVP中View和Model的解耦方式，而在View和ViewModel之间也通过Pubsub模式和数据绑定来进行通信，其架构图如下所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvvm.png" alt="MVVM架构图"></p>
<h3 id="ViewModel（视图模型）">ViewModel（视图模型）</h3>
<p>与MVP中的Presenter一样，MVVM中的ViewModel依旧介于View和Model之间。可以将其作为一个专门的Controller，充当数据的转换器，将Model的信息进行适合View的信息，从这个层面上，Viewodel更应该被看做另一个Model。</p>
<h4 id="ViewModel与Model">ViewModel与Model</h4>
<p>ViewModel与Model在通信方式上与MVP几乎没什么差异，但ViewModel在指责上不再只是将Model中的数据传递给View，其将处理View中的显示逻辑，对Model中的业务数据根据需要进行包装，包装成适配View的数据模型</p>
<h4 id="ViewModel与View">ViewModel与View</h4>
<p>与Controller和Presenter所不关心显示逻辑不同的是，ViewModel会处理大部分显示逻辑，并暴露一些方法用于保持View的状态。来源于Model的数据会根据显示逻辑进行包装后，通过Pubsub模式与View进行通信，这里View作为Subscriber而ViewModel作为Publisher。而View层将数据传递给ViewModel则是通过了数据绑定的形式，View处理自己的用户界面事件，必要时将他们映射到ViewModel中</p>
<h3 id="MVVM总结">MVVM总结</h3>
<p>MVVM专注于将UI开发从应用程序业务逻辑与行为分离，通过ViewModel为UI开发提供了更加友好的数据，使得UI开发更加容易。但需要注意的是用于实现数据绑定可能产生大量的标记，且MVVM并不适合UI简单的情况</p>
<hr>
<h2 id="总结">总结</h2>
<p>现有的一些前端框架如Backbone，Angular的等等都是基于MVC模式来进行模块的划分和相互通信的。理解MVC模式在JavaScript中的应用时理解这些库实现方式的基础</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然在做J2EE的时候就已经对MVC有一定的了解，但平常经常听到的MVVM和MVP模式却完全无法理解是什么意思，《JavaScript设计模式》一书中对MVC、MVP、MVVM做了一个详尽的解释，这里记录了一下上面的知识并做了一个简述，正好在学Angular，这些知识结合Angular一起也更加清晰具体了</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谁说前端面试简单我咬谁，汪汪汪！]]></title>
    <link href="http://lingyu.wang/2014/04/30/interview-overview/"/>
    <id>http://lingyu.wang/2014/04/30/interview-overview/</id>
    <published>2014-04-29T16:00:00.000Z</published>
    <updated>2014-09-18T14:55:18.000Z</updated>
    <content type="html"><![CDATA[<p>今天面完了最后一面，基本上都是等（bei）待（tai）状态了，也不打算再投新的了，这里把笔试面试中遇到的点总结一下。大致上分了一下知识点，不过还是不够精细，毕竟每个知识点都详细深入很复杂（很多我也不懂）…</p>
<a id="more"></a>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/gwuyo" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>大致上分了一下知识点，不过还是不够精细，毕竟每个知识点都详细深入很复杂（很多我也不懂）…</p>
<p>底下是找实习的一些感想，不想听感想只想看干货的到这里可以点跳转了~</p>
<h2 id="理想与现实的差距">理想与现实的差距</h2>
<p>本科时候太过堕落，没有实习过，现在回想起来相当的后悔。当时看找实习并不难，一直以为找实习很简单，也就面试一下，态度端正就能进。但经过这几周的笔试面试经历，发现和我以前想的完全不一样。并不是所有投简历的人都有面试机会，而面试也是层层筛选，甚至听说某公司产品最后都到5面副总裁面了，瞬间吓尿了。公司招收暑期实习都尽量希望实习生能留下来，留下来也许会容易很多，实习期也算是培训成本，自然笔试面试的要求就提高了</p>
<h2 id="学院派的狭隘">学院派的狭隘</h2>
<p>身为一个没有实习经历的学生，我对前端的认知主要来源于身边的其他人以及一些浅显的书本。在之前，我一直认为前端工程师只需要会写点HTML，会写点CSS，会写点JS完成一些交互就行了。主要学习的也就是JS和CSS的基础，自己实现的东西很少。当时主要就是用了用jQuery，没用其它框架了。而为了实习面试和笔试，更加专注于像js语言本身的坑，css布局等问题上了，认为面试也就问问这些，但实际上完全不是这么回事。面试官虽然会问基础，但他们似乎对上层更感兴趣。模块化，设计模式，异步控制，框架实现，代码组织和管理，项目自动化构建和测试等等，有些在学校里开发时候可能完全不会接触到，如果不是经常逛社区逛博客，可能听都没听过。但这些却是是在企业的工程里常用的，甚至认为是基础的东西，但我所看的一些书本中不会讲这些，或者讲了也不过是概要略过罢了。幸好平常有逛社区，耳濡目染的了解一点基础知识。有一些自己还写过demo，简单的用过。但自己试验性的使用，在没有长期使用需求的情况下，不会去深入地了解，可能一个月不用就忘得干干净净了（比如我的less）。而到面试的时候，面试官问基础也许还能糊弄，而一旦问深了，就只能回答不知道了，面试结果也不会太好</p>
<h2 id="漫漫前端路">漫漫前端路</h2>
<p>说句老实话，本科时候完全没有接触前端，更不会想到自己未来会选择前端这条路。到了大四下学期天天刷算法题（现在全忘干净了…），以为自己以后也会成为算法工程师。结果后来进了实验室做SSH，只是零散的接触前端。 真正决定以后从事前端工作也是在研二。在之前有对自己未来做一个规划，毕竟研究生以来一直做Java和SSH，也曾考虑过是否以后从事Java后台研发。但放弃这个想法而决定专职从事前端的契机，应该是接触css3的动画和变换开始的。当时出于好奇，去研究了一下css3的animation，看到网上大牛们实现的效果，直接吓尿。那些炫酷的效果完全改变了我对网页的理解。之前一直以为网页的作用不过是简单的数据展示和交互，而css3的动画效果所带来的体验直接击碎了那错误的想法。我喜欢看得见的东西，喜欢刷题时候红丝的AC，喜欢QT做出来的界面，自然也喜欢网页上炫酷的效果。于是乎我决定自己也要做出同样炫酷的网页，从此走上了前端之路。如今找实习投的岗位都是Web前端开发，以前的同学知道后都非常吃惊，他们也没想到我会从事前端，还有人劝我别做前端没有前途，应该做Android，做IOS（当然做这些也和有前途）。还有的学长认为前端很简单，说只有技术不行的才会做前端，对于这样的观点，我只能呵呵了，毕竟不做前端的人永远不会知道前端水有多深</p>
<h2 id="结语">结语</h2>
<p>找实习也终于结束了，虽然结果还没定下来，不过我也改变不了了。终于可以不用失眠睡不好觉了，也可以静下心来看看书写写代码了。最近学了Angular感受到了MVVM框架的强大，无奈练手机会不多。虽然把博客全改成Angular了，但也只是用到其中的部分功能，像自定义指令之类的完全没有去用，还是需要多写一写。另外买了司徒正美的新书《JavaScript框架设计》，里面的知识点很多，各种框架的源代码也很多，正在慢慢啃，慢慢吸收，进度相当缓慢，也需要一段时间吧。另外还计划看《jQuery技术内幕》，估计得到两三周之后了吧</p>
<p>这两天的状态大概是这个样子：<br><img src="http://skyinlayerblog.qiniudn.com/blog/img/sleepydog.jpg" alt="死狗"></p>
<p>五一假期好好休息休息，听一听歌吧~</p>
<embed src="http://www.xiami.com/widget/30211350_1770830087/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent">&nbsp;

]]></content>
    <summary type="html">
    <![CDATA[<p>今天面完了最后一面，基本上都是等（bei）待（tai）状态了，也不打算再投新的了，这里把笔试面试中遇到的点总结一下。大致上分了一下知识点，不过还是不够精细，毕竟每个知识点都详细深入很复杂（很多我也不懂）…</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="笔试面试题" scheme="http://lingyu.wang/tags/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试面试积累" scheme="http://lingyu.wang/categories/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有没有感觉有一些变化？]]></title>
    <link href="http://lingyu.wang/2014/04/26/new-page2/"/>
    <id>http://lingyu.wang/2014/04/26/new-page2/</id>
    <published>2014-04-25T16:00:00.000Z</published>
    <updated>2014-09-18T14:58:55.000Z</updated>
    <content type="html"><![CDATA[<p>如果你是曾经来过天镶博客的朋友，肯定会感觉到很大的不同，博客换页面啦！连续六天没有更新博客了，除了各种面试和项目上的事情以外，闲暇时间都在写这个新页面，也就没有写博文了。经过3天半的努力，新页面也终于做出来了~</p>
<a id="more"></a>

<h2 id="之前的页面">之前的页面</h2>
<h3 id="失败的模仿">失败的模仿</h3>
<p>之前的页面是模仿<a href="http://www.csszengarden.com/220//" target="_blank" rel="external">CSS禅意花园的220号作品</a>做的，虽然CSS什么都是自己写的（无耻地盗用了别人的素材图片），而且做成了响应式的，但模仿出来并不很像。其背景上巨大的字一开始以为是图片，结果是通过文字加mask实现的…但mask的跨浏览器支持很不好，于是乎就放弃了</p>
<h3 id="缺乏层次感">缺乏层次感</h3>
<p>由于缺少背景内容，用单纯的颜色去实现就会有一种没经过装修的毛坯房的感觉（而且北京还是灰色的）。于是去网上找了个纹理贴上去，这样背景比单纯的颜色要好一些。但整个页面都是同样的纹理平铺，所有的组件基本上没有太大的区分度，缺乏层次感</p>
<h3 id="左上角的空洞">左上角的空洞</h3>
<p>之前的页面左上角也没什么东西可放，而左上角区域也是网页最重要的区域，整个页面总感觉缺了什么，比较空洞。最初想弄几个图片或者用CSS画点什么放在左上角区域，但实践了一下发现丑的可怕，于是乎就放弃了…</p>
<h3 id="网速的桎梏">网速的桎梏</h3>
<p>开发之前那个页面的时候，基本没有使用图片，效果都使用CSS实现，背景纹理也是几百B的纹理，这一切都是因为整站搭载在Github上，访问速度较慢。最早一版本使用的html5up的网页，一个纹理60+k，慢的吐血，第二版也就长心眼了，但这个心眼也成了开发时的枷锁</p>
<h3 id="Jekyll做了太多">Jekyll做了太多</h3>
<p>之前博客的所有文件都是使用Jekyll生成的静态HTML页面，站点的维系就在于静态页面之间的相互跳转，分页什么的都很不方便（虽然实现了）</p>
<h2 id="刚出炉的包子更好吃">刚出炉的包子更好吃</h2>
<h3 id="Angular，不一样的开发模式">Angular，不一样的开发模式</h3>
<p>最近刚学的Angular，其MVVM模式、动态模板、双向绑定、路由功能等等都让我大开眼界。于是乎就决定通过Angular来重新实现这个博客，顺带练练手，使用ngRoute路由来将整个博客做成单页应用，文章列表等等都由Angular动态加载。这样Jekyll不再涉及页面具体的逻辑，只需要生成博客中需要的json、xml以及文章的html等资源文件就可以了。而且使用Angular的filter去实现搜索功能简直爽翻啦~</p>
<h3 id="CDN，飞一般的感觉">CDN，飞一般的感觉</h3>
<p>上一版本的博客页面一个最大的问题就是，担心加载速度。放在github上，GFW常年抽风，所有的资源文件（JS、CSS、字体、图片）等等都放在github上，各种慢。在中间写Gitbook的时候，慢的都想砸电脑了，一个js就600k。偶然间尝试使用<a href="http://www.staticfile.org/" target="_blank" rel="external">七牛的CDN</a>，加载上面的jQuery、ace等库，速度提升显著。将库文件全部改成CDN提供后，又在七牛上申请了免费的云空间。新博客页面把使用的资源都放在七牛的云空间上，比之前要快得多，也敢使用大图片和矢量图标之类的</p>
<h3 id="Grunt，自动化构建的利器">Grunt，自动化构建的利器</h3>
<p>Grunt这个东西其实在上一版就已经使用了，通过使用Grunt的各种插件，将博客的编译，开启本地服务器，上传到Github等等都封装到一个命令，一行命令就可以完成整个博客的构建。同时打破了Jekyll的文件目录形式，自己组织源码文件夹，然后通过Grunt来进行文件的复制生成等等。这样管理资源也变得更加容易了</p>
<h3 id="新样式，新感觉">新样式，新感觉</h3>
<p>虽然一直在努力看一些设计的书和博客，学习网页设计，但无奈审美太乡村非主流。之前的页面配色真心不咋地（虽然现在还是不咋地），一直觉得一个不会网页设计的前端工程师不能算一个真正的前端工程师，于是乎就到处去参照别人的网页，吸取一些好看的网页的设计思路，然后对其进行模仿。新的页面参考了很多页面，后续也会进行更多的改进（不排除闲得无聊再重写一个的可能）。相对于之前的页面，也算换换口味吧</p>
<h2 id="最后">最后</h2>
<p>最近各种面试被虐的心力憔悴，而且还各种pending没有结果，偷闲换个页面转换一下心情，在这里祝愿自己能早点收到offer吧</p>
<p>这里贴一张小白的微笑，勉励一下自己吧~</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-4-26-new-page2/flag.jpg" alt="小白的微笑" title="小白的微笑"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果你是曾经来过天镶博客的朋友，肯定会感觉到很大的不同，博客换页面啦！连续六天没有更新博客了，除了各种面试和项目上的事情以外，闲暇时间都在写这个新页面，也就没有写博文了。经过3天半的努力，新页面也终于做出来了~</p>
]]>
    
    </summary>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的设计模式]]></title>
    <link href="http://lingyu.wang/2014/04/20/js-design-patterns/"/>
    <id>http://lingyu.wang/2014/04/20/js-design-patterns/</id>
    <published>2014-04-19T16:00:00.000Z</published>
    <updated>2014-09-18T14:57:09.000Z</updated>
    <content type="html"><![CDATA[<p>这几天在看《JavaScript设计模式》这本书，里面主要就是讲述了“四人帮”的设计模式在JavaScript中的应用和实现。之前使用Angular发现里面有太多的设计模式，而以前看的关于设计模式的东西也忘得差不多了，看这本书正好帮我找回了以前对于常见设计模式的理解，更是学到了如何使用JavaScript实现这些设计模式</p>
<a id="more"></a>

<h3 id="读书笔记连接">读书笔记连接</h3>
<p>读书笔记详细内容请看：<a href="/gitbook/jsDesignPatterns/README.html">读书笔记连接</a></p>
<h3 id="读书">读书</h3>
<p>最近博客更新的不是很频繁，这并不代表我一直都在摸鱼。实际上还是有看一些书的，也做了读书笔记。</p>
<h3 id="书评">书评</h3>
<p>这几天在看《JavaScript设计模式》这本书，里面主要就是讲述了“四人帮”的设计模式在JavaScript中的应用和实现。之前使用Angular发现里面有太多的设计模式，而以前看的关于设计模式的东西也忘得差不多了，看这本书正好帮我找回了以前对于常见设计模式的理解，更是学到了如何使用JavaScript实现这些设计模式。</p>
<p>关于《JavaScript设计模式》这本书，虽然翻译者是汤姆大叔，但说实话，翻译的很蛋疼。读起来不是太好懂。更蛋疼的是，虽然还只看了一半，却发现很多代码中的错误。除了很多代码缩进恶心，还有很多地方代码甚至连到了一起，中间空格被吃掉了</p>
<h3 id="Gitbook">Gitbook</h3>
<p>由于读书笔记总是会记录比较多，而且在读时还会自己去实现其中的例子，如果全部发到博客上的话，缩成两到三篇文章由太长，每个模式都单独写一篇又容易刷屏，把其他的文章全部顶掉。所以决定把它们都放在gitbook上，也就是左下角侧边栏的“读书笔记”里面。之前的《CSS禅意花园》和《Don’t make me think》的读书笔记也都放在里面了。未来如果有读书笔记应该也会放在里面吧</p>
<h3 id="优化">优化</h3>
<p>其实Gitbook这个东西加了有一段时间了，但是因为它的css文件、字体文件和js文件太大（200+k和600+k），放在github上无奈速度太慢，所以也就没怎么用了。最近看了看他模块内部的结构，发现其代码不是动态生成的，这个CSS和JS都是静态的，果断将其丢到了七牛云存储上，而它使用的诸如ace等库也改成了七牛提供的CDN，速度飙升。在把所有图片都丢到七牛上之后，终于可以勉强使用了（也是勉强使用，有时候还是很慢）。如果可以的话，后面把所有博客的图片都丢到七牛上</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这几天在看《JavaScript设计模式》这本书，里面主要就是讲述了“四人帮”的设计模式在JavaScript中的应用和实现。之前使用Angular发现里面有太多的设计模式，而以前看的关于设计模式的东西也忘得差不多了，看这本书正好帮我找回了以前对于常见设计模式的理解，更是学到了如何使用JavaScript实现这些设计模式</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的继承]]></title>
    <link href="http://lingyu.wang/2014/04/18/javascript-inherit/"/>
    <id>http://lingyu.wang/2014/04/18/javascript-inherit/</id>
    <published>2014-04-17T16:00:00.000Z</published>
    <updated>2014-09-18T14:55:35.000Z</updated>
    <content type="html"><![CDATA[<p>面试遇到了继承的问题，虽然以前有在《JavaScript模式》里读过，不过由于记得不是很牢直接花样作死了。面试官也说继承的知识相当重要，于是乎又在闲暇的时候写了些继承的实现</p>
<a id="more"></a>

<h2 id="new都干了些什么">new都干了些什么</h2>
<hr>
<h3 id="大致流程">大致流程</h3>
<p>通过new创建的对象，大致过程如下：</p>
<ol>
<li>首先创建个Object</li>
<li>修改这个对象的<code>__proto__</code>，使其指向构造函数的<code>prototype</code></li>
<li>将这个对象交给构造函数的<code>this</code>，调用构造函数</li>
<li>如果构造函数没有return，那么返回这个对象。否则构造函数返回return语句后面的内容</li>
</ol>
<h3 id="模拟一下">模拟一下</h3>
<p>我们可以通过在Function.prototype上创建个新方法来模拟new：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.__new__ = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> newObj;</div><div class="line">    <span class="keyword">var</span> resultObj;</div><div class="line">    newObj = {};</div><div class="line">    newObj.__proto__ = <span class="keyword">this</span>.prototype;</div><div class="line">    resultObj = <span class="keyword">this</span>.apply(newObj, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> resultObj === <span class="string">'object'</span> && resultObj) || newObj;</div><div class="line">};</div></pre></td></tr></table></figure>

<h2 id="constructor的问题">constructor的问题</h2>
<p>在创建一个函数时，会为这个函数增加一个<code>prototype</code>属性指向一个对象，而这个<code>prototype</code>对象内有一个属性就是<code>constructor</code>，这样在使用构造函数创建一个新对象时，新对象的<code>__proto__</code>自然指向含有<code>constructor</code>的构造函数的<code>prototype</code>对象。但当更换了这个构造函数的<code>prototype</code>，一切就不一样了。比如如下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span></span>{}</div><div class="line">A.prototype = {}</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A().constructor)</div><div class="line"><span class="comment">//输出：function Object() { [native code] }</span></div></pre></td></tr></table></figure>

<p>这里并没有输出<code>function A(){}</code>。因为A的<code>prototype</code>对象已经被重写了，其为一个Object实例，A的<code>prototype</code>对象中不包含<code>constructor</code>属性。而输出Object构造函数是因为Object实例的<code>__proto__</code>指向<code>function Object(){}</code>的prototype属性，而它内部有constructor：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(tmp.__proto__.hasOwnProperty(<span class="string">"constructor"</span>));</div><div class="line"><span class="comment">//输出：false</span></div><div class="line"><span class="built_in">console</span>.log(tmp.__proto__.__proto__.hasOwnProperty(<span class="string">"constructor"</span>));</div><div class="line"><span class="comment">//输出：true</span></div></pre></td></tr></table></figure>

<p>所以，如果直接使用通过修改<code>prototype</code>的方式实现继承，这将导致<code>constructor</code>不正确，比如如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{}</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child().constructor);</div><div class="line"><span class="comment">//输出：function Parent(){}</span></div></pre></td></tr></table></figure>

<p>如果想要<code>new Child().constructor</code>指向Child，我们需要显示的修改其<code>prototype</code>的<code>constructor</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{}</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Child().constructor);</div><div class="line"><span class="comment">//输出：function Child(){}</span></div></pre></td></tr></table></figure>

<h2 id="继承方法">继承方法</h2>
<h3 id="直接继承">直接继承</h3>
<p>这种方式也就是上面的例子了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Child);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Parent);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst.constructor);</div><div class="line"><span class="comment">//输出：function Child(){}</span></div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出如下图</span></div></pre></td></tr></table></figure>

<p>整个childIst对象如下图所示：</p>
<p><img src="http://lingyu.wang/img/js_inherit/1.png" alt="直接继承时的对象"></p>
<p>这种方式实现简单，这种方式有如下特点：</p>
<ol>
<li>所有子类实例共用一个父类实例，节省空间</li>
<li>父类的所有属性都会被暴露给子类</li>
<li>父类的属性子类无法直接修改，只能覆盖</li>
<li>无法实现多继承</li>
</ol>
<h3 id="Object-create方式">Object.create方式</h3>
<p>在ECMAScript5中新增了<code>Object.create</code>方法用于实现继承，其大致实现如下（不考虑属性添加）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.create = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> </span>{</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>{}</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">};</div></pre></td></tr></table></figure>

<p>所以一种可行的继承方式变成如下这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Child);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Parent);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst.constructor);</div><div class="line"><span class="comment">//输出：function Child(){}</span></div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：如下图所示</span></div></pre></td></tr></table></figure>

<p><img src="http://lingyu.wang/img/js_inherit/2.png" alt="Object.create继承时的对象"></p>
<p>没有parentName属性，因为这种方式实现的继承并没有创建父类实例，而是通过一个临时函数复制了父类的<code>prototype</code>来创建。这样的话父类不在其<code>prototype</code>中的属性不会被复制到临时构造函数中，这些属性对子类是不可见的</p>
<p>这种继承方式的特点是：</p>
<ol>
<li>父类仅其prototype上的属性对子类可见</li>
<li>同样无法多继承</li>
<li>所有子类实例公用的一个父类实例</li>
<li>ES5方法，兼容性，ie9+，不兼容时需要polyfill</li>
</ol>
<p>这种通过创建一个临时对象的方式可以用在很多地方，只要需要隐藏父类自身属性的场景都可以用到</p>
<h3 id="复制属性实现继承——共用原型">复制属性实现继承——共用原型</h3>
<p>传统的类继承，子类实例不会共享父类实例，每一个子类实例拥有自己的父类实例。而JS中并没有这样的继承方式，可以通过将父类的所有值拷贝给子类实例的方式来实现继承：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</div><div class="line">};</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line">Child.prototype = Parent.prototype;</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Child);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Parent);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst.constructor);</div><div class="line"><span class="comment">//输出：function Child(){}</span></div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：见下图</span></div></pre></td></tr></table></figure>

<p>子类实例的结构图如下所示：</p>
<p><img src="http://lingyu.wang/img/js_inherit/3.png" alt="复制属性，共用原型时的对象"></p>
<p>这种方式，通过<code>Parent.apply(this)</code>将子类实例传递给父类构造函数，让父类构造函数将其属性写入子类之中，这里只复制了父类<code>this</code>上的属性，没有复制原型上的属性。然后再子类构造函数中定义子类属性，若与父类属性同名，将会覆盖父类属性。最后将子类构造函数指向父类构造函数的<code>prototype</code>，使得子类实例拥有父类实例的原型链</p>
<p>这种方式继承有如下特点：</p>
<ol>
<li>子类属性覆盖掉了父类属性，同时每个子类实例可修改其父类属性而不影响到其他对象</li>
<li>可以通过<code>delete</code>来对父类不想要暴露的属性进行删除</li>
<li>每个子类实例拥有自己的父类属性</li>
<li>子类与父类同名属性发生覆盖，覆盖后无法再获取覆盖前的父类属性值</li>
<li>由于父类和子类共享<code>prototype</code>，若修改子类的<code>prototype</code>属性会影响到所有继承于父类的子类，所以不能修改</li>
</ol>
<h3 id="复制属性实现继承——不共用原型">复制属性实现继承——不共用原型</h3>
<p>可通过修改上述方法实现不共用原型的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span> </span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</div><div class="line">};</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();</div><div class="line">Child.prototype.constructor = Child;</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：见下图</span></div></pre></td></tr></table></figure>

<p><img src="http://lingyu.wang/img/js_inherit/4.png" alt="复制属性，不共用原型时的对象"></p>
<p>还是通过原型链的方式，这样子类实例就有可修改的父类属性了。但这样会重复调用父类构造函数，导致创建重复属性（比如parentName）浪费内存空间，但这样就去除了上面的共用构造函数<code>prototype</code>所带来的问题。</p>
<h3 id="扁平复制">扁平复制</h3>
<p>由于继承的目标就是让子类拥有父类的特性，那么最为简单粗暴的方法，就是把父类的所有属性和方法全部复制到子类上去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> parentIst = <span class="keyword">new</span> Parent();</div><div class="line">    <span class="keyword">var</span> item;</div><div class="line">    <span class="keyword">for</span>(item <span class="keyword">in</span> parentIst) {</div><div class="line">        <span class="keyword">this</span>[item] = parentIst[item];</div><div class="line">    }</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Child);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst <span class="keyword">instanceof</span> Parent);</div><div class="line"><span class="comment">//输出：true</span></div><div class="line"><span class="built_in">console</span>.log(childIst.constructor);</div><div class="line"><span class="comment">//输出：function Child(){}</span></div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：见下图</span></div></pre></td></tr></table></figure>

<p><img src="http://lingyu.wang/img/js_inherit/5.png" alt="扁平复制所有属性时的对象"></p>
<p>这种方式实现的继承比较扁平，由于没有使用原型继承，其原型链层数不会增加，有如下特点：</p>
<ol>
<li>可以实现多继承</li>
<li>会发生属性覆盖，被覆盖的属性无法获得</li>
<li><code>instanceof</code>操作符无法检测父类</li>
<li>子类实例拥有所有父类实例的所有属性，且可修改和删除</li>
<li>父类所有属性均进入到子类中（可能后面会被覆盖，可以通过<code>Object.create</code>所提供的方式修改实现）</li>
</ol>
<h3 id="隐藏属性的扁平复制——仅复制父类原型属性">隐藏属性的扁平复制——仅复制父类原型属性</h3>
<p>考虑到属性隐藏，可以使用Object.create的方式来进行属性隐藏，那么代码就变成下面这样了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">var</span> tmpFn = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{};</div><div class="line">    <span class="keyword">var</span> tmpFnIst;</div><div class="line">    <span class="keyword">var</span> item;</div><div class="line">    tmpFn.prototype = Parent.prototype;</div><div class="line">    tmpFnIst = <span class="keyword">new</span> tmpFn();</div><div class="line">    <span class="keyword">for</span>(item <span class="keyword">in</span> tmpFnIst) {</div><div class="line">        <span class="keyword">this</span>[item] = tmpFnIst[item];</div><div class="line">    }</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：见下图</span></div></pre></td></tr></table></figure>

<p><img src="http://lingyu.wang/img/js_inherit/6.png" alt="扁平复制父类原型属性时的对象"></p>
<p>可以看到，通过临时构造函数，将父类中不在其<code>prototype</code>中的属性进行了隐藏</p>
<h3 id="隐藏属性的扁平复制——仅复制父类自身属性">隐藏属性的扁平复制——仅复制父类自身属性</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">this</span>.parentName = <span class="string">"parent"</span>;</div><div class="line">}</div><div class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parentName;</div><div class="line">}</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span><span class="params">()</span></span>{</div><div class="line">    Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">this</span>.childName = <span class="string">"child"</span>;</div><div class="line">}</div><div class="line"><span class="keyword">var</span> childIst = <span class="keyword">new</span> Child();</div><div class="line"><span class="built_in">console</span>.log(childIst);</div><div class="line"><span class="comment">//输出：见下图</span></div></pre></td></tr></table></figure>

<p><img src="http://lingyu.wang/img/js_inherit/7.png" alt="扁平复制父类自身属性的对象"></p>
<p>这种方式和上面方式刚好相反，仅仅复制父类自身方法，而不复制其原型链上的方法</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>面试遇到了继承的问题，虽然以前有在《JavaScript模式》里读过，不过由于记得不是很牢直接花样作死了。面试官也说继承的知识相当重要，于是乎又在闲暇的时候写了些继承的实现</p>
]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="前端技术" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
      <category term="笔试面试积累" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
</feed>
