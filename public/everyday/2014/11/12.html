<h2 id="收获">收获</h2>
<p>今天又读了几十页《程序员必读的软件架构》，记了点笔记：</p>
<ul>
<li>软件架构师应当是建造大师<ul>
<li>架构师脱离开发团队，没有参与变成而对开发者指指点点，只会让开发者感到厌烦</li>
<li>互联网发展迅速，需要团队中有人一直跟随着技术的发展，才有能力对如何设计软件做出正确的决策</li>
<li>架构师应当任何时候只关注一个项目，跟进项目的发展，并保证架构随着项目的开发不断演化</li>
</ul>
</li>
<li>从开发者到架构师<ul>
<li>经验是一个很好的标准，但是还需要看的更深<ul>
<li>架构驱动力：捕捉和挑战一套复杂的非功能需求，还是简单假设他们的存在</li>
<li>设计软件：从零开始设计一个软件系统，还是扩展已有的</li>
<li>技术风险：证明架构能够工作，还是盲目乐观</li>
<li>架构演化：持续参与和演化架构，还是交给“实现团队”</li>
<li>编写代码：参与交付的实践部分，还是袖手旁观</li>
<li>质量保证：保证质量并选择标准，还是反其道而行之或无所作为</li>
</ul>
</li>
<li>开发人员通往架构师的道路是一个演化过程，不断积累跨越不同领域的融会贯通的技术、知识、经验。</li>
</ul>
</li>
<li>扩展T<ul>
<li>T指的是技术，架构师同样需要懂得技术。在技术的深度上，至少要能够回答两个问题<ul>
<li>该方案能否奏效</li>
<li>是否要这样去构建</li>
</ul>
</li>
<li>架构师同时需要有开放的思维，不能受困于单一技术栈，这就要求技术的广度，这样才能找出最合适的技术，做出最正确的决策</li>
<li>架构师需要有深厚的技术积累、多年软件构建经验、广阔的知识面</li>
</ul>
</li>
<li>软技能<ul>
<li>领导力：创造共有的愿景，并带领团队前行</li>
<li>沟通：将想法和愿景传达给他人</li>
<li>影响力：每个人都有自己的想法，能将自己的想法传达给别人而不至于让别人反感并主动追求需要的结果</li>
<li>信心：信心是领导力、影响力和沟通的基础</li>
<li>合作：架构角色不应该被鼓励</li>
<li>指导：进行角色、技术方面的指导</li>
<li>辅导：帮助他人进步</li>
<li>动力：保持团队愉快、开朗、积极</li>
<li>润滑剂：退后一步，促进讨论，帮助团队达成共识</li>
<li>政治：离政治越远越好，才能做出可靠的决策</li>
<li>责任感：不要因为失败而去职责团队中的其他人，软件不能满足业务目标、无法交付非功能性需求或技术品质不够，都是架构师的问题</li>
<li>授权：需要进行授权交给其他人做一些事</li>
</ul>
</li>
<li>软件架构不是接力运动<ul>
<li>有的架构师只是负责架构设计，然后就丢给实现团队去实现并不闻不问不负责，最后往往接手的团队不会对这个方案负责， 最初创建的“架构”变得脱离现实。在这种情况下，架构师是无法保证自己的架构是否正确的</li>
<li>创建一个最初的愿景，交流，并在整个开发的生命周期中不断的演化，这对于一个成功的软件项目是必须的</li>
</ul>
</li>
<li>软件架构要引入控制吗<ul>
<li>只有引入了一定程度的控制和约束，指导和一致性才可能成为现实</li>
<li>控制也可以只是保证代码库有一个清晰一致的结构，以包、命名空间、组件、层等形式合理地组织你的代码</li>
<li>从部分控制开始，倾听反馈，以便随着项目的推进再微调</li>
</ul>
</li>
<li>小心鸿沟<ul>
<li>开发者更加关注底层细节，由此会忽略一些其他的问题</li>
<li>架构师则关注“大局”，但应该融入到开发团队当中，而不是高高在上</li>
<li>软件架构师：<ul>
<li>包容与合作：帮助团队了解大局，确保每个人都明白决策背后的原理和目的</li>
<li>动手：如果可能，参与一些开发来提高对架构交付的理解，或者参加协助设计和代码评审，了解底层能够更好地理解开发对于架构的感受，可以帮助架构朝着正确的方向演化</li>
</ul>
</li>
<li>软件开发者：<ul>
<li>了解大局：了解大局能够帮助做出符合架构决策的判断，增强对系统整体的理解</li>
<li>挑战架构决策：了解了架构，才有机会挑战架构决策。架构是合作的过程，如果有不合理的地方，应当有自己的见解并乐于挑战</li>
<li>申请参与：开发者也可以参与到架构之中</li>
</ul>
</li>
</ul>
</li>
<li>未来的软件架构师在哪里<ul>
<li>架构师的技术积累和经验积累应当分享出来帮助别人</li>
<li>企业内的技术晋升会导致大量的资深技术人员脱离技术岗位，也导致了技术导师的消失</li>
<li>编码经验积累容易，练习手段较多，但架构、设计的实践机会较少</li>
</ul>
</li>
<li>每个人都是架构师，除非他们有其他身份<ul>
<li>不同的团队需要不同的领导风格，但总要有人总览大局</li>
<li>与敏捷对立的是大型预先设计，而不是架构</li>
<li>代码集体所有制，每个人都要能在架构的层次上工作</li>
</ul>
</li>
<li>软件架构咨询师<ul>
<li>架构师应当对该业务领域有相当的了解</li>
</ul>
</li>
<li>架构驱动力<ul>
<li>驱动、影响、塑造最终的软件架构</li>
<li>功能需求：设计软件需要了解要满足的目标。需求驱动架构</li>
<li>质量属性：非功能性需求反映服务等级，包括<ul>
<li>性能</li>
<li>可伸缩性</li>
<li>可用性</li>
<li>安全性</li>
</ul>
</li>
<li>约束<ul>
<li>任职的组织对于技术选型、部署平台等都有会约束</li>
</ul>
</li>
<li>原则<ul>
<li>约束是强加的，而原则则是自己为了将一致性和清晰度引入代码库所采用的原则或架构的原则</li>
</ul>
</li>
<li>理解影响<ul>
<li>在高层次上理解需求、约束和原则至关重要。</li>
<li>可以帮助减少摆在面前的可选项</li>
<li>能够根据特定的目标和语境，做出“明智”的设计决策</li>
<li>用变动的成本来衡量设计决策的重要性，避免昂贵的返工</li>
</ul>
</li>
</ul>
</li>
<li>质量属性（非功能需求）<ul>
<li>一些属性：<ul>
<li>性能：通常指响应时间或延迟</li>
<li>可伸缩性：软件处理更多用户、请求、数据、消息等的能力，与并发机制密不可分</li>
<li>可用性：软件对服务请求的可操作和可见程度</li>
<li>安全性</li>
<li>灾难恢复</li>
<li>可访问性：方便残障人士</li>
<li>监测：软件、平台的功能性监测、性能监测、故障报警等等</li>
<li>管理：运行时故那里需求</li>
<li>审计：事件日志及记录</li>
<li>灵活性：软件执行多任务或以不同方式执行单任务的灵活性</li>
<li>可扩展性：方便功能扩展，插件或API等</li>
<li>可维护性：遵循架构和开发原则</li>
<li>法律法规</li>
<li>国际化</li>
<li>本地化</li>
</ul>
</li>
<li>属性很多，观察已有系统找出领域中常用的质量属性</li>
</ul>
</li>
<li>处理非功能需求<ul>
<li>需求提出方极少明确提出非功能性需求</li>
<li>与业务方沟通，量化非功能性需求</li>
</ul>
</li>
<li>约束<ul>
<li>非技术约束<ul>
<li>时间</li>
<li>预算</li>
<li>人力</li>
<li>组织</li>
</ul>
</li>
<li>技术约束<ul>
<li>批准技术清单</li>
<li>现有系统的互操作性</li>
<li>目标部署平台</li>
<li>技术成熟度</li>
<li>开放源代码</li>
<li>供应商“关系”</li>
<li>过去的失败</li>
<li>内部知识产权</li>
</ul>
</li>
<li>约束可以划分优先级，低优先级的约束会因为高优先级的约束而放宽</li>
</ul>
</li>
<li>原则<ul>
<li>开发原则<ul>
<li>编码标准和规范</li>
<li>自动化单元测试</li>
<li>静态分析工具</li>
<li>其他</li>
</ul>
</li>
<li>架构原则<ul>
<li>分层策略：向上抽象</li>
<li>业务逻辑位置：确保业务逻辑在一个地方</li>
<li>高内聚、低耦合、SOLID：关注点分离相关原则，构建高内聚的小结构单元</li>
<li>无状态组件：无状态组件会有很强的可伸缩性</li>
<li>存储过程：提供关系型数据库的数据访问方法</li>
<li>域模型：丰富与贫瘠：面向对象的系统还是粗粒度的组件和服务使用的数据结构</li>
<li>HTTP会话的使用：如何支持会话，会话的存储，服务器故障后的会话恢复</li>
<li>始终一致与最终一致</li>
</ul>
</li>
<li>最佳实践也可能带来意想不到的负面影响，先评估原则的好处，再确定是否引入</li>
</ul>
</li>
<li>技术不是实现细节<ul>
<li>架构图应当包含技术的选择</li>
<li>大多数需求能够通过几乎所有的技术满足，但如果有复杂的非功能性需求的时候，就不一定都管用了</li>
<li>别忘了还有约束</li>
<li>技术的选择关乎到一致性的保持，另外选择同一个技术栈的技术更容易保持一致性</li>
<li>可以通过解耦来推迟技术决策，但这其实是将决策的重点转移</li>
<li>决策都是权衡，任何技术都有优缺点</li>
</ul>
</li>
<li>更多分层等于更高复杂度<ul>
<li>引入额外的层，在解耦的同时，带来了跟高的复杂度、更多的风险点</li>
</ul>
</li>
<li>协同设计是一把双刃剑<ul>
<li>我们拥有的知识、经验和偏好往往会影响我们设计软件的方式</li>
<li>交流有助于打破孤岛，团队每个人有自己的想法，但应当达成共识</li>
</ul>
</li>
<li>软件架构师对话的平台<ul>
<li>软件的使用者知识利益相关者的一类，通常还有很多其他的类型：<ul>
<li>当前的开发团队：开发团队需要了解架构，知道驱动力是什么，才能保证解决方案与架构一致且有效</li>
<li>未来的开发团队：了解了架构才能明白解决方案如何运作，并以一致的方式去修改它</li>
<li>其他团队：系统如何与其他团队集成</li>
<li>数据库管理员：需要了解你的系统如何使用它们的数据库服务</li>
<li>执行/支持人员：业务人员需要了解如何运行和支持你的系统</li>
<li>遵守、风险和审计：规定遵守</li>
<li>安全团队：需要经过安全评审才能进入生产环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="感想">感想</h2>
<p>不懂的太多了，好多东西都需要恶补</p>
