<h1 id="阅读">阅读</h1>
<h2 id="全球最快的JS模板引擎"><a href="http://www.html-js.com/article/JS-on-the-worlds-fastest-JS-template-engine">全球最快的JS模板引擎</a></h2>
<p>这个模板的实现挺有意思的，先用split提取出html和特殊规则，然后针对特殊规则用正则匹配，替换成对应的js代码的字符串，然后把所有的字符串拼接，放在new Function中执行，就编译了，返回的函数是编译结果这样就还能复用…</p>
<h2 id="一个对前端模板技术的全面总结"><a href="http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology">一个对前端模板技术的全面总结</a></h2>
<h3 id="三种模板：">三种模板：</h3>
<ol>
<li>String-based 模板技术 (基于字符串的parse和compile过程)</li>
<li>Dom-based 模板技术 (基于Dom的link或compile过程)</li>
<li>杂交的Living templating 技术 (基于字符串的parse 和 基于dom的compile过程)</li>
</ol>
<h3 id="innerHTML：">innerHTML：</h3>
<ul>
<li>优势：<ol>
<li>快</li>
<li>字符到DOM，方便直观</li>
</ol>
</li>
<li>劣势：<ol>
<li>安全问题，容易XSS</li>
<li>慢，容易为了一个节点重新渲染大量内容</li>
<li>必须完全移除，然后重新渲染</li>
<li>有时会出错，但无提示</li>
</ol>
</li>
</ul>
<h3 id="String-based">String-based</h3>
<p>字符串编译或者通过AST解析后，丢到new Function生成执行函数，然后加上data来渲染，最终结果也是字符串，通过innerHTML插入到页面</p>
<ol>
<li>初始化简单</li>
<li>轻便，脱离DOM</li>
<li>灵活的语法支持</li>
</ol>
<h3 id="Dom-based">Dom-based</h3>
<p>字符串通过解析器解析，编译后生成无状态DOM，然后链接到活动的DOM，并与model双向绑定</p>
<ol>
<li>声明式开发</li>
<li>局部刷刷新</li>
<li>双向绑定</li>
</ol>
<h3 id="Living_Template_Engine">Living Template Engine</h3>
<p>字符串通过DSL-based解析器生成AST语法树，然后编译到活动DOM，并与model双向绑定</p>
<p>利用脏检查检测数据变化后，在AST和DOM API基础上来完成View组装</p>
<h1 id="收获">收获</h1>
<p>无</p>
<h1 id="生活">生活</h1>
<p>走了，离开北京，离开校园…再见了小伙伴们</p>
