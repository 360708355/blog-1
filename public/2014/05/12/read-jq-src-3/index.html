<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="天镶"><meta name="description"><title>jQuery的事件机制——核心篇 | 天镶的博客</title><link href="/favicon.ico" rel="icon"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/typo/typo-1.1.css"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/highlight/highlight-8.0-dark.css"><link rel="stylesheet" media="screen" href="/stylesheets/app.css"></head><body><a id="totop" href="#page-header" class="iconfont">&#xe60b;</a><header id="page-header"><div class="wrapper"><a href="/page/profile.html"><img alt="avatar" src="/images/avatar.jpg" class="avatar"></a><div class="title"> <a href="/">天镶的博客</a></div><nav class="nav"><ul class="links"><li><a href="/"> 首页</a></li><li><a href="/archives"> 归档</a></li><li><a href="/page/profile.html"> 关于</a></li><li><a href="http://read.lingyu.wang/"> 笔记</a></li><li><a href="/everyday"> 日记</a></li></ul><div class="icons"><a href="/atom.xml" class="icon rss"><i class="iconfont">&#xe602;</i></a><a href="http://weibo.com/lingyucoder" class="icon weibo"><i class="iconfont">&#xe600;</i></a><a href="http://github.com/lingyucoder" class="icon github"><i class="iconfont">&#xe604;</i></a><a href="http://twitter.com/lingyucoder" class="icon twitter"><i class="iconfont">&#xe607;</i></a></div></nav></div></header><section id="wrapper"><div id="main"><article class="post"><div class="content desc typo"><h1 class="blog-title">jQuery的事件机制——核心篇</h1><div class="toc-index"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jQuery源码——事件机制"><span class="toc-number">1.</span> <span class="toc-text">jQuery源码——事件机制</span></a></li><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事件管理器"><span class="toc-number">1.1.</span> <span class="toc-text">事件管理器</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global"><span class="toc-number">1.1.1.</span> <span class="toc-text">global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add_(elem,_types,_handler,_data,_selector)"><span class="toc-number">1.1.2.</span> <span class="toc-text">add (elem, types, handler, data, selector)</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件创建逻辑"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">事件创建逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件绑定逻辑"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">事件绑定逻辑</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#remove_(elem,_types,_handler,_selector,_mappedTypes)"><span class="toc-number">1.1.3.</span> <span class="toc-text">remove (elem, types, handler, selector, mappedTypes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trigger_(event,_data,_elem,_onlyHandlers)"><span class="toc-number">1.1.4.</span> <span class="toc-text">trigger (event, data, elem, onlyHandlers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch_(event)"><span class="toc-number">1.1.5.</span> <span class="toc-text">dispatch (event)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handlers_(event,_handlers)"><span class="toc-number">1.1.6.</span> <span class="toc-text">handlers (event, handlers)</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.2.</span> <span class="toc-text">总结</span></a></li></ol></div><p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>
<a id="more"></a>

<h1 id="jQuery源码——事件机制">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>
<h2 id="事件管理器">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>
<h3 id="global">global</h3>
<p>存放事件是否存在</p>
<h3 id="add_(elem,_types,_handler,_data,_selector)">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>
<p>所以代码大致流程如下：</p>
<h4 id="事件创建逻辑">事件创建逻辑</h4>
<p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> handleObjIn, eventHandle, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.get( elem );
    
<span class="keyword">if</span> ( !elemData ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( handler.handler ) {
    handleObjIn = handler;
    handler = handleObjIn.handler;
    selector = handleObjIn.selector;
}
</pre></td></tr></table></figure>


<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !handler.guid ) {
    handler.guid = jQuery.guid++;
}
</pre></td></tr></table></figure>


<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(events = elemData.events) ) {
    events = elemData.events = {};
}
<span class="keyword">if</span> ( !(eventHandle = elemData.handle) ) {
    eventHandle = elemData.handle = <span class="function"><span class="keyword">function</span><span class="params">( e )</span> {</span>
        <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== strundefined && jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, <span class="built_in">arguments</span> ) : <span class="literal">undefined</span>;
    };
}
</pre></td></tr></table></figure>


<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>
<h4 id="事件绑定逻辑">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];
namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();

<span class="keyword">if</span> ( !type ) {
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};

type = ( selector ? special.delegateType : special.bindType ) || type;

special = jQuery.event.special[ type ] || {};
</pre></td></tr></table></figure>


<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>handleObj = jQuery.extend({
    type: type,
    origType: origType,
    data: data,
    handler: handler,
    guid: handler.guid,
    selector: selector,
    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
    namespace: namespaces.join(<span class="string">"."</span>)
}, handleObjIn );
</pre></td></tr></table></figure>


<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>
<ol>
<li>type：事件的映射后的名称</li>
<li>origType：事件的原始名称</li>
<li>data：事件的默认数据</li>
<li>handler：回调函数</li>
<li>guid：回调函数的id</li>
<li>selector：启用事件代理时，被代理的节点的选择器</li>
<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>
<li>namespace：重组后的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !(handlers = events[ type ]) ) {
    handlers = events[ type ] = [];
    handlers.delegateCount = <span class="number">0</span>;

    <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) {
        <span class="keyword">if</span> ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle, <span class="literal">false</span> );
        }
    }
}
</pre></td></tr></table></figure>


<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.add ) {
    special.add.call( elem, handleObj );

    <span class="keyword">if</span> ( !handleObj.handler.guid ) {
        handleObj.handler.guid = handler.guid;
    }
}
</pre></td></tr></table></figure>


<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">if</span> ( selector ) {
    handlers.splice( handlers.delegateCount++, <span class="number">0</span>, handleObj );
} <span class="keyword">else</span> {
    handlers.push( handleObj );
}
</pre></td></tr></table></figure>


<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>jQuery.event.global[ type ] = <span class="literal">true</span>;
</pre></td></tr></table></figure>


<p>最后再全局中标记一下事件已存在就行了</p>
<h3 id="remove_(elem,_types,_handler,_selector,_mappedTypes)">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>
<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> j, origCount, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.hasData( elem ) && data_priv.get( elem );
<span class="keyword">if</span> ( !elemData || !(events = elemData.events) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];
t = types.length;
<span class="keyword">while</span> ( t-- ) {
    <span class="comment">//后面的代码</span>
}
</pre></td></tr></table></figure>


<p>处理情况1，和上面的add一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[<span class="number">1</span>];

namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();
</pre></td></tr></table></figure>


<p>获取事件的命名空间，和add方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !type ) {
    <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) {
        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="literal">true</span> );
    }
    <span class="keyword">continue</span>;
}
</pre></td></tr></table></figure>


<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
origCount = j = handlers.length;
<span class="keyword">while</span> ( j-- ) {
    <span class="comment">//详细删除代码</span>
}
</pre></td></tr></table></figure>


<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>handleObj = handlers[ j ];
<span class="keyword">if</span> ( ( mappedTypes || origType === handleObj.origType ) &&
    ( !handler || handler.guid === handleObj.guid ) &&
    ( !tmp || tmp.test( handleObj.namespace ) ) &&
    ( !selector || selector === handleObj.selector || selector === <span class="string">"**"</span> && handleObj.selector ) ) {
    handlers.splice( j, <span class="number">1</span> );

    <span class="keyword">if</span> ( handleObj.selector ) {
        handlers.delegateCount--;
    }
    <span class="keyword">if</span> ( special.remove ) {
        special.remove.call( elem, handleObj );
    }
}
</pre></td></tr></table></figure>


<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( origCount && !handlers.length ) {
    <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class="literal">false</span> ) {
        jQuery.removeEvent( elem, type, elemData.handle );
    }
    <span class="keyword">delete</span> events[ type ];
}
</pre></td></tr></table></figure>


<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) {
    <span class="keyword">delete</span> elemData.handle;
    data_priv.remove( elem, <span class="string">"events"</span> );
}
</pre></td></tr></table></figure>


<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>
<h3 id="trigger_(event,_data,_elem,_onlyHandlers)">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> i, cur, tmp, bubbleType, ontype, handle, special,
    eventPath = [ elem || document ],
    type = hasOwn.call( event, <span class="string">"type"</span> ) ? event.type : event,
    namespaces = hasOwn.call( event, <span class="string">"namespace"</span> ) ? event.namespace.split(<span class="string">"."</span>) : [];

cur = tmp = elem = elem || document;

<span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>检测是否有focus和blur事件，它们不会在这里被触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt;= <span class="number">0</span> ) {
    namespaces = type.split(<span class="string">"."</span>);
    type = namespaces.shift();
    namespaces.sort();
}
ontype = type.indexOf(<span class="string">":"</span>) &lt; <span class="number">0</span> && <span class="string">"on"</span> + type;
</pre></td></tr></table></figure>


<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>event = event[ jQuery.expando ] ?
    event :
    <span class="keyword">new</span> jQuery.Event( type, <span class="keyword">typeof</span> event === <span class="string">"object"</span> && event );

event.isTrigger = onlyHandlers ? <span class="number">2</span> : <span class="number">3</span>;
event.namespace = namespaces.join(<span class="string">"."</span>);
event.namespace_re = event.namespace ?
    <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(^|\\.)"</span> + namespaces.join(<span class="string">"\\.(?:.*\\.|)"</span>) + <span class="string">"(\\.|$)"</span> ) :
    <span class="literal">null</span>;

event.result = <span class="literal">undefined</span>;
<span class="keyword">if</span> ( !event.target ) {
    event.target = elem;
}
</pre></td></tr></table></figure>


<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>
<ol>
<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>
<li>namespace: 事件的命名空间</li>
<li>namespace_re: 一个用于匹配当前命名空间的正则</li>
<li>result: 事件运行的结果</li>
<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>
</ol>
<p>事件对象的具体实现，后面会说</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>data = data == <span class="literal">null</span> ?
    [ event ] :
    jQuery.makeArray( data, [ event ] );

special = jQuery.event.special[ type ] || {};
<span class="keyword">if</span> ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    <span class="comment">/*如果是特殊事件，需要找到对应的真实名称*/</span>
    bubbleType = special.delegateType || type;
    <span class="keyword">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
    }
    <span class="keyword">for</span> ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
    }

    <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span>
    <span class="keyword">if</span> ( tmp === (elem.ownerDocument || document) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
    }
}
</pre></td></tr></table></figure>


<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
    event.type = i &gt; <span class="number">1</span> ?
        bubbleType :
        special.bindType || type;

    handle = ( data_priv.get( cur, <span class="string">"events"</span> ) || {} )[ event.type ] && data_priv.get( cur, <span class="string">"handle"</span> );
    <span class="keyword">if</span> ( handle ) {
        handle.apply( cur, data );
    }

    handle = ontype && cur[ ontype ];
    <span class="keyword">if</span> ( handle && handle.apply && jQuery.acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        <span class="keyword">if</span> ( event.result === <span class="literal">false</span> ) {
            event.preventDefault();
        }
    }
}
event.type = type;
</pre></td></tr></table></figure>


<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="keyword">if</span> ( !onlyHandlers && !event.isDefaultPrevented() ) {
    <span class="keyword">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="literal">false</span>) &&
        jQuery.acceptData( elem ) ) {
        <span class="keyword">if</span> ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
            tmp = elem[ ontype ];
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = <span class="literal">null</span>;
            }
            jQuery.event.triggered = type;
            elem[ type ]();
            jQuery.event.triggered = <span class="literal">undefined</span>;
            <span class="keyword">if</span> ( tmp ) {
                elem[ ontype ] = tmp;
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>运行完了，返回事件运行的结果</p>
<h3 id="dispatch_(event)">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>
<ol>
<li>事件代理的情况</li>
<li>特殊事件</li>
<li>回调终止（stopPropagation）</li>
<li>事件的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>event = jQuery.event.fix( event );

<span class="keyword">var</span> i, j, ret, matched, handleObj,
    handlerQueue = [],
    args = slice.call( <span class="built_in">arguments</span> ),
    handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="string">"events"</span> ) || {} )[ event.type ] || [],
    special = jQuery.event.special[ event.type ] || {};

args[<span class="number">0</span>] = event;
event.delegateTarget = <span class="keyword">this</span>;
</pre></td></tr></table></figure>


<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.preDispatch && special.preDispatch.call( <span class="keyword">this</span>, event ) === <span class="literal">false</span> ) {
    <span class="keyword">return</span>;
}
</pre></td></tr></table></figure>


<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );
</pre></td></tr></table></figure>


<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>i = <span class="number">0</span>;
<span class="keyword">while</span> ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
    event.currentTarget = matched.elem;
    j = <span class="number">0</span>;
    <span class="keyword">while</span> ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
        <span class="keyword">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                    .apply( matched.elem, args );
            <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) {
                <span class="keyword">if</span> ( (event.result = ret) === <span class="literal">false</span> ) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>
<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( special.postDispatch ) {
    special.postDispatch.call( <span class="keyword">this</span>, event );
}
<span class="keyword">return</span> event.result;
</pre></td></tr></table></figure>


<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>
<h3 id="handlers_(event,_handlers)">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">var</span> i, matches, sel, handleObj,
    handlerQueue = [],
    delegateCount = handlers.delegateCount,
    cur = event.target;
</pre></td></tr></table></figure>


<p>获取当前事件的目标和代理个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">//如果存在代理</span>
<span class="keyword">if</span> ( delegateCount && cur.nodeType && (!event.button || event.type !== <span class="string">"click"</span>) ) {
    <span class="comment">//从被代理元素冒泡到代理元素</span>
    <span class="keyword">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || <span class="keyword">this</span> ) {
        <span class="comment">//屏蔽disable元素的点击事件</span>
        <span class="keyword">if</span> ( cur.disabled !== <span class="literal">true</span> || event.type !== <span class="string">"click"</span> ) {
            <span class="comment">//cur元素需要执行的回调对象列表</span>
            matches = [];
            <span class="comment">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span>
            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; delegateCount; i++ ) {
                handleObj = handlers[ i ];
                sel = handleObj.selector + <span class="string">" "</span>;
                <span class="comment">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span>
                <span class="keyword">if</span> ( matches[ sel ] === <span class="literal">undefined</span> ) {
                    matches[ sel ] = handleObj.needsContext ?
                        jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= <span class="number">0</span> :
                        jQuery.find( sel, <span class="keyword">this</span>, <span class="literal">null</span>, [ cur ] ).length;
                }
                <span class="comment">//如果符合,说明cur元素需要执行这个回调,加到列表中</span>
                <span class="keyword">if</span> ( matches[ sel ] ) {
                    matches.push( handleObj );
                }
            }
            <span class="comment">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span>
            <span class="keyword">if</span> ( matches.length ) {
                handlerQueue.push({ elem: cur, handlers: matches });
            }
        }
    }
}
</pre></td></tr></table></figure>


<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>
<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>
<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>
<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="keyword">if</span> ( delegateCount &lt; handlers.length ) {
    handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });
}
<span class="keyword">return</span> handlerQueue;
</pre></td></tr></table></figure>


<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>
<h2 id="总结">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>
<hr><div class="tags"><a href="/tags/JavaScript/" class="blog-tag">JavaScript</a></div><hr><div class="jia"><div class="jiathis_style_32x32"><a class="jiathis_button_qzone"></a><a class="jiathis_button_tsina"></a><a class="jiathis_button_tqq"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_renren"></a><a href="http://www.jiathis.com/share?uid=1409314953297200" target="_blank" class="jiathis jiathis_txt jtico jtico_jiathis"></a></div><script type="text/javascript">var jiathis_config = {data_track_clickback:'true'};    </script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1409314953297200" charset="utf-8"></script></div><hr><div id="duoshuo" data-url="http://lingyu.wang/2014/05/12/read-jq-src-3/" data-thread-key="/blog/2014/05/12/read-jq-src-3/" data-title="jQuery的事件机制——核心篇" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name:'skyinlayer'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><div class="pager"><a href="/2014/05/12/read-jq-src-4/" title="jQuery的事件机制——事件对象、兼容、接口" class="pre">上一页</a><a href="/2014/05/10/read-jq-src-2/" title="jQuery的数据缓存" class="next">下一页</a></div></div><aside id="aside"><section class="recent"><h3 class="title iconfont">最新文章<i>&#xe601;</i></h3><div class="links"><ul><li><a href="/2015/04/18/learn-canvas-1/">前端动画对比</a></li><li><a href="/2015/01/26/18-books/">读书破万卷，敲码别走神</a></li><li><a href="/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/">构建华丽UI的7条准则（上部）</a></li><li><a href="/2014/11/24/risingstack-nodejs-style-guide/">RisingStack的Node.js风格指南</a></li><li><a href="/2014/11/18/peertc-and-fivechess/">Peertc和五子棋</a></li></ul></div></section><section class="categories"><h3 class="title iconfont">分类<i>&#xe605;</i></h3><div class="links"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS技术/">JS技术</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJs/">NodeJs</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端综合/">前端综合</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/即时通信/">即时通信</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/响应式/">响应式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考总结/">思考总结</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/游戏开发/">游戏开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔试面试/">笔试面试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">10</span></li></ul></div></section><section class="tags"><h3 class="title iconfont">标签<i>&#xe603;</i></h3><div class="links"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/">Canvas</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataChannel/">DataChannel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generator/">Generator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gulp/">Gulp</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">39</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kissy/">Kissy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/">NodeJs</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/">SEO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebIM/">WebIM</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/">WebRTC</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grunt/">grunt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xmpp/">xmpp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画/">动画</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储函数/">存储函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思考/">思考</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试面试题/">笔试面试题</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a><span class="tag-list-count">10</span></li></ul></div></section><section class="archives"><h3 class="title iconfont"> 归档<i>&#xe60a;</i></h3><div class="links"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04">2015年4月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01">2015年1月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11">2014年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10">2014年10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09">2014年9月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">2014年7月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">2014年5月</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">2014年4月</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">2014年3月</a><span class="archive-list-count">29</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02">2014年2月</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01">2014年1月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12">2013年12月</a><span class="archive-list-count">1</span></li></ul></div></section></aside></section><footer id="page-footer"><span style="float:right"><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5aa4945a04cc5a5a4cd6835ccb7d419' type='text/javascript'%3E%3C/script%3E"));</script></span><p>&copy;Powered by<a href="http://hexo.io" target="_blank" title="hexo">&nbsp;hexo&nbsp;</a>and Theme by<a href="https://github.com/LingyuCoder/lingyu-theme">&nbsp;LingyuCoder</a></p></footer><canvas id="snow"></canvas><style type="text/css">#snow {
    position: fixed;
    display: block;
    pointer-events: none;
    top: 0;
    left: 0;
}
</style><script type="text/javascript" src="/scripts/snow.js"></script><script type="text/javascript">var snow = new Snow('snow', {
    'amount': 10,
    'size': [8, 20],
    'rotation': [1, 5],
    'speed': [40, 80],
    'swing': [0.1, 1],
    'amplitude': [30, 50],
    'alpha': [0.1, 0.95],
    'images': [
        'http://skyinlayerblog.qiniudn.com/blog/img/snow_1.png',
        'http://skyinlayerblog.qiniudn.com/blog/img/snow_2.png',
        'http://skyinlayerblog.qiniudn.com/blog/img/snow_3.png',
        'http://skyinlayerblog.qiniudn.com/blog/img/snow_4.png'
    ]
});

window.addEventListener('resize', function() {
    snow.resize(window.innerWidth, window.innerHeight);
}, false);

window.addEventListener('load', function() {
    snow.start();
}, false);</script><script type="text/javascript" src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script><script type="text/javascript">$(function(){
    var duoshuoIds = [];
    var map = {};
    $('.meta').each(function(){
        var $this = $(this);
        var id = $this.attr('thread');
        duoshuoIds.push(id);
        map[id] = $this;
    });
    duoshuoIds.length && $.ajax({
        url: 'http://api.duoshuo.com/threads/counts.jsonp',
        data: {
            threads: duoshuoIds.join(','),
            short_name: 'skyinlayer'
        },
        success: function(data){
            $.each(data.response, function(key, value){
                var $el = map[key];
                if($el) {
                    $.each(['comments','likes', 'reposts'], function(index, type){
                        $el.find('.' + type).append('<span>' + value[type] + '</span>');
                    });
                }
            });
        },
        dataType: 'jsonp'
    });
});</script></body></html>