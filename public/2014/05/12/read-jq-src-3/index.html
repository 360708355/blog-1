<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="天镶"><meta name="description"><title>jQuery的事件机制——核心篇 | 天镶的博客</title><link href="/favicon.png" rel="icon"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/typo/typo-1.1.css"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/highlight/highlight-8.0-dark.css"><link rel="stylesheet" media="screen" href="/stylesheets/app.css"></head><body><a id="totop" href="#page-header" class="iconfont">&#xe60b;</a><header id="page-header"><div class="wrapper"><a href="/page/profile.html"><img alt="avatar" src="/images/avatar.jpg" class="avatar"></a><div class="title"> <a href="/">天镶的博客</a></div><nav class="nav"><ul class="links"><li><a href="/"> 首页</a></li><li><a href="/archives"> 归档</a></li><li><a href="/page/profile.html"> 关于</a></li><li><a href="/page/gitbook/index.html"> 笔记</a></li></ul><div class="icons"><a href="/atom.xml" class="icon rss"><i class="iconfont">&#xe602;</i></a><a href="http://weibo.com/lingyucoder" class="icon weibo"><i class="iconfont">&#xe600;</i></a><a href="http://github.com/lingyucoder" class="icon github"><i class="iconfont">&#xe604;</i></a><a href="http://twitter.com/lingyucoder" class="icon twitter"><i class="iconfont">&#xe607;</i></a></div></nav></div></header><section id="wrapper"><div id="main"><article class="post"><div class="content desc typo"><h1 class="blog-title">jQuery的事件机制——核心篇</h1><div class="toc-index"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#jQuery源码——事件机制"><span class="toc-number">1.</span> <span class="toc-text">jQuery源码——事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#事件管理器"><span class="toc-number">1.1.</span> <span class="toc-text">事件管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global"><span class="toc-number">1.1.1.</span> <span class="toc-text">global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add_(elem,_types,_handler,_data,_selector)"><span class="toc-number">1.1.2.</span> <span class="toc-text">add (elem, types, handler, data, selector)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件创建逻辑"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">事件创建逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件绑定逻辑"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">事件绑定逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove_(elem,_types,_handler,_selector,_mappedTypes)"><span class="toc-number">1.1.3.</span> <span class="toc-text">remove (elem, types, handler, selector, mappedTypes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trigger_(event,_data,_elem,_onlyHandlers)"><span class="toc-number">1.1.4.</span> <span class="toc-text">trigger (event, data, elem, onlyHandlers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatch_(event)"><span class="toc-number">1.1.5.</span> <span class="toc-text">dispatch (event)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handlers_(event,_handlers)"><span class="toc-number">1.1.6.</span> <span class="toc-text">handlers (event, handlers)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div><p>这篇主要介绍了jQuery中事件管理器的一些核心方法，涉及事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等</p>
<a id="more"></a>

<h1 id="jQuery源码——事件机制">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>
<h2 id="事件管理器">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>
<h3 id="global">global</h3>
<p>存放事件是否存在</p>
<h3 id="add_(elem,_types,_handler,_data,_selector)">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>
<p>所以代码大致流程如下：</p>
<h4 id="事件创建逻辑">事件创建逻辑</h4>
<p>在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> handleObjIn, eventHandle, tmp,</div><div class="line">    events, t, handleObj,</div><div class="line">    special, handlers, type, namespaces, origType,</div><div class="line">    elemData = data_priv.get( elem );</div><div class="line">    </div><div class="line"><span class="keyword">if</span> ( !elemData ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( handler.handler ) {</div><div class="line">    handleObjIn = handler;</div><div class="line">    handler = handleObjIn.handler;</div><div class="line">    selector = handleObjIn.selector;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !handler.guid ) {</div><div class="line">    handler.guid = jQuery.guid++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !(events = elemData.events) ) {</div><div class="line">    events = elemData.events = {};</div><div class="line">}</div><div class="line"><span class="keyword">if</span> ( !(eventHandle = elemData.handle) ) {</div><div class="line">    eventHandle = elemData.handle = <span class="function"><span class="keyword">function</span><span class="params">( e )</span> </span>{</div><div class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span> jQuery !== strundefined && jQuery.event.triggered !== e.type ?</div><div class="line">            jQuery.event.dispatch.apply( elem, <span class="built_in">arguments</span> ) : <span class="literal">undefined</span>;</div><div class="line">    };</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>
<h4 id="事件绑定逻辑">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];</div><div class="line">t = types.length;</div><div class="line"><span class="keyword">while</span> ( t-- ) {</div><div class="line">    <span class="comment">//后面的代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tmp = rtypenamespace.exec( types[t] ) || [];</div><div class="line">type = origType = tmp[<span class="number">1</span>];</div><div class="line">namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( !type ) {</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line"></div><div class="line">type = ( selector ? special.delegateType : special.bindType ) || type;</div><div class="line"></div><div class="line">special = jQuery.event.special[ type ] || {};</div></pre></td></tr></table></figure>

<p>情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">handleObj = jQuery.extend({</div><div class="line">    type: type,</div><div class="line">    origType: origType,</div><div class="line">    data: data,</div><div class="line">    handler: handler,</div><div class="line">    guid: handler.guid,</div><div class="line">    selector: selector,</div><div class="line">    needsContext: selector && jQuery.expr.match.needsContext.test( selector ),</div><div class="line">    namespace: namespaces.join(<span class="string">"."</span>)</div><div class="line">}, handleObjIn );</div></pre></td></tr></table></figure>

<p>这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：</p>
<ol>
<li>type：事件的映射后的名称</li>
<li>origType：事件的原始名称</li>
<li>data：事件的默认数据</li>
<li>handler：回调函数</li>
<li>guid：回调函数的id</li>
<li>selector：启用事件代理时，被代理的节点的选择器</li>
<li>needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文</li>
<li>namespace：重组后的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !(handlers = events[ type ]) ) {</div><div class="line">    handlers = events[ type ] = [];</div><div class="line">    handlers.delegateCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === <span class="literal">false</span> ) {</div><div class="line">        <span class="keyword">if</span> ( elem.addEventListener ) {</div><div class="line">            elem.addEventListener( type, eventHandle, <span class="literal">false</span> );</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.add ) {</div><div class="line">    special.add.call( elem, handleObj );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( !handleObj.handler.guid ) {</div><div class="line">        handleObj.handler.guid = handler.guid;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( selector ) {</div><div class="line">    handlers.splice( handlers.delegateCount++, <span class="number">0</span>, handleObj );</div><div class="line">} <span class="keyword">else</span> {</div><div class="line">    handlers.push( handleObj );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jQuery.event.global[ type ] = <span class="literal">true</span>;</div></pre></td></tr></table></figure>

<p>最后再全局中标记一下事件已存在就行了</p>
<h3 id="remove_(elem,_types,_handler,_selector,_mappedTypes)">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：</p>
<ol>
<li>type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件</li>
<li>有可能存在命名空间如<code>event.namespace</code>的情况</li>
<li>特殊事件需要进行名称转换，以及钩子调用</li>
<li>如果是事件代理也需要注意代理逻辑</li>
<li>在移除了一个事件的所有回调对象后，可以移除这个事件</li>
<li>在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> j, origCount, tmp,</div><div class="line">    events, t, handleObj,</div><div class="line">    special, handlers, type, namespaces, origType,</div><div class="line">    elemData = data_priv.hasData( elem ) && data_priv.get( elem );</div><div class="line"><span class="keyword">if</span> ( !elemData || !(events = elemData.events) ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">types = ( types || <span class="string">""</span> ).match( rnotwhite ) || [ <span class="string">""</span> ];</div><div class="line">t = types.length;</div><div class="line"><span class="keyword">while</span> ( t-- ) {</div><div class="line">    <span class="comment">//后面的代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>处理情况1，和上面的add一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tmp = rtypenamespace.exec( types[t] ) || [];</div><div class="line">type = origType = tmp[<span class="number">1</span>];</div><div class="line"></div><div class="line">namespaces = ( tmp[<span class="number">2</span>] || <span class="string">""</span> ).split( <span class="string">"."</span> ).sort();</div></pre></td></tr></table></figure>

<p>获取事件的命名空间，和add方法一样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !type ) {</div><div class="line">    <span class="keyword">for</span> ( type <span class="keyword">in</span> events ) {</div><div class="line">        jQuery.event.remove( elem, type + types[ t ], handler, selector, <span class="literal">true</span> );</div><div class="line">    }</div><div class="line">    <span class="keyword">continue</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line">type = ( selector ? special.delegateType : special.bindType ) || type;</div><div class="line">handlers = events[ type ] || [];</div><div class="line">origCount = j = handlers.length;</div><div class="line"><span class="keyword">while</span> ( j-- ) {</div><div class="line">    <span class="comment">//详细删除代码</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">handleObj = handlers[ j ];</div><div class="line"><span class="keyword">if</span> ( ( mappedTypes || origType === handleObj.origType ) &&</div><div class="line">    ( !handler || handler.guid === handleObj.guid ) &&</div><div class="line">    ( !tmp || tmp.test( handleObj.namespace ) ) &&</div><div class="line">    ( !selector || selector === handleObj.selector || selector === <span class="string">"**"</span> && handleObj.selector ) ) {</div><div class="line">    handlers.splice( j, <span class="number">1</span> );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ( handleObj.selector ) {</div><div class="line">        handlers.delegateCount--;</div><div class="line">    }</div><div class="line">    <span class="keyword">if</span> ( special.remove ) {</div><div class="line">        special.remove.call( elem, handleObj );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( origCount && !handlers.length ) {</div><div class="line">    <span class="keyword">if</span> ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === <span class="literal">false</span> ) {</div><div class="line">        jQuery.removeEvent( elem, type, elemData.handle );</div><div class="line">    }</div><div class="line">    <span class="keyword">delete</span> events[ type ];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( jQuery.isEmptyObject( events ) ) {</div><div class="line">    <span class="keyword">delete</span> elemData.handle;</div><div class="line">    data_priv.remove( elem, <span class="string">"events"</span> );</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果节点中没有任何事件了，直接释放掉事件存储空间</p>
<h3 id="trigger_(event,_data,_elem,_onlyHandlers)">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, cur, tmp, bubbleType, ontype, handle, special,</div><div class="line">    eventPath = [ elem || <span class="built_in">document</span> ],</div><div class="line">    type = hasOwn.call( event, <span class="string">"type"</span> ) ? event.type : event,</div><div class="line">    namespaces = hasOwn.call( event, <span class="string">"namespace"</span> ) ? event.namespace.split(<span class="string">"."</span>) : [];</div><div class="line"></div><div class="line">cur = tmp = elem = elem || <span class="built_in">document</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( elem.nodeType === <span class="number">3</span> || elem.nodeType === <span class="number">8</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( rfocusMorph.test( type + jQuery.event.triggered ) ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>检测是否有focus和blur事件，它们不会在这里被触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( type.indexOf(<span class="string">"."</span>) &gt;= <span class="number">0</span> ) {</div><div class="line">    namespaces = type.split(<span class="string">"."</span>);</div><div class="line">    type = namespaces.shift();</div><div class="line">    namespaces.sort();</div><div class="line">}</div><div class="line">ontype = type.indexOf(<span class="string">":"</span>) &lt; <span class="number">0</span> && <span class="string">"on"</span> + type;</div></pre></td></tr></table></figure>

<p>获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">event = event[ jQuery.expando ] ?</div><div class="line">    event :</div><div class="line">    <span class="keyword">new</span> jQuery.Event( type, <span class="keyword">typeof</span> event === <span class="string">"object"</span> && event );</div><div class="line"></div><div class="line">event.isTrigger = onlyHandlers ? <span class="number">2</span> : <span class="number">3</span>;</div><div class="line">event.namespace = namespaces.join(<span class="string">"."</span>);</div><div class="line">event.namespace_re = event.namespace ?</div><div class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(^|\\.)"</span> + namespaces.join(<span class="string">"\\.(?:.*\\.|)"</span>) + <span class="string">"(\\.|$)"</span> ) :</div><div class="line">    <span class="literal">null</span>;</div><div class="line"></div><div class="line">event.result = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">if</span> ( !event.target ) {</div><div class="line">    event.target = elem;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:</p>
<ol>
<li>isTrigger: 判断是否需要出发浏览器本身的事件回调</li>
<li>namespace: 事件的命名空间</li>
<li>namespace_re: 一个用于匹配当前命名空间的正则</li>
<li>result: 事件运行的结果</li>
<li>target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</li>
</ol>
<p>事件对象的具体实现，后面会说</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">data = data == <span class="literal">null</span> ?</div><div class="line">    [ event ] :</div><div class="line">    jQuery.makeArray( data, [ event ] );</div><div class="line"></div><div class="line">special = jQuery.event.special[ type ] || {};</div><div class="line"><span class="keyword">if</span> ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === <span class="literal">false</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {</div><div class="line">    <span class="comment">/*如果是特殊事件，需要找到对应的真实名称*/</span></div><div class="line">    bubbleType = special.delegateType || type;</div><div class="line">    <span class="keyword">if</span> ( !rfocusMorph.test( bubbleType + type ) ) {</div><div class="line">        cur = cur.parentNode;</div><div class="line">    }</div><div class="line">    <span class="keyword">for</span> ( ; cur; cur = cur.parentNode ) {</div><div class="line">        eventPath.push( cur );</div><div class="line">        tmp = cur;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span></div><div class="line">    <span class="keyword">if</span> ( tmp === (elem.ownerDocument || <span class="built_in">document</span>) ) {</div><div class="line">        eventPath.push( tmp.defaultView || tmp.parentWindow || <span class="built_in">window</span> );</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过<code>elem.parentNode</code>来获取元素到window的路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {</div><div class="line">    event.type = i &gt; <span class="number">1</span> ?</div><div class="line">        bubbleType :</div><div class="line">        special.bindType || type;</div><div class="line"></div><div class="line">    handle = ( data_priv.get( cur, <span class="string">"events"</span> ) || {} )[ event.type ] && data_priv.get( cur, <span class="string">"handle"</span> );</div><div class="line">    <span class="keyword">if</span> ( handle ) {</div><div class="line">        handle.apply( cur, data );</div><div class="line">    }</div><div class="line"></div><div class="line">    handle = ontype && cur[ ontype ];</div><div class="line">    <span class="keyword">if</span> ( handle && handle.apply && jQuery.acceptData( cur ) ) {</div><div class="line">        event.result = handle.apply( cur, data );</div><div class="line">        <span class="keyword">if</span> ( event.result === <span class="literal">false</span> ) {</div><div class="line">            event.preventDefault();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line">event.type = type;</div></pre></td></tr></table></figure>

<p>顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !onlyHandlers && !event.isDefaultPrevented() ) {</div><div class="line">    <span class="keyword">if</span> ( (!special._default || special._default.apply( eventPath.pop(), data ) === <span class="literal">false</span>) &&</div><div class="line">        jQuery.acceptData( elem ) ) {</div><div class="line">        <span class="keyword">if</span> ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {</div><div class="line">            tmp = elem[ ontype ];</div><div class="line">            <span class="keyword">if</span> ( tmp ) {</div><div class="line">                elem[ ontype ] = <span class="literal">null</span>;</div><div class="line">            }</div><div class="line">            jQuery.event.triggered = type;</div><div class="line">            elem[ type ]();</div><div class="line">            jQuery.event.triggered = <span class="literal">undefined</span>;</div><div class="line">            <span class="keyword">if</span> ( tmp ) {</div><div class="line">                elem[ ontype ] = tmp;</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> event.result;</div></pre></td></tr></table></figure>

<p>运行完了，返回事件运行的结果</p>
<h3 id="dispatch_(event)">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：</p>
<ol>
<li>事件代理的情况</li>
<li>特殊事件</li>
<li>回调终止（stopPropagation）</li>
<li>事件的命名空间</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">event = jQuery.event.fix( event );</div><div class="line"></div><div class="line"><span class="keyword">var</span> i, j, ret, matched, handleObj,</div><div class="line">    handlerQueue = [],</div><div class="line">    args = slice.call( <span class="built_in">arguments</span> ),</div><div class="line">    handlers = ( data_priv.get( <span class="keyword">this</span>, <span class="string">"events"</span> ) || {} )[ event.type ] || [],</div><div class="line">    special = jQuery.event.special[ event.type ] || {};</div><div class="line"></div><div class="line">args[<span class="number">0</span>] = event;</div><div class="line">event.delegateTarget = <span class="keyword">this</span>;</div></pre></td></tr></table></figure>

<p>这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.preDispatch && special.preDispatch.call( <span class="keyword">this</span>, event ) === <span class="literal">false</span> ) {</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>钩子你好，钩子再见…这次是preDispatch钩子…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">handlerQueue = jQuery.event.handlers.call( <span class="keyword">this</span>, event, handlers );</div></pre></td></tr></table></figure>

<p>将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {</div><div class="line">    event.currentTarget = matched.elem;</div><div class="line">    j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {</div><div class="line">        <span class="keyword">if</span> ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {</div><div class="line">            event.handleObj = handleObj;</div><div class="line">            event.data = handleObj.data;</div><div class="line">            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )</div><div class="line">                    .apply( matched.elem, args );</div><div class="line">            <span class="keyword">if</span> ( ret !== <span class="literal">undefined</span> ) {</div><div class="line">                <span class="keyword">if</span> ( (event.result = ret) === <span class="literal">false</span> ) {</div><div class="line">                    event.preventDefault();</div><div class="line">                    event.stopPropagation();</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>
<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( special.postDispatch ) {</div><div class="line">    special.postDispatch.call( <span class="keyword">this</span>, event );</div><div class="line">}</div><div class="line"><span class="keyword">return</span> event.result;</div></pre></td></tr></table></figure>

<p>钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>
<h3 id="handlers_(event,_handlers)">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, matches, sel, handleObj,</div><div class="line">    handlerQueue = [],</div><div class="line">    delegateCount = handlers.delegateCount,</div><div class="line">    cur = event.target;</div></pre></td></tr></table></figure>

<p>获取当前事件的目标和代理个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果存在代理</span></div><div class="line"><span class="keyword">if</span> ( delegateCount && cur.nodeType && (!event.button || event.type !== <span class="string">"click"</span>) ) {</div><div class="line">    <span class="comment">//从被代理元素冒泡到代理元素</span></div><div class="line">    <span class="keyword">for</span> ( ; cur !== <span class="keyword">this</span>; cur = cur.parentNode || <span class="keyword">this</span> ) {</div><div class="line">        <span class="comment">//屏蔽disable元素的点击事件</span></div><div class="line">        <span class="keyword">if</span> ( cur.disabled !== <span class="literal">true</span> || event.type !== <span class="string">"click"</span> ) {</div><div class="line">            <span class="comment">//cur元素需要执行的回调对象列表</span></div><div class="line">            matches = [];</div><div class="line">            <span class="comment">//获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行</span></div><div class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; delegateCount; i++ ) {</div><div class="line">                handleObj = handlers[ i ];</div><div class="line">                sel = handleObj.selector + <span class="string">" "</span>;</div><div class="line">                <span class="comment">//判断元素是否符合选择器,这里还进行了缓存防止重复判断</span></div><div class="line">                <span class="keyword">if</span> ( matches[ sel ] === <span class="literal">undefined</span> ) {</div><div class="line">                    matches[ sel ] = handleObj.needsContext ?</div><div class="line">                        jQuery( sel, <span class="keyword">this</span> ).index( cur ) &gt;= <span class="number">0</span> :</div><div class="line">                        jQuery.find( sel, <span class="keyword">this</span>, <span class="literal">null</span>, [ cur ] ).length;</div><div class="line">                }</div><div class="line">                <span class="comment">//如果符合,说明cur元素需要执行这个回调,加到列表中</span></div><div class="line">                <span class="keyword">if</span> ( matches[ sel ] ) {</div><div class="line">                    matches.push( handleObj );</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">//如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中</span></div><div class="line">            <span class="keyword">if</span> ( matches.length ) {</div><div class="line">                handlerQueue.push({ elem: cur, handlers: matches });</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>
<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>
<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>
<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( delegateCount &lt; handlers.length ) {</div><div class="line">    handlerQueue.push({ elem: <span class="keyword">this</span>, handlers: handlers.slice( delegateCount ) });</div><div class="line">}</div><div class="line"><span class="keyword">return</span> handlerQueue;</div></pre></td></tr></table></figure>

<p>对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>
<h2 id="总结">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>
<hr><div class="tags"><a href="/tags/JavaScript/" class="blog-tag">JavaScript</a></div><hr><div class="jia"><div class="jiathis_style_32x32"><a class="jiathis_button_qzone"></a><a class="jiathis_button_tsina"></a><a class="jiathis_button_tqq"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_renren"></a><a href="http://www.jiathis.com/share?uid=1409314953297200" target="_blank" class="jiathis jiathis_txt jtico jtico_jiathis"></a></div><script type="text/javascript">var jiathis_config = {data_track_clickback:'true'};    </script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1409314953297200" charset="utf-8"></script></div><hr><div id="duoshuo" data-url="http://lingyu.wang/2014/05/12/read-jq-src-3/" data-thread-key="/blog/2014/05/12/read-jq-src-3/" data-title="jQuery的事件机制——核心篇" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name:'skyinlayer'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><div class="pager"><a href="/2014/05/17/read-jq-src-5/" title="jQuery的异步控制" class="pre">上一页</a><a href="/2014/05/12/read-jq-src-4/" title="jQuery的事件机制——事件对象、兼容、接口" class="next">下一页</a></div></div><aside id="aside"><section class="recent"><h3 class="title iconfont">最新文章<i>&#xe601;</i></h3><div class="links"><ul><li><a href="/2014/09/24/koa-anywhere/">koa-anywhere</a></li><li><a href="/2014/09/22/learn-fe/">学前端的一点总结</a></li><li><a href="/2014/07/29/generator/">细说Generator</a></li><li><a href="/2014/05/31/kissy-anime-plugin/">如何写一个KISSY动画插件</a></li><li><a href="/2014/05/22/webrtc-data-channels/">WebRTC的RTCDataChannel</a></li></ul></div></section><section class="categories"><h3 class="title iconfont">分类<i>&#xe605;</i></h3><div class="links"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJs/">NodeJs</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/">前端技术</a><span class="category-list-count">33</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/性能优化/">性能优化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/笔试面试积累/">笔试面试积累</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端技术/网站建设/">网站建设</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/即时通信/">即时通信</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库技术/">数据库技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码阅读/">源码阅读</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活情感/">生活情感</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔试面试积累/">笔试面试积累</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/网站建设/">网站建设</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">9</span></li></ul></div></section><section class="tags"><h3 class="title iconfont">标签<i>&#xe603;</i></h3><div class="links"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generator/">Generator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kissy/">Kissy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/">NodeJs</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/">SEO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebIM/">WebIM</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/">WebRTC</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grunt/">grunt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xmpp/">xmpp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画/">动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储函数/">存储函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思考/">思考</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试面试题/">笔试面试题</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a><span class="tag-list-count">9</span></li></ul></div></section><section class="archives"><h3 class="title iconfont"> 归档<i>&#xe60a;</i></h3><div class="links"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09">2014年9月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">2014年7月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">2014年5月</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">2014年4月</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">2014年3月</a><span class="archive-list-count">29</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02">2014年2月</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01">2014年1月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12">2013年12月</a><span class="archive-list-count">1</span></li></ul></div></section></aside></section><footer id="page-footer"><span style="float:right"><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-51090540-1', 'http://plugins.lingyu.wang');
ga('send', 'pageview');</script></span><span style="float:right"><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5aa4945a04cc5a5a4cd6835ccb7d419' type='text/javascript'%3E%3C/script%3E"));</script></span><p>&copy;Powered by<a href="http://hexo.io" target="_blank" title="hexo">&nbsp;hexo&nbsp;</a>and Theme by<a href="https://github.com/LingyuCoder/lingyu-theme">&nbsp;LingyuCoder</a></p></footer><script type="text/javascript" src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script><script type="text/javascript">$(function(){
    var duoshuoIds = [];
    var map = {};
    $('.meta').each(function(){
        var $this = $(this);
        var id = $this.attr('thread');
        duoshuoIds.push(id);
        map[id] = $this;
    });
    duoshuoIds.length && $.ajax({
        url: 'http://api.duoshuo.com/threads/counts.jsonp',
        data: {
            threads: duoshuoIds.join(','),
            short_name: 'skyinlayer'
        },
        success: function(data){
            $.each(data.response, function(key, value){
                var $el = map[key];
                if($el) {
                    $.each(['comments','likes', 'reposts'], function(index, type){
                        $el.find('.' + type).append('<span>' + value[type] + '</span>');
                    });
                }
            });
        },
        dataType: 'jsonp'
    });
});</script></body></html>