<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="天镶"><meta name="description"><title>jQuery的数据缓存 | 天镶的博客</title><link href="/favicon.ico" rel="icon"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/typo/typo-1.1.css"><link rel="stylesheet" media="screen" href="/stylesheets/plugins/highlight/highlight-8.0-dark.css"><link rel="stylesheet" media="screen" href="/stylesheets/app.css"></head><body><a id="totop" href="#page-header" class="iconfont">&#xe60b;</a><header id="page-header"><div class="wrapper"><a href="/page/profile.html"><img alt="avatar" src="/images/avatar.jpg" class="avatar"></a><div class="title"> <a href="/">天镶的博客</a></div><nav class="nav"><ul class="links"><li><a href="/"> 首页</a></li><li><a href="/archives"> 归档</a></li><li><a href="/page/profile.html"> 关于</a></li><li><a href="http://read.lingyu.wang/"> 笔记</a></li><li><a href="/everyday"> 日记</a></li></ul><div class="icons"><a href="/atom.xml" class="icon rss"><i class="iconfont">&#xe602;</i></a><a href="http://weibo.com/lingyucoder" class="icon weibo"><i class="iconfont">&#xe600;</i></a><a href="http://github.com/lingyucoder" class="icon github"><i class="iconfont">&#xe604;</i></a><a href="http://twitter.com/lingyucoder" class="icon twitter"><i class="iconfont">&#xe607;</i></a></div></nav></div></header><section id="wrapper"><div id="main"><article class="post"><div class="content desc typo"><h1 class="blog-title">jQuery的数据缓存</h1><div class="toc-index"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery的数据缓存简介"><span class="toc-number">1.</span> <span class="toc-text">jQuery的数据缓存简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jq中数据缓存的限制"><span class="toc-number">2.</span> <span class="toc-text">jq中数据缓存的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据对象"><span class="toc-number">3.</span> <span class="toc-text">数据对象</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法和属性"><span class="toc-number">3.1.</span> <span class="toc-text">静态方法和属性</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uid"><span class="toc-number">3.1.1.</span> <span class="toc-text">uid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#accepts"><span class="toc-number">3.1.2.</span> <span class="toc-text">accepts</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#核心方法"><span class="toc-number">3.2.</span> <span class="toc-text">核心方法</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#key_(owner)"><span class="toc-number">3.2.1.</span> <span class="toc-text">key (owner)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set_(owner,_data,_value)"><span class="toc-number">3.2.2.</span> <span class="toc-text">set (owner, data, value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get_(owner,_key)"><span class="toc-number">3.2.3.</span> <span class="toc-text">get (owner, key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access_(owner,_key,_value)"><span class="toc-number">3.2.4.</span> <span class="toc-text">access (owner, key, value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#remove_(owner,_key)"><span class="toc-number">3.2.5.</span> <span class="toc-text">remove (owner, key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasData_(owner)"><span class="toc-number">3.2.6.</span> <span class="toc-text">hasData (owner)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#discard_(owner)"><span class="toc-number">3.2.7.</span> <span class="toc-text">discard (owner)</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#数据对象创建"><span class="toc-number">3.3.</span> <span class="toc-text">数据对象创建</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery对数据对象操作接口"><span class="toc-number">4.</span> <span class="toc-text">jQuery对数据对象操作接口</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dataAttr方法"><span class="toc-number">4.1.</span> <span class="toc-text">dataAttr方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">4.2.</span> <span class="toc-text">静态方法</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hasData_(elem)"><span class="toc-number">4.2.1.</span> <span class="toc-text">hasData (elem)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data_(elem,_name,_data)"><span class="toc-number">4.2.2.</span> <span class="toc-text">data (elem, name, data)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#removeData_(elem,_name)"><span class="toc-number">4.2.3.</span> <span class="toc-text">removeData (elem, name)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#_data_(elem,_name,_data)"><span class="toc-number">4.2.4.</span> <span class="toc-text">_data (elem, name, data)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#_removeData_(elem,_name)"><span class="toc-number">4.2.5.</span> <span class="toc-text">_removeData (elem, name)</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#在jq对象上添加数据对象操作方法"><span class="toc-number">4.3.</span> <span class="toc-text">在jq对象上添加数据对象操作方法</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#data_(key,_value)"><span class="toc-number">4.3.1.</span> <span class="toc-text">data (key, value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#removeData_(key)"><span class="toc-number">4.3.2.</span> <span class="toc-text">removeData (key)</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#为动画服务的queue和dequeue"><span class="toc-number">5.</span> <span class="toc-text">为动画服务的queue和dequeue</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法-1"><span class="toc-number">5.1.</span> <span class="toc-text">静态方法</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue_(elem,_type,_data)"><span class="toc-number">5.1.1.</span> <span class="toc-text">queue (elem, type, data)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dequeue_(elem,_type)"><span class="toc-number">5.1.2.</span> <span class="toc-text">dequeue (elem, type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#_queueHooks_(elem,_type)"><span class="toc-number">5.1.3.</span> <span class="toc-text">_queueHooks (elem, type)</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#jq对象上的queue和dequeue"><span class="toc-number">5.2.</span> <span class="toc-text">jq对象上的queue和dequeue</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#queue_(type,_data)"><span class="toc-number">5.2.1.</span> <span class="toc-text">queue (type, data)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dequeue_(type)"><span class="toc-number">5.2.2.</span> <span class="toc-text">dequeue (type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clearQueue_(type)"><span class="toc-number">5.2.3.</span> <span class="toc-text">clearQueue (type)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#promise_(type,_obj)"><span class="toc-number">5.2.4.</span> <span class="toc-text">promise (type, obj)</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div><p>这次记录了一下jQuery的数据缓存——data部分，jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口</p>
<a id="more"></a>

<h2 id="jQuery的数据缓存简介">jQuery的数据缓存简介</h2>
<p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>
<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>
<h2 id="jq中数据缓存的限制">jq中数据缓存的限制</h2>
<p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>jQuery.acceptData = <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="keyword">return</span> owner.nodeType === <span class="number">1</span> || owner.nodeType === <span class="number">9</span> || !( +owner.nodeType );
};
</pre></td></tr></table></figure>


<h2 id="数据对象">数据对象</h2>
<p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Data</span><span class="params">()</span> {</span>
    <span class="comment">/*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/</span>
    <span class="built_in">Object</span>.defineProperty( <span class="keyword">this</span>.cache = {}, <span class="number">0</span>, {
        get: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">return</span> {};
        }
    });
    <span class="comment">/*为这个数据对象添上jQuery版本号+随机数的版本号*/</span>
    <span class="keyword">this</span>.expando = jQuery.expando + <span class="built_in">Math</span>.random();
}
</pre></td></tr></table></figure>


<h3 id="静态方法和属性">静态方法和属性</h3>
<h4 id="uid">uid</h4>
<p>数据对象的id，自增</p>
<h4 id="accepts">accepts</h4>
<p>判断是否能够接受数据，直接指向之前的acceptData</p>
<h3 id="核心方法">核心方法</h3>
<h4 id="key_(owner)">key (owner)</h4>
<p>owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>
<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>
<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>
<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>
<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>key: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="comment">/*如果这个所有者不能接收数据，返回0*/</span>
    <span class="keyword">if</span> ( !Data.accepts( owner ) ) {
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    <span class="keyword">var</span> descriptor = {},
        <span class="comment">/*获取这个所有者已经有这个版本的数据的id*/</span>
        unlock = owner[ <span class="keyword">this</span>.expando ];
    <span class="comment">/*如果这个所有者没有对应的数据对象，那么创建一个*/</span>
    <span class="keyword">if</span> ( !unlock ) {
        <span class="comment">/*自增的uid*/</span>
        unlock = Data.uid++;
        <span class="comment">/*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/</span>
        <span class="keyword">try</span> {
            descriptor[ <span class="keyword">this</span>.expando ] = { value: unlock };
            <span class="built_in">Object</span>.defineProperties( owner, descriptor );
        <span class="comment">/*如果不能使用Object.defineProperites，那么直接使用extend*/</span>
        } <span class="keyword">catch</span> ( e ) {
            descriptor[ <span class="keyword">this</span>.expando ] = unlock;
            jQuery.extend( owner, descriptor );
        }
    }
    <span class="comment">/*在cache中创建对象的数据空间*/</span>
    <span class="keyword">if</span> ( !<span class="keyword">this</span>.cache[ unlock ] ) {
        <span class="keyword">this</span>.cache[ unlock ] = {};
    }
    <span class="comment">/*返回这个新的id*/</span>
    <span class="keyword">return</span> unlock;
},
</pre></td></tr></table></figure>


<h4 id="set_(owner,_data,_value)">set (owner, data, value)</h4>
<p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>
<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>
<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>
<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">/*加入数据（往cache中加数据）*/</span>
set: <span class="function"><span class="keyword">function</span><span class="params">( owner, data, value )</span> {</span>
    <span class="keyword">var</span> prop,
        <span class="comment">/*首先获得这个所有者的id（没有就新建一个）*/</span>
        unlock = <span class="keyword">this</span>.key( owner ),
        <span class="comment">/*获得这个数据对象对应的cache内的空间*/</span>
        cache = <span class="keyword">this</span>.cache[ unlock ];

    <span class="comment">/*如果数据时string直接写进去*/</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> data === <span class="string">"string"</span> ) {
        cache[ data ] = value;

    <span class="comment">/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/</span>
    } <span class="keyword">else</span> {
        <span class="keyword">if</span> ( jQuery.isEmptyObject( cache ) ) {
            jQuery.extend( <span class="keyword">this</span>.cache[ unlock ], data );
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> ( prop <span class="keyword">in</span> data ) {
                cache[ prop ] = data[ prop ];
            }
        }
    }
    <span class="keyword">return</span> cache;
},
</pre></td></tr></table></figure>


<h4 id="get_(owner,_key)">get (owner, key)</h4>
<p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>
<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="comment">/*获取数据（从cache中取数据）*/</span>
get: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> {</span>
    <span class="comment">/*通过owner获取id，从cache中获取在对应的完整缓存对象*/</span>
    <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache[ <span class="keyword">this</span>.key( owner ) ];
    <span class="comment">/*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/</span>
    <span class="keyword">return</span> key === <span class="literal">undefined</span> ?
        cache : cache[ key ];
},
</pre></td></tr></table></figure>


<h4 id="access_(owner,_key,_value)">access (owner, key, value)</h4>
<p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>
<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：</p>
<ol>
<li>如果没有key和value，那么使用get方法获取整个数据空间对象</li>
<li>如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值</li>
<li>如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中</li>
<li>如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>access: <span class="function"><span class="keyword">function</span><span class="params">( owner, key, value )</span> {</span>
    <span class="keyword">var</span> stored;
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ||
            ((key && <span class="keyword">typeof</span> key === <span class="string">"string"</span>) && value === <span class="literal">undefined</span>) ) {

        stored = <span class="keyword">this</span>.get( owner, key );

        <span class="keyword">return</span> stored !== <span class="literal">undefined</span> ?
            stored : <span class="keyword">this</span>.get( owner, jQuery.camelCase(key) );
    }

    <span class="keyword">this</span>.set( owner, key, value );

    <span class="keyword">return</span> value !== <span class="literal">undefined</span> ? value : key;
},
</pre></td></tr></table></figure>


<h4 id="remove_(owner,_key)">remove (owner, key)</h4>
<p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>
<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="comment">/*从owner移除属性 */</span>
remove: <span class="function"><span class="keyword">function</span><span class="params">( owner, key )</span> {</span>
    <span class="keyword">var</span> i, name, camel,
        unlock = <span class="keyword">this</span>.key( owner ),
        cache = <span class="keyword">this</span>.cache[ unlock ];
    <span class="comment">/*如果没有key，移除整个owner所拥有的缓存*/</span>
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {
        <span class="keyword">this</span>.cache[ unlock ] = {};
    } <span class="keyword">else</span> {
        <span class="comment">// Support array or space separated string of keys</span>
        <span class="comment">/*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/</span>
        <span class="keyword">if</span> ( jQuery.isArray( key ) ) {
            name = key.concat( key.map( jQuery.camelCase ) );
        } <span class="keyword">else</span> {
            <span class="comment">/*如果key不是数组，将key转成驼峰*/</span>
            camel = jQuery.camelCase( key );
            <span class="comment">/*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/</span>
            <span class="keyword">if</span> ( key <span class="keyword">in</span> cache ) {
                name = [ key, camel ];
            } <span class="keyword">else</span> {
                <span class="comment">/*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/</span>
                name = camel;
                <span class="comment">/*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/</span>
                name = name <span class="keyword">in</span> cache ?
                    [ name ] : ( name.match( rnotwhite ) || [] );
            }
        }
        <span class="comment">/*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/</span>
        i = name.length;
        <span class="keyword">while</span> ( i-- ) {
            <span class="keyword">delete</span> cache[ name[ i ] ];
        }
    }
},
</pre></td></tr></table></figure>


<h4 id="hasData_(owner)">hasData (owner)</h4>
<p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/*判断是否存在数据*/</span>
hasData: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="comment">/*判断缓存对象是否是空对象*/</span>
    <span class="keyword">return</span> !jQuery.isEmptyObject(
        <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ] || {}
    );
},
</pre></td></tr></table></figure>


<h4 id="discard_(owner)">discard (owner)</h4>
<p>移除掉owner的所有缓存，直接在cache上用delete删</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*移除整个缓存对象*/</span>
discard: <span class="function"><span class="keyword">function</span><span class="params">( owner )</span> {</span>
    <span class="keyword">if</span> ( owner[ <span class="keyword">this</span>.expando ] ) {
        <span class="keyword">delete</span> <span class="keyword">this</span>.cache[ owner[ <span class="keyword">this</span>.expando ] ];
    }
}
</pre></td></tr></table></figure>


<h3 id="数据对象创建">数据对象创建</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*私有数据对象*/</span>
<span class="keyword">var</span> data_priv = <span class="keyword">new</span> Data();
<span class="comment">/*公有数据对象*/</span>
<span class="keyword">var</span> data_user = <span class="keyword">new</span> Data();
</pre></td></tr></table></figure>


<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>
<h2 id="jQuery对数据对象操作接口">jQuery对数据对象操作接口</h2>
<h3 id="dataAttr方法">dataAttr方法</h3>
<p>事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>
<figure class="highlight javscript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>function dataAttr( elem, key, <span class="built_in">data</span> ) {
    <span class="built_in">var</span> name;

    <span class="comment">/*如果没有data，而元素为element类型*/</span>
    <span class="keyword">if</span> ( <span class="built_in">data</span> <span class="subst">===</span> undefined <span class="subst">&&</span> elem<span class="built_in">.</span>nodeType <span class="subst">===</span> <span class="number">1</span> ) {

        <span class="comment">/*从data-xxx属性中获取数据*/</span>
        name <span class="subst">=</span> <span class="string">"data-"</span> <span class="subst">+</span> key<span class="built_in">.</span>replace( rmultiDash, <span class="string">"-$1"</span> )<span class="built_in">.</span>toLowerCase();
        <span class="built_in">data</span> <span class="subst">=</span> elem<span class="built_in">.</span>getAttribute( name );
        <span class="comment">/*如果对象是字符串，分别尝试转成true、false、null，如果使用{}包裹，当做JSON解析*/</span>
        <span class="keyword">if</span> ( typeof <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"string"</span> ) {
            try {
                <span class="built_in">data</span> <span class="subst">=</span> <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"true"</span> <span class="subst">?</span> <span class="literal">true</span> :
                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"false"</span> <span class="subst">?</span> <span class="literal">false</span> :
                    <span class="built_in">data</span> <span class="subst">===</span> <span class="string">"null"</span> <span class="subst">?</span> <span class="built_in">null</span> :
                    <span class="comment">// Only convert to a number if it doesn't change the string</span>
                    <span class="subst">+</span><span class="built_in">data</span> <span class="subst">+</span> <span class="string">""</span> <span class="subst">===</span> <span class="built_in">data</span> <span class="subst">?</span> <span class="subst">+</span><span class="built_in">data</span> :
                    rbrace<span class="built_in">.</span>test( <span class="built_in">data</span> ) <span class="subst">?</span> jQuery<span class="built_in">.</span>parseJSON( <span class="built_in">data</span> ) :
                    <span class="built_in">data</span>;
            } catch( e ) {}

            <span class="comment">/*写入到公共数据对象中*/</span>
            data_user<span class="built_in">.</span><span class="built_in">set</span>( elem, key, <span class="built_in">data</span> );
        } <span class="keyword">else</span> {
            <span class="built_in">data</span> <span class="subst">=</span> undefined;
        }
    }
    <span class="keyword">return</span> <span class="built_in">data</span>;
}
</pre></td></tr></table></figure>


<h3 id="静态方法">静态方法</h3>
<p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>
<h4 id="hasData_(elem)">hasData (elem)</h4>
<p>判断元素是否含有数据，这里会检测公有数据和私有数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>hasData: <span class="function"><span class="keyword">function</span><span class="params">( elem )</span> {</span>
    <span class="keyword">return</span> data_user.hasData( elem ) || data_priv.hasData( elem );
},
</pre></td></tr></table></figure>


<h4 id="data_(elem,_name,_data)">data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
    <span class="keyword">return</span> data_user.access( elem, name, data );
},
</pre></td></tr></table></figure>


<h4 id="removeData_(elem,_name)">removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作公有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
    data_user.remove( elem, name );
},
</pre></td></tr></table></figure>


<h4 id="_data_(elem,_name,_data)">_data (elem, name, data)</h4>
<p>通过数据对象的access方法获得或写入数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>_data: <span class="function"><span class="keyword">function</span><span class="params">( elem, name, data )</span> {</span>
    <span class="keyword">return</span> data_priv.access( elem, name, data );
},
</pre></td></tr></table></figure>


<h4 id="_removeData_(elem,_name)">_removeData (elem, name)</h4>
<p>从数据对象移除数据，只操作私有数据对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>_removeData: <span class="function"><span class="keyword">function</span><span class="params">( elem, name )</span> {</span>
    data_priv.remove( elem, name );
}
</pre></td></tr></table></figure>


<h3 id="在jq对象上添加数据对象操作方法">在jq对象上添加数据对象操作方法</h3>
<p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>
<h4 id="data_(key,_value)">data (key, value)</h4>
<p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：</p>
<ol>
<li>如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象</li>
<li>如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象</li>
<li>否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre>data: <span class="function"><span class="keyword">function</span><span class="params">( key, value )</span> {</span>
    <span class="keyword">var</span> i, name, data,
        elem = <span class="keyword">this</span>[ <span class="number">0</span> ],
        attrs = elem && elem.attributes;

    
    <span class="comment">/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/</span>
    <span class="keyword">if</span> ( key === <span class="literal">undefined</span> ) {
        <span class="comment">/*jq对象中有节点*/</span>
        <span class="keyword">if</span> ( <span class="keyword">this</span>.length ) {
            <span class="comment">/*第一个节点的数据*/</span>
            data = data_user.get( elem );
            <span class="comment">/*如果节点为element类型且私有数据中没有标记hasDataAttrs
            将节点中的所有data-类型的属性写入到公共数据中
            然后在私有数据中设定hasDataAttrs为true*/</span>
            <span class="keyword">if</span> ( elem.nodeType === <span class="number">1</span> && !data_priv.get( elem, <span class="string">"hasDataAttrs"</span> ) ) {
                i = attrs.length;
                <span class="keyword">while</span> ( i-- ) {
                    name = attrs[ i ].name;

                    <span class="keyword">if</span> ( name.indexOf( <span class="string">"data-"</span> ) === <span class="number">0</span> ) {
                        name = jQuery.camelCase( name.slice(<span class="number">5</span>) );
                        dataAttr( elem, name, data[ name ] );
                    }
                }
                data_priv.set( elem, <span class="string">"hasDataAttrs"</span>, <span class="literal">true</span> );
            }
        }

        <span class="keyword">return</span> data;
    }

    <span class="comment">/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/</span>
    <span class="keyword">if</span> ( <span class="keyword">typeof</span> key === <span class="string">"object"</span> ) {
        <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            data_user.set( <span class="keyword">this</span>, key );
        });
    }
    <span class="comment">/*通过access判断*/</span>
    <span class="keyword">return</span> access( <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span><span class="params">( value )</span> {</span>
        <span class="keyword">var</span> data,
            <span class="comment">/*生成驼峰的key*/</span>
            camelKey = jQuery.camelCase( key );
        <span class="comment">/*如果jq对象中有元素，且没有value，说明调用get获取数据*/</span>
        <span class="keyword">if</span> ( elem && value === <span class="literal">undefined</span> ) {
            <span class="comment">/*直接使用key获取*/</span>
            data = data_user.get( elem, key );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }
            <span class="comment">/*如果直接用key未能获取导数据，尝试驼峰格式的key*/</span>
            data = data_user.get( elem, camelKey );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }

            <span class="comment">/*如果还是无法获取，尝试从data-属性获取*/</span>
            data = dataAttr( elem, camelKey, <span class="literal">undefined</span> );
            <span class="keyword">if</span> ( data !== <span class="literal">undefined</span> ) {
                <span class="keyword">return</span> data;
            }

            <span class="comment">/*我们尝试了所有情况，但还是没有数据，返回undefined*/</span>
            <span class="keyword">return</span>;
        }

        <span class="comment">/*写入数据*/</span>
        <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="comment">/*通过驼峰形式key获取公共数据*/</span>
            <span class="keyword">var</span> data = data_user.get( <span class="keyword">this</span>, camelKey );
            <span class="comment">/*往驼峰形式key中写入公共数据*/</span>
            data_user.set( <span class="keyword">this</span>, camelKey, value );

            <span class="comment">/*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/</span>
            <span class="keyword">if</span> ( key.indexOf(<span class="string">"-"</span>) !== -<span class="number">1</span> && data !== <span class="literal">undefined</span> ) {
                data_user.set( <span class="keyword">this</span>, key, value );
            }
        });
    }, <span class="literal">null</span>, value, <span class="built_in">arguments</span>.length &gt; <span class="number">1</span>, <span class="literal">null</span>, <span class="literal">true</span> );
},
</pre></td></tr></table></figure>


<h4 id="removeData_(key)">removeData (key)</h4>
<p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*从公共数据中移除包含key（或key中元素）的键值对*/</span>
removeData: <span class="function"><span class="keyword">function</span><span class="params">( key )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        data_user.remove( <span class="keyword">this</span>, key );
    });
}
</pre></td></tr></table></figure>


<h2 id="为动画服务的queue和dequeue">为动画服务的queue和dequeue</h2>
<p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>
<h3 id="静态方法-1">静态方法</h3>
<h4 id="queue_(elem,_type,_data)">queue (elem, type, data)</h4>
<p>逻辑不复杂，也分读写两种情况。以<code>type + &quot;queue&quot;</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>
<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>
<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">/*压入或读取一组数据*/</span>
queue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type, data )</span> {</span>
    <span class="keyword">var</span> queue;

    <span class="keyword">if</span> ( elem ) {
        <span class="comment">/*重命名一下type，默认叫fxqueue*/</span>
        type = ( type || <span class="string">"fx"</span> ) + <span class="string">"queue"</span>;
        <span class="comment">/*从私有数据中获得已有的queue数据*/</span>
        queue = data_priv.get( elem, type );

        <span class="comment">/*如果存在data，需要写入数据*/</span>
        <span class="keyword">if</span> ( data ) {
            <span class="comment">/*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/</span>
            <span class="keyword">if</span> ( !queue || jQuery.isArray( data ) ) {
                queue = data_priv.access( elem, type, jQuery.makeArray(data) );
            <span class="comment">/*之前有数据，直接把data连在数据数组后头*/</span>
            } <span class="keyword">else</span> {
                queue.push( data );
            }
        }
        <span class="keyword">return</span> queue || [];
    }
},
</pre></td></tr></table></figure>


<h4 id="dequeue_(elem,_type)">dequeue (elem, type)</h4>
<p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>
<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="comment">/*运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉*/</span>
dequeue: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> {</span>
    <span class="comment">/*获取type，默认为fx*/</span>
    type = type || <span class="string">"fx"</span>;
    <span class="comment">/*获取一组数据*/</span>
    <span class="keyword">var</span> queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        <span class="comment">/*获取状态*/</span>
        fn = queue.shift(),
        <span class="comment">/*获取元素的钩子*/</span>
        hooks = jQuery._queueHooks( elem, type ),
        next = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            jQuery.dequeue( elem, type );
        };

    <span class="comment">/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/</span>
    <span class="keyword">if</span> ( fn === <span class="string">"inprogress"</span> ) {
        fn = queue.shift();
        startLength--;
    }
    <span class="keyword">if</span> ( fn ) {

        <span class="comment">/*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/</span>
        <span class="keyword">if</span> ( type === <span class="string">"fx"</span> ) {
            queue.unshift( <span class="string">"inprogress"</span> );
        }

        <span class="comment">/*删除掉钩子中的停止函数*/</span>
        <span class="keyword">delete</span> hooks.stop;
        <span class="comment">/*在这个函数上调用，并提供钩子*/</span>
        fn.call( elem, next, hooks );
    }
    <span class="comment">/*如果队列已经空了，那么调用empty删除掉这个键值对*/</span>
    <span class="keyword">if</span> ( !startLength && hooks ) {
        hooks.empty.fire();
    }
},
</pre></td></tr></table></figure>


<h4 id="_queueHooks_(elem,_type)">_queueHooks (elem, type)</h4>
<p>提供默认钩子的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>_queueHooks: <span class="function"><span class="keyword">function</span><span class="params">( elem, type )</span> {</span>
    <span class="keyword">var</span> key = type + <span class="string">"queueHooks"</span>;
    <span class="keyword">return</span> data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: jQuery.Callbacks(<span class="string">"once memory"</span>).add(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            data_priv.remove( elem, [ type + <span class="string">"queue"</span>, key ] );
        })
    });
}
</pre></td></tr></table></figure>


<h3 id="jq对象上的queue和dequeue">jq对象上的queue和dequeue</h3>
<h4 id="queue_(type,_data)">queue (type, data)</h4>
<p>对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>queue: <span class="function"><span class="keyword">function</span><span class="params">( type, data )</span> {</span>
        <span class="keyword">var</span> setter = <span class="number">2</span>;

        <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {
            data = type;
            type = <span class="string">"fx"</span>;
            setter--;
        }

        <span class="keyword">if</span> ( <span class="built_in">arguments</span>.length &lt; setter ) {
            <span class="keyword">return</span> jQuery.queue( <span class="keyword">this</span>[<span class="number">0</span>], type );
        }

        <span class="keyword">return</span> data === <span class="literal">undefined</span> ?
            <span class="keyword">this</span> :
            <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">var</span> queue = jQuery.queue( <span class="keyword">this</span>, type, data );

                <span class="comment">// ensure a hooks for this queue</span>
                jQuery._queueHooks( <span class="keyword">this</span>, type );

                <span class="keyword">if</span> ( type === <span class="string">"fx"</span> && queue[<span class="number">0</span>] !== <span class="string">"inprogress"</span> ) {
                    jQuery.dequeue( <span class="keyword">this</span>, type );
                }
            });
    },
</pre></td></tr></table></figure>


<h4 id="dequeue_(type)">dequeue (type)</h4>
<p>对jq对象中每个DOM元素执行dequeue操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/</span>
dequeue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        jQuery.dequeue( <span class="keyword">this</span>, type );
    });
},
</pre></td></tr></table></figure>


<h4 id="clearQueue_(type)">clearQueue (type)</h4>
<p>清除jq对象中每个DOM的type对应的数据列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">/*清除对应的类型的操作列表*/</span>
clearQueue: <span class="function"><span class="keyword">function</span><span class="params">( type )</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.queue( type || <span class="string">"fx"</span>, [] );
},
</pre></td></tr></table></figure>


<h4 id="promise_(type,_obj)">promise (type, obj)</h4>
<p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="comment">/*创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象*/</span>
promise: <span class="function"><span class="keyword">function</span><span class="params">( type, obj )</span> {</span>
    <span class="keyword">var</span> tmp,
        count = <span class="number">1</span>,
        defer = jQuery.Deferred(),
        elements = <span class="keyword">this</span>,
        i = <span class="keyword">this</span>.length,
        resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            <span class="keyword">if</span> ( !( --count ) ) {
                defer.resolveWith( elements, [ elements ] );
            }
        };

    <span class="keyword">if</span> ( <span class="keyword">typeof</span> type !== <span class="string">"string"</span> ) {
        obj = type;
        type = <span class="literal">undefined</span>;
    }
    type = type || <span class="string">"fx"</span>;
    
    <span class="keyword">while</span> ( i-- ) {
        tmp = data_priv.get( elements[ i ], type + <span class="string">"queueHooks"</span> );
        <span class="keyword">if</span> ( tmp && tmp.empty ) {
            count++;
            tmp.empty.add( resolve );
        }
    }
    resolve();
    <span class="keyword">return</span> defer.promise( obj );
}
</pre></td></tr></table></figure>


<h2 id="总结">总结</h2>
<p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>
<hr><div class="tags"><a href="/tags/JavaScript/" class="blog-tag">JavaScript</a></div><hr><div class="jia"><div class="jiathis_style_32x32"><a class="jiathis_button_qzone"></a><a class="jiathis_button_tsina"></a><a class="jiathis_button_tqq"></a><a class="jiathis_button_weixin"></a><a class="jiathis_button_renren"></a><a href="http://www.jiathis.com/share?uid=1409314953297200" target="_blank" class="jiathis jiathis_txt jtico jtico_jiathis"></a></div><script type="text/javascript">var jiathis_config = {data_track_clickback:'true'};    </script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1409314953297200" charset="utf-8"></script></div><hr><div id="duoshuo" data-url="http://lingyu.wang/2014/05/10/read-jq-src-2/" data-thread-key="/blog/2014/05/10/read-jq-src-2/" data-title="jQuery的数据缓存" class="ds-thread"></div><script type="text/javascript">var duoshuoQuery = {short_name:'skyinlayer'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div></article><div class="pager"><a href="/2014/05/12/read-jq-src-4/" title="jQuery的事件机制——事件对象、兼容、接口" class="pre">上一页</a><a href="/2014/05/08/read-jq-src-1/" title="jQuery的核心方法和类型判断" class="next">下一页</a></div></div><aside id="aside"><section class="recent"><h3 class="title iconfont">最新文章<i>&#xe601;</i></h3><div class="links"><ul><li><a href="/2015/01/26/18-books/">读书破万卷，敲码别走神</a></li><li><a href="/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/">构建华丽UI的7条准则（上部）</a></li><li><a href="/2014/11/24/risingstack-nodejs-style-guide/">RisingStack的Node.js风格指南</a></li><li><a href="/2014/11/18/peertc-and-fivechess/">Peertc和五子棋</a></li><li><a href="/2014/10/21/datachannel/">使用WebRTC DataChannel在浏览器间传递数据</a></li></ul></div></section><section class="categories"><h3 class="title iconfont">分类<i>&#xe605;</i></h3><div class="links"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS技术/">JS技术</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NodeJs/">NodeJs</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端综合/">前端综合</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/即时通信/">即时通信</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/响应式/">响应式</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考总结/">思考总结</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/性能优化/">性能优化</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔试面试/">笔试面试</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/翻译/">翻译</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a><span class="category-list-count">10</span></li></ul></div></section><section class="tags"><h3 class="title iconfont">标签<i>&#xe603;</i></h3><div class="links"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">35</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/">Canvas</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataChannel/">DataChannel</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Generator/">Generator</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gulp/">Gulp</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">29</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">38</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kissy/">Kissy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJs/">NodeJs</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/">SEO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebIM/">WebIM</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebRTC/">WebRTC</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/grunt/">grunt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/koa/">koa</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oracle/">oracle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xmpp/">xmpp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动画/">动画</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/响应式/">响应式</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/存储函数/">存储函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思考/">思考</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试面试题/">笔试面试题</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计/">设计</a><span class="tag-list-count">10</span></li></ul></div></section><section class="archives"><h3 class="title iconfont"> 归档<i>&#xe60a;</i></h3><div class="links"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01">2015年1月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11">2014年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10">2014年10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09">2014年9月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07">2014年7月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05">2014年5月</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04">2014年4月</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03">2014年3月</a><span class="archive-list-count">29</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02">2014年2月</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01">2014年1月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12">2013年12月</a><span class="archive-list-count">1</span></li></ul></div></section></aside></section><footer id="page-footer"><span style="float:right"><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5aa4945a04cc5a5a4cd6835ccb7d419' type='text/javascript'%3E%3C/script%3E"));</script></span><p>&copy;Powered by<a href="http://hexo.io" target="_blank" title="hexo">&nbsp;hexo&nbsp;</a>and Theme by<a href="https://github.com/LingyuCoder/lingyu-theme">&nbsp;LingyuCoder</a></p></footer><canvas id="snow"></canvas><style type="text/css">#snow {
    position: fixed;
    display: block;
    pointer-events: none;
    top: 0;
    left: 0;
}
</style><script type="text/javascript" src="/scripts/snow.js"></script><script type="text/javascript">var snow = new Snow('snow', {
    'amount': 200,
    'size': [8, 20],
    'rotation': [1, 5],
    'speed': [40, 80],
    'swing': [0.1, 1],
    'amplitude': [30, 50],
    'alpha': [0.1, 0.95],
    'images': [
        '/images/snow_1.png',
        '/images/snow_2.png',
        '/images/snow_3.png',
        '/images/snow_4.png'
    ]
});

window.addEventListener('resize', function() {
    snow.resize(window.innerWidth, window.innerHeight);
}, false);

window.addEventListener('load', function() {
    snow.start();
}, false);</script><script type="text/javascript" src="http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js"></script><script type="text/javascript">$(function(){
    var duoshuoIds = [];
    var map = {};
    $('.meta').each(function(){
        var $this = $(this);
        var id = $this.attr('thread');
        duoshuoIds.push(id);
        map[id] = $this;
    });
    duoshuoIds.length && $.ajax({
        url: 'http://api.duoshuo.com/threads/counts.jsonp',
        data: {
            threads: duoshuoIds.join(','),
            short_name: 'skyinlayer'
        },
        success: function(data){
            $.each(data.response, function(key, value){
                var $el = map[key];
                if($el) {
                    $.each(['comments','likes', 'reposts'], function(index, type){
                        $el.find('.' + type).append('<span>' + value[type] + '</span>');
                    });
                }
            });
        },
        dataType: 'jsonp'
    });
});</script></body></html>