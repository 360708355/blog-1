
<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>

<h1 id="generator">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>

<ol>
  <li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
  <li>创建一个generator对象，其有如下值：
    <ul>
      <li>Scope：新建的作用域链</li>
      <li>Code：generator function内部的代码</li>
      <li>ExecutionContext：EC，目前值为null</li>
      <li>State：”newborn”</li>
      <li>Handler：默认的generator的处理器</li>
    </ul>
  </li>
</ol>

<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>

<h1 id="yield">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
  <li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
  <li>从EC栈弹出当前的EC</li>
  <li>返回(normal, 1中的结果值, null)</li>
</ol>

<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>

<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>

<h1 id="return">return行为</h1>
<p>当执行到<code>return e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
  <li>将这个generator对象的状态修改为closed</li>
  <li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
  <li>throw这个对象</li>
</ol>

<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>

<h1 id="generator-1">Generator对象的私有属性</h1>

<ul>
  <li>prototype：Object.prototype</li>
  <li>code：generator函数的函数体</li>
  <li>ExecutionContext：内部代码运行使用的EC</li>
  <li>Scope：作用域链</li>
  <li>Handler：标准的generator句柄</li>
  <li>State：newborn、executing、suspended、closed</li>
  <li>Send：看内部方法部分</li>
  <li>Throw：看内部方法部分</li>
  <li>Close：看内部方法部分</li>
</ul>

<h1 id="section">外部接口</h1>
<p>next
—</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入一个undefined</li>
  <li>返回结果</li>
</ol>

<p>调用私有send方法</p>

<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<p>同样是调用私有send方法，不过传入了参数</p>

<h2 id="throw">throw</h2>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.throw，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.close，不传入任何参数</li>
  <li>返回结果</li>
</ol>

<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>

<h2 id="section-1">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>

<h1 id="section-2">状态定义</h1>

<ul>
  <li>newborn：Code不为null，EC为null</li>
  <li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
  <li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
  <li>closed：Code为null，EC为null</li>
</ul>

<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>

<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>

<p>当然也可以通过close方法，手动修改状态为closed</p>

<h1 id="section-3">内部方法</h1>
<p>send方法
—</p>

<ol>
  <li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
  <li>如果state为newborn
    <ol>
      <li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
      <li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
      <li>将这个EC压入EC栈中</li>
      <li>执行generator中的代码，并返回或得到的结果</li>
    </ol>
  </li>
  <li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>

<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>

<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>

<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>

<h2 id="throw-1">throw</h2>

<ol>
  <li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
  <li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
  <li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>

<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>

<h2 id="close-1">close</h2>

<ol>
  <li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
  <li>如果state已经是closed了，那直接return就好</li>
  <li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
  <li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>

<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>

<h2 id="resumeec-completiontype-v">Resume(EC, completionType, V)</h2>

<ol>
  <li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
  <li>从EC通过currentGenerator获取单签generator对象</li>
  <li>设置当前作用域链为当前generator对象的作用域链</li>
  <li>继续执行代码，并根据completionType做相应的处理</li>
</ol>

<h1 id="nodejs">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>

<h2 id="section-4">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">harmony generators ES Wiki</a></p>

