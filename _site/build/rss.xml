<?xml version="1.0" encoding="utf-8" ?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
    <channel>
        <title>天镶的博客 SkyInlayer`s Blog</title>
        <atom:link href="http://lingyu.wang/rss.xml" rel="self" type="application/rss+xml"/>
        <link>http://skyinlayer.com/</link>
        <description>天镶SkyInlayer的个人博客</description>
        <language>zh-CN</language>
        
            <item>
                <title><![CDATA[ 细说Generator ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/07/29/generator.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 29 Jul 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>

<h1 id="generator">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>

<ol>
  <li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
  <li>创建一个generator对象，其有如下值：
    <ul>
      <li>Scope：新建的作用域链</li>
      <li>Code：generator function内部的代码</li>
      <li>ExecutionContext：EC，目前值为null</li>
      <li>State：”newborn”</li>
      <li>Handler：默认的generator的处理器</li>
    </ul>
  </li>
</ol>

<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>

<h1 id="yield">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
  <li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
  <li>从EC栈弹出当前的EC</li>
  <li>返回(normal, 1中的结果值, null)</li>
</ol>

<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>

<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>

<h1 id="return">return行为</h1>
<p>当执行到<code>return e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
  <li>将这个generator对象的状态修改为closed</li>
  <li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
  <li>throw这个对象</li>
</ol>

<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>

<h1 id="generator-1">Generator对象的私有属性</h1>

<ul>
  <li>prototype：Object.prototype</li>
  <li>code：generator函数的函数体</li>
  <li>ExecutionContext：内部代码运行使用的EC</li>
  <li>Scope：作用域链</li>
  <li>Handler：标准的generator句柄</li>
  <li>State：newborn、executing、suspended、closed</li>
  <li>Send：看内部方法部分</li>
  <li>Throw：看内部方法部分</li>
  <li>Close：看内部方法部分</li>
</ul>

<h1 id="section">外部接口</h1>
<p>next
—</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入一个undefined</li>
  <li>返回结果</li>
</ol>

<p>调用私有send方法</p>

<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<p>同样是调用私有send方法，不过传入了参数</p>

<h2 id="throw">throw</h2>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.throw，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.close，不传入任何参数</li>
  <li>返回结果</li>
</ol>

<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>

<h2 id="section-1">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>

<h1 id="section-2">状态定义</h1>

<ul>
  <li>newborn：Code不为null，EC为null</li>
  <li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
  <li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
  <li>closed：Code为null，EC为null</li>
</ul>

<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>

<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>

<p>当然也可以通过close方法，手动修改状态为closed</p>

<h1 id="section-3">内部方法</h1>
<p>send方法
—</p>

<ol>
  <li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
  <li>如果state为newborn
    <ol>
      <li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
      <li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
      <li>将这个EC压入EC栈中</li>
      <li>执行generator中的代码，并返回或得到的结果</li>
    </ol>
  </li>
  <li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>

<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>

<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>

<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>

<h2 id="throw-1">throw</h2>

<ol>
  <li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
  <li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
  <li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>

<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>

<h2 id="close-1">close</h2>

<ol>
  <li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
  <li>如果state已经是closed了，那直接return就好</li>
  <li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
  <li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>

<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>

<h2 id="resumeec-completiontype-v">Resume(EC, completionType, V)</h2>

<ol>
  <li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
  <li>从EC通过currentGenerator获取单签generator对象</li>
  <li>设置当前作用域链为当前generator对象的作用域链</li>
  <li>继续执行代码，并根据completionType做相应的处理</li>
</ol>

<h1 id="nodejs">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>

<h2 id="section-4">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">harmony generators ES Wiki</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/07/29/generator.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 细说Generator ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/07/29/generator.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 29 Jul 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>

<h1 id="generator">Generator函数</h1>
<p>generator函数执行的时候，会进行如下动作：</p>

<ol>
  <li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
  <li>创建一个generator对象，其有如下值：
    <ul>
      <li>Scope：新建的作用域链</li>
      <li>Code：generator function内部的代码</li>
      <li>ExecutionContext：EC，目前值为null</li>
      <li>State：”newborn”</li>
      <li>Handler：默认的generator的处理器</li>
    </ul>
  </li>
</ol>

<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>

<h1 id="yield">yield的行为</h1>
<p>当执行到<code>yield e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
  <li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
  <li>从EC栈弹出当前的EC</li>
  <li>返回(normal, 1中的结果值, null)</li>
</ol>

<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>

<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>

<h1 id="return">return行为</h1>
<p>当执行到<code>return e</code>时：</p>

<ol>
  <li>计算出表达式e的值</li>
  <li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
  <li>将这个generator对象的状态修改为closed</li>
  <li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
  <li>throw这个对象</li>
</ol>

<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>

<h1 id="generator-1">Generator对象的私有属性</h1>

<ul>
  <li>prototype：Object.prototype</li>
  <li>code：generator函数的函数体</li>
  <li>ExecutionContext：内部代码运行使用的EC</li>
  <li>Scope：作用域链</li>
  <li>Handler：标准的generator句柄</li>
  <li>State：newborn、executing、suspended、closed</li>
  <li>Send：看内部方法部分</li>
  <li>Throw：看内部方法部分</li>
  <li>Close：看内部方法部分</li>
</ul>

<h1 id="section">外部接口</h1>
<p>next
—</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入一个undefined</li>
  <li>返回结果</li>
</ol>

<p>调用私有send方法</p>

<h2 id="send">send</h2>
<p>send方法允许指定一个值，作为上一次yield的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.send，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<p>同样是调用私有send方法，不过传入了参数</p>

<h2 id="throw">throw</h2>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.throw，传入当前第一个参数</li>
  <li>返回结果</li>
</ol>

<h2 id="close">close</h2>
<p>调用close方法可以直接以当前的value作为Generator的返回值</p>

<ol>
  <li>如果this指向的不是generator对象，抛异常</li>
  <li>调用this.close，不传入任何参数</li>
  <li>返回结果</li>
</ol>

<h2 id="iterate">iterate</h2>
<p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>

<h2 id="section-1">小结</h2>
<p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>

<h1 id="section-2">状态定义</h1>

<ul>
  <li>newborn：Code不为null，EC为null</li>
  <li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
  <li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
  <li>closed：Code为null，EC为null</li>
</ul>

<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>

<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>

<p>当然也可以通过close方法，手动修改状态为closed</p>

<h1 id="section-3">内部方法</h1>
<p>send方法
—</p>

<ol>
  <li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
  <li>如果state为newborn
    <ol>
      <li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
      <li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
      <li>将这个EC压入EC栈中</li>
      <li>执行generator中的代码，并返回或得到的结果</li>
    </ol>
  </li>
  <li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>

<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>

<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>

<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>

<h2 id="throw-1">throw</h2>

<ol>
  <li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
  <li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
  <li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>

<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>

<h2 id="close-1">close</h2>

<ol>
  <li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
  <li>如果state已经是closed了，那直接return就好</li>
  <li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
  <li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>

<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>

<h2 id="resumeec-completiontype-v">Resume(EC, completionType, V)</h2>

<ol>
  <li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
  <li>从EC通过currentGenerator获取单签generator对象</li>
  <li>设置当前作用域链为当前generator对象的作用域链</li>
  <li>继续执行代码，并根据completionType做相应的处理</li>
</ol>

<h1 id="nodejs">NodeJs上的不同</h1>
<p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>

<h2 id="section-4">资料</h2>
<p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">harmony generators ES Wiki</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/07/29/generator.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 如何写一个KISSY动画插件 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/31/kissy-anime-plugin.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 31 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin">Github页面</a></p>

<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>

<h2 id="cssjavascript">CSS与JavaScript动画对比</h2>
<p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>

<h3 id="css">CSS动画</h3>
<p>####animation
CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：
1. animation-name：动画的名称，也就是定义的keyframes关键帧的名称
2. animation-duration：一次动画的时长
3. animation-timing-funciton：缓动函数，这个后面会有详细介绍
4. animation-delay：动画延迟时间
5. animation-iteration-count：动画的播放次数
6. animation-direction：动画时正向播放还是倒着播放
7. animation-play-state：动画的状态，暂停还是播放
8. animation-fill-mode：动画播放时间之外的状态，是否重回动画初始
9. animation：复合属性，上面属性合在一起的写法</p>

<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>

<h4 id="transition">transition</h4>
<p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：
1. transition-property：需要参与过渡的属性
2. transition-duration 过渡的时长
3. transition-timing-function：过渡的缓动函数
4. transition-delay：过渡的延时</p>

<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>

<h4 id="section">优缺点</h4>
<p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>

<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>

<p>另外，<a href="http://lingyu.wang/#/item">这里</a>有我曾经写过的一些CSS3动画效果</p>

<h3 id="javascript">JavaScript动画</h3>
<p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：
1. 计算当前元素样式
2. 修改元素样式
3. 重绘元素</p>

<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>

<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>

<h2 id="section-1">需求分析</h2>
<p>###动画属性
通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：
1. 涉及的元素（elems）
2. 需要改变的样式（styles）
3. 时长（duration）
4. 缓动函数（easing-function）
5. 播放次数（times）</p>

<h3 id="section-2">动画控制</h3>
<p>而控制上，我们应该实现的功能：
1. 开始（run）
2. 暂停（pause）
3. 暂停恢复（resume）
4. 中止（stop）
5. 倒放（reverse）
6. 单帧（go）</p>

<h3 id="section-3">动画能够改变的内容</h3>
<p>需要能够改变的内容有：
1. CSS样式
2. 滚动</p>

<h2 id="section-4">动画对象</h2>
<p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>

<p>所以，动画的对象大致上是这样：
<code>javascript
function Anime(){}
Anime.prototype.run = function(){};
Anime.prototype.pause = function(){};
Anime.prototype.resume = function(){};
Anime.prototype.stop = function(){};
Anime.prototype.go = function(){};
</code></p>

<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>

<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>

<p><code>javascript
function Anime(elems, styles, config){}
</code>
conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：
<code>javascript
var defaultConfig = {
    callback: noop,
    duration: 1500,
    reverse: false,
    easing: "linear",
    times: 1,
    spend: 0,
    state: "running"
};
</code></p>

<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：
* running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态
* paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态
* ended为终止状态，可以通过run放法进行重放，转到running状态</p>

<h2 id="section-5">动画队列</h2>
<p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>

<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>

<p>所以，队列首先得实现相关的添加删除操作，注意去重：
```javascript
var animeQueue = [];</p>

<p>function addAnime(anime) {
    if (S.indexOf(anime, animeQueue) === -1) {
        animeQueue.push(anime);
        checkRunning();
    }
}</p>

<p>function deleteAnime(anime) {
    var index = S.indexOf(anime, animeQueue);
    if (index &gt;= 0) {
        animeQueue.splice(index, 1);
        checkRunning();
    }
}
```</p>

<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：
<code>javascript
function pulse() {
    var deleteIndex = [],
        i, m, tmp;
    if (running) {
        S.each(animeQueue, function(anime, index) {
            if (anime.state === "running") {
                anime.go();
            } else {
                deleteIndex.push(index);
            }
        });
        for (i = deleteIndex.length; i--;) {
            animeQueue.splice(deleteIndex[i], 1);
        }
        dealing = false;
        checkRunning();
    }
}
</code>
checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：
<code>javascript
function checkRunning() {
    if (animeQueue.length &gt; 0) {
        running = true;
        if (!dealing) {
            dealing = true;
            requestAnimationFrame(pulse);
        }
    } else {
        running = false;
        dealing = false;
    }
}
</code></p>

<h2 id="section-6">缓动函数</h2>
<p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>

<h2 id="section-7">样式处理</h2>
<p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：
1. 从元素获取样式的起始值（从什么地方开始）
2. 获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）
3. 计算当前时间点的中间值（经过怎样的过程）
4. 向元素赋予计算出来的中间值（经过怎样的过程）</p>

<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：
```javascript
function getCSS(elem, style) {
    var val;
    if (hooks[style] &amp;&amp; hooks[style].get) {
        val = hooks[style].get(elem, style);
    } else {
        val = hooks._default.get(elem, style);
    }
    return parseCSS(val, style);
}</p>

<p>function parseCSS(val, style, from) {
    if (hooks[style] &amp;&amp; hooks[style].parse) {
        return hooks[style].parse(val, from);
    }
    return hooks._default.parse(val, from);
}</p>

<p>function computeCSS(style, from, to, pos) {
    if (hooks[style] &amp;&amp; hooks[style].compute) {
        return hooks[style].compute(from, to, pos);
    }
    return hooks._default.compute(from, to, pos);</p>

<p>}</p>

<p>function assignCSS(elem, style, val) {
    if (hooks[style] &amp;&amp; hooks[style].assign) {
        return hooks[style].assign(elem, style, val);
    }
    return hooks._default.assign(elem, style, val);
}
```</p>

<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>

<h2 id="section-8">特殊处理</h2>
<p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例
###颜色属性
如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：
1. HEX：<code>#fff</code>或<code>#f0f0f0</code>
2. RGB：<code>rgb(245, 28, 33)</code>
3. RGBA：<code>rgba(245, 28, 33, .6)</code>
4. 直接名称：<code>red</code>、<code>white</code>等等
5. HSL和HSLA，这里不做实现</p>

<h4 id="section-9">获取</h4>
<p>获取和一般CSS属性没差， 直接使用默认方式了</p>

<h4 id="section-10">解析</h4>
<p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>

<p><code>javascript
function parseColor(val) {
    val = val.replace(rClearSpace, "").toLowerCase();
    if (normalColors[val]) {
        return normalColors[val];
    }
    var color = [];
    var tmp;
    var i;
    if (rHexColor.test(val)) {
        tmp = [];
        if (val.length === 4) {
            for (i = 3; i--;) {
                tmp[i] = val.charAt(i + 1);
                tmp[i] += tmp[i];
            }
        } else if (val.length === 7) {
            for (i = 3; i--;) {
                tmp[i] = val.substr(1 + i * 2, 2);
            }
        }
        for (i = 3; i--;) {
            color[i] = parseInt(tmp[i], 16);
        }
        color[3] = 1;
    } else if (!S.isNull(tmp = val.match(rRGB))) {
        for (i = 3; i--;) {
            color[i] = parseInt(tmp[i + 1], 10);
        }
        color[3] = 1;
    } else if (!S.isNull(tmp = val.match(rRGBA))) {
        for (i = 4; i--;) {
            color[i] = Number(tmp[i + 1]);
        }
    }
    return color;
}
</code></p>

<h4 id="section-11">计算</h4>
<p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了
<code>javascript
function computeColor(from, to, pos) {
    var _default = hooks._default,
        result = [],
        i;
    for (i = 0; i &lt;= 2; i++) {
        result.push(parseInt(_default.compute(from[i], to[i], pos), 10));
    }
    result.push(_default.compute(from[3], to[3], pos));
    return result;
}
</code></p>

<h4 id="section-12">赋值</h4>
<p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式
<code>javascript
function assignColor(elem, style, val) {
    if(KISSY.Features.isIELessThan(9)){
        Dom.css(elem, style, "rgb(" + val.slice(0, 3).join(",") + ")");
    } else {
        Dom.css(elem, style, "rgba(" + val.join(",") + ")");
    }
}
</code></p>

<h3 id="section-13">滚动</h3>
<p>####获取
滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>

<h4 id="section-14">解析</h4>
<p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>

<h4 id="section-15">计算</h4>
<p>计算过程也是，使用默认计算即可</p>

<h4 id="section-16">赋值</h4>
<p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>

<p><code>javascript
S.each("scrollTop scrollLeft".split(" "), function(type) {
    var _default = hooks._default;
    hooks[type] = {
        assign: function(elem, style, val) {
            Dom[type](elem, val);
        },
        get: function(elem, style) {
            return Dom[type](elem);
        }
    };
});
</code></p>

<h3 id="transform">transform</h3>
<p><strong>这里只处理了2D的transform</strong></p>

<p>transform的值也有很多不同的形式：
1. matrix
2. rotate
3. translate、translateX、translateY
4. scale、scaleX、scaleY
5. skew、skewX、skewY</p>

<h4 id="section-17">获取</h4>
<p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>

<h4 id="section-18">解析</h4>
<p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：
<code>javascript
var result = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1
};
</code></p>

<p>代码较长</p>

<p>```javascript
function decomposeMatrix(matrix) {
    var scaleX, scaleY, skew,
        A = matrix[0],
        B = matrix[1],
        C = matrix[2],
        D = matrix[3];</p>

<pre><code>// Make sure matrix is not singular
if (A * D - B * C) {
    scaleX = Math.sqrt(A * A + B * B);
    skew = (A * C + B * D) / (A * D - C * B);
    scaleY = (A * D - B * C) / scaleX;
    // step (6)
    if (A * D &lt; B * C) {
        skew = -skew;
        scaleX = -scaleX;
    }
    // matrix is singular and cannot be interpolated
} else {
    // In this case the elem shouldn't be rendered, hence scale == 0
    scaleX = scaleY = skew = 0;
}

// The recomposition order is very important
// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971
return {
    translateX: myParse(matrix[4]),
    translateY: myParse(matrix[5]),
    rotate: myParse(Math.atan2(B, A) * 180 / Math.PI),
    skewX: myParse(Math.atan(skew) * 180 / Math.PI),
    skewY: 0,
    scaleX: myParse(scaleX),
    scaleY: myParse(scaleY)
}; }
</code></pre>

<p>function valueStringToArray(val) {
    var result = val.split(“,”);
    result = S.map(result, function(value) {
        return myParse(value);
    });
    return result;
}</p>

<p>function parseTransform(val) {
    var result = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        skewY: 0,
        scaleX: 1,
        scaleY: 1
    };
    var value;
    var regResult;
    var i, j, m;
    var name;
    var strs;
    strs = val.replace(rClearSpace, “”).split(“)”);
    for (i = 0, m = strs.length; i &lt; m; i++) {
        if (!strs[i] || strs[i] === “none”) continue;
        regResult = strs[i].split(“(“);
        name = regResult[0];
        value = valueStringToArray(regResult[1]);
        switch (name) {
            case “matrix”:
                result = decomposeMatrix(value);
                break;
            case “translate”:
            case “skew”:
                result[name + “X”] = value[0] || 0;
                result[name + “Y”] = value[1] || 0;
                break;
            case “scale”:
                result[name + “X”] = value[0] || 0;
                result[name + “Y”] = value[1] || result[name + “X”];
                break;
            case “translateX”:
            case “translateY”:
            case “scaleX”:
            case “scaleY”:
            case “skewX”:
            case “skewY”:
            case “rotate”:
                result[name] = value[0] || 0;
                break;
            default:
                continue;
        }
    }
    return result;
}
```
这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>

<h4 id="section-19">计算</h4>
<p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>

<p><code>javascript
function computeTransform(from, to, pos) {
    var _default = hooks._default;
    var result = {};
    S.each(to, function(value, key) {
        result[key] = _default.compute(from[key], to[key], pos);
    });
    return result;
}
</code></p>

<h3 id="section-20">赋值</h3>
<p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：
<code>javascript
function assignTransform(elem, style, val) {
    var valueArray = [];
    S.each(val, function(value, key) {
        if ((key.indexOf("scale") &gt; -1 &amp;&amp; value === 1) || (key.indexOf("scale") === -1 &amp;&amp; value === 0)) {
            return;
        }
        if (key === "rotate" || key.indexOf("skew") &gt; -1) {
            value += "deg";
        } else if (key.indexOf("translate") &gt; -1) {
            value += "px";
        }
        valueArray.push(key + "(" + value + ")");
    });
    Dom.css(elem, style, valueArray.join(" "));
}
</code></p>

<h2 id="section-21">总结</h2>
<p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/31/kissy-anime-plugin.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 如何写一个KISSY动画插件 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/31/kissy-anime-plugin.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 31 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin">Github页面</a></p>

<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>

<h2 id="cssjavascript">CSS与JavaScript动画对比</h2>
<p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>

<h3 id="css">CSS动画</h3>
<p>####animation
CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：
1. animation-name：动画的名称，也就是定义的keyframes关键帧的名称
2. animation-duration：一次动画的时长
3. animation-timing-funciton：缓动函数，这个后面会有详细介绍
4. animation-delay：动画延迟时间
5. animation-iteration-count：动画的播放次数
6. animation-direction：动画时正向播放还是倒着播放
7. animation-play-state：动画的状态，暂停还是播放
8. animation-fill-mode：动画播放时间之外的状态，是否重回动画初始
9. animation：复合属性，上面属性合在一起的写法</p>

<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>

<h4 id="transition">transition</h4>
<p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：
1. transition-property：需要参与过渡的属性
2. transition-duration 过渡的时长
3. transition-timing-function：过渡的缓动函数
4. transition-delay：过渡的延时</p>

<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>

<h4 id="section">优缺点</h4>
<p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>

<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>

<p>另外，<a href="http://lingyu.wang/#/item">这里</a>有我曾经写过的一些CSS3动画效果</p>

<h3 id="javascript">JavaScript动画</h3>
<p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：
1. 计算当前元素样式
2. 修改元素样式
3. 重绘元素</p>

<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>

<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>

<h2 id="section-1">需求分析</h2>
<p>###动画属性
通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：
1. 涉及的元素（elems）
2. 需要改变的样式（styles）
3. 时长（duration）
4. 缓动函数（easing-function）
5. 播放次数（times）</p>

<h3 id="section-2">动画控制</h3>
<p>而控制上，我们应该实现的功能：
1. 开始（run）
2. 暂停（pause）
3. 暂停恢复（resume）
4. 中止（stop）
5. 倒放（reverse）
6. 单帧（go）</p>

<h3 id="section-3">动画能够改变的内容</h3>
<p>需要能够改变的内容有：
1. CSS样式
2. 滚动</p>

<h2 id="section-4">动画对象</h2>
<p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>

<p>所以，动画的对象大致上是这样：
<code>javascript
function Anime(){}
Anime.prototype.run = function(){};
Anime.prototype.pause = function(){};
Anime.prototype.resume = function(){};
Anime.prototype.stop = function(){};
Anime.prototype.go = function(){};
</code></p>

<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>

<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>

<p><code>javascript
function Anime(elems, styles, config){}
</code>
conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：
<code>javascript
var defaultConfig = {
    callback: noop,
    duration: 1500,
    reverse: false,
    easing: "linear",
    times: 1,
    spend: 0,
    state: "running"
};
</code></p>

<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：
* running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态
* paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态
* ended为终止状态，可以通过run放法进行重放，转到running状态</p>

<h2 id="section-5">动画队列</h2>
<p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>

<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>

<p>所以，队列首先得实现相关的添加删除操作，注意去重：
```javascript
var animeQueue = [];</p>

<p>function addAnime(anime) {
    if (S.indexOf(anime, animeQueue) === -1) {
        animeQueue.push(anime);
        checkRunning();
    }
}</p>

<p>function deleteAnime(anime) {
    var index = S.indexOf(anime, animeQueue);
    if (index &gt;= 0) {
        animeQueue.splice(index, 1);
        checkRunning();
    }
}
```</p>

<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：
<code>javascript
function pulse() {
    var deleteIndex = [],
        i, m, tmp;
    if (running) {
        S.each(animeQueue, function(anime, index) {
            if (anime.state === "running") {
                anime.go();
            } else {
                deleteIndex.push(index);
            }
        });
        for (i = deleteIndex.length; i--;) {
            animeQueue.splice(deleteIndex[i], 1);
        }
        dealing = false;
        checkRunning();
    }
}
</code>
checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：
<code>javascript
function checkRunning() {
    if (animeQueue.length &gt; 0) {
        running = true;
        if (!dealing) {
            dealing = true;
            requestAnimationFrame(pulse);
        }
    } else {
        running = false;
        dealing = false;
    }
}
</code></p>

<h2 id="section-6">缓动函数</h2>
<p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>

<h2 id="section-7">样式处理</h2>
<p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：
1. 从元素获取样式的起始值（从什么地方开始）
2. 获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）
3. 计算当前时间点的中间值（经过怎样的过程）
4. 向元素赋予计算出来的中间值（经过怎样的过程）</p>

<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：
```javascript
function getCSS(elem, style) {
    var val;
    if (hooks[style] &amp;&amp; hooks[style].get) {
        val = hooks[style].get(elem, style);
    } else {
        val = hooks._default.get(elem, style);
    }
    return parseCSS(val, style);
}</p>

<p>function parseCSS(val, style, from) {
    if (hooks[style] &amp;&amp; hooks[style].parse) {
        return hooks[style].parse(val, from);
    }
    return hooks._default.parse(val, from);
}</p>

<p>function computeCSS(style, from, to, pos) {
    if (hooks[style] &amp;&amp; hooks[style].compute) {
        return hooks[style].compute(from, to, pos);
    }
    return hooks._default.compute(from, to, pos);</p>

<p>}</p>

<p>function assignCSS(elem, style, val) {
    if (hooks[style] &amp;&amp; hooks[style].assign) {
        return hooks[style].assign(elem, style, val);
    }
    return hooks._default.assign(elem, style, val);
}
```</p>

<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>

<h2 id="section-8">特殊处理</h2>
<p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例
###颜色属性
如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：
1. HEX：<code>#fff</code>或<code>#f0f0f0</code>
2. RGB：<code>rgb(245, 28, 33)</code>
3. RGBA：<code>rgba(245, 28, 33, .6)</code>
4. 直接名称：<code>red</code>、<code>white</code>等等
5. HSL和HSLA，这里不做实现</p>

<h4 id="section-9">获取</h4>
<p>获取和一般CSS属性没差， 直接使用默认方式了</p>

<h4 id="section-10">解析</h4>
<p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>

<p><code>javascript
function parseColor(val) {
    val = val.replace(rClearSpace, "").toLowerCase();
    if (normalColors[val]) {
        return normalColors[val];
    }
    var color = [];
    var tmp;
    var i;
    if (rHexColor.test(val)) {
        tmp = [];
        if (val.length === 4) {
            for (i = 3; i--;) {
                tmp[i] = val.charAt(i + 1);
                tmp[i] += tmp[i];
            }
        } else if (val.length === 7) {
            for (i = 3; i--;) {
                tmp[i] = val.substr(1 + i * 2, 2);
            }
        }
        for (i = 3; i--;) {
            color[i] = parseInt(tmp[i], 16);
        }
        color[3] = 1;
    } else if (!S.isNull(tmp = val.match(rRGB))) {
        for (i = 3; i--;) {
            color[i] = parseInt(tmp[i + 1], 10);
        }
        color[3] = 1;
    } else if (!S.isNull(tmp = val.match(rRGBA))) {
        for (i = 4; i--;) {
            color[i] = Number(tmp[i + 1]);
        }
    }
    return color;
}
</code></p>

<h4 id="section-11">计算</h4>
<p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了
<code>javascript
function computeColor(from, to, pos) {
    var _default = hooks._default,
        result = [],
        i;
    for (i = 0; i &lt;= 2; i++) {
        result.push(parseInt(_default.compute(from[i], to[i], pos), 10));
    }
    result.push(_default.compute(from[3], to[3], pos));
    return result;
}
</code></p>

<h4 id="section-12">赋值</h4>
<p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式
<code>javascript
function assignColor(elem, style, val) {
    if(KISSY.Features.isIELessThan(9)){
        Dom.css(elem, style, "rgb(" + val.slice(0, 3).join(",") + ")");
    } else {
        Dom.css(elem, style, "rgba(" + val.join(",") + ")");
    }
}
</code></p>

<h3 id="section-13">滚动</h3>
<p>####获取
滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>

<h4 id="section-14">解析</h4>
<p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>

<h4 id="section-15">计算</h4>
<p>计算过程也是，使用默认计算即可</p>

<h4 id="section-16">赋值</h4>
<p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>

<p><code>javascript
S.each("scrollTop scrollLeft".split(" "), function(type) {
    var _default = hooks._default;
    hooks[type] = {
        assign: function(elem, style, val) {
            Dom[type](elem, val);
        },
        get: function(elem, style) {
            return Dom[type](elem);
        }
    };
});
</code></p>

<h3 id="transform">transform</h3>
<p><strong>这里只处理了2D的transform</strong></p>

<p>transform的值也有很多不同的形式：
1. matrix
2. rotate
3. translate、translateX、translateY
4. scale、scaleX、scaleY
5. skew、skewX、skewY</p>

<h4 id="section-17">获取</h4>
<p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>

<h4 id="section-18">解析</h4>
<p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：
<code>javascript
var result = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1
};
</code></p>

<p>代码较长</p>

<p>```javascript
function decomposeMatrix(matrix) {
    var scaleX, scaleY, skew,
        A = matrix[0],
        B = matrix[1],
        C = matrix[2],
        D = matrix[3];</p>

<pre><code>// Make sure matrix is not singular
if (A * D - B * C) {
    scaleX = Math.sqrt(A * A + B * B);
    skew = (A * C + B * D) / (A * D - C * B);
    scaleY = (A * D - B * C) / scaleX;
    // step (6)
    if (A * D &lt; B * C) {
        skew = -skew;
        scaleX = -scaleX;
    }
    // matrix is singular and cannot be interpolated
} else {
    // In this case the elem shouldn't be rendered, hence scale == 0
    scaleX = scaleY = skew = 0;
}

// The recomposition order is very important
// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971
return {
    translateX: myParse(matrix[4]),
    translateY: myParse(matrix[5]),
    rotate: myParse(Math.atan2(B, A) * 180 / Math.PI),
    skewX: myParse(Math.atan(skew) * 180 / Math.PI),
    skewY: 0,
    scaleX: myParse(scaleX),
    scaleY: myParse(scaleY)
}; }
</code></pre>

<p>function valueStringToArray(val) {
    var result = val.split(“,”);
    result = S.map(result, function(value) {
        return myParse(value);
    });
    return result;
}</p>

<p>function parseTransform(val) {
    var result = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        skewY: 0,
        scaleX: 1,
        scaleY: 1
    };
    var value;
    var regResult;
    var i, j, m;
    var name;
    var strs;
    strs = val.replace(rClearSpace, “”).split(“)”);
    for (i = 0, m = strs.length; i &lt; m; i++) {
        if (!strs[i] || strs[i] === “none”) continue;
        regResult = strs[i].split(“(“);
        name = regResult[0];
        value = valueStringToArray(regResult[1]);
        switch (name) {
            case “matrix”:
                result = decomposeMatrix(value);
                break;
            case “translate”:
            case “skew”:
                result[name + “X”] = value[0] || 0;
                result[name + “Y”] = value[1] || 0;
                break;
            case “scale”:
                result[name + “X”] = value[0] || 0;
                result[name + “Y”] = value[1] || result[name + “X”];
                break;
            case “translateX”:
            case “translateY”:
            case “scaleX”:
            case “scaleY”:
            case “skewX”:
            case “skewY”:
            case “rotate”:
                result[name] = value[0] || 0;
                break;
            default:
                continue;
        }
    }
    return result;
}
```
这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>

<h4 id="section-19">计算</h4>
<p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>

<p><code>javascript
function computeTransform(from, to, pos) {
    var _default = hooks._default;
    var result = {};
    S.each(to, function(value, key) {
        result[key] = _default.compute(from[key], to[key], pos);
    });
    return result;
}
</code></p>

<h3 id="section-20">赋值</h3>
<p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：
<code>javascript
function assignTransform(elem, style, val) {
    var valueArray = [];
    S.each(val, function(value, key) {
        if ((key.indexOf("scale") &gt; -1 &amp;&amp; value === 1) || (key.indexOf("scale") === -1 &amp;&amp; value === 0)) {
            return;
        }
        if (key === "rotate" || key.indexOf("skew") &gt; -1) {
            value += "deg";
        } else if (key.indexOf("translate") &gt; -1) {
            value += "px";
        }
        valueArray.push(key + "(" + value + ")");
    });
    Dom.css(elem, style, valueArray.join(" "));
}
</code></p>

<h2 id="section-21">总结</h2>
<p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/31/kissy-anime-plugin.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ WebRTC的RTCDataChannel ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/22/webrtc-data-channels.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 22 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>

<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>

<blockquote>
  <p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>

<h3 id="section">为什么我们需要另外一个数据通道</h3>
<p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>

<p>RTCDataChannel则是一个完全不同的途径：
* 它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。
* RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</p>

<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>

<h3 id="stunturn">一个警告：信令、STUN和TURN</h3>
<p>尽管WebRTC允许点对点的通信，但它依然需要服务器：
* 信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器
* NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</p>

<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>

<h3 id="section-1">功能</h3>
<p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能" />
以上来自<a href="http://www.igvita.com/">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html">High Performance Browser Networking</a></p>

<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：
* 可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢
* 不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</p>

<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>

<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>

<h3 id="section-2">配置数据通道</h3>
<p>网上已经有很多RTCDataChannel的例子了：
* <a href="http://simpl.info/dc">simpl.info/dc</a>
* <a href="http://googlechrome.github.io/webrtc/dc1.html">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)
* <a href="http://pubnub.github.io/webrtc">pubnub.github.io/webrtc</a>(两个PubNub用户)</p>

<p>ps：PubBub是一个实时信息通讯应用开发公司</p>

<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>

<p>```javascript
var peerConnection = new RTCPeerConnection();</p>

<p>//使用信令传输信道创建对等连接
var dataChannel =
  peerConnection.createDataChannel(“myLabel”, dataChannelOptions);</p>

<p>dataChannel.onerror = function (error) {
  console.log(“Data Channel Error:”, error);
};</p>

<p>dataChannel.onmessage = function (event) {
  console.log(“Got Data Channel Message:”, event.data);
};</p>

<p>dataChannel.onopen = function () {
  dataChannel.send(“Hello World!”);
};</p>

<p>dataChannel.onclose = function () {
  console.log(“The Data Channel is Closed”);
};
```</p>

<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：
<code>javascript
var dataChannelOptions = {
  ordered: false, //不保证到达顺序
  maxRetransmitTime: 3000, //最大重传时间
};
</code>
我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758">RFC 3758</a>（SCTP部分可靠性）
* ordered: 数据通道是否保证按序传输数据
* maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）
* maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）
* protocol：允许使用一个自协议，但如果协议不支持，将会失败
* negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道
* id：为数据通道提供一个自己定义的ID</p>

<h3 id="section-3">它安全吗？</h3>
<p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS">Wireshark的维基</a></p>

<h3 id="section-4">改变你考虑数据的方式</h3>
<p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>

<h3 id="section-5">搭建一个文件共享应用</h3>
<p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>

<p>需要成功传输一个文件，我们需要如下几步：
1. <a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/">通过JavaScript的File API读取文件数据</a>
2. 使用RTCPeerConnection在用户间创建一个对等连接
3. 使用RTCDataChannel在用户间创建一个数据通道</p>

<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：
* <strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。
* <strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。
* <strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</p>

<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：
<code>javascript
function saveFile(blob) {
  var link = document.createElement('a');
  link.href = window.URL.createObjectURL(blob);
  link.download = 'File Name';
  link.click();
};
</code></p>

<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>

<h3 id="section-6">那么我们能做什么？</h3>
<p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：
* 上面已经提到了点对点的文件传输了
* 多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/">Banana Bread</a>
* 内容交付：由<a href="https://peercdn.com/">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</p>

<h3 id="section-7">改变你构建应用的方式</h3>
<p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/">PeerJS</a>和<a href="https://github.com/pubnub/webrtc">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>

<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>

<h3 id="section-8">更多资讯</h3>
<ul>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting started with WebRTC</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></li>
  <li><a href="http://bit.ly/webrtcwebaudio">WebRTC resources</a></li>
  <li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api">W3C Working Draft</a></li>
  <li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04">IETF WebRTC Data Channel Protocol Draft</a></li>
  <li><a href="http://bloggeek.me/send-file-webrtc-data-api/">How to send a File Using WebRTC Data API</a></li>
  <li><a href="http://bloggeek.me/webrtc-data-channel-uses/">7 Creative Uses of WebRTC’s Data Channel</a></li>
  <li><a href="https://developer.mozilla.org/en/demos/detail/bananabread">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/22/webrtc-data-channels.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ WebRTC的RTCDataChannel ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/22/webrtc-data-channels.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 22 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>

<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>

<blockquote>
  <p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>

<h3 id="section">为什么我们需要另外一个数据通道</h3>
<p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>

<p>RTCDataChannel则是一个完全不同的途径：
* 它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。
* RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</p>

<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>

<h3 id="stunturn">一个警告：信令、STUN和TURN</h3>
<p>尽管WebRTC允许点对点的通信，但它依然需要服务器：
* 信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器
* NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</p>

<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>

<h3 id="section-1">功能</h3>
<p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能" />
以上来自<a href="http://www.igvita.com/">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html">High Performance Browser Networking</a></p>

<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：
* 可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢
* 不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</p>

<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>

<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>

<h3 id="section-2">配置数据通道</h3>
<p>网上已经有很多RTCDataChannel的例子了：
* <a href="http://simpl.info/dc">simpl.info/dc</a>
* <a href="http://googlechrome.github.io/webrtc/dc1.html">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)
* <a href="http://pubnub.github.io/webrtc">pubnub.github.io/webrtc</a>(两个PubNub用户)</p>

<p>ps：PubBub是一个实时信息通讯应用开发公司</p>

<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>

<p>```javascript
var peerConnection = new RTCPeerConnection();</p>

<p>//使用信令传输信道创建对等连接
var dataChannel =
  peerConnection.createDataChannel(“myLabel”, dataChannelOptions);</p>

<p>dataChannel.onerror = function (error) {
  console.log(“Data Channel Error:”, error);
};</p>

<p>dataChannel.onmessage = function (event) {
  console.log(“Got Data Channel Message:”, event.data);
};</p>

<p>dataChannel.onopen = function () {
  dataChannel.send(“Hello World!”);
};</p>

<p>dataChannel.onclose = function () {
  console.log(“The Data Channel is Closed”);
};
```</p>

<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：
<code>javascript
var dataChannelOptions = {
  ordered: false, //不保证到达顺序
  maxRetransmitTime: 3000, //最大重传时间
};
</code>
我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758">RFC 3758</a>（SCTP部分可靠性）
* ordered: 数据通道是否保证按序传输数据
* maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）
* maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）
* protocol：允许使用一个自协议，但如果协议不支持，将会失败
* negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道
* id：为数据通道提供一个自己定义的ID</p>

<h3 id="section-3">它安全吗？</h3>
<p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS">Wireshark的维基</a></p>

<h3 id="section-4">改变你考虑数据的方式</h3>
<p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>

<h3 id="section-5">搭建一个文件共享应用</h3>
<p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>

<p>需要成功传输一个文件，我们需要如下几步：
1. <a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/">通过JavaScript的File API读取文件数据</a>
2. 使用RTCPeerConnection在用户间创建一个对等连接
3. 使用RTCDataChannel在用户间创建一个数据通道</p>

<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：
* <strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。
* <strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。
* <strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</p>

<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：
<code>javascript
function saveFile(blob) {
  var link = document.createElement('a');
  link.href = window.URL.createObjectURL(blob);
  link.download = 'File Name';
  link.click();
};
</code></p>

<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>

<h3 id="section-6">那么我们能做什么？</h3>
<p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：
* 上面已经提到了点对点的文件传输了
* 多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/">Banana Bread</a>
* 内容交付：由<a href="https://peercdn.com/">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</p>

<h3 id="section-7">改变你构建应用的方式</h3>
<p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/">PeerJS</a>和<a href="https://github.com/pubnub/webrtc">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>

<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>

<h3 id="section-8">更多资讯</h3>
<ul>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting started with WebRTC</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></li>
  <li><a href="http://bit.ly/webrtcwebaudio">WebRTC resources</a></li>
  <li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api">W3C Working Draft</a></li>
  <li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04">IETF WebRTC Data Channel Protocol Draft</a></li>
  <li><a href="http://bloggeek.me/send-file-webrtc-data-api/">How to send a File Using WebRTC Data API</a></li>
  <li><a href="http://bloggeek.me/webrtc-data-channel-uses/">7 Creative Uses of WebRTC’s Data Channel</a></li>
  <li><a href="https://developer.mozilla.org/en/demos/detail/bananabread">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/22/webrtc-data-channels.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS的渲染阻塞 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/21/google-render-blocking-css.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>

<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>默认情况下CSS是渲染阻塞资源</li>
  <li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
  <li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>

<h3 id="css">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>

<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>

<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>

<h3 id="section-1">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>

<p><code>html
&lt;link href="style.css" rel="stylesheet"&gt;
&lt;link href="print.css" rel="stylesheet" media="print"&gt;
&lt;link href="other.css" rel="stylesheet" media="(min-width: 40em)"&gt;
</code></p>

<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>

<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>

<p>让我们考虑如下例子：
<code>html
&lt;link href="style.css"    rel="stylesheet"&gt;
&lt;link href="style.css"    rel="stylesheet" media="screen"&gt;
&lt;link href="portrait.css" rel="stylesheet" media="orientation:portrait"&gt;
&lt;link href="print.css"    rel="stylesheet" media="print"&gt;
</code></p>

<ol>
  <li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
  <li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
  <li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
  <li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>

<h3 id="section-2">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/21/google-render-blocking-css.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS的渲染阻塞 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/21/google-render-blocking-css.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>

<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>默认情况下CSS是渲染阻塞资源</li>
  <li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
  <li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>

<h3 id="css">CSS是渲染阻塞资源</h3>
<p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>

<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>

<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>

<h3 id="section-1">媒体类型和媒体查询</h3>
<p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>

<p><code>html
&lt;link href="style.css" rel="stylesheet"&gt;
&lt;link href="print.css" rel="stylesheet" media="print"&gt;
&lt;link href="other.css" rel="stylesheet" media="(min-width: 40em)"&gt;
</code></p>

<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>

<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>

<p>让我们考虑如下例子：
<code>html
&lt;link href="style.css"    rel="stylesheet"&gt;
&lt;link href="style.css"    rel="stylesheet" media="screen"&gt;
&lt;link href="portrait.css" rel="stylesheet" media="orientation:portrait"&gt;
&lt;link href="print.css"    rel="stylesheet" media="print"&gt;
</code></p>

<ol>
  <li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
  <li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
  <li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
  <li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>

<h3 id="section-2">浏览器下载</h3>
<p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/21/google-render-blocking-css.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用导航计时监测渲染关键路径 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
  <li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>

<h3 id="section-1">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API" /></p>

<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>

<p>那么，这些时间戳代表着什么？
* domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间
* domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间
* domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点
    * 许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间
* domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了
* loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</p>

<h3 id="section-2">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：
* domIneractive：说明DOM构建完毕
* domContentLoaded：当DOM和CSSOM都完成后触发
    * 如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发
* domComplete：当页面及其所有资源全部完毕时触发</p>

<p>```html</p>
<html>
  <head>
    <title>Critical Path: Measure</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <script>
      function measureCRP() {
        var t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        var stats = document.createElement('p');
        stats.textContent = 'interactive: ' + interactive + 'ms, ' +
            'dcl: ' + dcl + 'ms, complete: ' + complete + 'ms';
        document.body.appendChild(stats);
      }
    </script>
  </head>
  <body onload="measureCRP()">
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
<p>```
上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果" /></p>

<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用导航计时监测渲染关键路径 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
  <li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>

<h3 id="section-1">用于监测的时间戳</h3>
<p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API" /></p>

<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>

<p>那么，这些时间戳代表着什么？
* domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间
* domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间
* domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点
    * 许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间
* domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了
* loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</p>

<h3 id="section-2">里程碑</h3>
<p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：
* domIneractive：说明DOM构建完毕
* domContentLoaded：当DOM和CSSOM都完成后触发
    * 如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发
* domComplete：当页面及其所有资源全部完毕时触发</p>

<p>```html</p>
<html>
  <head>
    <title>Critical Path: Measure</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <script>
      function measureCRP() {
        var t = window.performance.timing,
          interactive = t.domInteractive - t.domLoading,
          dcl = t.domContentLoadedEventStart - t.domLoading,
          complete = t.domComplete - t.domLoading;
        var stats = document.createElement('p');
        stats.textContent = 'interactive: ' + interactive + 'ms, ' +
            'dcl: ' + dcl + 'ms, complete: ' + complete + 'ms';
        document.body.appendChild(stats);
      }
    </script>
  </head>
  <body onload="measureCRP()">
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
<p>```
上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果" /></p>

<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 通过JavaScript增加交互性 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/21/google-adding-interactivity-with-javaScript.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
  <li>JavaScript的执行会阻塞CSSOM的构建</li>
  <li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>

<h3 id="javascript">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script>
      var span = document.getElementsByTagName('span')[0];
      span.textContent = 'interactive'; // change DOM text content
      span.style.display = 'inline';  // change CSSOM property
      // create a new element, style it, and append it to the DOM
      var loadTime = document.createElement('div');
      loadTime.textContent = 'You loaded this page on: ' + new Date();
      loadTime.style.color = 'blue';
      document.body.appendChild(loadTime);
    </script>
  </body>
</html>
<p>```</p>

<ul>
  <li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
  <li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>

<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>

<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>

<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName('span')</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>

<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>

<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>

<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>

<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：
1. 脚本在文档中的位置很重要
2. 发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续
3. JavaScript能够查询和修改DOM和CSSOM
4. JavaScript只有在CSSOM被构建完毕之后才会执行</p>

<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>

<h3 id="javascript-1">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>

<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script External</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script src="app.js"></script>
  </body>
</html>
<p>```</p>

<p><code>javascript
var span = document.getElementsByTagName('span')[0];
span.textContent = 'interactive'; // 改变DOM中的文本
span.style.display = 'inline';  // 改变CSSOM属性
// 创建一个新元素，为其添加样式，并将其加入到DOM中
var loadTime = document.createElement('div');
loadTime.textContent = 'You loaded this page on: ' + new Date();
loadTime.style.color = 'blue';
document.body.appendChild(loadTime);
</code></p>

<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>

<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>

<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：
```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script Async</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script src="app.js" async=""></script>
  </body>
</html>
<p>```</p>

<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/21/google-adding-interactivity-with-javaScript.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 通过JavaScript增加交互性 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/21/google-adding-interactivity-with-javaScript.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 21 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
  <li>JavaScript的执行会阻塞CSSOM的构建</li>
  <li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>

<h3 id="javascript">JavaScript造成的阻塞</h3>
<p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script>
      var span = document.getElementsByTagName('span')[0];
      span.textContent = 'interactive'; // change DOM text content
      span.style.display = 'inline';  // change CSSOM property
      // create a new element, style it, and append it to the DOM
      var loadTime = document.createElement('div');
      loadTime.textContent = 'You loaded this page on: ' + new Date();
      loadTime.style.color = 'blue';
      document.body.appendChild(loadTime);
    </script>
  </body>
</html>
<p>```</p>

<ul>
  <li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
  <li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>

<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>

<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>

<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName('span')</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>

<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>

<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>

<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>

<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：
1. 脚本在文档中的位置很重要
2. 发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续
3. JavaScript能够查询和修改DOM和CSSOM
4. JavaScript只有在CSSOM被构建完毕之后才会执行</p>

<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>

<h3 id="javascript-1">解析器的阻塞和异步JavaScript</h3>
<p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>

<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script External</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script src="app.js"></script>
  </body>
</html>
<p>```</p>

<p><code>javascript
var span = document.getElementsByTagName('span')[0];
span.textContent = 'interactive'; // 改变DOM中的文本
span.style.display = 'inline';  // 改变CSSOM属性
// 创建一个新元素，为其添加样式，并将其加入到DOM中
var loadTime = document.createElement('div');
loadTime.textContent = 'You loaded this page on: ' + new Date();
loadTime.style.color = 'blue';
document.body.appendChild(loadTime);
</code></p>

<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>

<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>

<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：
```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path: Script Async</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
    <script src="app.js" async=""></script>
  </body>
</html>
<p>```</p>

<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/21/google-adding-interactivity-with-javaScript.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 渲染树的构建，布局和绘制 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/20/google-render-tree-construction-layout-and-paint.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 20 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>

<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>DOM树和CSSOM树结合组成了渲染树</li>
  <li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
  <li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
  <li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>

<h3 id="section-1">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树" /></p>

<p>为了构建渲染树，浏览器所做的工作大致如下：
1. 从DOM树的根节点开始，遍历每个可见的节点
    * 有些节点本身不可见（比如script、meta等等）
    * 有些节点被CSS隐藏了，这些节点也会被渲染树忽略
2. 对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息
3. 提交可见的节点和他们的内容和样式</p>

<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>

<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>

<h3 id="section-2">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>

<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Critial Path: Hello world!</title>
  </head>
  <body>
    <div style="width: 50%">
      <div style="width: 50%">Hello world!</div>
    </div>
  </body>
</html>
<p>```</p>

<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>

<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>

<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>

<h3 id="section-3">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段" /></p>

<ul>
  <li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
  <li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>

<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>

<p>这些都完成后，我们的页面终于展示在视口里了</p>

<h3 id="section-4">总结</h3>

<p>我们来重温一下所有的步骤：
1. 处理HTML标记，构建DOM树
2. 处理CSS标记，构建CSSOM树
3. 合并DOM树和CSSOM树，构建渲染树
4. 在渲染树上运行布局阶段，计算每个可见节点的几何图形
5. 绘制每个独立的节点到屏幕上</p>

<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>

<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/20/google-render-tree-construction-layout-and-paint.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 渲染树的构建，布局和绘制 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/20/google-render-tree-construction-layout-and-paint.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 20 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>CSSOM树和DOM树组合生成渲染树，渲染树将决定每一个可见元素的计算样式，并作为输入交给绘制线程，绘制线程将会把他们渲染成像素打到屏幕上。优化这些步骤将是提升渲染性能的关键所在。</p>

<p>上一章节介绍了如何构建对象模型。我们从HTML和CSS构建出了DOM树和CSSOM树。但是，他们描述的是文档的不同方面：DOM树描述的是页面内容，而CSSOM树则描述的是需要被使用到页面内容上的样式规则，由此可见，他们是相互独立的数据结构。那么我们应当如何去合并这两棵树来让浏览器渲染像素到屏幕呢？</p>

<h3 id="section">长话短说</h3>
<ul>
  <li>DOM树和CSSOM树结合组成了渲染树</li>
  <li>渲染树（Render tree）只会包含需要绘制到页面上的节点</li>
  <li>布局（Layout）会计算出每一个对象的具体位置和大小</li>
  <li>绘制（Paint）是最后异步，将会将渲染树渲染成像素，显示到屏幕上</li>
</ul>

<h3 id="section-1">构建渲染树</h3>
<p>浏览器首先需要结合DOM树和CSSOM树到渲染树，渲染树获取所有页面上可见的DOM内容，再吧CSSOM中的样式信息附着到每一个节点上</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/7.png" alt="组合DOM树和CSSOM树，生成渲染树" /></p>

<p>为了构建渲染树，浏览器所做的工作大致如下：
1. 从DOM树的根节点开始，遍历每个可见的节点
    * 有些节点本身不可见（比如script、meta等等）
    * 有些节点被CSS隐藏了，这些节点也会被渲染树忽略
2. 对于每一个可见节点，会从CSSOM中找并应用到其对应的样式信息
3. 提交可见的节点和他们的内容和样式</p>

<p><strong>需要注意的是，<code>visibility:hidden</code>和<code>display:none</code>是不同的。前者会将元素隐藏，但元素依旧在页面中占据空间（会被绘制成空的盒子），所以需要递交给布局阶段进行处理。而后者会从渲染树中移除元素及所有子元素，他们被递交给布局阶段</strong></p>

<p>这个阶段完毕后，会生成一个包含所有可见节点的内容和样式信息的渲染树。接下来可以进行布局阶段了</p>

<h3 id="section-2">布局阶段</h3>
<p>目前为止，我们已经获取了可见节点的计算样式，但我们还没有计算元素在设备视口中的最终的位置和尺寸——计算这些就是布局阶段的工作，它还有另外一个我们熟知的名称：回流（reflow）</p>

<p>为了计算每个节点的最终位置和尺寸，需要从根节点开始遍历渲染树，计算渲染树中每个对象在页面上的几何图形。比如如下例子：</p>

<p>```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Critial Path: Hello world!</title>
  </head>
  <body>
    <div style="width: 50%">
      <div style="width: 50%">Hello world!</div>
    </div>
  </body>
</html>
<p>```</p>

<p>上面的页面的body元素包含两个嵌套的div，第一个div（父元素）其节点的宽度为视口宽度的50%，第二个div在第一个div之中，宽度是第一个元素的50%，也就是视口宽的的50%。</p>

<p>布局阶段输出的是一个盒子模型，它精确地描述了元素在视口中的确切位置和尺寸：所有相对单位都会被转变为屏幕上的绝对像素值，等等</p>

<p>现在我们知道了哪些元素可见，他们的计算样式，以及他们的几何图形，我们终于能够将这些信息传递给最终阶段。这个阶段将渲染树中的每个节点绘制成屏幕上像素。通常这个阶段叫做绘制阶段（painting）或是光栅化（rasterizing）</p>

<h3 id="section-3">绘制阶段</h3>
<p>这里面每个步骤都需要浏览器惊醒一定量的工作，也就说会花费一定的时间。我们可以通过Chrome开发者工具看我们上面所说到的三个阶段。</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/8.png" alt="开发者工具中查看布局阶段" /></p>

<ul>
  <li>Timeline中的Layout事件包含渲染树的构建阶段和位置尺寸的计算阶段</li>
  <li>一旦布局阶段完成，浏览器会开启“Paint Setup”和“Paint”事件，用来将渲染树转变成屏幕上的像素</li>
</ul>

<p>上面所说的渲染树构建、布局阶段、绘制阶段所需要的事件会根据文档的大小、样式的多少、设备的配置有关。文档越大，浏览器需要做更多的工作。样式越复杂，浏览器需要考虑更多的绘制（绘制一个固定颜色代价很低，但绘制一个阴影代价很大）。</p>

<p>这些都完成后，我们的页面终于展示在视口里了</p>

<h3 id="section-4">总结</h3>

<p>我们来重温一下所有的步骤：
1. 处理HTML标记，构建DOM树
2. 处理CSS标记，构建CSSOM树
3. 合并DOM树和CSSOM树，构建渲染树
4. 在渲染树上运行布局阶段，计算每个可见节点的几何图形
5. 绘制每个独立的节点到屏幕上</p>

<p>考虑如果DOM或CSSOM发生改变时，会发生些什么？我们需要重复这些工作来确定如何回执到屏幕上</p>

<p>优化渲染的关键就是减少这5步所花费的时间。减少这5步所花费的事件能够让页面尽可能快的展示到页面上。在首次页面渲染之后，每次更新后的渲染效率也会提高。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/20/google-render-tree-construction-layout-and-paint.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 构建对象模型 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/20/google-constructing-the-object-model.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 20 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>浏览器渲染页面之前会构建DOM树和CSSOM树</p>

<h2 id="section">长话短说</h2>
<ul>
  <li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
  <li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
  <li>DOM和CSSOM是互相独立的数据结构</li>
  <li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>

<h2 id="dom">DOM树构建</h2>
<p>比如一段如下HTML
```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
<p>```</p>

<p>其从字节到DOM树的过程如下图所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程" /></p>

<p>具体的过程分为如下几步：
1. 转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符
2. 标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则
3. 对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则
4. DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构" /></p>

<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>

<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程" /></p>

<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>

<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>

<h2 id="cssom">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>

<p><code>css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
</code></p>

<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>

<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM" /></p>

<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM" /></p>

<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>

<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>

<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理" /></p>

<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/20/google-constructing-the-object-model.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 构建对象模型 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/20/google-constructing-the-object-model.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 20 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>浏览器渲染页面之前会构建DOM树和CSSOM树</p>

<h2 id="section">长话短说</h2>
<ul>
  <li>字节(bytes) → 字符(characters) → 标记(tokens) → 节点(nodes) → 对象模型(object model)</li>
  <li>HTML标记将会被转化为一个文档对象模型（Document Object<code>enter code here</code> Module，以下简称DOM），而CSS标记将会被转化成一个CSS对象模型（CSSOM）</li>
  <li>DOM和CSSOM是互相独立的数据结构</li>
  <li>Chrome的开发者工具的Timeline里面可以捕捉到DOM和CSSOM的构建和处理</li>
</ul>

<h2 id="dom">DOM树构建</h2>
<p>比如一段如下HTML
```html</p>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
<p>```</p>

<p>其从字节到DOM树的过程如下图所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/1.png" alt="从字节到DOM树的过程" /></p>

<p>具体的过程分为如下几步：
1. 转换（Conversion）：浏览器从网络或硬盘中读取原始的字节，并根据其编码方式转换为独立的字符
2. 标记化（Tokenizing）：浏览器根据W3C的html5标准解析出尖括号内的字符串，每一个标记有自己的意义和规则
3. 对象化（Lexing）：将标记转变为对象，对象内定义了他们的值和规则
4. DOM构建（DOM construction）：由于HTML标记定义了节点之间的关系，且这个关系是树型结构的（某个节点包含多个节点），所以通过一个树来保存</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/2.png" alt="DOM树的树状结构" /></p>

<p>整个过程输出的是一个DOM，它是网页的DOM树，后面的处理都会用到DOM树</p>

<p>每一次浏览器要讲HTML标记转换成DOM树，都需要经过这些过程：从字节转换到字符，获取其中的标记，转换标记到节点，通过节点构建DOM树，这些过程需要消耗一定的时间</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/3.png" alt="Chrome DevTools中的DOM树构建过程" /></p>

<p>如果打开Chrome开发者工具，并在页面加载时记录Timeline，你讲看到这些步骤的具体时间。在上例中，浏览器花费了约5ms将一个HTML碎片从字节转换到DOM树，当然，如果页面较大，这个时间会更长。在接下来的创建流畅动画的章节中，如果浏览器需要处理大量的HTML，这里很容易成为瓶颈。</p>

<p>DOM树构建好后，我们还需要将其渲染到屏幕上。DOM树中并没有告诉浏览器应该如何渲染这些节点，而完成这个职责的就是下面的CSSOM树了</p>

<h2 id="cssom">CSSOM树构建</h2>
<p>当浏览器为页面构建DOM树的时候，它会统计head部分的link标签，指向外部CSS样式文件。浏览器需要这些文件来渲染页面，它会直接发送请求来获取文件</p>

<p><code>css
body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
</code></p>

<p>当然我们也可以在HTML标记中声明CSS样式（内联样式），但保持CSS和HTML的独立使得我们能够将设计与内容分离：设计者基于CSS工作，而开发者则专注于HTML，等等</p>

<p>和HTML一样，我们将CSS样式转换到某种浏览器能够理解且使用的结构。其大致过程如下：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/4.png" alt="浏览器将CSS字节转换到CSSOM" /></p>

<p>浏览器将CSS字节转换成字符，然后构建标记和节点，最后练级到一个叫做CSS对象模型（CSSOM）的树型数据结构</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/5.png" alt="树状CSSOM" /></p>

<p>HTML是树状结构很好理解，那么为什么CSSOM也是树状结构呢？在计算页面上对象的需要使用的样式集时，浏览器首先将最常规的样式赋给节点（如果是body元素的孩子，那么会使用body的所有样式），然后递归细化，逐步添加上特殊的规则，这也就是级联样式表中“级联”的意思</p>

<p>上面的树并不是完整的CSSOM树，目前只是展示了样式表中的样式如何互相覆盖。么一个浏览器都提供了一套自己的样式，也就是“用户代理样式（user agent styles）”，在我们不提供任何样式的时候，就会使用这些央视。如果在Chrome开发者工具里面查看“计算后样式（computed styles）”，可以看到所有节点中样式的来源</p>

<p>如果想知道CSS处理花费多长时间，可以在开发者工具中记录Timeline，并查看“Resalcuate”事件：与DOM解析不同的是，这里不会分开的“Parse CSS”各个阶段，解析、CSSOM树构建以及样式的递归计算都放在这一个事件之中</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-20/6.png" alt="通过开发者工具查看样式处理" /></p>

<p>这里可以看到，这次样式处理花费了约0.6ms，涉及页面上的8个元素。那这8个元素从哪儿来？CSSOM和DOM是完全独立的数据结构，浏览器隐藏了很重要的一步，通过渲染树（render tree）将CSSOM和DOM连接起来，下一章就将介绍这个渲染树</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/20/google-constructing-the-object-model.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 响应式Web设计基础 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/19/google-responsive-design-fundamentals.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 19 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/">Responsive Web Design Fundamentals</a></p>

<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>

<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>

<h2 id="section">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>

<h3 id="section-1">长话短说</h3>
<ol>
  <li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
  <li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
  <li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
  <li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>

<h3 id="section-2">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>

<p><code>html
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
</code>
我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>

<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>

<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>

<h3 id="section-3">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>

<h2 id="section-4">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>

<h3 id="section-5">长话短说</h3>
<ol>
  <li>不要为元素设定大且固定的尺寸</li>
  <li>内容的展现不应该依赖于一个特定的视口宽度</li>
  <li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>

<h3 id="section-6">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>

<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>

<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>

<h2 id="css">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>

<h3 id="section-7">长话短说</h3>
<ol>
  <li>媒体查询可以根据设备特点来应用样式</li>
  <li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
  <li>为元素使用相对大小防止破坏布局</li>
</ol>

<h3 id="section-8">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：
<code>html
&lt;link rel="stylesheet" href="print.css" media="print"&gt;
</code></p>

<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>

<p>```css
@media print {
  /* print style sheets go here */
}</p>

<p>@import url(print.css) print;
```</p>

<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>

<h3 id="section-9">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：
<code>css
@media (query) {
  /* CSS Rules used when query matches */
}
</code></p>

<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>

<ul>
  <li>min-width: 匹配所有宽度大于设定值的浏览器</li>
  <li>max-width: 匹配所有宽度小于设定值的浏览器</li>
  <li>min-height: 匹配所有高度大于设定值的浏览器</li>
  <li>max-height: 匹配所有高度小于设定值的浏览器</li>
  <li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li>
  <li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li>
</ul>

<h3 id="min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>

<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>

<h3 id="section-10">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>

<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>

<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>

<h2 id="section-11">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>

<h3 id="section-12">长话短说</h3>
<ol>
  <li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
  <li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
  <li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>

<h3 id="section-13">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>

<h3 id="section-14">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>

<h3 id="section-15">优化文本阅读</h3>
<p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>

<h3 id="section-16">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/19/google-responsive-design-fundamentals.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 响应式Web设计基础 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/19/google-responsive-design-fundamentals.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 19 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>本文所有内容来自<a href="https://developers.google.com/web/fundamentals/documentation/multi-device-layouts/rwd-fundamentals/">Responsive Web Design Fundamentals</a></p>

<p>手机、大屏手机、平板电脑、桌面电脑、游戏控制台、电视、甚至是可穿戴设备，如此多的设备也形成了多种多样的屏幕尺寸。屏幕的大小总在变，我们需要我们的网页今后能够适应任何屏幕尺寸</p>

<p>响应式Web设计，最初的定义（<a href="http://alistapart.com/article/responsive-web-design/">Ethan Marcotte in A List Apart</a>）是让网页响应用户及其所用设备的需求。在响应式设计中，布局将会随着设备的屏幕尺寸和显示能力而改变。比如，在手机上，用户只看到包含内容的单列视图，而在平板电脑中则能看到两列</p>

<h2 id="section">设置视口信息</h2>
<p>网页若需要适配不同的设备，在其文档的head元素中，需要包含一个meta元素，这个meta元素视口控制信息。这个meta元素告诉浏览器如何控制页面的尺寸缩放</p>

<h3 id="section-1">长话短说</h3>
<ol>
  <li>使用meta元素，里面包含视口控制信息去控制浏览器视口的宽度和缩放</li>
  <li>写入<code>width=device-width</code>去使用设备的像素去匹配屏幕的宽度</li>
  <li>写入<code>initial-scale=1</code>去建立CSS像素与设备像素的1:1对等关系</li>
  <li>保证你的页面在用户缩放的时候依旧可用</li>
</ol>

<h3 id="section-2">最佳实践</h3>
<p>为了提供最佳的用户体验，手机浏览器一般以980px（这个值会可能在不同设备中略有不同）的宽度渲染页面，然后会尝试去减少文字大小以及缩放内容到屏幕大小来让内容看起来更加适于阅读。对于用户来说，这也意味着字体的大小可能会不一致，用户需要通过双击或手势缩放来放大网页，这样才能看到内容并与之交互</p>

<p><code>html
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
</code>
我们可以使用meta标签来指定viewport信息，这里<code>width=device-width</code>表明页面将会以设备的像素大小来适配屏幕宽度。这样无论是在小屏幕手机上还是大屏幕显示器上，页面都可以为不同的屏幕尺寸进行内容的回流</p>

<p>有一些浏览器会在横竖屏切换时保持页面宽度不变，他们仅仅会进行缩放，而不会让内容回流来适应屏幕。增加属性<code>initial-scale=1</code>告诉浏览器去建立CSS像素和设备像素的1:1对等关系，而无视设备的方向，这样网页就能适应横竖屏的宽度变化了</p>

<p><strong>使用一个逗号去区分属性保持老式浏览器也能获取到值</strong></p>

<h3 id="section-3">确定一个可访问的视口</h3>
<p>除了使用<code>initial-scale</code>，也可以在视口控制信息中加入<code>minimum-scale</code>,<code>maximum-scale</code>和<code>user-scalable</code>等属性。这些值将限制用户缩放视口的比例，可能会降低网页的可访问性</p>

<h2 id="section-4">使得内容适配视口</h2>
<p>无论是手机还是桌面电脑，用户通常是垂直滚动页。也就是说，强迫用户水平滚动页面或者必须缩放才能看到整个页面，都会降低用户体验</p>

<h3 id="section-5">长话短说</h3>
<ol>
  <li>不要为元素设定大且固定的尺寸</li>
  <li>内容的展现不应该依赖于一个特定的视口宽度</li>
  <li>使用CSS的媒体查询来为不同的屏幕尺寸提供不同的样式</li>
</ol>

<h3 id="section-6">最佳实践</h3>
<p>在开发手机网页中使用<code>meta viewport</code>元素进行开发时，很容易导致页面内容无法匹配某些特定的视口。比如，一张图片能够在较宽呃视口中完全显示，但在较窄的视口中则必须要水平滚动才能看到右边的部分。我们需要调整页面内容来适应视口的宽度，这样它们就不需要水平滚动了</p>

<p>由于不同设备基于CSS像素的尺寸和宽度不同（手机和平板之间不同，甚至不同的手机之间也不同），所以页面内容不能只依赖于一个特定的视口宽度。</p>

<p>如果元素设定了较大的绝对宽度，元素在窄设备中将由于太宽而只能显示一部分。取而代之，考虑使用相对宽度（如<code>width: 100%</code>）</p>

<h2 id="css">为响应式使用CSS的媒体查询</h2>
<p>媒体查询其实能在CSS样式中使用的过滤器，他们能够很轻易的根据设备的特点来改变渲染网页内容的CSS样式，这些特点包括设备的显示类型，宽高，横竖屏甚至是分辨率</p>

<h3 id="section-7">长话短说</h3>
<ol>
  <li>媒体查询可以根据设备特点来应用样式</li>
  <li>使用<code>min-width</code>而不是<code>min-device-width</code>来保证更多情况下能有好的体验</li>
  <li>为元素使用相对大小防止破坏布局</li>
</ol>

<h3 id="section-8">最佳实践</h3>
<p>比如，我们可以通过这样的方式加入打印时需要的样式：
<code>html
&lt;link rel="stylesheet" href="print.css" media="print"&gt;
</code></p>

<p>除了在样式的link元素中增加<code>media</code>属性，还有两种其他方法在CSS文件在中使用媒体查询：<code>@media</code>和<code>@import</code>。处于效率考虑，推荐使用前两种方式</p>

<p>```css
@media print {
  /* print style sheets go here */
}</p>

<p>@import url(print.css) print;
```</p>

<p>媒体查询中的逻辑不会互相冲突，并且符合媒体查询条件而引入的CSS样式也会根据CSS优先级标准作用与页面中</p>

<h3 id="section-9">根据视口大小使用媒体查询</h3>
<p>媒体查询为创建响应式的体验成为可能，通过媒体查询，我们能为小屏幕，大屏幕，或者两者之间来提供特定的样式表。媒体查询的语法允许我们根据设备的特点来创建匹配规则：
<code>css
@media (query) {
  /* CSS Rules used when query matches */
}
</code></p>

<p>媒体查询提供了很多查询条件供我们使用，其中我们在响应式web设计中用的最多是<code>min-width</code>、<code>max-width</code>、<code>min-height</code>、<code>max-height</code></p>

<ul>
  <li>min-width: 匹配所有宽度大于设定值的浏览器</li>
  <li>max-width: 匹配所有宽度小于设定值的浏览器</li>
  <li>min-height: 匹配所有高度大于设定值的浏览器</li>
  <li>max-height: 匹配所有高度小于设定值的浏览器</li>
  <li>orientation=portrait: 匹配竖屏，也就是高度大于或等于宽度</li>
  <li>orientation=landscape: 匹配横屏，也就是宽度大于或等于高度</li>
</ul>

<h3 id="min-device-width">关于min-device-width</h3>
<p>除了<code>*-width</code>，我们也可以在媒体查询中使用<code>*-device-width</code>，这两者有微妙且重要的差异。<code>min-width</code>检测的是浏览器的窗口的尺寸，而<code>min-device-width</code>检测的则是屏幕的尺寸</p>

<p>在手机上，这个差异一般不会有什么影响，毕竟用户不能自由调整窗口的尺寸。但在桌面上，用户能够自由控制窗口尺寸并希望网页内容能够很自然的适应窗口，所以，应当尽量避免使用<code>*-device-width</code>，否则网页将无法响应桌面浏览器窗口的缩放</p>

<h3 id="section-10">使用相对单位</h3>
<p>响应式设计的一个关键概念就是流动性和比例性，而不是使用固定宽度进行布局。计量时使用相对单位能够简化布局，并防止出现创建的组件对于视口过大的情况。</p>

<p>比如，将顶层宽度设为100%，使其宽度撑开到整个视口大小，它的宽度永远不会大于或小于视口大小。这个div无论在iPhone的320px、黑莓Z10的342px还是Nexus 5的360px下，都能横向填满屏幕</p>

<p>另外使用相对单位允许浏览器在用户缩放网页时重新渲染整个页面，而不会增加一个水平滚动条。</p>

<h2 id="section-11">如何选择断点</h2>
<p>尽管哦我们可以考虑基于设备类型来定义断点，但需要谨慎使用这种方式。基于特定的的设备、产品、品牌名称或操作系统定义断点，就算今天能正常使用，以后也会出现维护上的噩梦。取而代之的是，网页内容应该根据其自身来决定如何在容器中进行布局。</p>

<h3 id="section-12">长话短说</h3>
<ol>
  <li>基于网页内容创建断点，永远不要基于特定的设备、产品或品牌</li>
  <li>以移动先行的思想设计网页，然后随着屏幕可用大小增加而渐进增强用户体验</li>
  <li>保持每一行文字的最大宽度在70到80个字符左右</li>
</ol>

<h3 id="section-13">从小到大来挑选主要断点</h3>
<p>首先，在较小的屏幕尺寸上设计网页，然后主键扩大屏幕大小直到必须要增加断点。这样断点的选取是基于网页内容，并且断点会尽可能的少。</p>

<h3 id="section-14">必要时添加次要断点</h3>
<p>除了显著影响布局的主要断点外，用于小范围调整的次要断点也非常有用。比如在主要断点中间，增加一些次要断点来调整元素的margin或padding，或者增加文本大小让他们在布局中显得更加自然</p>

<h3 id="section-15">优化文本阅读</h3>
<p>传统的可读性理论建议一个理想的列每一行应该包含70到80个字符(8~10个英文单词)，也就是说，每当一行单词数量增加到10个时，我们就应该就应该加一个断点了</p>

<h3 id="section-16">不要完全隐藏内容</h3>
<p>当需要根据屏幕大小选择行的显示内容时，需要注意。不要简单的由于其无法适应屏幕就将其隐藏。屏幕的大小并不能说明用户想要什么。比如，在天气预报中移除了花粉浓度对于一个不外出或没有花粉过敏症呃人来说可能没什么，但对于患有花粉过敏症的人来说就很致命了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/19/google-responsive-design-fundamentals.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的异步控制 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/17/read-jq-src-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 17 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>

<h2 id="jquerycallbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态
###配置选项
创建一个回调函数列表可能会用到如下参数：
1. options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置
2. once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次
3. memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果
4. unique：决定了回调函数列表中的函数能否重复
5. stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</p>

<p>接下来看看构造函数：</p>

<p><code>javascript
options = typeof options === "string" ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</code></p>

<p>options可以是字符串，如<code>"once memory"</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>

<h3 id="section-1">私有变量</h3>
<p><code>javascript
var // Last fire value (for non-forgettable lists)
    /*用于存放运行结果*/
    memory,
    /*标志所有回调函数列表是否被触发过*/
    fired,
    /*标志当前正在执行回调函数列表中的函数*/
    firing,
    /*第一个被执行的回调函数*/
    firingStart,
    /*回调函数列表的长度*/
    firingLength,
    /*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/
    firingIndex,
    /*保存回调函数的列表*/
    list = [],
    /*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/
    stack = !options.once &amp;&amp; [],
</code></p>

<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>

<h3 id="fire">触发函数fire</h3>
<p>```javascript
fire = function( data ) {
    /<em>如果使用了memory配置，data会先被保存在memory中</em>/
    memory = options.memory &amp;&amp; data;
    /<em>表明这个回调函数列表已经被触发过了</em>/
    fired = true;
    /<em>确定当前执行的回调函数在回调函数列表中的位置</em>/
    firingIndex = firingStart || 0;
    /<em>将起始设为0</em>/
    firingStart = 0;
    /<em>获取回调函数列表的总长度</em>/
    firingLength = list.length;
    /<em>修改状态为正在执行</em>/
    firing = true;
    /<em>依次执行回调函数</em>/
    for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
        /<em>如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空</em>/
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
            memory = false; // To prevent further calls using add
            break;
        }
    }
    /<em>修改正在执行状态为false</em>/
    firing = false;</p>

<pre><code>/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/
if ( list ) {
    /*多次执行的话，stack是个数组*/
    if ( stack ) {
        /*从等待队列中弹出数据再次执行*/
        if ( stack.length ) {
            fire( stack.shift() );
        }
    /*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/
    } else if ( memory ) {
        list = [];
    /*否则说明函数没有正常执行完成，将回调函数列表设为无效*/
    } else {
        self.disable();
    }
} }, ``` 这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用
</code></pre>

<h3 id="section-2">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>

<h4 id="add">add</h4>
<p><code>javascript
add: function() {
    if ( list ) {
        //首先保存当前列表长度
        var start = list.length;
        /*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */
        (function add( args ) {
            jQuery.each( args, function( _, arg ) {
                var type = jQuery.type( arg );
                if ( type === "function" ) {
                    if ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== "string" ) {
                    // Inspect recursively
                    add( arg );
                }
            });
        })( arguments );
        /*如果正在执行回调函数列表，那么需要维护一下长度*/
        if ( firing ) {
            firingLength = list.length;
        /*如果memory中已经有值，执行所有新增加的回调函数*/
        } else if ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    /*返回this方便链式操作*/
    return this;
},
</code>
这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>

<h4 id="remove">remove</h4>
<p><code>javascript
remove: function() {
    if ( list ) {
        /*遍历arguments，对每个函数分执行删除操作*/
        jQuery.each( arguments, function( _, arg ) {
            var index;
            /*通过jQuery.inArray获取函数在回调函数列表中的位置*/
            while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
                /*删除掉这个函数*/
                list.splice( index, 1 );
                /*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/
                if ( firing ) {
                    if ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    if ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    /*返回this方便链式操作*/
    return this;
},
</code>
这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>

<h4 id="has-fn">has (fn)</h4>
<p><code>javascript
has: function( fn ) {
    return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );
},
</code>
判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：
1. 若有fn，直接用inArray判定
2. 若无fn，直接判断列表是否有长度不为0的list列表</p>

<h4 id="empty">empty</h4>
<p><code>javascript
empty: function() {
    list = [];
    firingLength = 0;
    return this;
},
</code>
清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>

<h4 id="disabledisabled">disable和disabled</h4>
<p><code>javascript
disabled: function() {
    list = stack = memory = undefined;
    return this;
},
disabled: function() {
    return !list;
},
</code>
将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>

<h4 id="locklocked">lock和locked</h4>
<p><code>javascript
lock: function() {
    stack = undefined;
    if ( !memory ) {
        self.disable();
    }
    return this;
},
locked: function() {
    return !stack;
},
</code>
lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>

<h4 id="firewithfire">fireWith和fire</h4>
<p><code>javascript
fireWith: function( context, args ) {
    /*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/
    if ( list &amp;&amp; ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        /*如果正在出发，就放到等待队列中*/
        /*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/
        if ( firing ) {
            stack.push( args );
        /*否则直接触发*/
        } else {
            fire( args );
        }
    }
    return this;
},
fire: function() {
    self.fireWith( this, arguments );
    return this;
},
fired: function() {
    return !!fired;
}
</code>
这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>

<p>fired没啥好说的，判断回调函数列表是否被触发过</p>

<h3 id="section-3">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>

<h2 id="deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>

<h3 id="section-4">构造函数</h3>
<p>####三个状态，三个操作，三个列表
Deferred有三个状态：
1. pending
2. resolved
3. rejected</p>

<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>

<p>事实上，每个操作对应着一系列的回调函数，看一下定义：
<code>javascript
var tuples = [
    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
    [ "notify", "progress", jQuery.Callbacks("memory") ]
],
</code>
可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：
1. resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved
2. reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected
3. notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</p>

<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：
```javascript
/<em>针对三个操作分别进行加工</em>/
jQuery.each( tuples, function( i, tuple ) {
    /<em>获取操作的回调函数列表</em>/
    var list = tuple[ 2 ],
        /<em>获取操作执行后的状态</em>/
        stateString = tuple[ 3 ];</p>

<pre><code>// promise[ done | fail | progress ] = list.add
/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/
promise[ tuple[1] ] = list.add;

// Handle state
/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/
if ( stateString ) {
    list.add(function() {
        // state = [ resolved | rejected ]
        state = stateString;

    // [ reject_list | resolve_list ].disable; progress_list.lock
    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
}

// deferred[ resolve | reject | notify ]
/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/
deferred[ tuple[0] ] = function() {
    deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
    return this;
};
/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/
deferred[ tuple[0] + "With" ] = list.fireWith; }); ``` 上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法： 1. resolve 2. reject 3. notify 4. resolveWith 5. rejectWith 6. notifyWith
</code></pre>

<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>

<p>同时，这里还会为promise增加三个方法：
1. done
2. fail
3. progress</p>

<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>

<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>

<h3 id="promise">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>

<p><code>javascript
promise = {
    /*获得当前状态的方法*/
    state: function() {
        return state;
    },
    /*无论执行成功与否，都执行参数中的回调*/
    always: function() {
        deferred.done( arguments ).fail( arguments );
        return this;
    },
    /*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/
    then: function( /* fnDone, fnFail, fnProgress */ ) {
        /*then的代码*/
    },
    // Get a promise for this deferred
    // If obj is provided, the promise aspect is added to the object
    /*获取promise对象*/
    promise: function( obj ) {
        return obj != null ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
/*pipe方法，实际上就是then，为了符合标准罢了*/
promise.pipe = promise.then;
/*这里为Promise添加了done、fail、progress方法*/
/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/
jQuery.each( tuples, function( i, tuple ) {
    /*上面的代码*/
});
/*将Promise对象的所有方法拷贝给Deferred对象*/
promise.promise( deferred );
</code></p>

<p>这里可以看到，promise对象提供了几个接口：
1. state：获取当前Deferred对象的状态
2. always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行
3. then：使用done、fail、progress分别绑定函数，代码较多，后面再讲
4. promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象
5. pipe：就是then，别名而已
6. done，fail，progress：上面介绍过，不赘述了</p>

<h4 id="promisedeferred">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>

<h4 id="thenpipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：
<code>javascript
then: function( /* fnDone, fnFail, fnProgress */ ) {
    var fns = arguments;
    /*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */
    return jQuery.Deferred(function( newDefer ) {
        /*对于上面三种，分别将函数加入到对应的回调函数列表中*/
        jQuery.each( tuples, function( i, tuple ) {
            var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];
            /*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/
            deferred[ tuple[1] ](function() {
                var returned = fn &amp;&amp; fn.apply( this, arguments );
                /*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/
                if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                /*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/
                } else {
                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                }
            });
        });
        fns = null;
    }).promise();
},
</code>
这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>

<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>

<h3 id="section-5">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>

<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>

<p>```javascript
when: function( subordinate /* , …, subordinateN <em>/ ) {
    var i = 0,
        /</em>切分参数到数组<em>/
        resolveValues = slice.call( arguments ),
        /</em>数组长度*/
        length = resolveValues.length,</p>

<pre><code>    /* 未完成的需要监听的Deferred对象的个数 */
    remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,
    /*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

    /*
    使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

    如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
    */
    updateFunc = function( i, contexts, values ) {
        return function( value ) {
            contexts[ i ] = this;
            values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
            if ( values === progressValues ) {
                deferred.notifyWith( contexts, values );
            } else if ( !( --remaining ) ) {
                deferred.resolveWith( contexts, values );
            }
        };
    },

    progressValues, progressContexts, resolveContexts;

/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/
if ( length &gt; 1 ) {
    progressValues = new Array( length );
    progressContexts = new Array( length );
    resolveContexts = new Array( length );
    for ( ; i &lt; length; i++ ) {
        /*这里只处理Deferred/Promise，其他不考虑*/
        if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
            resolveValues[ i ].promise()
                .done( updateFunc( i, resolveContexts, resolveValues ) )
                .fail( deferred.reject )
                .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
            --remaining;
        }
    }
}

/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/
if ( !remaining ) {
    deferred.resolveWith( resolveContexts, resolveValues );
}
/*将这个管理Deferred对象返回*/
return deferred.promise(); } ```
</code></pre>

<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>

<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>

<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>

<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>

<h2 id="section-6">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/17/read-jq-src-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的异步控制 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/17/read-jq-src-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 17 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">简介</h2>
<p>jQuery中使用Deferred进行异步控制，其亦提供promise方法获取Promise对象，但实现上和其他的Promise的实现并不相同。Deferred/Promise对象的核心实现为三个回调函数队列，分别保存正确（done）、错误（fail）、进行中（progress）三个回调函数列表，它们都是<code>jQuery.Callbacks</code>实例</p>

<h2 id="jquerycallbacks">jQuery.Callbacks</h2>
<p>这是回调函数列表的构造器，内部使用一个数组来保存回调函数列表，并提供一系列的方法来维护这个列表。另外这个列表还有一些状态
###配置选项
创建一个回调函数列表可能会用到如下参数：
1. options：一个选项类表，确定了回调函数列表如何工作，以及一些常见配置
2. once：默认情况下回调函数列表的执行时没有次数限制的，但如果设置了once，将设置回调函数列表只会被执行一次
3. memory：决定了在回调函数列表在执行过程中，是否会保留上一个函数执行的结果
4. unique：决定了回调函数列表中的函数能否重复
5. stopOnFalse：决定了在一个回调函数返回false后，后面的回调函数将不会被执行</p>

<p>接下来看看构造函数：</p>

<p><code>javascript
options = typeof options === "string" ?
    ( optionsCache[ options ] || createOptions( options ) ) :
    jQuery.extend( {}, options );
</code></p>

<p>options可以是字符串，如<code>"once memory"</code>，如果是字符串，就先进行解析并缓存。如果options是对象，那么直接options就是这个对象</p>

<h3 id="section-1">私有变量</h3>
<p><code>javascript
var // Last fire value (for non-forgettable lists)
    /*用于存放运行结果*/
    memory,
    /*标志所有回调函数列表是否被触发过*/
    fired,
    /*标志当前正在执行回调函数列表中的函数*/
    firing,
    /*第一个被执行的回调函数*/
    firingStart,
    /*回调函数列表的长度*/
    firingLength,
    /*当前执行的回调函数在回调函数列表中的下标，如果移除了回调函数，将会对其进行修改*/
    firingIndex,
    /*保存回调函数的列表*/
    list = [],
    /*如果回调函数列表时多次执行的，那么在运行回调函数列表的过程中，可能会再次触发，这时候就需要一个队列进行等待了*/
    stack = !options.once &amp;&amp; [],
</code></p>

<p>这里面都是一些私有变量，没啥太多好说的，官方代码里也对每个变量都写了注释</p>

<h3 id="fire">触发函数fire</h3>
<p>```javascript
fire = function( data ) {
    /<em>如果使用了memory配置，data会先被保存在memory中</em>/
    memory = options.memory &amp;&amp; data;
    /<em>表明这个回调函数列表已经被触发过了</em>/
    fired = true;
    /<em>确定当前执行的回调函数在回调函数列表中的位置</em>/
    firingIndex = firingStart || 0;
    /<em>将起始设为0</em>/
    firingStart = 0;
    /<em>获取回调函数列表的总长度</em>/
    firingLength = list.length;
    /<em>修改状态为正在执行</em>/
    firing = true;
    /<em>依次执行回调函数</em>/
    for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
        /<em>如果回调函数返回值是false且设定了stopOnFalse，那么执行结束，memory清空</em>/
        if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
            memory = false; // To prevent further calls using add
            break;
        }
    }
    /<em>修改正在执行状态为false</em>/
    firing = false;</p>

<pre><code>/*如果等待队列中有数据，那么需要获取等待队列中的数据，再次执行回调函数列表*/
if ( list ) {
    /*多次执行的话，stack是个数组*/
    if ( stack ) {
        /*从等待队列中弹出数据再次执行*/
        if ( stack.length ) {
            fire( stack.shift() );
        }
    /*如果是单次执行，且所有函数正常执行完成，缓存了最终结果，清空回调函数列表*/
    } else if ( memory ) {
        list = [];
    /*否则说明函数没有正常执行完成，将回调函数列表设为无效*/
    } else {
        self.disable();
    }
} }, ``` 这里可以看到触发回调函数列表的逻辑。触发后，会依次执行列表中的回调函数，这里执行时有一个stopOnFalse设置，如果函数返回false，那么就终止执行。另外在执行过程中，如果又有新的执行请求到来，需要将执行请求放入等待队列之中，等待当前执行中的所有回调函数完成之后再重新执行。当然这个设定对once类型的回调函数列表不起作用
</code></pre>

<h3 id="section-2">实例</h3>
<p>接下来创建了一个self对象，并进行了返回，这是个一个构造函数，说明self是真正返回的实例。看看实例中有哪些方法：</p>

<h4 id="add">add</h4>
<p><code>javascript
add: function() {
    if ( list ) {
        //首先保存当前列表长度
        var start = list.length;
        /*使用jQuery.each方法遍历深度遍历arguments：
        1. 如果键值对中值为函数，那么直接添加，需要注意的是如果有unique选项，在添加前需要判重
        2. 如果值为对象那么遍历这个对象进行添加 */
        (function add( args ) {
            jQuery.each( args, function( _, arg ) {
                var type = jQuery.type( arg );
                if ( type === "function" ) {
                    if ( !options.unique || !self.has( arg ) ) {
                    list.push( arg );
                    }
                } else if ( arg &amp;&amp; arg.length &amp;&amp; type !== "string" ) {
                    // Inspect recursively
                    add( arg );
                }
            });
        })( arguments );
        /*如果正在执行回调函数列表，那么需要维护一下长度*/
        if ( firing ) {
            firingLength = list.length;
        /*如果memory中已经有值，执行所有新增加的回调函数*/
        } else if ( memory ) {
            firingStart = start;
            fire( memory );
        }
    }
    /*返回this方便链式操作*/
    return this;
},
</code>
这个方法往回调函数列表中添加新函数，jQuery会非常智能的使用each对参数进行深度遍历来添加所有函数。需要注意的是，如果回调函数列表正在执行，添加之后需要维护长度。另外如果memory中有数据，我们就应该立即执行新添加的回调函数</p>

<h4 id="remove">remove</h4>
<p><code>javascript
remove: function() {
    if ( list ) {
        /*遍历arguments，对每个函数分执行删除操作*/
        jQuery.each( arguments, function( _, arg ) {
            var index;
            /*通过jQuery.inArray获取函数在回调函数列表中的位置*/
            while ( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
                /*删除掉这个函数*/
                list.splice( index, 1 );
                /*如果正在执行回调函数，需要维护长度和当前正在执行的回调函数的下标*/
                if ( firing ) {
                    if ( index &lt;= firingLength ) {
                        firingLength--;
                    }
                    if ( index &lt;= firingIndex ) {
                        firingIndex--;
                    }
                }
            }
        });
    }
    /*返回this方便链式操作*/
    return this;
},
</code>
这里同样使用<code>jQuery.each</code>遍历所有参数，获取其中的函数，通过inArray判定，然后通过splice移除。这里需要注意的是，在回调函数列表正在执行时，删除操作同样需要维护长度，另外还可能需要维护当前正在运行的函数的下标</p>

<h4 id="has-fn">has (fn)</h4>
<p><code>javascript
has: function( fn ) {
    return fn ? jQuery.inArray( fn, list ) &gt; -1 : !!( list &amp;&amp; list.length );
},
</code>
判断一个函数是否在回调函数列表中，分判断函数和判断列表两种情况：
1. 若有fn，直接用inArray判定
2. 若无fn，直接判断列表是否有长度不为0的list列表</p>

<h4 id="empty">empty</h4>
<p><code>javascript
empty: function() {
    list = [];
    firingLength = 0;
    return this;
},
</code>
清空回调函数列表，没啥好说的…list社为空数组，长度设为0</p>

<h4 id="disabledisabled">disable和disabled</h4>
<p><code>javascript
disabled: function() {
    list = stack = memory = undefined;
    return this;
},
disabled: function() {
    return !list;
},
</code>
将回调函数列表设定为无效，实际上就是将list，stack，memory设成undefined，检测无效也很简单，直接通过list判断，没设定无效情况下，list都是数组，其必然是真值</p>

<h4 id="locklocked">lock和locked</h4>
<p><code>javascript
lock: function() {
    stack = undefined;
    if ( !memory ) {
        self.disable();
    }
    return this;
},
locked: function() {
    return !stack;
},
</code>
lock和locked故名思意就是将回调函数列表锁住，其判定方式是stack是否存在，在once设置下，stack本来就不存在，直接就是locked。而非once情况下，lock函数会设定stack为undefined，这样就无法在回调函数运行时进行fire了，就算锁住了。另外，如果没有memory，说明回调函数执行失败了，直接disbale掉就好</p>

<h4 id="firewithfire">fireWith和fire</h4>
<p><code>javascript
fireWith: function( context, args ) {
    /*如果回调函数列表还有效，没触发过或者可以多次触发，那么就满足触发条件了*/
    if ( list &amp;&amp; ( !fired || stack ) ) {
        args = args || [];
        args = [ context, args.slice ? args.slice() : args ];
        /*如果正在出发，就放到等待队列中*/
        /*如果once且触发过或正在触发，可以从私有方法fire中看到，fired是在方法一开始被设置的，所以无法通过上面的fired条件，能到这里必然是没有触发或多次触发的情况。而没有触发不存在firing状态，也就不需要检测stack了*/
        if ( firing ) {
            stack.push( args );
        /*否则直接触发*/
        } else {
            fire( args );
        }
    }
    return this;
},
fire: function() {
    self.fireWith( this, arguments );
    return this;
},
fired: function() {
    return !!fired;
}
</code>
这里fire实际上使用fireWith实现的，我们只需要看fireWith就好。这里fireWith将触发回调函数列表的执行，触发条件是：当前回调函数列表有效，且没触发过或可以多次触发（stack存在就是可以多次触发），需要注意的是，如果正在触发，也就是firing状态时，触发请求将会被放入stack中等待</p>

<p>fired没啥好说的，判断回调函数列表是否被触发过</p>

<h3 id="section-3">小结</h3>
<p>这个<code>jQuery.Callbacks</code>本质上就是维护一个数组，这个数组中都是函数。一个特点就是可以通过fire方式去挨个执行这些函数，并提供了一些配置来确定执行的过程以及执行的次数。每个Deferred对象将拥有三个Callbacks实例</p>

<h2 id="deferred">Deferred</h2>
<p>jQuery的异步控制使用Deferred/Promise，每一个Deferred对象对应一个Promise对象，首先来看看其构造函数</p>

<h3 id="section-4">构造函数</h3>
<p>####三个状态，三个操作，三个列表
Deferred有三个状态：
1. pending
2. resolved
3. rejected</p>

<p>pending状态是最初状态，它等待resolve操作或reject操作，使用resolve操作表示成功，将跳转到resolved状态，而使用reject将跳转到rejected状态，这两个转变是不可逆的。另外在pending状态下可以无限次调用notify操作</p>

<p>事实上，每个操作对应着一系列的回调函数，看一下定义：
<code>javascript
var tuples = [
    [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
    [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
    [ "notify", "progress", jQuery.Callbacks("memory") ]
],
</code>
可以看到，这里为resolve、reject、notify这三个操作分别创建了Callbakcs的实例。这里为三个操作的具体定义如下：
1. resolve方法，对应的添加回调函数的方法是done，回调函数列表类型是once和memory，运行后状态转变到resolved
2. reject方法，对应的添加回调函数的方法是fail，回调函数列表类型是once和memory，运行后状态转变到rejected
3. notify方法，对应的添加回调函数的方法为progress，回调函数列表类型是memory，说明可执行多次，执行后不会转变状态</p>

<p>构造函数下面，会为每一个操作在Promise对象和Deferred对象上生成对应的函数（Promise上是：done、fail、progress。Deferred上是：resolve、reject、notify）：
```javascript
/<em>针对三个操作分别进行加工</em>/
jQuery.each( tuples, function( i, tuple ) {
    /<em>获取操作的回调函数列表</em>/
    var list = tuple[ 2 ],
        /<em>获取操作执行后的状态</em>/
        stateString = tuple[ 3 ];</p>

<pre><code>// promise[ done | fail | progress ] = list.add
/*为promise对象分别生成done、fail、progress方法，直接映射到对应的回调函数列表对象的add添加方法*/
promise[ tuple[1] ] = list.add;

// Handle state
/* 如果状态会改变，说明是resolve方法或reject方法，由于状态转变不可逆，所以需要在回调函数列表最后添加三个函数，分别用于状态修改、使回调函数列表无效、将回调函数列表锁住*/
if ( stateString ) {
    list.add(function() {
        // state = [ resolved | rejected ]
        state = stateString;

    // [ reject_list | resolve_list ].disable; progress_list.lock
    }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
}

// deferred[ resolve | reject | notify ]
/*在deferred上添加resolve、reject、notify方法，分别映射到其回调函数列表的fireWith上*/
deferred[ tuple[0] ] = function() {
    deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
    return this;
};
/*为deferred对象添加resolveWith，rejectWith，notifyWith，对应的回调函数列表的fireWith*/
deferred[ tuple[0] + "With" ] = list.fireWith; }); ``` 上面的三种操作，只是定义了名称，这里才是真正生成对应函数的地方。jq会为每个Deferred对象生成6个方法： 1. resolve 2. reject 3. notify 4. resolveWith 5. rejectWith 6. notifyWith
</code></pre>

<p>上面三个实际上是直接调用下面三个，只不过加了个默认的参数。下面三个实际上就是对应回调函数列表的fireWith方法。</p>

<p>同时，这里还会为promise增加三个方法：
1. done
2. fail
3. progress</p>

<p>这三个方法就是为对应的回调函数列表添加新函数的方法，直接映射到对应回调函数列表的add方法就行了</p>

<p>另外需要注意一下resolve和reject方法的一次性，实际上也就是在回调函数列表最后加上disable和lock方法</p>

<h3 id="promise">promise对象</h3>
<p>上面反复说了Promise对象，来看看Promise对象的真正面貌：</p>

<p><code>javascript
promise = {
    /*获得当前状态的方法*/
    state: function() {
        return state;
    },
    /*无论执行成功与否，都执行参数中的回调*/
    always: function() {
        deferred.done( arguments ).fail( arguments );
        return this;
    },
    /*顺序声明三个函数，分别在成功，失败，执行中时进行调用，返回一个promise对象*/
    then: function( /* fnDone, fnFail, fnProgress */ ) {
        /*then的代码*/
    },
    // Get a promise for this deferred
    // If obj is provided, the promise aspect is added to the object
    /*获取promise对象*/
    promise: function( obj ) {
        return obj != null ? jQuery.extend( obj, promise ) : promise;
    }
},
deferred = {};
/*pipe方法，实际上就是then，为了符合标准罢了*/
promise.pipe = promise.then;
/*这里为Promise添加了done、fail、progress方法*/
/*这里为Deferred添加了resolve、resolveWith、reject、rejectWith、notify、notifyWith方法*/
jQuery.each( tuples, function( i, tuple ) {
    /*上面的代码*/
});
/*将Promise对象的所有方法拷贝给Deferred对象*/
promise.promise( deferred );
</code></p>

<p>这里可以看到，promise对象提供了几个接口：
1. state：获取当前Deferred对象的状态
2. always：欧诺更是使用done和fail，使得参数中的方法在deferred成功和失败时都执行
3. then：使用done、fail、progress分别绑定函数，代码较多，后面再讲
4. promise：如果对象存在，向一个对象添加promise对象中的接口，否则直接返回promise对象
5. pipe：就是then，别名而已
6. done，fail，progress：上面介绍过，不赘述了</p>

<h4 id="promisedeferred">Promise和Deferred的区别</h4>
<p>这里在申明了promise对象之后，在Deferred对象中添加了promise所有的方法。另外Deferred对象拥有之前说的resolve等6个方法，Deferred对象和Promise对象的区别就很明显了：Promise实际上就是没有resolve、resolveWith、reject、rejectWith、notify、notifyWith这六个方法，其他和Deferred对象一样</p>

<h4 id="thenpipe">then和pipe</h4>
<p>上面略过了then方法，这里单独拉出来说一下：
<code>javascript
then: function( /* fnDone, fnFail, fnProgress */ ) {
    var fns = arguments;
    /*这里新建了一个Deferred对象，并返回其Promise对象，以构成一个Deferred对象链
    由于这里返回的是Promise对象，没有resolve等方法，所以触发必须在整个Deferred对象链的头上触发
    链上的每个Deferred对象的三个回调函数列表的最后，都会有一个函数，用于触发链的下一个Deferred对象的相对应的回调函数列表
    */
    return jQuery.Deferred(function( newDefer ) {
        /*对于上面三种，分别将函数加入到对应的回调函数列表中*/
        jQuery.each( tuples, function( i, tuple ) {
            var fn = jQuery.isFunction( fns[ i ] ) &amp;&amp; fns[ i ];
            /*向当前Deferred最后添加一个函数，用于触发链的下一个Deferred对象的相关回调函数列表*/
            deferred[ tuple[1] ](function() {
                var returned = fn &amp;&amp; fn.apply( this, arguments );
                /*如果返回值是Deferred对象，获取其Promise对象，并为其绑定相关触发操作*/
                if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
                    returned.promise()
                        .done( newDefer.resolve )
                        .fail( newDefer.reject )
                        .progress( newDefer.notify );
                /*如果不是Deferred对象，直接在新建的deferred对象上添加相关触发操作*/
                } else {
                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                }
            });
        });
        fns = null;
    }).promise();
},
</code>
这个函数是Deferred的一个非常重要的函数，它实现了一个Deferred链。这个Deferred链的特点是，只有链的头节点是Deferred对象，后面都是Promise对象，这也意味着，只能在头节点触发resolve、reject、notify操作。触发了操作之后，对应的操作会顺着链传递下去，触发了一个节点resolve，执行完毕后，会自动触发下一个节点的resolve，reject和notify同理。</p>

<p>这里传入的三个函数会分别在当前的Deferred相关操作被触发时执行，如果执行返回的是一个Deferred/Promise对象，获取其Promise对象，新建的Deferred对象将会被链在这个返回的Deferred对象之后。如果返回其他的值，新建的Deferred对象的resolveWith、rejectWith、notifyWith方法会被直接触发，达到链式的效果。</p>

<h3 id="section-5">小结</h3>
<p>这就是jQuery的Deferred/Promise的全貌了。Promise对象实际上是Deferred对象的除去resolve等6个方法的子集。done、fail、progress分别对应一个回调函数列表，这三个方法实际上就是往对应的回调函数列表中插入函数。但then和pipe不相同，它们会新建一个Deferred对象，并构造一个Deferred对象链。这也让jQuery的Deferred/Promise显得不论不类。</p>

<h2 id="when">when</h2>
<p>when方法提供了将多个Deferred对象聚集的能力，在when方法中传入一些Deferred对象，返回一个Deferred对象。在参数中的所有Deferred对象都被resolve之后，会resolve这个返回的Deferred对象，如果参数中的Deferred有一个被reject了，那么这个返回的Deferred也会被reject。另外，在参数中的Deferred对象resolve时，返沪ideDeferred也会被notify。</p>

<p>```javascript
when: function( subordinate /* , …, subordinateN <em>/ ) {
    var i = 0,
        /</em>切分参数到数组<em>/
        resolveValues = slice.call( arguments ),
        /</em>数组长度*/
        length = resolveValues.length,</p>

<pre><code>    /* 未完成的需要监听的Deferred对象的个数 */
    remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,
    /*新建一个Deferred对象用于管理所有的Deferred对象结果，*不妨就叫管理Deferred吧，如果参数只有一个Deferred，就不需要新建了，直接用它就行了/
    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

    /*
    使用一个计数器来计算的，计数器就是remaining，初始为需要执行的Deferred对象的个数，每有一个Deferred被resolve，就减一，减到0时，所有的Deferred都被resolve了，就触发新建的Deferred的resolve。

    如果有Deferred被resolve，但remaining没有到0，就触发管理Deferred的notify
    */
    updateFunc = function( i, contexts, values ) {
        return function( value ) {
            contexts[ i ] = this;
            values[ i ] = arguments.length &gt; 1 ? slice.call( arguments ) : value;
            if ( values === progressValues ) {
                deferred.notifyWith( contexts, values );
            } else if ( !( --remaining ) ) {
                deferred.resolveWith( contexts, values );
            }
        };
    },

    progressValues, progressContexts, resolveContexts;

/*为每个Deferred对象增加我们的更新函数，如果有reject，那么也触发管理Deferred的reject*/
if ( length &gt; 1 ) {
    progressValues = new Array( length );
    progressContexts = new Array( length );
    resolveContexts = new Array( length );
    for ( ; i &lt; length; i++ ) {
        /*这里只处理Deferred/Promise，其他不考虑*/
        if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
            resolveValues[ i ].promise()
                .done( updateFunc( i, resolveContexts, resolveValues ) )
                .fail( deferred.reject )
                .progress( updateFunc( i, progressContexts, progressValues ) );
        } else {
            --remaining;
        }
    }
}

/*如果传入的参数都没有Deferred，直接resolve管理Deferred就好*/
if ( !remaining ) {
    deferred.resolveWith( resolveContexts, resolveValues );
}
/*将这个管理Deferred对象返回*/
return deferred.promise(); } ```
</code></pre>

<p>从上面可以看到主要的实现思路就是，新建一个管理Deferred对象，它期望在参数中所有的Deferred被resolve后，执行自己的resolve操作。内部使用了一个计数器remaining，用于表明还有多少个Deferred尚未resolve。当这个计数器变成0时，所有的Deferred都被resolve了，那么这个管理Deferred也可以被resolve了。</p>

<p>为了维护这个计数器，在每个Deferred的done回调函数列表最后，绑定一个updateFunc函数，这个函数内部会修改remaining，以及判断是应该执行管理Deferred对象的resolve还是notify</p>

<p>而由于任何一个Deferred被reject的话，管理Deferred都会被reject，所以直接在每一个Deferred的fail回调函数列表上添加管理Deferred的reject方法就行了</p>

<p>另外需要注意一下参数中只有一个或没有Deferred的情况，前者可以省去创建管理Deferred对象，直接使用参数中的Deferred对象作为管理对象就行了。后者则可以直接执行resolve方法</p>

<h2 id="section-6">总结</h2>
<p>jQuery中使用Deferred/Promise对象进行异步管理，其内部维护了三个Callbacks回调函数列表，这与常规的Promise的链式实现并不一致。在稍早的版本中，then方法其实也是和done、fail、progress一样往回调函数列表里添加方法，并不会形成Deferred链，后来Resig估计也发现了自己理解错了标准，于是乎通过pipe和then生成Deferred链，但这种Callbacks和Deferred链同时存在的方式，显得不伦不类，不过普通的需求基本上都能满足。jQuery的ready、ajax等都是使用Deferred/Promise来进行异步控制的</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/17/read-jq-src-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的事件机制——事件对象、兼容、接口 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/12/read-jq-src-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 12 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>接上一篇 <a href="http://lingyu.wang/#/art/blog/2014/05/12/read-jq-src-3">jQuery的事件机制——核心篇</a></p>

<h2 id="section">事件对象</h2>
<p>jq中使用自己创立的对象传递给回调函数，这里解析一下这个事件对象：
###构造函数
jq的事件对象的构造函数如下：
<code>javascript
jQuery.Event = function( src, props ) {
    //内部的代码
};
</code>
接下来接下下内部代码：</p>

<p><code>javascript
/*兼容不使用new的情况*/
if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
}
</code>
用于防止出现没有使用new直接调用构造函数的情况</p>

<p>```javascript
if ( src &amp;&amp; src.type ) {
    this.originalEvent = src;
    this.type = src.type;</p>

<pre><code>// Events bubbling up the document may have been marked as prevented
// by a handler lower down the tree; reflect the correct value.
this.isDefaultPrevented = src.defaultPrevented ||
        // Support: Android &lt; 4.0
        src.defaultPrevented === undefined &amp;&amp;
        src.getPreventDefault &amp;&amp; src.getPreventDefault() ?
    returnTrue :
    returnFalse;
</code></pre>

<p>// Event type
} else {
    this.type = src;
}
```
这里根据传入的是事件对象还是事件名称分别进行处理，当传入原生事件对象时，使用originalEvent指向原生事件对象，并获取它的事件名称。另外还要判断事件是否已经屏蔽默认行为了。如果传入的是字符串，直接写入到事件名称中</p>

<p><code>javascript
/*通过extend添加额外属性*/
if ( props ) {
    jQuery.extend( this, props );
}
</code>
事件对象可以添加一些其他属性，这里添加的属性通过props传入，直接extend就好</p>

<p>```javascript
/<em>创建时间</em>/
this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();</p>

<p>/<em>jq事件对象标记</em>/
this[ jQuery.expando ] = true;
```
一个创建时的时间戳，不知道干嘛用的，至于版本号标记，主要是用来判断对象是原生事件对象还是jq自己的事件对象</p>

<h3 id="section-1">原型上的方法</h3>
<p>事件对象实际上是jq新建的对象，对原生事件对象进行了一层包裹，那么应该提供一些方法操作原生事件对象。我们操作原生事件对象无外乎preventDefault和stopPropagation，这里就是做了一层封装</p>

<p><code>javascript
isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,
</code>
默认情况下，不会阻止默认行为，事件不会被终止。这里ImmediatePropagtaionStop其实和PropagationStop没什么区别</p>

<p>```javascript
preventDefault: function() {
    var e = this.originalEvent;</p>

<pre><code>this.isDefaultPrevented = returnTrue;

if ( e &amp;&amp; e.preventDefault ) {
    e.preventDefault();
} }, ``` 阻止默认行为，先在jq的事件对象上做个标记，然后调用原生事件的preventDefault方法
</code></pre>

<p>```javascript
stopPropagation: function() {
    var e = this.originalEvent;</p>

<pre><code>this.isPropagationStopped = returnTrue;

if ( e &amp;&amp; e.stopPropagation ) {
    e.stopPropagation();
} }, stopImmediatePropagation: function() {
this.isImmediatePropagationStopped = returnTrue;
this.stopPropagation(); } ``` 终止事件执行，同样是先在事件对象上做个标记，然后调用原生事件的pstopPropagation方法，可以看到，两个方法没什么区别
</code></pre>

<h2 id="section-2">事件对象在事件机制中的使用</h2>
<p>jq不嫌麻烦自己弄了个事件对象进行包装，就是为了屏蔽浏览器之间事件对象上的差异。这里jq事件对象需要根据事件的类型，来构建兼容的事件对象，同样是使用钩子的形式，调用这些钩子的地方，在事件管理器的fix方法</p>

<h3 id="fix">fix方法</h3>
<p>fix方法就是将原生事件对象加工为jq自己的事件对象，内部都是用钩子来加对不同类型的事件进行加工</p>

<p><code>javascript
if ( event[ jQuery.expando ] ) {
    return event;
}
</code>
jq事件对象上有jq版本标记，如果标记已存在，说明是jq时间爱你对象，没必要加工了</p>

<p>```javascript
var i, prop, copy,
    /<em>获取事件的名称</em>/
    type = event.type,
    /<em>将原生事件对象缓存</em>/
    originalEvent = event,
    /<em>获取事件对象对应的钩子</em>/
    fixHook = this.fixHooks[ type ];</p>

<p>/<em>如果没有钩子，需要判断这个对象类型是鼠标事件还是键盘事件</em>/
if ( !fixHook ) {
    this.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? this.mouseHooks :
        rkeyEvent.test( type ) ? this.keyHooks :
        {};
}
```
这里会获取特殊事件的钩子，如果没有钩子，那需要判断事件是鼠标事件还是按键事件，这俩都需要特别处理。另外也会做缓存，获取到钩子后写入到fixHooks中，下次同样类型的事件就能直接获取钩子了</p>

<p>```javascript
/<em>获取鼠标事件或键盘事件应当拷贝的相关属性的列表</em>/
copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;</p>

<p>/<em>新建一个包装了原生事件对象的jq事件对象</em>/
event = new jQuery.Event( originalEvent );
/<em>将这些需要拷贝的属性全部拷贝到jq事件对象中</em>/
i = copy.length;
while ( i– ) {
    prop = copy[ i ];
    event[ prop ] = originalEvent[ prop ];
}
```
鼠标类型事件和按键类型时间都有自己的一些属性，当然还有些公有属性，这里需要获取事件应当从原生事件中拷贝值名称的列表。获取到列表后新建一个jq事件对象进行拷贝。</p>

<p><code>javascript
if ( !event.target ) {
    event.target = document;
}
if ( event.target.nodeType === 3 ) {
    event.target = event.target.parentNode;
}
</code>
这里修复了一些事件target不正确的问题</p>

<p><code>javascript
return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
</code>
最后再通过filter钩子做一下最后的加工处理。处理完成之后，返回jq的事件对象</p>

<h3 id="section-3">鼠标事件和键盘事件的处理</h3>
<p>fix中都是调用钩子来获得元素列表和filter最后处理，在事件管理器中定义了鼠标事件和键盘事件需要的属性</p>

<h4 id="section-4">公有属性</h4>
<p><code>javascript
props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
</code>
这些是鼠标和键盘事件公有的属性</p>

<h4 id="section-5">键盘事件</h4>
<p>```javascript
keyHooks: {
    props: “char charCode key keyCode”.split(“ “),
    filter: function( event, original ) {</p>

<pre><code>    // Add which for key events
    if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
    }

    return event;
} }, ``` 这里是键盘钩子，定义了键盘事件特有属性以及其filter，filter主要是将如charCode、keyCode等进行统一，创建出符合W3C标准的which
</code></pre>

<h4 id="section-6">鼠标事件</h4>
<p><code>javascript
mouseHooks: {
    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
        var eventDoc, doc, body,
            button = original.button;
        if ( event.pageX == null &amp;&amp; original.clientX != null ) {
            eventDoc = event.target.ownerDocument || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;
            event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
            event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
        }
        if ( !event.which &amp;&amp; button !== undefined ) {
            event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
        }
        return event;
    }
},
</code>
同样的方式，定义了鼠标事件特有的属性，另外做了一个兼容，做出了pageX、pageY、which等属性</p>

<h2 id="section-7">特殊事件</h2>
<p>上一篇讲了jq事件核心，可以看到针对特殊事件，基本上每个地方都需要通过钩子特殊处理，那么有哪些特殊事件呢？这些在事件管理器的special里都有：</p>

<h3 id="load">load</h3>
<p><code>javascript
load: {
    // Prevent triggered image.load events from bubbling to window.load
    noBubble: true
},
</code>
load事件不冒泡，需要注意
###focus和blur
<code>javascript
focus: {
    // Fire native event if possible so blur/focus sequence is correct
    trigger: function() {
        if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
            this.focus();
            return false;
        }
    },
    delegateType: "focusin"
},
blur: {
    trigger: function() {
        if ( this === safeActiveElement() &amp;&amp; this.blur ) {
            this.blur();
            return false;
        }
    },
    delegateType: "focusout"
},
</code>
focus和blur事件，这俩有自己的trigger钩子，另外其使用代理时名称也不同。事实上focus和blur除了trigger钩子，还有在事件注册和事件删除时的setup和teardown钩子，可以看到代码如下
```javascript
if ( !support.focusinBubbles ) {
    jQuery.each({ focus: “focusin”, blur: “focusout” }, function( orig, fix ) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };
        jQuery.event.special[ fix ] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = data_priv.access( doc, fix );
                if ( !attaches ) {
                    doc.addEventListener( orig, handler, true );
                }
                data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches = data_priv.access( doc, fix ) - 1;</p>

<pre><code>            if ( !attaches ) {
                doc.removeEventListener( orig, handler, true );
                data_priv.remove( doc, fix );

            } else {
                data_priv.access( doc, fix, attaches );
            }
        }
    };
}); } ``` ###click ```javascript click: {
// For checkbox, fire native event so checked state will be right
trigger: function() {
    if ( this.type === "checkbox" &amp;&amp; this.click &amp;&amp; jQuery.nodeName( this, "input" ) ) {
        this.click();
        return false;
    }
},
/*浏览器兼容，如果元素是a标签，那么不触发原生click事件*/
// For cross-browser consistency, don't fire native .click() on links
_default: function( event ) {
    return jQuery.nodeName( event.target, "a" );
} }, ``` 点击时间爱你，在checkbox上有钩子，调用其原生api。另外，当元素为a标签时，不触发原生click事件 ###beforeunload ```javascript beforeunload: {
postDispatch: function( event ) {

    // Support: Firefox 20+
    // Firefox doesn't alert if the returnValue field is not set.
    if ( event.result !== undefined ) {
        event.originalEvent.returnValue = event.result;
    }
} } ``` beforeunlaod事件在ff中最后结果可能不同，需要做兼容 ###mouseenter和mouseleave mouseover和mouseout的问题在于，他们只监听最外层的大容器，而大容器中是由很多子元素的。如果鼠标在子元素上，而离开了大容器，mouseout事件也会触发。
</code></pre>

<p>比如一个列式菜单，最上层菜单上有一些选项，鼠标悬停在选项上，右侧会出现该选项下的子选项。如果在菜单上使用mouseover和mouseout来绑定事件，当鼠标移动到子选项时，实际上移出了容器，会触发mouseout事件，菜单就被隐藏了…</p>

<p>jq通过新建两个事件mouseenter和mouseleave来防止这种情况发生</p>

<p>```javascript
jQuery.each({
    mouseenter: “mouseover”,
    mouseleave: “mouseout”
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,</p>

<pre><code>    handle: function( event ) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

        // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply( this, arguments );
            event.type = fix;
        }
        return ret;
    }
}; }); ``` 可以看到，这里可以看到，使用contains判断当前元素是否被包含在容器中，如果包含将不会执行回调函数
</code></pre>

<h2 id="jquery">jQuery对象上的方法</h2>
<p>我们需要一系列的方法将事件用于jQuery对象之上，依旧是在fn上扩展，有如下一些方法：
1. on： 绑定事件添加回调
2. one：绑定知识性一次的事件
3. off：移除事件
4. trigger：对每一个元素触发事件
5. triggerHandler：对jq对象中的第一个元素触发事件</p>

<h3 id="on-types-selector-data-fn-one">on (types, selector, data, fn, /*内部使用*/one)</h3>
<p>jq使用on方法在元素时行绑定事件，这里types可以是一个<code>event1 event2</code>这样的字符串，同时绑定多个事件公用相同的回调函数fn。另外，当types为对象时，键为事件名称，值为回调函数，也可以一次绑定多个事件。这是一个多接口方法，需要根据传入的参数判断如何处理</p>

<p><code>javascript
if ( typeof types === "object" ) {
    // ( types-Object, selector, data )
    if ( typeof selector !== "string" ) {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
    }
    /*一次绑定多个事件*/
    for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
    }
    return this;
}
</code>
可以看到，这里就是处理types为对象的情况，这里实际上根据types中的每个键值对，递归调用了on方法进行单个绑定</p>

<p><code>javascript
/*可以不提供数据*/
if ( data == null &amp;&amp; fn == null ) {
    // ( types, fn )
    //情况1
    fn = selector;
    data = selector = undefined;
} else if ( fn == null ) {
    if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        //情况2
        fn = data;
        data = undefined;
    } else {
        // ( types, data, fn )
        //情况3
        fn = data;
        data = selector;
        selector = undefined;
    }
}
if ( fn === false ) {
    fn = returnFalse;
} else if ( !fn ) {
    return this;
}
</code>
这里处理了三种情况：
1. 只有事件名称和回调函数
2. 有事件名称，代理选择器和回调函数
3. 有事件名称，事件数据和回调函数</p>

<p>如果没有回调函数，需要给与一个默认的回调函数，这个默认回调函数直接<code>return false</code></p>

<p><code>javascript
if ( one === 1 ) {
    origFn = fn;
    fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
    };
    // Use same guid so caller can remove using origFn
    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
}
</code>
我们可以绑定一次性事件，实现骑士很简单，通过闭包对事件回调函数做一个包装，在其被运行之前，调用off移除掉事件就行了</p>

<p><code>javascript
return this.each( function() {
    jQuery.event.add( this, types, fn, data, selector );
});
</code>
最后，确定好了配置，最后在jq对象中的每个元素上调用通过事件管理器的add方法添加事件回调函数</p>

<h3 id="one--types-selector-data-fn-">one ( types, selector, data, fn )</h3>
<p>绑定一次性事件，上面的on已经做了实现，这里只不过是调用一下接口</p>

<p><code>javascript
one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
},
</code></p>

<h3 id="off--types-selector-fn-">off ( types, selector, fn )</h3>
<p>同样是个多接口函数，在只有事件名称时，直接删除整个事件。如果有确定回调函数，那么删除对应时间的对应回调函数。需要注意代理的情况</p>

<p><code>javascript
if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
    // ( event )  dispatched jQuery.Event
    handleObj = types.handleObj;
    jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
    );
    return this;
}
</code>
这里处理的是参数是事件对象的情况，这种情况会在使用one绑定事件回调执行后自动删除时发生。获取事件对象其中的属性，递归调用off删除</p>

<p><code>javascript
if ( typeof types === "object" ) {
    // ( types-object [, selector] )
    for ( type in types ) {
        this.off( type, selector, types[ type ] );
    }
    return this;
}
</code>
如果typs是事件名称到回调函数的键值对，那么对其中的每个键和值，分别进行删除，递归调用off删除</p>

<p><code>javascript
if ( selector === false || typeof selector === "function" ) {
    // ( types [, fn] )
    fn = selector;
    selector = undefined;
}
if ( fn === false ) {
    fn = returnFalse;
}
</code>
这里处理了只有事件名称和回调函数的接口情况</p>

<p><code>javascript
return this.each(function() {
    jQuery.event.remove( this, types, fn, selector );
});
</code>
最后，对jq对象中的每个元素移除事件中的回调函数就好</p>

<h3 id="trigger-type-data--triggerhandler-type-data">trigger (type, data) 和 triggerHandler (type, data)</h3>
<p>没啥说的，都是直接用的事件管理器的trigger方法。只不过前者对每个元素调用一次，后者只对第一个元素调用</p>

<p><code>javascript
/*对jq对象中的每个元素触发事件*/
trigger: function( type, data ) {
    return this.each(function() {
        jQuery.event.trigger( type, data, this );
    });
},
/*对jq对象中的第一个元素触发事件*/
triggerHandler: function( type, data ) {
    var elem = this[0];
    if ( elem ) {
        return jQuery.event.trigger( type, data, elem, true );
    }
}
</code></p>

<h2 id="section-8">总结</h2>
<p>这一篇直接看的话，肯定会不知所云…最好能结合上一篇一起看，上一篇介绍了事件机制的核心方法，这一篇主要是jq事件对象和一些兼容性问题的解决方法（主要是钩子）。jq的钩子方式很不错，在写框架对付兼容性问题时可以多多使用</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/12/read-jq-src-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的事件机制——事件对象、兼容、接口 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/12/read-jq-src-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 12 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>接上一篇 <a href="http://lingyu.wang/#/art/blog/2014/05/12/read-jq-src-3">jQuery的事件机制——核心篇</a></p>

<h2 id="section">事件对象</h2>
<p>jq中使用自己创立的对象传递给回调函数，这里解析一下这个事件对象：
###构造函数
jq的事件对象的构造函数如下：
<code>javascript
jQuery.Event = function( src, props ) {
    //内部的代码
};
</code>
接下来接下下内部代码：</p>

<p><code>javascript
/*兼容不使用new的情况*/
if ( !(this instanceof jQuery.Event) ) {
    return new jQuery.Event( src, props );
}
</code>
用于防止出现没有使用new直接调用构造函数的情况</p>

<p>```javascript
if ( src &amp;&amp; src.type ) {
    this.originalEvent = src;
    this.type = src.type;</p>

<pre><code>// Events bubbling up the document may have been marked as prevented
// by a handler lower down the tree; reflect the correct value.
this.isDefaultPrevented = src.defaultPrevented ||
        // Support: Android &lt; 4.0
        src.defaultPrevented === undefined &amp;&amp;
        src.getPreventDefault &amp;&amp; src.getPreventDefault() ?
    returnTrue :
    returnFalse;
</code></pre>

<p>// Event type
} else {
    this.type = src;
}
```
这里根据传入的是事件对象还是事件名称分别进行处理，当传入原生事件对象时，使用originalEvent指向原生事件对象，并获取它的事件名称。另外还要判断事件是否已经屏蔽默认行为了。如果传入的是字符串，直接写入到事件名称中</p>

<p><code>javascript
/*通过extend添加额外属性*/
if ( props ) {
    jQuery.extend( this, props );
}
</code>
事件对象可以添加一些其他属性，这里添加的属性通过props传入，直接extend就好</p>

<p>```javascript
/<em>创建时间</em>/
this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();</p>

<p>/<em>jq事件对象标记</em>/
this[ jQuery.expando ] = true;
```
一个创建时的时间戳，不知道干嘛用的，至于版本号标记，主要是用来判断对象是原生事件对象还是jq自己的事件对象</p>

<h3 id="section-1">原型上的方法</h3>
<p>事件对象实际上是jq新建的对象，对原生事件对象进行了一层包裹，那么应该提供一些方法操作原生事件对象。我们操作原生事件对象无外乎preventDefault和stopPropagation，这里就是做了一层封装</p>

<p><code>javascript
isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,
</code>
默认情况下，不会阻止默认行为，事件不会被终止。这里ImmediatePropagtaionStop其实和PropagationStop没什么区别</p>

<p>```javascript
preventDefault: function() {
    var e = this.originalEvent;</p>

<pre><code>this.isDefaultPrevented = returnTrue;

if ( e &amp;&amp; e.preventDefault ) {
    e.preventDefault();
} }, ``` 阻止默认行为，先在jq的事件对象上做个标记，然后调用原生事件的preventDefault方法
</code></pre>

<p>```javascript
stopPropagation: function() {
    var e = this.originalEvent;</p>

<pre><code>this.isPropagationStopped = returnTrue;

if ( e &amp;&amp; e.stopPropagation ) {
    e.stopPropagation();
} }, stopImmediatePropagation: function() {
this.isImmediatePropagationStopped = returnTrue;
this.stopPropagation(); } ``` 终止事件执行，同样是先在事件对象上做个标记，然后调用原生事件的pstopPropagation方法，可以看到，两个方法没什么区别
</code></pre>

<h2 id="section-2">事件对象在事件机制中的使用</h2>
<p>jq不嫌麻烦自己弄了个事件对象进行包装，就是为了屏蔽浏览器之间事件对象上的差异。这里jq事件对象需要根据事件的类型，来构建兼容的事件对象，同样是使用钩子的形式，调用这些钩子的地方，在事件管理器的fix方法</p>

<h3 id="fix">fix方法</h3>
<p>fix方法就是将原生事件对象加工为jq自己的事件对象，内部都是用钩子来加对不同类型的事件进行加工</p>

<p><code>javascript
if ( event[ jQuery.expando ] ) {
    return event;
}
</code>
jq事件对象上有jq版本标记，如果标记已存在，说明是jq时间爱你对象，没必要加工了</p>

<p>```javascript
var i, prop, copy,
    /<em>获取事件的名称</em>/
    type = event.type,
    /<em>将原生事件对象缓存</em>/
    originalEvent = event,
    /<em>获取事件对象对应的钩子</em>/
    fixHook = this.fixHooks[ type ];</p>

<p>/<em>如果没有钩子，需要判断这个对象类型是鼠标事件还是键盘事件</em>/
if ( !fixHook ) {
    this.fixHooks[ type ] = fixHook =
        rmouseEvent.test( type ) ? this.mouseHooks :
        rkeyEvent.test( type ) ? this.keyHooks :
        {};
}
```
这里会获取特殊事件的钩子，如果没有钩子，那需要判断事件是鼠标事件还是按键事件，这俩都需要特别处理。另外也会做缓存，获取到钩子后写入到fixHooks中，下次同样类型的事件就能直接获取钩子了</p>

<p>```javascript
/<em>获取鼠标事件或键盘事件应当拷贝的相关属性的列表</em>/
copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;</p>

<p>/<em>新建一个包装了原生事件对象的jq事件对象</em>/
event = new jQuery.Event( originalEvent );
/<em>将这些需要拷贝的属性全部拷贝到jq事件对象中</em>/
i = copy.length;
while ( i– ) {
    prop = copy[ i ];
    event[ prop ] = originalEvent[ prop ];
}
```
鼠标类型事件和按键类型时间都有自己的一些属性，当然还有些公有属性，这里需要获取事件应当从原生事件中拷贝值名称的列表。获取到列表后新建一个jq事件对象进行拷贝。</p>

<p><code>javascript
if ( !event.target ) {
    event.target = document;
}
if ( event.target.nodeType === 3 ) {
    event.target = event.target.parentNode;
}
</code>
这里修复了一些事件target不正确的问题</p>

<p><code>javascript
return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
</code>
最后再通过filter钩子做一下最后的加工处理。处理完成之后，返回jq的事件对象</p>

<h3 id="section-3">鼠标事件和键盘事件的处理</h3>
<p>fix中都是调用钩子来获得元素列表和filter最后处理，在事件管理器中定义了鼠标事件和键盘事件需要的属性</p>

<h4 id="section-4">公有属性</h4>
<p><code>javascript
props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
</code>
这些是鼠标和键盘事件公有的属性</p>

<h4 id="section-5">键盘事件</h4>
<p>```javascript
keyHooks: {
    props: “char charCode key keyCode”.split(“ “),
    filter: function( event, original ) {</p>

<pre><code>    // Add which for key events
    if ( event.which == null ) {
        event.which = original.charCode != null ? original.charCode : original.keyCode;
    }

    return event;
} }, ``` 这里是键盘钩子，定义了键盘事件特有属性以及其filter，filter主要是将如charCode、keyCode等进行统一，创建出符合W3C标准的which
</code></pre>

<h4 id="section-6">鼠标事件</h4>
<p><code>javascript
mouseHooks: {
    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
    filter: function( event, original ) {
        var eventDoc, doc, body,
            button = original.button;
        if ( event.pageX == null &amp;&amp; original.clientX != null ) {
            eventDoc = event.target.ownerDocument || document;
            doc = eventDoc.documentElement;
            body = eventDoc.body;
            event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
            event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
        }
        if ( !event.which &amp;&amp; button !== undefined ) {
            event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
        }
        return event;
    }
},
</code>
同样的方式，定义了鼠标事件特有的属性，另外做了一个兼容，做出了pageX、pageY、which等属性</p>

<h2 id="section-7">特殊事件</h2>
<p>上一篇讲了jq事件核心，可以看到针对特殊事件，基本上每个地方都需要通过钩子特殊处理，那么有哪些特殊事件呢？这些在事件管理器的special里都有：</p>

<h3 id="load">load</h3>
<p><code>javascript
load: {
    // Prevent triggered image.load events from bubbling to window.load
    noBubble: true
},
</code>
load事件不冒泡，需要注意
###focus和blur
<code>javascript
focus: {
    // Fire native event if possible so blur/focus sequence is correct
    trigger: function() {
        if ( this !== safeActiveElement() &amp;&amp; this.focus ) {
            this.focus();
            return false;
        }
    },
    delegateType: "focusin"
},
blur: {
    trigger: function() {
        if ( this === safeActiveElement() &amp;&amp; this.blur ) {
            this.blur();
            return false;
        }
    },
    delegateType: "focusout"
},
</code>
focus和blur事件，这俩有自己的trigger钩子，另外其使用代理时名称也不同。事实上focus和blur除了trigger钩子，还有在事件注册和事件删除时的setup和teardown钩子，可以看到代码如下
```javascript
if ( !support.focusinBubbles ) {
    jQuery.each({ focus: “focusin”, blur: “focusout” }, function( orig, fix ) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };
        jQuery.event.special[ fix ] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = data_priv.access( doc, fix );
                if ( !attaches ) {
                    doc.addEventListener( orig, handler, true );
                }
                data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches = data_priv.access( doc, fix ) - 1;</p>

<pre><code>            if ( !attaches ) {
                doc.removeEventListener( orig, handler, true );
                data_priv.remove( doc, fix );

            } else {
                data_priv.access( doc, fix, attaches );
            }
        }
    };
}); } ``` ###click ```javascript click: {
// For checkbox, fire native event so checked state will be right
trigger: function() {
    if ( this.type === "checkbox" &amp;&amp; this.click &amp;&amp; jQuery.nodeName( this, "input" ) ) {
        this.click();
        return false;
    }
},
/*浏览器兼容，如果元素是a标签，那么不触发原生click事件*/
// For cross-browser consistency, don't fire native .click() on links
_default: function( event ) {
    return jQuery.nodeName( event.target, "a" );
} }, ``` 点击时间爱你，在checkbox上有钩子，调用其原生api。另外，当元素为a标签时，不触发原生click事件 ###beforeunload ```javascript beforeunload: {
postDispatch: function( event ) {

    // Support: Firefox 20+
    // Firefox doesn't alert if the returnValue field is not set.
    if ( event.result !== undefined ) {
        event.originalEvent.returnValue = event.result;
    }
} } ``` beforeunlaod事件在ff中最后结果可能不同，需要做兼容 ###mouseenter和mouseleave mouseover和mouseout的问题在于，他们只监听最外层的大容器，而大容器中是由很多子元素的。如果鼠标在子元素上，而离开了大容器，mouseout事件也会触发。
</code></pre>

<p>比如一个列式菜单，最上层菜单上有一些选项，鼠标悬停在选项上，右侧会出现该选项下的子选项。如果在菜单上使用mouseover和mouseout来绑定事件，当鼠标移动到子选项时，实际上移出了容器，会触发mouseout事件，菜单就被隐藏了…</p>

<p>jq通过新建两个事件mouseenter和mouseleave来防止这种情况发生</p>

<p>```javascript
jQuery.each({
    mouseenter: “mouseover”,
    mouseleave: “mouseout”
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,</p>

<pre><code>    handle: function( event ) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;

        // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply( this, arguments );
            event.type = fix;
        }
        return ret;
    }
}; }); ``` 可以看到，这里可以看到，使用contains判断当前元素是否被包含在容器中，如果包含将不会执行回调函数
</code></pre>

<h2 id="jquery">jQuery对象上的方法</h2>
<p>我们需要一系列的方法将事件用于jQuery对象之上，依旧是在fn上扩展，有如下一些方法：
1. on： 绑定事件添加回调
2. one：绑定知识性一次的事件
3. off：移除事件
4. trigger：对每一个元素触发事件
5. triggerHandler：对jq对象中的第一个元素触发事件</p>

<h3 id="on-types-selector-data-fn-one">on (types, selector, data, fn, /*内部使用*/one)</h3>
<p>jq使用on方法在元素时行绑定事件，这里types可以是一个<code>event1 event2</code>这样的字符串，同时绑定多个事件公用相同的回调函数fn。另外，当types为对象时，键为事件名称，值为回调函数，也可以一次绑定多个事件。这是一个多接口方法，需要根据传入的参数判断如何处理</p>

<p><code>javascript
if ( typeof types === "object" ) {
    // ( types-Object, selector, data )
    if ( typeof selector !== "string" ) {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
    }
    /*一次绑定多个事件*/
    for ( type in types ) {
        this.on( type, selector, data, types[ type ], one );
    }
    return this;
}
</code>
可以看到，这里就是处理types为对象的情况，这里实际上根据types中的每个键值对，递归调用了on方法进行单个绑定</p>

<p><code>javascript
/*可以不提供数据*/
if ( data == null &amp;&amp; fn == null ) {
    // ( types, fn )
    //情况1
    fn = selector;
    data = selector = undefined;
} else if ( fn == null ) {
    if ( typeof selector === "string" ) {
        // ( types, selector, fn )
        //情况2
        fn = data;
        data = undefined;
    } else {
        // ( types, data, fn )
        //情况3
        fn = data;
        data = selector;
        selector = undefined;
    }
}
if ( fn === false ) {
    fn = returnFalse;
} else if ( !fn ) {
    return this;
}
</code>
这里处理了三种情况：
1. 只有事件名称和回调函数
2. 有事件名称，代理选择器和回调函数
3. 有事件名称，事件数据和回调函数</p>

<p>如果没有回调函数，需要给与一个默认的回调函数，这个默认回调函数直接<code>return false</code></p>

<p><code>javascript
if ( one === 1 ) {
    origFn = fn;
    fn = function( event ) {
        // Can use an empty set, since event contains the info
        jQuery().off( event );
        return origFn.apply( this, arguments );
    };
    // Use same guid so caller can remove using origFn
    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
}
</code>
我们可以绑定一次性事件，实现骑士很简单，通过闭包对事件回调函数做一个包装，在其被运行之前，调用off移除掉事件就行了</p>

<p><code>javascript
return this.each( function() {
    jQuery.event.add( this, types, fn, data, selector );
});
</code>
最后，确定好了配置，最后在jq对象中的每个元素上调用通过事件管理器的add方法添加事件回调函数</p>

<h3 id="one--types-selector-data-fn-">one ( types, selector, data, fn )</h3>
<p>绑定一次性事件，上面的on已经做了实现，这里只不过是调用一下接口</p>

<p><code>javascript
one: function( types, selector, data, fn ) {
    return this.on( types, selector, data, fn, 1 );
},
</code></p>

<h3 id="off--types-selector-fn-">off ( types, selector, fn )</h3>
<p>同样是个多接口函数，在只有事件名称时，直接删除整个事件。如果有确定回调函数，那么删除对应时间的对应回调函数。需要注意代理的情况</p>

<p><code>javascript
if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
    // ( event )  dispatched jQuery.Event
    handleObj = types.handleObj;
    jQuery( types.delegateTarget ).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
    );
    return this;
}
</code>
这里处理的是参数是事件对象的情况，这种情况会在使用one绑定事件回调执行后自动删除时发生。获取事件对象其中的属性，递归调用off删除</p>

<p><code>javascript
if ( typeof types === "object" ) {
    // ( types-object [, selector] )
    for ( type in types ) {
        this.off( type, selector, types[ type ] );
    }
    return this;
}
</code>
如果typs是事件名称到回调函数的键值对，那么对其中的每个键和值，分别进行删除，递归调用off删除</p>

<p><code>javascript
if ( selector === false || typeof selector === "function" ) {
    // ( types [, fn] )
    fn = selector;
    selector = undefined;
}
if ( fn === false ) {
    fn = returnFalse;
}
</code>
这里处理了只有事件名称和回调函数的接口情况</p>

<p><code>javascript
return this.each(function() {
    jQuery.event.remove( this, types, fn, selector );
});
</code>
最后，对jq对象中的每个元素移除事件中的回调函数就好</p>

<h3 id="trigger-type-data--triggerhandler-type-data">trigger (type, data) 和 triggerHandler (type, data)</h3>
<p>没啥说的，都是直接用的事件管理器的trigger方法。只不过前者对每个元素调用一次，后者只对第一个元素调用</p>

<p><code>javascript
/*对jq对象中的每个元素触发事件*/
trigger: function( type, data ) {
    return this.each(function() {
        jQuery.event.trigger( type, data, this );
    });
},
/*对jq对象中的第一个元素触发事件*/
triggerHandler: function( type, data ) {
    var elem = this[0];
    if ( elem ) {
        return jQuery.event.trigger( type, data, elem, true );
    }
}
</code></p>

<h2 id="section-8">总结</h2>
<p>这一篇直接看的话，肯定会不知所云…最好能结合上一篇一起看，上一篇介绍了事件机制的核心方法，这一篇主要是jq事件对象和一些兼容性问题的解决方法（主要是钩子）。jq的钩子方式很不错，在写框架对付兼容性问题时可以多多使用</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/12/read-jq-src-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的事件机制——核心篇 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/12/read-jq-src-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 12 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h1 id="jquery">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>

<h2 id="section">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>

<h3 id="global">global</h3>
<p>存放事件是否存在</p>

<h3 id="add-elem-types-handler-data-selector">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>

<p>所以代码大致流程如下：
####事件创建逻辑
在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>

<p>```javascript
var handleObjIn, eventHandle, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.get( elem );</p>

<p>if ( !elemData ) {
    return;
}
```
获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>

<p><code>javascript
if ( handler.handler ) {
    handleObjIn = handler;
    handler = handleObjIn.handler;
    selector = handleObjIn.selector;
}
</code>
接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>

<p><code>javascript
if ( !handler.guid ) {
    handler.guid = jQuery.guid++;
}
</code>
为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>

<p><code>javascript
if ( !(events = elemData.events) ) {
    events = elemData.events = {};
}
if ( !(eventHandle = elemData.handle) ) {
    eventHandle = elemData.handle = function( e ) {
        return typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, arguments ) : undefined;
    };
}
</code>
从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>

<h4 id="section-1">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：
1. type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件
2. 有可能存在命名空间如<code>event.namespace</code>的情况
3. 特殊事件需要进行名称转换，以及钩子调用
4. 如果是事件代理也需要注意代理逻辑</p>

<p><code>javascript
types = ( types || "" ).match( rnotwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
    //后面的代码
}
</code>
处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>

<p>```javascript
tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[1];
namespaces = ( tmp[2] || “” ).split( “.” ).sort();</p>

<p>if ( !type ) {
    continue;
}
```
处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>

<p>```javascript
special = jQuery.event.special[ type ] || {};</p>

<table>
  <tbody>
    <tr>
      <td>type = ( selector ? special.delegateType : special.bindType )</td>
      <td> </td>
      <td>type;</td>
    </tr>
  </tbody>
</table>

<p>special = jQuery.event.special[ type ] || {};
```
情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>

<p><code>javascript
handleObj = jQuery.extend({
    type: type,
    origType: origType,
    data: data,
    handler: handler,
    guid: handler.guid,
    selector: selector,
    needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
    namespace: namespaces.join(".")
}, handleObjIn );
</code>
这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：
1. type：事件的映射后的名称
2. origType：事件的原始名称
3. data：事件的默认数据
4. handler：回调函数
5. guid：回调函数的id
6. selector：启用事件代理时，被代理的节点的选择器
7. needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文
8. namespace：重组后的命名空间</p>

<p>```javascript
if ( !(handlers = events[ type ]) ) {
    handlers = events[ type ] = [];
    handlers.delegateCount = 0;</p>

<pre><code>if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
    if ( elem.addEventListener ) {
        elem.addEventListener( type, eventHandle, false );
    }
} } ``` 如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子
</code></pre>

<p>```javascript
if ( special.add ) {
    special.add.call( elem, handleObj );</p>

<pre><code>if ( !handleObj.handler.guid ) {
    handleObj.handler.guid = handler.guid;
} } ``` 这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子
</code></pre>

<p><code>javascript
if ( selector ) {
    handlers.splice( handlers.delegateCount++, 0, handleObj );
} else {
    handlers.push( handleObj );
}
</code>
好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>

<p><code>javascript
jQuery.event.global[ type ] = true;
</code>
最后再全局中标记一下事件已存在就行了</p>

<h3 id="remove-elem-types-handler-selector-mappedtypes">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：
1. type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件
2. 有可能存在命名空间如<code>event.namespace</code>的情况
3. 特殊事件需要进行名称转换，以及钩子调用
4. 如果是事件代理也需要注意代理逻辑
5. 在移除了一个事件的所有回调对象后，可以移除这个事件
6. 在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</p>

<p><code>javascript
var j, origCount, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );
if ( !elemData || !(events = elemData.events) ) {
    return;
}
</code>
获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>

<p><code>javascript
types = ( types || "" ).match( rnotwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
    //后面的代码
}
</code>
处理情况1，和上面的add一样</p>

<p>```javascript
tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[1];</p>

<p>namespaces = ( tmp[2] || “” ).split( “.” ).sort();
```
获取事件的命名空间，和add方法一样</p>

<p><code>javascript
if ( !type ) {
    for ( type in events ) {
        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
    }
    continue;
}
</code>
如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>

<p><code>javascript
special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
origCount = j = handlers.length;
while ( j-- ) {
    //详细删除代码
}
</code>
这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>

<p>```javascript
handleObj = handlers[ j ];
if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
    ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
    ( !selector || selector === handleObj.selector || selector === “**” &amp;&amp; handleObj.selector ) ) {
    handlers.splice( j, 1 );</p>

<pre><code>if ( handleObj.selector ) {
    handlers.delegateCount--;
}
if ( special.remove ) {
    special.remove.call( elem, handleObj );
} } ``` 这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了
</code></pre>

<p><code>javascript
if ( origCount &amp;&amp; !handlers.length ) {
    if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
        jQuery.removeEvent( elem, type, elemData.handle );
    }
    delete events[ type ];
}
</code>
这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>

<p><code>javascript
if ( jQuery.isEmptyObject( events ) ) {
    delete elemData.handle;
    data_priv.remove( elem, "events" );
}
</code>
如果节点中没有任何事件了，直接释放掉事件存储空间</p>

<h3 id="trigger-event-data-elem-onlyhandlers">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>

<p>```javascript
var i, cur, tmp, bubbleType, ontype, handle, special,
    eventPath = [ elem || document ],
    type = hasOwn.call( event, “type” ) ? event.type : event,
    namespaces = hasOwn.call( event, “namespace” ) ? event.namespace.split(“.”) : [];</p>

<table>
  <tbody>
    <tr>
      <td>cur = tmp = elem = elem</td>
      <td> </td>
      <td>document;</td>
    </tr>
  </tbody>
</table>

<p>if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
    return;
}
```
做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>

<p><code>javascript
if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    return;
}
</code>
检测是否有focus和blur事件，它们不会在这里被触发</p>

<p><code>javascript
if ( type.indexOf(".") &gt;= 0 ) {
    namespaces = type.split(".");
    type = namespaces.shift();
    namespaces.sort();
}
ontype = type.indexOf(":") &lt; 0 &amp;&amp; "on" + type;
</code>
获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>

<p>```javascript
event = event[ jQuery.expando ] ?
    event :
    new jQuery.Event( type, typeof event === “object” &amp;&amp; event );</p>

<p>event.isTrigger = onlyHandlers ? 2 : 3;
event.namespace = namespaces.join(“.”);
event.namespace_re = event.namespace ?
    new RegExp( “(^|\.)” + namespaces.join(“\.(?:.*\.|)”) + “(\.|$)” ) :
    null;</p>

<p>event.result = undefined;
if ( !event.target ) {
    event.target = elem;
}
```
常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:
1. isTrigger: 判断是否需要出发浏览器本身的事件回调
2. namespace: 事件的命名空间
3. namespace_re: 一个用于匹配当前命名空间的正则
4. result: 事件运行的结果
5. target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</p>

<p>事件对象的具体实现，后面会说</p>

<p>```javascript
data = data == null ?
    [ event ] :
    jQuery.makeArray( data, [ event ] );</p>

<p>special = jQuery.event.special[ type ] || {};
if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
    return;
}
```
将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>

<p>```javascript
if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {
    /<em>如果是特殊事件，需要找到对应的真实名称</em>/
    bubbleType = special.delegateType || type;
    if ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
    }
    for ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
    }</p>

<pre><code>// Only add window if we got to document (e.g., not plain obj or detached DOM)
if ( tmp === (elem.ownerDocument || document) ) {
    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
} } ``` jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过`elem.parentNode`来获取元素到window的路径
</code></pre>

<p>```javascript
i = 0;
while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {
    event.type = i &gt; 1 ?
        bubbleType :
        special.bindType || type;</p>

<pre><code>handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, "handle" );
if ( handle ) {
    handle.apply( cur, data );
}

handle = ontype &amp;&amp; cur[ ontype ];
if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {
    event.result = handle.apply( cur, data );
    if ( event.result === false ) {
        event.preventDefault();
    }
} } event.type = type; ``` 顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault
</code></pre>

<p><code>javascript
if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
    if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;
        jQuery.acceptData( elem ) ) {
        if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {
            tmp = elem[ ontype ];
            if ( tmp ) {
                elem[ ontype ] = null;
            }
            jQuery.event.triggered = type;
            elem[ type ]();
            jQuery.event.triggered = undefined;
            if ( tmp ) {
                elem[ ontype ] = tmp;
            }
        }
    }
}
</code>
onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>

<p><code>javascript
return event.result;
</code>
运行完了，返回事件运行的结果</p>

<h3 id="dispatch-event">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：
1. 事件代理的情况
2. 特殊事件
3. 回调终止（stopPropagation）
4. 事件的命名空间</p>

<p>```javascript
event = jQuery.event.fix( event );</p>

<p>var i, j, ret, matched, handleObj,
    handlerQueue = [],
    args = slice.call( arguments ),
    handlers = ( data_priv.get( this, “events” ) || {} )[ event.type ] || [],
    special = jQuery.event.special[ event.type ] || {};</p>

<p>args[0] = event;
event.delegateTarget = this;
```
这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>

<p><code>javascript
if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
    return;
}
</code>
钩子你好，钩子再见…这次是preDispatch钩子…</p>

<p><code>javascript
handlerQueue = jQuery.event.handlers.call( this, event, handlers );
</code>
将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>

<p><code>javascript
i = 0;
while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {
    event.currentTarget = matched.elem;
    j = 0;
    while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {
        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                    .apply( matched.elem, args );
            if ( ret !== undefined ) {
                if ( (event.result = ret) === false ) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
}
</code>
遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>

<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>

<p><code>javascript
if ( special.postDispatch ) {
    special.postDispatch.call( this, event );
}
return event.result;
</code>
钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>

<h3 id="handlers-event-handlers">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>

<p><code>javascript
var i, matches, sel, handleObj,
    handlerQueue = [],
    delegateCount = handlers.delegateCount,
    cur = event.target;
</code>
获取当前事件的目标和代理个数</p>

<p><code>javascript
//如果存在代理
if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== "click") ) {
    //从被代理元素冒泡到代理元素
    for ( ; cur !== this; cur = cur.parentNode || this ) {
        //屏蔽disable元素的点击事件
        if ( cur.disabled !== true || event.type !== "click" ) {
            //cur元素需要执行的回调对象列表
            matches = [];
            //获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行
            for ( i = 0; i &lt; delegateCount; i++ ) {
                handleObj = handlers[ i ];
                sel = handleObj.selector + " ";
                //判断元素是否符合选择器,这里还进行了缓存防止重复判断
                if ( matches[ sel ] === undefined ) {
                    matches[ sel ] = handleObj.needsContext ?
                        jQuery( sel, this ).index( cur ) &gt;= 0 :
                        jQuery.find( sel, this, null, [ cur ] ).length;
                }
                //如果符合,说明cur元素需要执行这个回调,加到列表中
                if ( matches[ sel ] ) {
                    matches.push( handleObj );
                }
            }
            //如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中
            if ( matches.length ) {
                handlerQueue.push({ elem: cur, handlers: matches });
            }
        }
    }
}
</code>
真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>

<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>

<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>

<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>

<p><code>javascript
if ( delegateCount &lt; handlers.length ) {
    handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
}
return handlerQueue;
</code>
对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>

<h2 id="section-2">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/12/read-jq-src-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的事件机制——核心篇 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/12/read-jq-src-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 12 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h1 id="jquery">jQuery源码——事件机制</h1>
<p>jQuery提供了一套完善的事件管理机制，这一整套事件管理机制构建在jQuery的data之上，使用元素的私有数据域来保存事件的相关配置和回调函数列表。jQuery提供了自定义事件的处理，并模拟了事件的冒泡机制。通过冒泡机制，提供了一套事件代理接口</p>

<h2 id="section">事件管理器</h2>
<p>jQuery提供一个<code>jQuery.event</code>的辅助类，它提供了一系列管理事件的方法。主题思想来自Dean Edwards的库。事实上，事件亦无外乎CRUD操作，只不过多了个触发操作（实际上属于R操作的一种），这个辅助类提供了add、remove、trigger、dispatch几个核心方法用添加、删除、触发事件、执行回调函数等功能，另外还提供了一些钩子和辅助函数用于兼容一些特殊事件</p>

<h3 id="global">global</h3>
<p>存放事件是否存在</p>

<h3 id="add-elem-types-handler-data-selector">add (elem, types, handler, data, selector)</h3>
<p>这个函数用于绑定对应的事件，整体思路大致是：确定事件在元素的私有数据空间中是否存在，如果不存在就创建，创建时为事件绑定一个回调函数，里面使用dispatch执行事件的回调函数列表</p>

<p>所以代码大致流程如下：
####事件创建逻辑
在元素么有绑定过这个事件，或者压根没有绑定过事件时，需要创建事件的对应存储空间以及事件的统一回调函数</p>

<p>```javascript
var handleObjIn, eventHandle, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.get( elem );</p>

<p>if ( !elemData ) {
    return;
}
```
获取元素的私有数据空间，如果无法获得私有数据空间，说明是文本节点或注释节点，那么也无法绑定时间了，直接返回</p>

<p><code>javascript
if ( handler.handler ) {
    handleObjIn = handler;
    handler = handleObjIn.handler;
    selector = handleObjIn.selector;
}
</code>
接着确定配置中的回调函数，如果存在事件代理，需要确定需要被代理的元素的选择器</p>

<p><code>javascript
if ( !handler.guid ) {
    handler.guid = jQuery.guid++;
}
</code>
为回调函数创建一个唯一的id来提供优化，实际上还是通过jQuery的guid得到</p>

<p><code>javascript
if ( !(events = elemData.events) ) {
    events = elemData.events = {};
}
if ( !(eventHandle = elemData.handle) ) {
    eventHandle = elemData.handle = function( e ) {
        return typeof jQuery !== strundefined &amp;&amp; jQuery.event.triggered !== e.type ?
            jQuery.event.dispatch.apply( elem, arguments ) : undefined;
    };
}
</code>
从元素的私有数据空间中获取存放事件的对象，如果不存在就新建一个。然后从元素的私有数据中获取事件处理函数，如果没有，就新建一个函数。每一个事件对应一个回调函数，这个回调函数使用dispatch方法来执行事件的回调函数列表中的所有函数</p>

<h4 id="section-1">事件绑定逻辑</h4>
<p>在创建完事件的存储空间，或者获取到已有的存储空间之后，就需要把往事件的回调函数列表中添加事件了。这里需要处理的问题包括：
1. type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件
2. 有可能存在命名空间如<code>event.namespace</code>的情况
3. 特殊事件需要进行名称转换，以及钩子调用
4. 如果是事件代理也需要注意代理逻辑</p>

<p><code>javascript
types = ( types || "" ).match( rnotwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
    //后面的代码
}
</code>
处理情况1，通过切分将多个事件名称切分出来，分别进行处理</p>

<p>```javascript
tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[1];
namespaces = ( tmp[2] || “” ).split( “.” ).sort();</p>

<p>if ( !type ) {
    continue;
}
```
处理情况2，同样是使用正则获取到命名空间和事件名称，如果获取不到事件名称，那么直接continue略过</p>

<p>```javascript
special = jQuery.event.special[ type ] || {};</p>

<table>
  <tbody>
    <tr>
      <td>type = ( selector ? special.delegateType : special.bindType )</td>
      <td> </td>
      <td>type;</td>
    </tr>
  </tbody>
</table>

<p>special = jQuery.event.special[ type ] || {};
```
情况3下，如果事件是特殊事件，需要获取特殊事件需要被映射的事件名称</p>

<p><code>javascript
handleObj = jQuery.extend({
    type: type,
    origType: origType,
    data: data,
    handler: handler,
    guid: handler.guid,
    selector: selector,
    needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
    namespace: namespaces.join(".")
}, handleObjIn );
</code>
这里将回调函数封装成带有配置的回调对象，方便后续的删除、查找等操作。这里记录了很多信息：
1. type：事件的映射后的名称
2. origType：事件的原始名称
3. data：事件的默认数据
4. handler：回调函数
5. guid：回调函数的id
6. selector：启用事件代理时，被代理的节点的选择器
7. needsContext：如果是事件代理模式，通过Sizzle判断元素是否需要上下文
8. namespace：重组后的命名空间</p>

<p>```javascript
if ( !(handlers = events[ type ]) ) {
    handlers = events[ type ] = [];
    handlers.delegateCount = 0;</p>

<pre><code>if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
    if ( elem.addEventListener ) {
        elem.addEventListener( type, eventHandle, false );
    }
} } ``` 如果这个事件刚注册，给它一个回调对象列表，并设定代理数为0。在情况3下，需要处理setup钩子
</code></pre>

<p>```javascript
if ( special.add ) {
    special.add.call( elem, handleObj );</p>

<pre><code>if ( !handleObj.handler.guid ) {
    handleObj.handler.guid = handler.guid;
} } ``` 这里同样是情况3下的钩子处理，上面setup是事件注册钩子，而这里则是方法添加的钩子
</code></pre>

<p><code>javascript
if ( selector ) {
    handlers.splice( handlers.delegateCount++, 0, handleObj );
} else {
    handlers.push( handleObj );
}
</code>
好了，该玩的钩子都玩完了，将回调对象加入到回调对象列表中吧，这里需要处理情况4，如果是事件代理的话，元素的代理数增加，如果是代理情况，代理的回调对象加载列表前头</p>

<p><code>javascript
jQuery.event.global[ type ] = true;
</code>
最后再全局中标记一下事件已存在就行了</p>

<h3 id="remove-elem-types-handler-selector-mappedtypes">remove (elem, types, handler, selector, mappedTypes)</h3>
<p>删除逻辑也一样，从一个节点的事件存储中删除一个或个事件的一个回调或所有回调，这里同样需要考虑几个地方：
1. type字符串中可以通过<code>event1 event2 event3</code>这样的方式包含多个事件
2. 有可能存在命名空间如<code>event.namespace</code>的情况
3. 特殊事件需要进行名称转换，以及钩子调用
4. 如果是事件代理也需要注意代理逻辑
5. 在移除了一个事件的所有回调对象后，可以移除这个事件
6. 在移除了一个元素的所有事件后，可以释放这个元素的事件存储空间了</p>

<p><code>javascript
var j, origCount, tmp,
    events, t, handleObj,
    special, handlers, type, namespaces, origType,
    elemData = data_priv.hasData( elem ) &amp;&amp; data_priv.get( elem );
if ( !elemData || !(events = elemData.events) ) {
    return;
}
</code>
获取元素的私有数据空间以及其事件存储空间，如果没有，那没必要删除了</p>

<p><code>javascript
types = ( types || "" ).match( rnotwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
    //后面的代码
}
</code>
处理情况1，和上面的add一样</p>

<p>```javascript
tmp = rtypenamespace.exec( types[t] ) || [];
type = origType = tmp[1];</p>

<p>namespaces = ( tmp[2] || “” ).split( “.” ).sort();
```
获取事件的命名空间，和add方法一样</p>

<p><code>javascript
if ( !type ) {
    for ( type in events ) {
        jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
    }
    continue;
}
</code>
如果没有获取到事件名称，就得遍历事件存储空间中所有的事件删除handler对应的方法了，这里直接递归了</p>

<p><code>javascript
special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
origCount = j = handlers.length;
while ( j-- ) {
    //详细删除代码
}
</code>
这里处理了情况3和4，和add中一样，获取了事件需要被映射的名称，然后通过这个名称获取了事件回调对象列表。然后我们可以遍历回调函谁对象列表，进行删除操作了</p>

<p>```javascript
handleObj = handlers[ j ];
if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
    ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
    ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp;
    ( !selector || selector === handleObj.selector || selector === “**” &amp;&amp; handleObj.selector ) ) {
    handlers.splice( j, 1 );</p>

<pre><code>if ( handleObj.selector ) {
    handlers.delegateCount--;
}
if ( special.remove ) {
    special.remove.call( elem, handleObj );
} } ``` 这里就是删除的真正代码了，需要判断代理，判断命名空间，判断方法的guid，如果有map映射，判断名称。所有判断都通过之后，使用数组的splice进行删除。另外在删除之后，如果有代理，代理个数自然要减一，而如果是特殊事件，需要弟阿勇remove钩子了
</code></pre>

<p><code>javascript
if ( origCount &amp;&amp; !handlers.length ) {
    if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
        jQuery.removeEvent( elem, type, elemData.handle );
    }
    delete events[ type ];
}
</code>
这里处理情况5，如果事件的回调函数列表为空，那么可以delete掉这个事件了。特殊事件依旧有钩子，调用teardown</p>

<p><code>javascript
if ( jQuery.isEmptyObject( events ) ) {
    delete elemData.handle;
    data_priv.remove( elem, "events" );
}
</code>
如果节点中没有任何事件了，直接释放掉事件存储空间</p>

<h3 id="trigger-event-data-elem-onlyhandlers">trigger (event, data, elem, onlyHandlers)</h3>
<p>触发事件的方法，这里模拟了事件的冒泡机制，并且兼容了onXXX绑定的事件回调函数，另外还处理了preventDefault的情况</p>

<p>```javascript
var i, cur, tmp, bubbleType, ontype, handle, special,
    eventPath = [ elem || document ],
    type = hasOwn.call( event, “type” ) ? event.type : event,
    namespaces = hasOwn.call( event, “namespace” ) ? event.namespace.split(“.”) : [];</p>

<table>
  <tbody>
    <tr>
      <td>cur = tmp = elem = elem</td>
      <td> </td>
      <td>document;</td>
    </tr>
  </tbody>
</table>

<p>if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
    return;
}
```
做了一些准备工作，获取了事件的命名空间，初始化了冒泡的路径，如果没有提供trigger的元素则默认document，另外文本和注释节点无法触发事件</p>

<p><code>javascript
if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    return;
}
</code>
检测是否有focus和blur事件，它们不会在这里被触发</p>

<p><code>javascript
if ( type.indexOf(".") &gt;= 0 ) {
    namespaces = type.split(".");
    type = namespaces.shift();
    namespaces.sort();
}
ontype = type.indexOf(":") &lt; 0 &amp;&amp; "on" + type;
</code>
获取事件的名称和命名空间，另外还需要生成一个带on开头的事件名称，方便在兼容onXXX时使用</p>

<p>```javascript
event = event[ jQuery.expando ] ?
    event :
    new jQuery.Event( type, typeof event === “object” &amp;&amp; event );</p>

<p>event.isTrigger = onlyHandlers ? 2 : 3;
event.namespace = namespaces.join(“.”);
event.namespace_re = event.namespace ?
    new RegExp( “(^|\.)” + namespaces.join(“\.(?:.*\.|)”) + “(\.|$)” ) :
    null;</p>

<p>event.result = undefined;
if ( !event.target ) {
    event.target = elem;
}
```
常使用事件的都会使用event这个事件对象，jq模拟的事件机制也是一样，不过它自己新建了一个事件对象。这个事件对象包裹了浏览器原生的事件对象，并添加了很多其他的属性:
1. isTrigger: 判断是否需要出发浏览器本身的事件回调
2. namespace: 事件的命名空间
3. namespace_re: 一个用于匹配当前命名空间的正则
4. result: 事件运行的结果
5. target：触发事件的元素，需要注意的是事件代理情况下，target是被代理的元素</p>

<p>事件对象的具体实现，后面会说</p>

<p>```javascript
data = data == null ?
    [ event ] :
    jQuery.makeArray( data, [ event ] );</p>

<p>special = jQuery.event.special[ type ] || {};
if ( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
    return;
}
```
将event和data进行包裹，装成一个数组方便后面apply调用。这里处理了一下特殊事件，调用了其trigger钩子</p>

<p>```javascript
if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {
    /<em>如果是特殊事件，需要找到对应的真实名称</em>/
    bubbleType = special.delegateType || type;
    if ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
    }
    for ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
    }</p>

<pre><code>// Only add window if we got to document (e.g., not plain obj or detached DOM)
if ( tmp === (elem.ownerDocument || document) ) {
    eventPath.push( tmp.defaultView || tmp.parentWindow || window );
} } ``` jq为除了不需要冒泡的特殊事件或者本身就在window上触发的事件以外的情况都模拟了冒泡机制。这里就是不断通过`elem.parentNode`来获取元素到window的路径
</code></pre>

<p>```javascript
i = 0;
while ( (cur = eventPath[i++]) &amp;&amp; !event.isPropagationStopped() ) {
    event.type = i &gt; 1 ?
        bubbleType :
        special.bindType || type;</p>

<pre><code>handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] &amp;&amp; data_priv.get( cur, "handle" );
if ( handle ) {
    handle.apply( cur, data );
}

handle = ontype &amp;&amp; cur[ ontype ];
if ( handle &amp;&amp; handle.apply &amp;&amp; jQuery.acceptData( cur ) ) {
    event.result = handle.apply( cur, data );
    if ( event.result === false ) {
        event.preventDefault();
    }
} } event.type = type; ``` 顺着上面生成的冒泡路径依次执行事件绑定的统一回调函数（实际上就是dispatch）。这里首先需要从私有数据空间中获取到需要执行的具体方法，然后使用apply调用。另外，如果元素有通过onXXX绑定方法，也需要执行。另外如果执行的结果为false，调用事件对象的preventDefault
</code></pre>

<p><code>javascript
if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
    if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &amp;&amp;
        jQuery.acceptData( elem ) ) {
        if ( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) {
            tmp = elem[ ontype ];
            if ( tmp ) {
                elem[ ontype ] = null;
            }
            jQuery.event.triggered = type;
            elem[ type ]();
            jQuery.event.triggered = undefined;
            if ( tmp ) {
                elem[ ontype ] = tmp;
            }
        }
    }
}
</code>
onlyHandlers参数为true或事件被调用preventDefault方法，不需要执行事件在浏览器上的默认行为。不符合上述情况时，就需要检测浏览器默认行为来执行了。这里通过检测元素的onXXX属性来获得方法，在执行前需要标记事件已被执行，并在执行后恢复，防止多次触发</p>

<p><code>javascript
return event.result;
</code>
运行完了，返回事件运行的结果</p>

<h3 id="dispatch-event">dispatch (event)</h3>
<p>可以看到trigger内部并没有遍历回调对象列表来挨个执行回调函数的逻辑，其内部只是运行一个在add中创建的统一回调函数。从add中我们可以看到，统一回调函数中的逻辑实际上就是调用dispatch方法。dispatch方法同样需要注意几个问题：
1. 事件代理的情况
2. 特殊事件
3. 回调终止（stopPropagation）
4. 事件的命名空间</p>

<p>```javascript
event = jQuery.event.fix( event );</p>

<p>var i, j, ret, matched, handleObj,
    handlerQueue = [],
    args = slice.call( arguments ),
    handlers = ( data_priv.get( this, “events” ) || {} )[ event.type ] || [],
    special = jQuery.event.special[ event.type ] || {};</p>

<p>args[0] = event;
event.delegateTarget = this;
```
这里首先通过后面的fix工具方法，加工了一下事件对象。从私有数据空间中获得了回调对象列表。另外这里处理了事件代理的情况，可以看到delegateTarget指向触发事件的元素</p>

<p><code>javascript
if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
    return;
}
</code>
钩子你好，钩子再见…这次是preDispatch钩子…</p>

<p><code>javascript
handlerQueue = jQuery.event.handlers.call( this, event, handlers );
</code>
将回调对象列表进行加工，将在后面的handlers方法中详细介绍，主要是处理事件代理时的情况。</p>

<p><code>javascript
i = 0;
while ( (matched = handlerQueue[ i++ ]) &amp;&amp; !event.isPropagationStopped() ) {
    event.currentTarget = matched.elem;
    j = 0;
    while ( (handleObj = matched.handlers[ j++ ]) &amp;&amp; !event.isImmediatePropagationStopped() ) {
        if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                    .apply( matched.elem, args );
            if ( ret !== undefined ) {
                if ( (event.result = ret) === false ) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }
        }
    }
}
</code>
遍历执行handlers方法处理过的回调对象列表，这里需要考虑回调执行被终止的情况。如果上一方法已经运行了stopPropagation方法终止回调执行，直接循环就可以结束了。另外如果命名空间不符合，也不会执行。</p>

<p>执行时其实就是将事件对象拿出来apply一下，然后判断返回值，如果为false，终止回调执行，也不执行浏览器默认行为</p>

<p><code>javascript
if ( special.postDispatch ) {
    special.postDispatch.call( this, event );
}
return event.result;
</code>
钩子你又来了，这次是postDispatch钩子。全部运行完就可以返回了</p>

<h3 id="handlers-event-handlers">handlers (event, handlers)</h3>
<p>上面dispatch有提到过使用handlers回调对象列表的加工来处理事件代理的情况。jq的事件代理的观念是使用上和一般事件没有差别。这里依旧需要模拟事件的冒泡机制。这里的冒泡和trigger中的冒泡不同，trigger中的冒泡是从代理的元素（父元素）从上冒泡，而如果使用代理的话，被代理的元素（子元素）到代理元素（父元素）这一段将没有冒泡。这里的冒泡实现就是解决这个问题，只处理了被代理的元素到代理元素的冒泡。handlers最后会将冒泡的元素和回调对象组合成一个新的对象列表进行返回</p>

<p><code>javascript
var i, matches, sel, handleObj,
    handlerQueue = [],
    delegateCount = handlers.delegateCount,
    cur = event.target;
</code>
获取当前事件的目标和代理个数</p>

<p><code>javascript
//如果存在代理
if ( delegateCount &amp;&amp; cur.nodeType &amp;&amp; (!event.button || event.type !== "click") ) {
    //从被代理元素冒泡到代理元素
    for ( ; cur !== this; cur = cur.parentNode || this ) {
        //屏蔽disable元素的点击事件
        if ( cur.disabled !== true || event.type !== "click" ) {
            //cur元素需要执行的回调对象列表
            matches = [];
            //获取回调对象列表中的所有代理回调对象,挨个判断是否需要执行
            for ( i = 0; i &lt; delegateCount; i++ ) {
                handleObj = handlers[ i ];
                sel = handleObj.selector + " ";
                //判断元素是否符合选择器,这里还进行了缓存防止重复判断
                if ( matches[ sel ] === undefined ) {
                    matches[ sel ] = handleObj.needsContext ?
                        jQuery( sel, this ).index( cur ) &gt;= 0 :
                        jQuery.find( sel, this, null, [ cur ] ).length;
                }
                //如果符合,说明cur元素需要执行这个回调,加到列表中
                if ( matches[ sel ] ) {
                    matches.push( handleObj );
                }
            }
            //如果cur元素有需要执行的回调,进行包装,加到包装后的回调对象列表中
            if ( matches.length ) {
                handlerQueue.push({ elem: cur, handlers: matches });
            }
        }
    }
}
</code>
真正模拟冒泡的方法，这里过滤掉了disable元素的click事件</p>

<p>看for循环的终止条件中，看到cur是冒泡到的当前元素，而this中存放的是触发事件的真正元素（代理元素），这里用<code>cur !== this</code>判断循环终止，说明冒泡只从被代理的元素运行到代理元素</p>

<p>首先我们要知道，在add时，如果使用了代理的方式，会将代理的回调函数放在回调对象列表（这里是handlers）的前面而不是后面，具体的个数会使用delegateCount记录。这里对回调对象列表中的每个回调对象，会判断元素是否符合selector选择器，如果符合，就添加回调对象到matches中。这里还用了一点小技巧缓存了判断结果。</p>

<p>对于冒泡路径上的每个元素，都会确定其需要执行的回调对象的列表。将元素和其需要执行的回调对象列表进行封装，成为一个新的对象，其中有elem表示冒泡的当前元素，以及handlers表明回调函数对象列表。将这些新对象组织成一个经过加工的回调对象列表。</p>

<p><code>javascript
if ( delegateCount &lt; handlers.length ) {
    handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
}
return handlerQueue;
</code>
对于不使用事件代理的情况，直接将它们按照同样的格式生成新对象后，push到经过加工的回调对象列表后面，就可以得到完整的回调函数列表了</p>

<h2 id="section-2">总结</h2>
<p>事件管理器这块基本上包含了jq的事件机制的所有核心思想，事件代理、自定事件模拟的冒泡、特殊函数的处理，命名空间的处理等等。事件代理的冒泡机制和trigger中的冒泡需要注意理解，而特殊函数的钩子模式可以说贯穿jQuery始终。由于篇幅太长，这里并没有介绍jq的事件对象，以及一些像fix方法，这些将在下一篇进行介绍</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/12/read-jq-src-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的数据缓存 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/10/read-jq-src-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 10 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="jquery">jQuery的数据缓存简介</h2>
<p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>

<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>

<h2 id="jq">jq中数据缓存的限制</h2>
<p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据
<code>javascript
jQuery.acceptData = function( owner ) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};
</code></p>

<h2 id="section">数据对象</h2>
<p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为
<code>javascript
function Data() {
    /*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/
    Object.defineProperty( this.cache = {}, 0, {
        get: function() {
            return {};
        }
    });
    /*为这个数据对象添上jQuery版本号+随机数的版本号*/
    this.expando = jQuery.expando + Math.random();
}
</code></p>

<h3 id="section-1">静态方法和属性</h3>
<p>####uid
数据对象的id，自增
####accepts
判断是否能够接受数据，直接指向之前的acceptData</p>

<h3 id="section-2">核心方法</h3>
<p>####key (owner)
owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>

<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>

<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>

<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>

<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>

<p><code>javascript
key: function( owner ) {
    /*如果这个所有者不能接收数据，返回0*/
    if ( !Data.accepts( owner ) ) {
        return 0;
    }
    var descriptor = {},
        /*获取这个所有者已经有这个版本的数据的id*/
        unlock = owner[ this.expando ];
    /*如果这个所有者没有对应的数据对象，那么创建一个*/
    if ( !unlock ) {
        /*自增的uid*/
        unlock = Data.uid++;
        /*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/
        try {
            descriptor[ this.expando ] = { value: unlock };
            Object.defineProperties( owner, descriptor );
        /*如果不能使用Object.defineProperites，那么直接使用extend*/
        } catch ( e ) {
            descriptor[ this.expando ] = unlock;
            jQuery.extend( owner, descriptor );
        }
    }
    /*在cache中创建对象的数据空间*/
    if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
    }
    /*返回这个新的id*/
    return unlock;
},
</code></p>

<h4 id="set-owner-data-value">set (owner, data, value)</h4>
<p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>

<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>

<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>

<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>

<p>```javascript
/<em>加入数据（往cache中加数据）</em>/
set: function( owner, data, value ) {
    var prop,
        /<em>首先获得这个所有者的id（没有就新建一个）</em>/
        unlock = this.key( owner ),
        /<em>获得这个数据对象对应的cache内的空间</em>/
        cache = this.cache[ unlock ];</p>

<pre><code>/*如果数据时string直接写进去*/
if ( typeof data === "string" ) {
    cache[ data ] = value;

/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/
} else {
    if ( jQuery.isEmptyObject( cache ) ) {
        jQuery.extend( this.cache[ unlock ], data );
    } else {
        for ( prop in data ) {
            cache[ prop ] = data[ prop ];
        }
    }
}
return cache; }, ```
</code></pre>

<h4 id="get-owner-key">get (owner, key)</h4>
<p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>

<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>

<p><code>javascript
/*获取数据（从cache中取数据）*/
get: function( owner, key ) {
    /*通过owner获取id，从cache中获取在对应的完整缓存对象*/
    var cache = this.cache[ this.key( owner ) ];
    /*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/
    return key === undefined ?
        cache : cache[ key ];
},
</code></p>

<h4 id="access-owner-key-value">access (owner, key, value)</h4>
<p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>

<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：
1. 如果没有key和value，那么使用get方法获取整个数据空间对象
2. 如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值
3. 如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中
4. 如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</p>

<p>```javascript
access: function( owner, key, value ) {
    var stored;
    if ( key === undefined ||
            ((key &amp;&amp; typeof key === “string”) &amp;&amp; value === undefined) ) {</p>

<pre><code>    stored = this.get( owner, key );

    return stored !== undefined ?
        stored : this.get( owner, jQuery.camelCase(key) );
}

this.set( owner, key, value );

return value !== undefined ? value : key; }, ```
</code></pre>

<h4 id="remove-owner-key">remove (owner, key)</h4>
<p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>

<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>

<p><code>javascript
/*从owner移除属性 */
remove: function( owner, key ) {
    var i, name, camel,
        unlock = this.key( owner ),
        cache = this.cache[ unlock ];
    /*如果没有key，移除整个owner所拥有的缓存*/
    if ( key === undefined ) {
        this.cache[ unlock ] = {};
    } else {
        // Support array or space separated string of keys
        /*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/
        if ( jQuery.isArray( key ) ) {
            name = key.concat( key.map( jQuery.camelCase ) );
        } else {
            /*如果key不是数组，将key转成驼峰*/
            camel = jQuery.camelCase( key );
            /*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/
            if ( key in cache ) {
                name = [ key, camel ];
            } else {
                /*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/
                name = camel;
                /*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/
                name = name in cache ?
                    [ name ] : ( name.match( rnotwhite ) || [] );
            }
        }
        /*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/
        i = name.length;
        while ( i-- ) {
            delete cache[ name[ i ] ];
        }
    }
},
</code></p>

<h4 id="hasdata-owner">hasData (owner)</h4>
<p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象
<code>javascript
/*判断是否存在数据*/
hasData: function( owner ) {
    /*判断缓存对象是否是空对象*/
    return !jQuery.isEmptyObject(
        this.cache[ owner[ this.expando ] ] || {}
    );
},
</code></p>

<h4 id="discard-owner">discard (owner)</h4>
<p>移除掉owner的所有缓存，直接在cache上用delete删
<code>javascript
/*移除整个缓存对象*/
discard: function( owner ) {
    if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
    }
}
</code></p>

<h3 id="section-3">数据对象创建</h3>
<p><code>javascript
/*私有数据对象*/
var data_priv = new Data();
/*公有数据对象*/
var data_user = new Data();
</code></p>

<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>

<h2 id="jquery-1">jQuery对数据对象操作接口</h2>
<p>###dataAttr方法
事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>

<p>```javscript
function dataAttr( elem, key, data ) {
    var name;</p>

<pre><code>/*如果没有data，而元素为element类型*/
if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {

    /*从data-xxx属性中获取数据*/
    name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    data = elem.getAttribute( name );
    /*如果对象是字符串，分别尝试转成true、false、null，如果使用{}包裹，当做JSON解析*/
    if ( typeof data === "string" ) {
        try {
            data = data === "true" ? true :
                data === "false" ? false :
                data === "null" ? null :
                // Only convert to a number if it doesn't change the string
                +data + "" === data ? +data :
                rbrace.test( data ) ? jQuery.parseJSON( data ) :
                data;
        } catch( e ) {}

        /*写入到公共数据对象中*/
        data_user.set( elem, key, data );
    } else {
        data = undefined;
    }
}
return data; } ```
</code></pre>

<h3 id="section-4">静态方法</h3>
<p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>

<h4 id="hasdata-elem">hasData (elem)</h4>
<p>判断元素是否含有数据，这里会检测公有数据和私有数据
<code>javascript
hasData: function( elem ) {
    return data_user.hasData( elem ) || data_priv.hasData( elem );
},
</code>
####data (elem, name, data)
通过数据对象的access方法获得或写入数据，只操作公有数据对象
<code>javascript
data: function( elem, name, data ) {
    return data_user.access( elem, name, data );
},
</code>
####removeData (elem, name)
从数据对象移除数据，只操作公有数据对象
<code>javascript
removeData: function( elem, name ) {
    data_user.remove( elem, name );
},
</code>
####_data (elem, name, data)
通过数据对象的access方法获得或写入数据，只操作私有数据对象
<code>javascript
_data: function( elem, name, data ) {
    return data_priv.access( elem, name, data );
},
</code>
####_removeData (elem, name)
从数据对象移除数据，只操作私有数据对象
<code>javascript
_removeData: function( elem, name ) {
    data_priv.remove( elem, name );
}
</code></p>

<h3 id="jq-1">在jq对象上添加数据对象操作方法</h3>
<p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>

<h4 id="data-key-value">data (key, value)</h4>
<p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：
1. 如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象
2. 如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象
3. 否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</p>

<p>```javascript
data: function( key, value ) {
    var i, name, data,
        elem = this[ 0 ],
        attrs = elem &amp;&amp; elem.attributes;</p>

<pre><code>/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/
if ( key === undefined ) {
    /*jq对象中有节点*/
    if ( this.length ) {
        /*第一个节点的数据*/
        data = data_user.get( elem );
        /*如果节点为element类型且私有数据中没有标记hasDataAttrs
        将节点中的所有data-类型的属性写入到公共数据中
        然后在私有数据中设定hasDataAttrs为true*/
        if ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, "hasDataAttrs" ) ) {
            i = attrs.length;
            while ( i-- ) {
                name = attrs[ i ].name;

                if ( name.indexOf( "data-" ) === 0 ) {
                    name = jQuery.camelCase( name.slice(5) );
                    dataAttr( elem, name, data[ name ] );
                }
            }
            data_priv.set( elem, "hasDataAttrs", true );
        }
    }

    return data;
}

/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/
if ( typeof key === "object" ) {
    return this.each(function() {
        data_user.set( this, key );
    });
}
/*通过access判断*/
return access( this, function( value ) {
    var data,
        /*生成驼峰的key*/
        camelKey = jQuery.camelCase( key );
    /*如果jq对象中有元素，且没有value，说明调用get获取数据*/
    if ( elem &amp;&amp; value === undefined ) {
        /*直接使用key获取*/
        data = data_user.get( elem, key );
        if ( data !== undefined ) {
            return data;
        }
        /*如果直接用key未能获取导数据，尝试驼峰格式的key*/
        data = data_user.get( elem, camelKey );
        if ( data !== undefined ) {
            return data;
        }

        /*如果还是无法获取，尝试从data-属性获取*/
        data = dataAttr( elem, camelKey, undefined );
        if ( data !== undefined ) {
            return data;
        }

        /*我们尝试了所有情况，但还是没有数据，返回undefined*/
        return;
    }

    /*写入数据*/
    this.each(function() {
        /*通过驼峰形式key获取公共数据*/
        var data = data_user.get( this, camelKey );
        /*往驼峰形式key中写入公共数据*/
        data_user.set( this, camelKey, value );

        /*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/
        if ( key.indexOf("-") !== -1 &amp;&amp; data !== undefined ) {
            data_user.set( this, key, value );
        }
    });
}, null, value, arguments.length &gt; 1, null, true ); }, ```
</code></pre>

<h4 id="removedata-key">removeData (key)</h4>
<p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了
<code>javascript
/*从公共数据中移除包含key（或key中元素）的键值对*/
removeData: function( key ) {
    return this.each(function() {
        data_user.remove( this, key );
    });
}
</code></p>

<h2 id="queuedequeue">为动画服务的queue和dequeue</h2>
<p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>

<h3 id="section-5">静态方法</h3>
<p>####queue (elem, type, data)
逻辑不复杂，也分读写两种情况。以<code>type + "queue"</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>

<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>

<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>

<p>```javascript
/<em>压入或读取一组数据</em>/
queue: function( elem, type, data ) {
    var queue;</p>

<pre><code>if ( elem ) {
    /*重命名一下type，默认叫fxqueue*/
    type = ( type || "fx" ) + "queue";
    /*从私有数据中获得已有的queue数据*/
    queue = data_priv.get( elem, type );

    /*如果存在data，需要写入数据*/
    if ( data ) {
        /*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/
        if ( !queue || jQuery.isArray( data ) ) {
            queue = data_priv.access( elem, type, jQuery.makeArray(data) );
        /*之前有数据，直接把data连在数据数组后头*/
        } else {
            queue.push( data );
        }
    }
    return queue || [];
} }, ```
</code></pre>

<h4 id="dequeue-elem-type">dequeue (elem, type)</h4>
<p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>

<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>

<p>```javascript
/<em>运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉</em>/
dequeue: function( elem, type ) {
    /<em>获取type，默认为fx</em>/
    type = type || “fx”;
    /<em>获取一组数据</em>/
    var queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        /<em>获取状态</em>/
        fn = queue.shift(),
        /<em>获取元素的钩子</em>/
        hooks = jQuery._queueHooks( elem, type ),
        next = function() {
            jQuery.dequeue( elem, type );
        };</p>

<pre><code>/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/
if ( fn === "inprogress" ) {
    fn = queue.shift();
    startLength--;
}
if ( fn ) {

    /*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/
    if ( type === "fx" ) {
        queue.unshift( "inprogress" );
    }

    /*删除掉钩子中的停止函数*/
    delete hooks.stop;
    /*在这个函数上调用，并提供钩子*/
    fn.call( elem, next, hooks );
}
/*如果队列已经空了，那么调用empty删除掉这个键值对*/
if ( !startLength &amp;&amp; hooks ) {
    hooks.empty.fire();
} }, ```
</code></pre>

<h4 id="queuehooks-elem-type">_queueHooks (elem, type)</h4>
<p>提供默认钩子的函数
<code>javascript
_queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: jQuery.Callbacks("once memory").add(function() {
            data_priv.remove( elem, [ type + "queue", key ] );
        })
    });
}
</code></p>

<h3 id="jqqueuedequeue">jq对象上的queue和dequeue</h3>
<p>####queue (type, data)
对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行
```javascript
queue: function( type, data ) {
        var setter = 2;</p>

<pre><code>    if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
    }

    if ( arguments.length &lt; setter ) {
        return jQuery.queue( this[0], type );
    }

    return data === undefined ?
        this :
        this.each(function() {
            var queue = jQuery.queue( this, type, data );

            // ensure a hooks for this queue
            jQuery._queueHooks( this, type );

            if ( type === "fx" &amp;&amp; queue[0] !== "inprogress" ) {
                jQuery.dequeue( this, type );
            }
        });
}, ```
</code></pre>

<h4 id="dequeue-type">dequeue (type)</h4>
<p>对jq对象中每个DOM元素执行dequeue操作</p>

<p><code>javascript
/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/
dequeue: function( type ) {
    return this.each(function() {
        jQuery.dequeue( this, type );
    });
},
</code></p>

<h4 id="clearqueue-type">clearQueue (type)</h4>
<p>清除jq对象中每个DOM的type对应的数据列表
<code>javascript
/*清除对应的类型的操作列表*/
clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
},
</code></p>

<h4 id="promise-type-obj">promise (type, obj)</h4>
<p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve
```javascript
/<em>创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象</em>/
promise: function( type, obj ) {
    var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
            if ( !( –count ) ) {
                defer.resolveWith( elements, [ elements ] );
            }
        };</p>

<pre><code>if ( typeof type !== "string" ) {
    obj = type;
    type = undefined;
}
type = type || "fx";

while ( i-- ) {
    tmp = data_priv.get( elements[ i ], type + "queueHooks" );
    if ( tmp &amp;&amp; tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
    }
}
resolve();
return defer.promise( obj ); } ```
</code></pre>

<h2 id="section-6">总结</h2>
<p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/10/read-jq-src-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的数据缓存 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/10/read-jq-src-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 10 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="jquery">jQuery的数据缓存简介</h2>
<p>jq中能使用data接口在节点上进行数据缓存，事实上jq将节点上的数据分成了两个部分：userData和privData，分别表示公有数据和私有数据。私有数据中存放了一些jq的其他功能需要使用的数据，比如自定义事件等等。而userData则存放jq使用者的数据。这两个数据区分别有自己的接口。</p>

<p>jq的数据并不是直接存在dom节点中的，jq把所有的数据集中放置在两个数据对象之中，dom节点里只有数据的id。获取或插入数据时，会根据id在数据对象中找到这个dom节点对应的区域，在上面操作。</p>

<h2 id="jq">jq中数据缓存的限制</h2>
<p>并不是所有对象或节点都能缓存数据，在<code>jQuery.acceptData</code>中给出了能够缓存数据的对象类型，只有element和document以及一般Object能够缓存数据
<code>javascript
jQuery.acceptData = function( owner ) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};
</code></p>

<h2 id="section">数据对象</h2>
<p>jq中专门有一个数据对象类Data，用于构造数据对象。私有对象和公有对象都是铜鼓哦这个构造函数创建出来的Data类实例，其构造函数为
<code>javascript
function Data() {
    /*老式浏览器中没有Object.preventExtensions和Object.freeze方法来限制堆对象的操作。返回一个新建的空对象，他们没有set方法*/
    Object.defineProperty( this.cache = {}, 0, {
        get: function() {
            return {};
        }
    });
    /*为这个数据对象添上jQuery版本号+随机数的版本号*/
    this.expando = jQuery.expando + Math.random();
}
</code></p>

<h3 id="section-1">静态方法和属性</h3>
<p>####uid
数据对象的id，自增
####accepts
判断是否能够接受数据，直接指向之前的acceptData</p>

<h3 id="section-2">核心方法</h3>
<p>####key (owner)
owner表示数据的所有者，这个方法返回这个所有者所拥有的数据id</p>

<p>这个方法中首先会判断owner能否接受数据数据，不能直接返回0</p>

<p>然后会创建一个descriptor用于在创建时作为辅助对象，并尝试获取owner的当前jq版本的数据id，放在unlock变量中</p>

<p>如果这个unlock不存在，说明这个owner没有当前版本的数据缓存，那么就得新建了。首先通过<code>Data.uid</code>自增的方式获得一个唯一的id，然后将这个id写入到descriptor，jq首先会尝试es5的<code>Object.defineProperties</code>方法来创建一个不可遍历，不可写的键值对，键为jq版本号，值为数据id。如果不能使用es5的方法，会退一步使用extend写入。往owner中成功写入id后，再在数据对象的cache区域中申请一个区域就行了，实际上就是申请了一个空对象</p>

<p>最后，如果owner本来就id直接返回，否则返回新申请的id</p>

<p><code>javascript
key: function( owner ) {
    /*如果这个所有者不能接收数据，返回0*/
    if ( !Data.accepts( owner ) ) {
        return 0;
    }
    var descriptor = {},
        /*获取这个所有者已经有这个版本的数据的id*/
        unlock = owner[ this.expando ];
    /*如果这个所有者没有对应的数据对象，那么创建一个*/
    if ( !unlock ) {
        /*自增的uid*/
        unlock = Data.uid++;
        /*往这个所有者中添加这个数据对象的版本号，并将其值设为id*/
        try {
            descriptor[ this.expando ] = { value: unlock };
            Object.defineProperties( owner, descriptor );
        /*如果不能使用Object.defineProperites，那么直接使用extend*/
        } catch ( e ) {
            descriptor[ this.expando ] = unlock;
            jQuery.extend( owner, descriptor );
        }
    }
    /*在cache中创建对象的数据空间*/
    if ( !this.cache[ unlock ] ) {
        this.cache[ unlock ] = {};
    }
    /*返回这个新的id*/
    return unlock;
},
</code></p>

<h4 id="set-owner-data-value">set (owner, data, value)</h4>
<p>既然我们成功申请了空间，那么自然需要一个方法往这个空间里面添加我们的缓冲数据，set就是干这个的</p>

<p>owner是数据所有者，data是需要加入的数据对象或名称，value则是当data表示数据名称时，它用来表示数据的值。可以看出，这是一个兼容多种接口的方法</p>

<p>逻辑很简单，先获得owner的id，这里使用上面的key方法获得id，保证了获得id后，一定已经有相应的数据空间</p>

<p>获取到id后做接口兼容判断，如果data是字符串，直接往这个dom的数据空间中写入<code>data:value</code>键值对就行了。如果data不是字符串，而是一个对象，那么将这个对象中的键值对一一写入到数据空间中。这里有一个小优化，当数据空间中没有数据的时候，使用了<code>jQuery.extend</code>来直接浅拷贝进去</p>

<p>```javascript
/<em>加入数据（往cache中加数据）</em>/
set: function( owner, data, value ) {
    var prop,
        /<em>首先获得这个所有者的id（没有就新建一个）</em>/
        unlock = this.key( owner ),
        /<em>获得这个数据对象对应的cache内的空间</em>/
        cache = this.cache[ unlock ];</p>

<pre><code>/*如果数据时string直接写进去*/
if ( typeof data === "string" ) {
    cache[ data ] = value;

/*如果不是string，是对象，那么遍历对象复制进去，如果正好cache中是空对象，直接extend*/
} else {
    if ( jQuery.isEmptyObject( cache ) ) {
        jQuery.extend( this.cache[ unlock ], data );
    } else {
        for ( prop in data ) {
            cache[ prop ] = data[ prop ];
        }
    }
}
return cache; }, ```
</code></pre>

<h4 id="get-owner-key">get (owner, key)</h4>
<p>从owner对应的数据空间中获取数据的方法，也是一个兼容多接口的方法，当存在key时只获取key所对应的值。否则获取整个数据空间对象</p>

<p>思路很明了也很简单，首先获取owner的数据id，然后获取元素的数据空间，最后判断是否存在key来确定返回的内容</p>

<p><code>javascript
/*获取数据（从cache中取数据）*/
get: function( owner, key ) {
    /*通过owner获取id，从cache中获取在对应的完整缓存对象*/
    var cache = this.cache[ this.key( owner ) ];
    /*如果美没有申明要取的键，返回整个缓存，否则只返回键对应的值*/
    return key === undefined ?
        cache : cache[ key ];
},
</code></p>

<h4 id="access-owner-key-value">access (owner, key, value)</h4>
<p>一个包含了get和set的接口方法，根据参数来判断调用set方法还是get方法，使接口符合jq风格</p>

<p>owner是数据所有者，这个参数总是存在的，接口分为以下三种：
1. 如果没有key和value，那么使用get方法获取整个数据空间对象
2. 如果只有key而key是字符串，没有value，那么使用get方法获得数据空间中key对应的值
3. 如果只有key而key是对象，那么使用set方法将key中所有的键值对写入到数据空间中
4. 如果key和value都存在，那么使用set方法往数据空间中写入key:value键值对</p>

<p>```javascript
access: function( owner, key, value ) {
    var stored;
    if ( key === undefined ||
            ((key &amp;&amp; typeof key === “string”) &amp;&amp; value === undefined) ) {</p>

<pre><code>    stored = this.get( owner, key );

    return stored !== undefined ?
        stored : this.get( owner, jQuery.camelCase(key) );
}

this.set( owner, key, value );

return value !== undefined ? value : key; }, ```
</code></pre>

<h4 id="remove-owner-key">remove (owner, key)</h4>
<p>既然有增改查，必然有删。这里就是删除，需要注意的是这里key可能是数组，如果是数组，就要把数组中所有元素作为键分别进行删除了。这里会把所有需要删除的key包裹成一个数组，最后字需要循环遍历这个数组使用delete删除就行了</p>

<p>需要注意的是，这里有一个驼峰判断，比如<code>-moz-transform</code>这样的属性，会转成驼峰形式<code>mozTransform</code>，但删除时候为了保险起见会尝试普通key形式和驼峰的key。另外key如果是一个带有空白字符（比如空格或回车等）的字符串，那么也会做分割，生成一个key数组</p>

<p><code>javascript
/*从owner移除属性 */
remove: function( owner, key ) {
    var i, name, camel,
        unlock = this.key( owner ),
        cache = this.cache[ unlock ];
    /*如果没有key，移除整个owner所拥有的缓存*/
    if ( key === undefined ) {
        this.cache[ unlock ] = {};
    } else {
        // Support array or space separated string of keys
        /*如果key是数组，那么将key中的每个元素转换成驼峰形式然后进行删除*/
        if ( jQuery.isArray( key ) ) {
            name = key.concat( key.map( jQuery.camelCase ) );
        } else {
            /*如果key不是数组，将key转成驼峰*/
            camel = jQuery.camelCase( key );
            /*如果cache[key]存在，那么删除key和驼峰形式key对应的键值对*/
            if ( key in cache ) {
                name = [ key, camel ];
            } else {
                /*如果cache[key]不存在，那么要尝试删除驼峰形式的key*/
                name = camel;
                /*key可能是一个带有空格的字符串，所以需要对齐进行分割来获得所有要删除的key*/
                name = name in cache ?
                    [ name ] : ( name.match( rnotwhite ) || [] );
            }
        }
        /*上面都是获取移除的key的数组，真真移除key是在这里，用的delete*/
        i = name.length;
        while ( i-- ) {
            delete cache[ name[ i ] ];
        }
    }
},
</code></p>

<h4 id="hasdata-owner">hasData (owner)</h4>
<p>判断一个元素是否含有数据，直接判断这个元素对应的数据空间是否存在，如果存在看它是不是空对象
<code>javascript
/*判断是否存在数据*/
hasData: function( owner ) {
    /*判断缓存对象是否是空对象*/
    return !jQuery.isEmptyObject(
        this.cache[ owner[ this.expando ] ] || {}
    );
},
</code></p>

<h4 id="discard-owner">discard (owner)</h4>
<p>移除掉owner的所有缓存，直接在cache上用delete删
<code>javascript
/*移除整个缓存对象*/
discard: function( owner ) {
    if ( owner[ this.expando ] ) {
        delete this.cache[ owner[ this.expando ] ];
    }
}
</code></p>

<h3 id="section-3">数据对象创建</h3>
<p><code>javascript
/*私有数据对象*/
var data_priv = new Data();
/*公有数据对象*/
var data_user = new Data();
</code></p>

<p>可以看到，私有数据对象和公有数据对象都是数据对象构造函数的实例</p>

<h2 id="jquery-1">jQuery对数据对象操作接口</h2>
<p>###dataAttr方法
事由于HTML5存在<code>data-xxx</code>来在DOM节点上缓存数据，jq的数据缓存机制决定，当用户从DOM节点获取数据时，不仅获得其在jq中缓存的数据，也会获得使用HTML5的<code>data-xxx</code>缓存的数据，这个方法就是读取DOM节点中的所有<code>data-xxx</code>形式的数据，将其被分到jq的数据对象中。由于HTML5的缓存很弱，只能缓存字符串类型，这里在保存前还会做相应的数据转换，转换诸如true、false、null、数字以及还会判断是否是json，然后解析json</p>

<p>```javscript
function dataAttr( elem, key, data ) {
    var name;</p>

<pre><code>/*如果没有data，而元素为element类型*/
if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {

    /*从data-xxx属性中获取数据*/
    name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
    data = elem.getAttribute( name );
    /*如果对象是字符串，分别尝试转成true、false、null，如果使用{}包裹，当做JSON解析*/
    if ( typeof data === "string" ) {
        try {
            data = data === "true" ? true :
                data === "false" ? false :
                data === "null" ? null :
                // Only convert to a number if it doesn't change the string
                +data + "" === data ? +data :
                rbrace.test( data ) ? jQuery.parseJSON( data ) :
                data;
        } catch( e ) {}

        /*写入到公共数据对象中*/
        data_user.set( elem, key, data );
    } else {
        data = undefined;
    }
}
return data; } ```
</code></pre>

<h3 id="section-4">静态方法</h3>
<p>jq提供一系列的静态方法操作数据对象，jq为公有数据对象和私有数据对象分别定义了一套接口，私有数据对象的操作前一般都带下划线</p>

<h4 id="hasdata-elem">hasData (elem)</h4>
<p>判断元素是否含有数据，这里会检测公有数据和私有数据
<code>javascript
hasData: function( elem ) {
    return data_user.hasData( elem ) || data_priv.hasData( elem );
},
</code>
####data (elem, name, data)
通过数据对象的access方法获得或写入数据，只操作公有数据对象
<code>javascript
data: function( elem, name, data ) {
    return data_user.access( elem, name, data );
},
</code>
####removeData (elem, name)
从数据对象移除数据，只操作公有数据对象
<code>javascript
removeData: function( elem, name ) {
    data_user.remove( elem, name );
},
</code>
####_data (elem, name, data)
通过数据对象的access方法获得或写入数据，只操作私有数据对象
<code>javascript
_data: function( elem, name, data ) {
    return data_priv.access( elem, name, data );
},
</code>
####_removeData (elem, name)
从数据对象移除数据，只操作私有数据对象
<code>javascript
_removeData: function( elem, name ) {
    data_priv.remove( elem, name );
}
</code></p>

<h3 id="jq-1">在jq对象上添加数据对象操作方法</h3>
<p>jq对象既然维护了一系列的DOM节点，自然通过扩展fn的方式为这些DOM节点提供数据对象操作方法</p>

<h4 id="data-key-value">data (key, value)</h4>
<p>jq的接口有个特点，写全部，得第一。当往jq对象中写入数据时，每个DOM节点都会被写入数据，而读取数据时，只会读取DOM列表中的第一个节点的数据。这里也不例外。这个方法同样是重载方法：
1. 如果key和value都不存在，获取第一个元素的公有对象。在获取数据前，会检查第一个DOM节点，判断它是否存在HTML5的data属性，如果存在，会获取其值并复制到元素的jq数据对象中，并在元素的私有数据空间写入一个<code>hasDataAttrs:true</code>作为标示，最后返回合并了HTML5的data后的数据空间对象
2. 如果key是对象，那么每个DOM节点都需要写入这个对象，然后返回这个jq对象
3. 否则使用access来判断具体需要获取值还是写入。获取时，在含有DOM节点，有key而没有value时，获取key对应的值。如果通过直接key没有获得数据，就尝试将key转换为驼峰格式来获取对应的值。如果还获取不到，那么尝试使用dataAttr方法获取包含了HTML5的data的数据。如果还是获取不到，我们尽力了，返回undefined。写入时，则会遍历jq对象中所有的DOM节点，每个节点都会先检查是否有驼峰形式的key，无论有没有都写进去。但如果存在连字符，而没有驼峰key，那么写入普通key的键值对作为备份。</p>

<p>```javascript
data: function( key, value ) {
    var i, name, data,
        elem = this[ 0 ],
        attrs = elem &amp;&amp; elem.attributes;</p>

<pre><code>/*如果没有key也没有value，获取jq对象中第一个元素的所有公有数据，需要考虑dom元素的data-属性*/
if ( key === undefined ) {
    /*jq对象中有节点*/
    if ( this.length ) {
        /*第一个节点的数据*/
        data = data_user.get( elem );
        /*如果节点为element类型且私有数据中没有标记hasDataAttrs
        将节点中的所有data-类型的属性写入到公共数据中
        然后在私有数据中设定hasDataAttrs为true*/
        if ( elem.nodeType === 1 &amp;&amp; !data_priv.get( elem, "hasDataAttrs" ) ) {
            i = attrs.length;
            while ( i-- ) {
                name = attrs[ i ].name;

                if ( name.indexOf( "data-" ) === 0 ) {
                    name = jQuery.camelCase( name.slice(5) );
                    dataAttr( elem, name, data[ name ] );
                }
            }
            data_priv.set( elem, "hasDataAttrs", true );
        }
    }

    return data;
}

/*如果key是一个对象，说明需要将这个对象添加到jq中每个节点的公有数据中*/
if ( typeof key === "object" ) {
    return this.each(function() {
        data_user.set( this, key );
    });
}
/*通过access判断*/
return access( this, function( value ) {
    var data,
        /*生成驼峰的key*/
        camelKey = jQuery.camelCase( key );
    /*如果jq对象中有元素，且没有value，说明调用get获取数据*/
    if ( elem &amp;&amp; value === undefined ) {
        /*直接使用key获取*/
        data = data_user.get( elem, key );
        if ( data !== undefined ) {
            return data;
        }
        /*如果直接用key未能获取导数据，尝试驼峰格式的key*/
        data = data_user.get( elem, camelKey );
        if ( data !== undefined ) {
            return data;
        }

        /*如果还是无法获取，尝试从data-属性获取*/
        data = dataAttr( elem, camelKey, undefined );
        if ( data !== undefined ) {
            return data;
        }

        /*我们尝试了所有情况，但还是没有数据，返回undefined*/
        return;
    }

    /*写入数据*/
    this.each(function() {
        /*通过驼峰形式key获取公共数据*/
        var data = data_user.get( this, camelKey );
        /*往驼峰形式key中写入公共数据*/
        data_user.set( this, camelKey, value );

        /*key中存在连字符，而通过驼峰形式的key获取不到数据，需要直接对key写入数据*/
        if ( key.indexOf("-") !== -1 &amp;&amp; data !== undefined ) {
            data_user.set( this, key, value );
        }
    });
}, null, value, arguments.length &gt; 1, null, true ); }, ```
</code></pre>

<h4 id="removedata-key">removeData (key)</h4>
<p>这个就比较简单了，直接遍历jq对象中所有的DOM节点，每个都删除就行了
<code>javascript
/*从公共数据中移除包含key（或key中元素）的键值对*/
removeData: function( key ) {
    return this.each(function() {
        data_user.remove( this, key );
    });
}
</code></p>

<h2 id="queuedequeue">为动画服务的queue和dequeue</h2>
<p>事实上，jq还提供了一套为动画服务器的queue和dequeue接口，为动画服务提供data操作。这套接口操作是在私有数据对象上的。</p>

<h3 id="section-5">静态方法</h3>
<p>####queue (elem, type, data)
逻辑不复杂，也分读写两种情况。以<code>type + "queue"</code>（如果没有传入type，默认为fxqueue）为key，从私有数据空间获取数据。</p>

<p>如果是写情况，没有获得到数据或或得到的数据不是数组时，直接把key:data这样的键值对写进私有数据空间。如果获得到数据且是个数组，那么把data加在这个数组的后面。</p>

<p>如果是读情况，获得导数据后直接返回，如果没有数据，返回一个空数组</p>

<p>```javascript
/<em>压入或读取一组数据</em>/
queue: function( elem, type, data ) {
    var queue;</p>

<pre><code>if ( elem ) {
    /*重命名一下type，默认叫fxqueue*/
    type = ( type || "fx" ) + "queue";
    /*从私有数据中获得已有的queue数据*/
    queue = data_priv.get( elem, type );

    /*如果存在data，需要写入数据*/
    if ( data ) {
        /*之前没有缓存中没有数据且data是一个数组，那么就把这个data缓存*/
        if ( !queue || jQuery.isArray( data ) ) {
            queue = data_priv.access( elem, type, jQuery.makeArray(data) );
        /*之前有数据，直接把data连在数据数组后头*/
        } else {
            queue.push( data );
        }
    }
    return queue || [];
} }, ```
</code></pre>

<h4 id="dequeue-elem-type">dequeue (elem, type)</h4>
<p>事实上，在使用queue时一般都是压入一个函数和字符串混合成的数组，这里需要递归去执行这些函数</p>

<p>会找到第一个不是inprogress字符串的函数弹出并裕兴，然后将inprogress字符串压入，递归执行dequeue方法。如果所有全部执行完（数组为空），那么这组数据可以删除掉了。事实上在每次dequeue函数结束完成之后，会调动钩子中的函数，这些将会在动画中详细介绍</p>

<p>```javascript
/<em>运行一组数据，找到第一个不是inprogress字符串的函数弹出并运行，然后将inprogress重新压入，递归执行dequeue，如果函数全部执行完，那么通过钩子把这组数据删掉</em>/
dequeue: function( elem, type ) {
    /<em>获取type，默认为fx</em>/
    type = type || “fx”;
    /<em>获取一组数据</em>/
    var queue = jQuery.queue( elem, type ),
        startLength = queue.length,
        /<em>获取状态</em>/
        fn = queue.shift(),
        /<em>获取元素的钩子</em>/
        hooks = jQuery._queueHooks( elem, type ),
        next = function() {
            jQuery.dequeue( elem, type );
        };</p>

<pre><code>/*如果当前数据第一个元素是字符串，说明正在处理，拿到它下一个元素，是个函数*/
if ( fn === "inprogress" ) {
    fn = queue.shift();
    startLength--;
}
if ( fn ) {

    /*调用这个函数，如果类型是默认的fx，那么将继续处于处理中状态*/
    if ( type === "fx" ) {
        queue.unshift( "inprogress" );
    }

    /*删除掉钩子中的停止函数*/
    delete hooks.stop;
    /*在这个函数上调用，并提供钩子*/
    fn.call( elem, next, hooks );
}
/*如果队列已经空了，那么调用empty删除掉这个键值对*/
if ( !startLength &amp;&amp; hooks ) {
    hooks.empty.fire();
} }, ```
</code></pre>

<h4 id="queuehooks-elem-type">_queueHooks (elem, type)</h4>
<p>提供默认钩子的函数
<code>javascript
_queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return data_priv.get( elem, key ) || data_priv.access( elem, key, {
        empty: jQuery.Callbacks("once memory").add(function() {
            data_priv.remove( elem, [ type + "queue", key ] );
        })
    });
}
</code></p>

<h3 id="jqqueuedequeue">jq对象上的queue和dequeue</h3>
<p>####queue (type, data)
对jq对象中的每个DOM节点分别调用queue方法。但如果数据的第一个元素是函数而不是inprogress，那么会立即调用dequeue开始执行
```javascript
queue: function( type, data ) {
        var setter = 2;</p>

<pre><code>    if ( typeof type !== "string" ) {
        data = type;
        type = "fx";
        setter--;
    }

    if ( arguments.length &lt; setter ) {
        return jQuery.queue( this[0], type );
    }

    return data === undefined ?
        this :
        this.each(function() {
            var queue = jQuery.queue( this, type, data );

            // ensure a hooks for this queue
            jQuery._queueHooks( this, type );

            if ( type === "fx" &amp;&amp; queue[0] !== "inprogress" ) {
                jQuery.dequeue( this, type );
            }
        });
}, ```
</code></pre>

<h4 id="dequeue-type">dequeue (type)</h4>
<p>对jq对象中每个DOM元素执行dequeue操作</p>

<p><code>javascript
/*对jq对象中的每个元素执行dequeue操作，执行内部已压入的函数*/
dequeue: function( type ) {
    return this.each(function() {
        jQuery.dequeue( this, type );
    });
},
</code></p>

<h4 id="clearqueue-type">clearQueue (type)</h4>
<p>清除jq对象中每个DOM的type对应的数据列表
<code>javascript
/*清除对应的类型的操作列表*/
clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
},
</code></p>

<h4 id="promise-type-obj">promise (type, obj)</h4>
<p>获取一个promise对象，这个promise对象会在jq中的所有DOM元素type所对应的数据列表中的方法都已被执行完时resolve
```javascript
/<em>创建一个deferred对象，如果队列中所有的函数都被执行完毕，那么resolve这个deferred对象</em>/
promise: function( type, obj ) {
    var tmp,
        count = 1,
        defer = jQuery.Deferred(),
        elements = this,
        i = this.length,
        resolve = function() {
            if ( !( –count ) ) {
                defer.resolveWith( elements, [ elements ] );
            }
        };</p>

<pre><code>if ( typeof type !== "string" ) {
    obj = type;
    type = undefined;
}
type = type || "fx";

while ( i-- ) {
    tmp = data_priv.get( elements[ i ], type + "queueHooks" );
    if ( tmp &amp;&amp; tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
    }
}
resolve();
return defer.promise( obj ); } ```
</code></pre>

<h2 id="section-6">总结</h2>
<p>缓存的这块的核心知识还是比较好理解的，除了queue和dequeue要结合动画理解，需要注意的是HTML5的data带来的问题。其他的实际上就是对象上的增删改查了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/10/read-jq-src-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的核心方法和类型判断 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/08/read-jq-src-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 08 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="section">一些方法的缓存</h2>
<p>上来先做了一下commonjs的判断和兼容</p>

<p>之后将一些数组上和对象上的常用方法进行了缓存。另外还缓存了一个class2type对象和support对象，class2type对象将在后面的类型判断处详细介绍。而support用来保存嗅探到的浏览器特性是否支持
<code>javascript
/*缓存一些常用方法和对象*/
var arr = [];
/*切分数组*/
var slice = arr.slice;
/*数组合并*/
var concat = arr.concat;
/*添加到尾部*/
var push = arr.push;
/*查找位置*/
var indexOf = arr.indexOf;
/*判断变量类型*/
var class2type = {};
/*对象的toString方法，用于判断变量类型*/
var toString = class2type.toString;
/*对象的hasOwnProperty，判断属性是否在对象中*/
var hasOwn = class2type.hasOwnProperty;
/*字符串的trime方法*/
var trim = "".trim;
/*方法支持程度*/
var support = {};
</code></p>

<p>之后创建了jQuery方法
<code>javascript
jQuery = function( selector, context ) {
    return new jQuery.fn.init( selector, context );
}
</code>
可以看到，其使用<code>new jQuery.fn.init</code>创建了一个jq对象并返回了，jq对象的详细实现应该在init方法中</p>

<p>当然还有一些像缓存document，版本号，匹配<code>-ms-</code>和<code>-[\da-z]</code>这样的正则表达式，还有一个将字符串转大写的方法</p>

<p>```javascript
var
    document = window.document,</p>

<pre><code>version = "2.1.0",

jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
},

rmsPrefix = /^-ms-/,
rdashAlpha = /-([\da-z])/gi,

fcamelCase = function( all, letter ) {
    return letter.toUpperCase();
}; ```
</code></pre>

<h2 id="jquery">在jQuery对象上扩展方法</h2>
<p>紧接着是一系列在jq对象上扩展的方法：
可以看到在jq对象上扩展方法实际上就是在jQuery的prototype上扩展方法
这里定义了一系列在jQuery对象中操作元素集合的方法
####constructor
重新将constructor指向jQuery，防止constructor指向Object
<code>javascript
constructor: jQuery,
</code>
####selector
每个jQuery对象都与一个selector字符串，可以用它来检测jQuery对象，默认为空字符串
<code>javascript
selector: "",
</code>
####length
jQuery对象其实可以看做一个包含了很多dom元素和一系列扩展方法的类数组对象，其中必然会有一个length属性说明一共有多少dom元素，经常用来判断jq对象是否含有结果集
<code>javascript
length: 0,
</code>
####toArray
类数组对象转真正数组的方法，内部和我们将arguments或NodeList等于一样，使用slice实现
<code>javascript
toArray: function() {
    return slice.call( this );
},
</code></p>

<h4 id="get-num">get (num)</h4>
<p>从jq对象中获取下标为num的元素，如果num为负数，则获取倒数第num个，也就是下表为<code>length + num</code>的元素。如果num不存在，将这个jq对象转换成真数组并返回（同样使用的slice方法）
```javascript
get: function( num ) {
    return num != null ?</p>

<pre><code>    // Return a 'clean' array
    ( num &lt; 0 ? this[ num + this.length ] : this[ num ] ) :

    // Return just the object
    slice.call( this ); }, ``` ####pushStack (elems) 这是一个很重要的方法，后面很多地方会用到
</code></pre>

<p>这个方法实际上是创建一个新的jq对象，其结果集为elems中的dom节点，将现有的jq对象放在新创建对象的prevObject中，这样就能在新jq对象中查找到现有的jq对象了，设定一下context后返回新对象的引用</p>

<p>这种链式创建jq对象的方式可以理解为jq对象的一个链表(栈)，而我们永远拥有表头指针，使用end方法时，表头指针所指向的jq对象就会移除出链表。这也是jQuery那样链式操作的关键所在
```javascript
pushStack: function( elems ) {</p>

<pre><code>/*创建一个新jq对象用来保存结果集*/
var ret = jQuery.merge( this.constructor(), elems );

/*将之前的jq对象压栈*/
ret.prevObject = this;
/*context相同*/
ret.context = this.context;

/*返回新创建的jq对象的引用*/
return ret; }, ```
</code></pre>

<h4 id="each-callback-args">each (callback, args)</h4>
<p>这个方法相信使用过jq的人都很熟悉了，对当前jq对象中的每个元素调用callback方法，并可选的为callback传入args参数。内部有一个很强大的兼容各种参数的each方法，后续会有介绍，这里直接使用它了
<code>javascript
each: function( callback, args ) {
    return jQuery.each( this, callback, args );
},
</code></p>

<h4 id="map-callback">map (callback)</h4>
<p>这个方法和上面类似，不过是map方法，所以会生成一组结果，这一组结果会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>

<h4 id="slice">slice</h4>
<p>其实内部就是直接调用了<code>[].slice</code>切分jq对象获得dom节点数组，不同的是，这个获得的dom节点数组会使用pushStack方法在jq链上创建一个新jq对象来包裹
<code>javascript
map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
        return callback.call( elem, i, elem );
    }));
},
</code>
####first和last
这俩比较简单，获取jq对象的dom节点集中的第一个和最后一个，均使用eq方法实现
```javascript
first: function() {
    return this.eq( 0 );
},</p>

<p>last: function() {
    return this.eq( -1 );
},
```
####eq (i)
获取jq对象dom节点集的第i个元素，需要注意的是处理正数和负数的情况，正数为第i个，负数为倒数第i个，也就是第<code>length+i</code>个</p>

<p>这个方法也会将生成的结果用pushStack方法在jq链上创建新的jq对象来包裹
<code>javascript
eq: function( i ) {
    var len = this.length,
        j = +i + ( i &lt; 0 ? len : 0 );
    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );
},
</code>
####end
操作jq链，获得之前的jq对象。这里有个判定，如果之前没有对象了，新建一个空的jq对象并返回。把jq链看做一个栈的话，实际上就是弾栈操作
<code>javascript
end: function() {
    return this.prevObject || this.constructor(null);
},
</code>
####push、sort、splice
这些方法仅作内部使用，直接使用数组的方法
<code>javascript
push: push,
sort: arr.sort,
splice: arr.splice
</code></p>

<h2 id="jqueryextend">对象扩展方法jQuery.extend</h2>
<p>编写jq插件的开发者肯定不会对这个方法陌生</p>

<p>jq使用这个方法实现的混入模式，思想还是将遍历一个对象中的所有值，复制到一个已有的对象中</p>

<p>另外jq这个函数实现了深拷贝，其实也就是递归调用extend方法，这里用了很多的jQuery自己实现的类型判断</p>

<p>深拷贝需要注意数组和原生对象的情况，他们创建的容器是不相同的（<code>[]</code>和<code>{}</code>）</p>

<p>另外它使用了一个options来进行缓存，防止出现循环引用导致的无限递归情况</p>

<p>```javascript
jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;</p>

<pre><code>/*做接口的重载*/
// Handle a deep copy situation
if ( typeof target === "boolean" ) {
    deep = target;

    // skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
}

// Handle case when target is a string or something (possible in deep copy)
if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction(target) ) {
    target = {};
}

// extend jQuery itself if only one argument is passed
if ( i === length ) {
    target = this;
    i--;
}

for ( ; i &lt; length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
        // Extend the base object
        for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            /*看copy中是否已经存在需要复制的对象，防止死循环*/
            if ( target === copy ) {
                continue;
            }
            /*如果深拷贝，将递归复制*/
            // Recurse if we're merging plain objects or arrays
            if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                /*数组和对象分开判断，容器不一样*/
                if ( copyIsArray ) {
                    copyIsArray = false;
                    clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

                } else {
                    clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
                }

                // Never move original objects, clone them
                /*递归拷贝*/
                target[ name ] = jQuery.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}

// Return the modified object
return target; }; ```
</code></pre>

<h2 id="jquery-1">在jQuery上扩展的一些内部方法和静态方法</h2>
<p>有了<code>jQuery.extend</code>，我们就可以使用它在jQuery对象上申明一些静态方法或属性了，基本上每个模块都会通过这种方式申明一些内部方法和静态方法</p>

<h4 id="expando">expando</h4>
<p>用于随机生成一个jq的版本号
<code>javascript
expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
</code>
####isReady
假设jQuery已经准备好了，当然我们有一个$().ready方法，判断dom是否加载完成，这些后面promise那块会说</p>

<h4 id="error">error</h4>
<p>没啥好说的，甩个异常
<code>javascript
error: function( msg ) {
    throw new Error( msg );
},
</code></p>

<h4 id="noop">noop</h4>
<p>一个空函数，不知道干啥用的
<code>javascript
noop: function() {},
</code></p>

<h4 id="isfunction-obj">isFunction (obj)</h4>
<p>判断参数是否是函数，使用了jQuery.type进行判断，内部实际上用的是<code>typeof obj === 'function'</code>
<code>javascript
isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
},
</code>
####isArray (obj)
判断参数是否是数组，由于是2.1.0版本，不兼容ie6-7，所以直接使用了<code>Array.isArray</code>
<code>javascript
isArray: Array.isArray,
</code>
####isWindow (obj)
判断是否是window对象，这个使用window对象的<code>window.window === window</code>进行判断，但司徒正美说这种方式还是有缺陷的
<code>javascript
isWindow: function( obj ) {
    return obj != null &amp;&amp; obj === obj.window;
},
</code>
####isNumberic (obj)
这个是判断参数能否转换为数字，先通过parseFloat对参数进行转换，然后判断，很巧妙</p>

<p>这里用到了parseFloat返回NaN、任何数与NaN计算都是NaN、NaN和0比返回false
<code>javascript
isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    return obj - parseFloat( obj ) &gt;= 0;
},
</code></p>

<h4 id="isplainobject-obj">isPlainObject (obj)</h4>
<p>判断是否是原生对象。如果不是对象，或者是DOM对象，或者是window直接排除。看它原型上是否有isPrototypeOf方法，如果有，则是原生对象，否则不是。需要注意一点的是，在ff20-时查看constructor会报错，所以用了try catch包裹
```javascript
isPlainObject: function( obj ) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not “[object Object]”
    // - DOM nodes
    // - window
    if ( jQuery.type( obj ) !== “object” || obj.nodeType || jQuery.isWindow( obj ) ) {
        return false;
    }</p>

<pre><code>// Support: Firefox &lt;20
// The try/catch suppresses exceptions thrown when attempting to access
// the "constructor" property of certain host objects, ie. |window.location|
// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
try {
    if ( obj.constructor &amp;&amp;
            !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
        return false;
    }
} catch ( e ) {
    return false;
}

// If the function hasn't returned already, we're confident that
// |obj| is a plain object, created by {} or constructed with new Object
return true; }, ```
</code></pre>

<h4 id="isemptyobject-obj">isEmptyObject (obj)</h4>
<p>是否是空对象，判断方法是遍历这个对象，只要有能遍历到的键值对，返回false
<code>javascript
isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
        return false;
    }
    return true;
},
</code></p>

<h4 id="type-obj">type (obj)</h4>
<p>确定元素类型的方法，这个方法使用了class2type中存储的累心结果进行判断</p>

<p>首先判断<code>obj==null</code>，obj如果是undefined和null，都会在这里被拦截，直接转成字符串返回就可以了</p>

<p>然后判断如果obj是对象，那就需要通过class2type来判断了，class2type中汇总了一些常用的对象映射。如果class2type中没有找到，返回object。如果是函数，直接返回函数就行了</p>

<p>后面会有如何创建这个class2type缓存</p>

<p><code>javascript
type: function( obj ) {
    if ( obj == null ) {
        return obj + "";
    }
    // Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[ toString.call(obj) ] || "object" :
        typeof obj;
},
</code></p>

<h4 id="globaleval-code">globalEval (code)</h4>
<p>执行code中的代码，首先通过indexOf查找代码中是否有<code>use strict</code>，如果有，那么使用在document中创建script节点的方法执行代码，否则直接用js本身的eval
```javascript
globalEval: function( code ) {
    var script,
        indirect = eval;</p>

<pre><code>code = jQuery.trim( code );

if ( code ) {
    // If the code includes a valid, prologue position
    // strict mode pragma, execute code by injecting a
    // script tag into the document.
    if ( code.indexOf("use strict") === 1 ) {
        script = document.createElement("script");
        script.text = code;
        document.head.appendChild( script ).parentNode.removeChild( script );
    } else {
    // Otherwise, avoid the DOM node creation, insertion
    // and removal by using an indirect global eval
        indirect( code );
    }
} }, ```
</code></pre>

<h4 id="camelcase">camelCase</h4>
<p>将一个带连字符的字符串转驼峰形式
<code>javascript
camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
},
</code>
####nodeName
判断一个元素的标签名是否和传入的参数匹配，如果没有传入参数，返回元素的标签名…直接用元素的nodeName属性获得标签名，比较时注意一下全转成小写
<code>javascript
nodeName: function( elem, name ) {
    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
},
</code></p>

<h4 id="each">each</h4>
<p>来了，用于遍历的each方法，其有一个有参数的情况</p>

<p>在遍历时需要判断对象是类数组（注意是类数组）还是对象，类数组的话直接使用for循环，而对象使用for in。剩下就是在有无参数时候的不同调用方法了，有参数使用apply传入相应参数，如果没有使用call，传入下标和具体的值</p>

<p>```javascript
each: function( obj, callback, args ) {
    var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike( obj );
    /<em>有参数的情况下</em>/
    if ( args ) {
        /<em>数组或类数组对象</em>/
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback.apply( obj[ i ], args );</p>

<pre><code>            if ( value === false ) {
                break;
            }
        }
    /*普通对象*/
    } else {
        for ( i in obj ) {
            value = callback.apply( obj[ i ], args );

            if ( value === false ) {
                break;
            }
        }
    }
/*无参数的情况下，把当前元素和下标（键）当做参数传递*/
// A special, fast, case for the most common use of each
} else {
    if ( isArray ) {
        for ( ; i &lt; length; i++ ) {
            value = callback.call( obj[ i ], i, obj[ i ] );

            if ( value === false ) {
                break;
            }
        }
    } else {
        for ( i in obj ) {
            value = callback.call( obj[ i ], i, obj[ i ] );

            if ( value === false ) {
                break;
            }
        }
    }
}

return obj; }, ```
</code></pre>

<h4 id="trim">trim</h4>
<p>去掉字符串的首尾空白，由于不兼容老版本IE，直接用字符串的trim了，没有用正则
<code>javascript
trim: function( text ) {
    return text == null ? "" : trim.call( text );
},
</code></p>

<h4 id="makearray">makeArray</h4>
<p>讲一个类数组转化为数组，如果是数组直接push，如果不是真数组，使用merge，后面会介绍merge方法
```javascript
makeArray: function( arr, results ) {
    var ret = results || [];</p>

<pre><code>if ( arr != null ) {
    if ( isArraylike( Object(arr) ) ) {
        jQuery.merge( ret,
            typeof arr === "string" ?
            [ arr ] : arr
        );
    } else {
        push.call( ret, arr );
    }
}

return ret; }, ```
</code></pre>

<h4 id="inarray">inArray</h4>
<p>使用indexOf判断元素是否在数组内部
<code>javascript
inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
},
</code></p>

<h4 id="merge">merge</h4>
<p>通过遍历的方式将两个类数组合并
```javascript
merge: function( first, second ) {
    var len = +second.length,
        j = 0,
        i = first.length;</p>

<pre><code>for ( ; j &lt; len; j++ ) {
    first[ i++ ] = second[ j ];
}

first.length = i;

return first; }, ```
</code></pre>

<h4 id="grep-elems-callback-invert">grep (elems, callback, invert)</h4>
<p>将元素丢到callback中判断是否符合条件，返回所有符合条件的元素。invert为true时，返回所有不符合条件的元素</p>

<p>```javscript
grep: function( elems, callback, invert ) {
    var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;</p>

<pre><code>// Go through the array, only saving the items
// that pass the validator function
for ( ; i &lt; length; i++ ) {
    callbackInverse = !callback( elems[ i ], i );
    if ( callbackInverse !== callbackExpect ) {
        matches.push( elems[ i ] );
    }
}

return matches; }, ```
</code></pre>

<h4 id="map-elems-callback-arg">map (elems, callback, arg)</h4>
<p>jq自己实现的map操作，由于jq自身是个类数组，于是乎模拟数组实现了一系列操作，map就是其中一个</p>

<p>对数组、类数组、对象进行遍历map操作，结果放在一个数组中并返回
```javascript
map: function( elems, callback, arg ) {
    var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike( elems ),
        ret = [];</p>

<pre><code>// Go through the array, translating each of the items to their new values
/*数组或类数组*/
if ( isArray ) {
    for ( ; i &lt; length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
            ret.push( value );
        }
    }

// Go through every key on the object,
/*对象*/
} else {
    for ( i in elems ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
            ret.push( value );
        }
    }
}

// Flatten any nested arrays
return concat.apply( [], ret ); }, ```
</code></pre>

<h4 id="guid">guid</h4>
<p>一个全局的guid，用于生成独立id，每次被使用后自增</p>

<h4 id="proxy">proxy</h4>
<p>使用闭包的方式将对象绑定到函数的作用域链顶端，curry化的实现</p>

<p>```javascript
proxy: function( fn, context ) {
    var tmp, args, proxy;</p>

<pre><code>if ( typeof context === "string" ) {
    tmp = fn[ context ];
    context = fn;
    fn = tmp;
}

// Quick check to determine if target is callable, in the spec
// this throws a TypeError, but we will just return undefined.
/*必须是函数*/
if ( !jQuery.isFunction( fn ) ) {
    return undefined;
}

// Simulated bind
/*提取出参数*/
args = slice.call( arguments, 2 );
/*创建闭包，这个闭包使用了当前作用域的这些对象*/
proxy = function() {
    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
};

// Set the guid of unique handler to the same of original handler, so it can be removed
/*给代理增加一个自增的guid*/
proxy.guid = fn.guid = fn.guid || jQuery.guid++;
/*返回代理*/
return proxy; }, ```
</code></pre>

<h4 id="section-1">其他</h4>
<p>没啥好说的，看名字就知道了
```javascript
now: Date.now,</p>

<p>support: support
```</p>

<h2 id="section-2">类型判断</h2>
<p>####生成class2type
首先是生成class2type，使用了比较巧妙的方法，对一个字符串进行切分，然后使用<code>jQuery.each</code>方法来建立class2type</p>

<p><code>javascript
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});
</code></p>

<h4 id="section-3">判断类数组</h4>
<p>判断是否是类数组对象，主要是根据是否含有大于等于0的length属性判断，含有length属性也可能是function，表明参数个数，也可能是window，需要排除</p>

<p>```javascript
function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );</p>

<pre><code>if ( type === "function" || jQuery.isWindow( obj ) ) {
    return false;
}

if ( obj.nodeType === 1 &amp;&amp; length ) {
    return true;
}

return type === "array" || length === 0 ||
    typeof length === "number" &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj; } ```
</code></pre>

<h2 id="section-4">总结</h2>
<p>这一部分主要是申明了extend方法和一些在jq对象上的核心函数，以及相当多的类型判断相关</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/08/read-jq-src-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ jQuery的核心方法和类型判断 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/08/read-jq-src-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 08 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ <h2 id="section">一些方法的缓存</h2>
<p>上来先做了一下commonjs的判断和兼容</p>

<p>之后将一些数组上和对象上的常用方法进行了缓存。另外还缓存了一个class2type对象和support对象，class2type对象将在后面的类型判断处详细介绍。而support用来保存嗅探到的浏览器特性是否支持
<code>javascript
/*缓存一些常用方法和对象*/
var arr = [];
/*切分数组*/
var slice = arr.slice;
/*数组合并*/
var concat = arr.concat;
/*添加到尾部*/
var push = arr.push;
/*查找位置*/
var indexOf = arr.indexOf;
/*判断变量类型*/
var class2type = {};
/*对象的toString方法，用于判断变量类型*/
var toString = class2type.toString;
/*对象的hasOwnProperty，判断属性是否在对象中*/
var hasOwn = class2type.hasOwnProperty;
/*字符串的trime方法*/
var trim = "".trim;
/*方法支持程度*/
var support = {};
</code></p>

<p>之后创建了jQuery方法
<code>javascript
jQuery = function( selector, context ) {
    return new jQuery.fn.init( selector, context );
}
</code>
可以看到，其使用<code>new jQuery.fn.init</code>创建了一个jq对象并返回了，jq对象的详细实现应该在init方法中</p>

<p>当然还有一些像缓存document，版本号，匹配<code>-ms-</code>和<code>-[\da-z]</code>这样的正则表达式，还有一个将字符串转大写的方法</p>

<p>```javascript
var
    document = window.document,</p>

<pre><code>version = "2.1.0",

jQuery = function( selector, context ) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
},

rmsPrefix = /^-ms-/,
rdashAlpha = /-([\da-z])/gi,

fcamelCase = function( all, letter ) {
    return letter.toUpperCase();
}; ```
</code></pre>

<h2 id="jquery">在jQuery对象上扩展方法</h2>
<p>紧接着是一系列在jq对象上扩展的方法：
可以看到在jq对象上扩展方法实际上就是在jQuery的prototype上扩展方法
这里定义了一系列在jQuery对象中操作元素集合的方法
####constructor
重新将constructor指向jQuery，防止constructor指向Object
<code>javascript
constructor: jQuery,
</code>
####selector
每个jQuery对象都与一个selector字符串，可以用它来检测jQuery对象，默认为空字符串
<code>javascript
selector: "",
</code>
####length
jQuery对象其实可以看做一个包含了很多dom元素和一系列扩展方法的类数组对象，其中必然会有一个length属性说明一共有多少dom元素，经常用来判断jq对象是否含有结果集
<code>javascript
length: 0,
</code>
####toArray
类数组对象转真正数组的方法，内部和我们将arguments或NodeList等于一样，使用slice实现
<code>javascript
toArray: function() {
    return slice.call( this );
},
</code></p>

<h4 id="get-num">get (num)</h4>
<p>从jq对象中获取下标为num的元素，如果num为负数，则获取倒数第num个，也就是下表为<code>length + num</code>的元素。如果num不存在，将这个jq对象转换成真数组并返回（同样使用的slice方法）
```javascript
get: function( num ) {
    return num != null ?</p>

<pre><code>    // Return a 'clean' array
    ( num &lt; 0 ? this[ num + this.length ] : this[ num ] ) :

    // Return just the object
    slice.call( this ); }, ``` ####pushStack (elems) 这是一个很重要的方法，后面很多地方会用到
</code></pre>

<p>这个方法实际上是创建一个新的jq对象，其结果集为elems中的dom节点，将现有的jq对象放在新创建对象的prevObject中，这样就能在新jq对象中查找到现有的jq对象了，设定一下context后返回新对象的引用</p>

<p>这种链式创建jq对象的方式可以理解为jq对象的一个链表(栈)，而我们永远拥有表头指针，使用end方法时，表头指针所指向的jq对象就会移除出链表。这也是jQuery那样链式操作的关键所在
```javascript
pushStack: function( elems ) {</p>

<pre><code>/*创建一个新jq对象用来保存结果集*/
var ret = jQuery.merge( this.constructor(), elems );

/*将之前的jq对象压栈*/
ret.prevObject = this;
/*context相同*/
ret.context = this.context;

/*返回新创建的jq对象的引用*/
return ret; }, ```
</code></pre>

<h4 id="each-callback-args">each (callback, args)</h4>
<p>这个方法相信使用过jq的人都很熟悉了，对当前jq对象中的每个元素调用callback方法，并可选的为callback传入args参数。内部有一个很强大的兼容各种参数的each方法，后续会有介绍，这里直接使用它了
<code>javascript
each: function( callback, args ) {
    return jQuery.each( this, callback, args );
},
</code></p>

<h4 id="map-callback">map (callback)</h4>
<p>这个方法和上面类似，不过是map方法，所以会生成一组结果，这一组结果会使用pushStack方法在jq链上创建一个新jq对象来包裹</p>

<h4 id="slice">slice</h4>
<p>其实内部就是直接调用了<code>[].slice</code>切分jq对象获得dom节点数组，不同的是，这个获得的dom节点数组会使用pushStack方法在jq链上创建一个新jq对象来包裹
<code>javascript
map: function( callback ) {
    return this.pushStack( jQuery.map(this, function( elem, i ) {
        return callback.call( elem, i, elem );
    }));
},
</code>
####first和last
这俩比较简单，获取jq对象的dom节点集中的第一个和最后一个，均使用eq方法实现
```javascript
first: function() {
    return this.eq( 0 );
},</p>

<p>last: function() {
    return this.eq( -1 );
},
```
####eq (i)
获取jq对象dom节点集的第i个元素，需要注意的是处理正数和负数的情况，正数为第i个，负数为倒数第i个，也就是第<code>length+i</code>个</p>

<p>这个方法也会将生成的结果用pushStack方法在jq链上创建新的jq对象来包裹
<code>javascript
eq: function( i ) {
    var len = this.length,
        j = +i + ( i &lt; 0 ? len : 0 );
    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );
},
</code>
####end
操作jq链，获得之前的jq对象。这里有个判定，如果之前没有对象了，新建一个空的jq对象并返回。把jq链看做一个栈的话，实际上就是弾栈操作
<code>javascript
end: function() {
    return this.prevObject || this.constructor(null);
},
</code>
####push、sort、splice
这些方法仅作内部使用，直接使用数组的方法
<code>javascript
push: push,
sort: arr.sort,
splice: arr.splice
</code></p>

<h2 id="jqueryextend">对象扩展方法jQuery.extend</h2>
<p>编写jq插件的开发者肯定不会对这个方法陌生</p>

<p>jq使用这个方法实现的混入模式，思想还是将遍历一个对象中的所有值，复制到一个已有的对象中</p>

<p>另外jq这个函数实现了深拷贝，其实也就是递归调用extend方法，这里用了很多的jQuery自己实现的类型判断</p>

<p>深拷贝需要注意数组和原生对象的情况，他们创建的容器是不相同的（<code>[]</code>和<code>{}</code>）</p>

<p>另外它使用了一个options来进行缓存，防止出现循环引用导致的无限递归情况</p>

<p>```javascript
jQuery.extend = jQuery.fn.extend = function() {
    var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;</p>

<pre><code>/*做接口的重载*/
// Handle a deep copy situation
if ( typeof target === "boolean" ) {
    deep = target;

    // skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
}

// Handle case when target is a string or something (possible in deep copy)
if ( typeof target !== "object" &amp;&amp; !jQuery.isFunction(target) ) {
    target = {};
}

// extend jQuery itself if only one argument is passed
if ( i === length ) {
    target = this;
    i--;
}

for ( ; i &lt; length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
        // Extend the base object
        for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            /*看copy中是否已经存在需要复制的对象，防止死循环*/
            if ( target === copy ) {
                continue;
            }
            /*如果深拷贝，将递归复制*/
            // Recurse if we're merging plain objects or arrays
            if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                /*数组和对象分开判断，容器不一样*/
                if ( copyIsArray ) {
                    copyIsArray = false;
                    clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

                } else {
                    clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
                }

                // Never move original objects, clone them
                /*递归拷贝*/
                target[ name ] = jQuery.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}

// Return the modified object
return target; }; ```
</code></pre>

<h2 id="jquery-1">在jQuery上扩展的一些内部方法和静态方法</h2>
<p>有了<code>jQuery.extend</code>，我们就可以使用它在jQuery对象上申明一些静态方法或属性了，基本上每个模块都会通过这种方式申明一些内部方法和静态方法</p>

<h4 id="expando">expando</h4>
<p>用于随机生成一个jq的版本号
<code>javascript
expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
</code>
####isReady
假设jQuery已经准备好了，当然我们有一个$().ready方法，判断dom是否加载完成，这些后面promise那块会说</p>

<h4 id="error">error</h4>
<p>没啥好说的，甩个异常
<code>javascript
error: function( msg ) {
    throw new Error( msg );
},
</code></p>

<h4 id="noop">noop</h4>
<p>一个空函数，不知道干啥用的
<code>javascript
noop: function() {},
</code></p>

<h4 id="isfunction-obj">isFunction (obj)</h4>
<p>判断参数是否是函数，使用了jQuery.type进行判断，内部实际上用的是<code>typeof obj === 'function'</code>
<code>javascript
isFunction: function( obj ) {
    return jQuery.type(obj) === "function";
},
</code>
####isArray (obj)
判断参数是否是数组，由于是2.1.0版本，不兼容ie6-7，所以直接使用了<code>Array.isArray</code>
<code>javascript
isArray: Array.isArray,
</code>
####isWindow (obj)
判断是否是window对象，这个使用window对象的<code>window.window === window</code>进行判断，但司徒正美说这种方式还是有缺陷的
<code>javascript
isWindow: function( obj ) {
    return obj != null &amp;&amp; obj === obj.window;
},
</code>
####isNumberic (obj)
这个是判断参数能否转换为数字，先通过parseFloat对参数进行转换，然后判断，很巧妙</p>

<p>这里用到了parseFloat返回NaN、任何数与NaN计算都是NaN、NaN和0比返回false
<code>javascript
isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    return obj - parseFloat( obj ) &gt;= 0;
},
</code></p>

<h4 id="isplainobject-obj">isPlainObject (obj)</h4>
<p>判断是否是原生对象。如果不是对象，或者是DOM对象，或者是window直接排除。看它原型上是否有isPrototypeOf方法，如果有，则是原生对象，否则不是。需要注意一点的是，在ff20-时查看constructor会报错，所以用了try catch包裹
```javascript
isPlainObject: function( obj ) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not “[object Object]”
    // - DOM nodes
    // - window
    if ( jQuery.type( obj ) !== “object” || obj.nodeType || jQuery.isWindow( obj ) ) {
        return false;
    }</p>

<pre><code>// Support: Firefox &lt;20
// The try/catch suppresses exceptions thrown when attempting to access
// the "constructor" property of certain host objects, ie. |window.location|
// https://bugzilla.mozilla.org/show_bug.cgi?id=814622
try {
    if ( obj.constructor &amp;&amp;
            !hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
        return false;
    }
} catch ( e ) {
    return false;
}

// If the function hasn't returned already, we're confident that
// |obj| is a plain object, created by {} or constructed with new Object
return true; }, ```
</code></pre>

<h4 id="isemptyobject-obj">isEmptyObject (obj)</h4>
<p>是否是空对象，判断方法是遍历这个对象，只要有能遍历到的键值对，返回false
<code>javascript
isEmptyObject: function( obj ) {
    var name;
    for ( name in obj ) {
        return false;
    }
    return true;
},
</code></p>

<h4 id="type-obj">type (obj)</h4>
<p>确定元素类型的方法，这个方法使用了class2type中存储的累心结果进行判断</p>

<p>首先判断<code>obj==null</code>，obj如果是undefined和null，都会在这里被拦截，直接转成字符串返回就可以了</p>

<p>然后判断如果obj是对象，那就需要通过class2type来判断了，class2type中汇总了一些常用的对象映射。如果class2type中没有找到，返回object。如果是函数，直接返回函数就行了</p>

<p>后面会有如何创建这个class2type缓存</p>

<p><code>javascript
type: function( obj ) {
    if ( obj == null ) {
        return obj + "";
    }
    // Support: Android &lt; 4.0, iOS &lt; 6 (functionish RegExp)
    return typeof obj === "object" || typeof obj === "function" ?
        class2type[ toString.call(obj) ] || "object" :
        typeof obj;
},
</code></p>

<h4 id="globaleval-code">globalEval (code)</h4>
<p>执行code中的代码，首先通过indexOf查找代码中是否有<code>use strict</code>，如果有，那么使用在document中创建script节点的方法执行代码，否则直接用js本身的eval
```javascript
globalEval: function( code ) {
    var script,
        indirect = eval;</p>

<pre><code>code = jQuery.trim( code );

if ( code ) {
    // If the code includes a valid, prologue position
    // strict mode pragma, execute code by injecting a
    // script tag into the document.
    if ( code.indexOf("use strict") === 1 ) {
        script = document.createElement("script");
        script.text = code;
        document.head.appendChild( script ).parentNode.removeChild( script );
    } else {
    // Otherwise, avoid the DOM node creation, insertion
    // and removal by using an indirect global eval
        indirect( code );
    }
} }, ```
</code></pre>

<h4 id="camelcase">camelCase</h4>
<p>将一个带连字符的字符串转驼峰形式
<code>javascript
camelCase: function( string ) {
    return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
},
</code>
####nodeName
判断一个元素的标签名是否和传入的参数匹配，如果没有传入参数，返回元素的标签名…直接用元素的nodeName属性获得标签名，比较时注意一下全转成小写
<code>javascript
nodeName: function( elem, name ) {
    return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
},
</code></p>

<h4 id="each">each</h4>
<p>来了，用于遍历的each方法，其有一个有参数的情况</p>

<p>在遍历时需要判断对象是类数组（注意是类数组）还是对象，类数组的话直接使用for循环，而对象使用for in。剩下就是在有无参数时候的不同调用方法了，有参数使用apply传入相应参数，如果没有使用call，传入下标和具体的值</p>

<p>```javascript
each: function( obj, callback, args ) {
    var value,
        i = 0,
        length = obj.length,
        isArray = isArraylike( obj );
    /<em>有参数的情况下</em>/
    if ( args ) {
        /<em>数组或类数组对象</em>/
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback.apply( obj[ i ], args );</p>

<pre><code>            if ( value === false ) {
                break;
            }
        }
    /*普通对象*/
    } else {
        for ( i in obj ) {
            value = callback.apply( obj[ i ], args );

            if ( value === false ) {
                break;
            }
        }
    }
/*无参数的情况下，把当前元素和下标（键）当做参数传递*/
// A special, fast, case for the most common use of each
} else {
    if ( isArray ) {
        for ( ; i &lt; length; i++ ) {
            value = callback.call( obj[ i ], i, obj[ i ] );

            if ( value === false ) {
                break;
            }
        }
    } else {
        for ( i in obj ) {
            value = callback.call( obj[ i ], i, obj[ i ] );

            if ( value === false ) {
                break;
            }
        }
    }
}

return obj; }, ```
</code></pre>

<h4 id="trim">trim</h4>
<p>去掉字符串的首尾空白，由于不兼容老版本IE，直接用字符串的trim了，没有用正则
<code>javascript
trim: function( text ) {
    return text == null ? "" : trim.call( text );
},
</code></p>

<h4 id="makearray">makeArray</h4>
<p>讲一个类数组转化为数组，如果是数组直接push，如果不是真数组，使用merge，后面会介绍merge方法
```javascript
makeArray: function( arr, results ) {
    var ret = results || [];</p>

<pre><code>if ( arr != null ) {
    if ( isArraylike( Object(arr) ) ) {
        jQuery.merge( ret,
            typeof arr === "string" ?
            [ arr ] : arr
        );
    } else {
        push.call( ret, arr );
    }
}

return ret; }, ```
</code></pre>

<h4 id="inarray">inArray</h4>
<p>使用indexOf判断元素是否在数组内部
<code>javascript
inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
},
</code></p>

<h4 id="merge">merge</h4>
<p>通过遍历的方式将两个类数组合并
```javascript
merge: function( first, second ) {
    var len = +second.length,
        j = 0,
        i = first.length;</p>

<pre><code>for ( ; j &lt; len; j++ ) {
    first[ i++ ] = second[ j ];
}

first.length = i;

return first; }, ```
</code></pre>

<h4 id="grep-elems-callback-invert">grep (elems, callback, invert)</h4>
<p>将元素丢到callback中判断是否符合条件，返回所有符合条件的元素。invert为true时，返回所有不符合条件的元素</p>

<p>```javscript
grep: function( elems, callback, invert ) {
    var callbackInverse,
        matches = [],
        i = 0,
        length = elems.length,
        callbackExpect = !invert;</p>

<pre><code>// Go through the array, only saving the items
// that pass the validator function
for ( ; i &lt; length; i++ ) {
    callbackInverse = !callback( elems[ i ], i );
    if ( callbackInverse !== callbackExpect ) {
        matches.push( elems[ i ] );
    }
}

return matches; }, ```
</code></pre>

<h4 id="map-elems-callback-arg">map (elems, callback, arg)</h4>
<p>jq自己实现的map操作，由于jq自身是个类数组，于是乎模拟数组实现了一系列操作，map就是其中一个</p>

<p>对数组、类数组、对象进行遍历map操作，结果放在一个数组中并返回
```javascript
map: function( elems, callback, arg ) {
    var value,
        i = 0,
        length = elems.length,
        isArray = isArraylike( elems ),
        ret = [];</p>

<pre><code>// Go through the array, translating each of the items to their new values
/*数组或类数组*/
if ( isArray ) {
    for ( ; i &lt; length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
            ret.push( value );
        }
    }

// Go through every key on the object,
/*对象*/
} else {
    for ( i in elems ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
            ret.push( value );
        }
    }
}

// Flatten any nested arrays
return concat.apply( [], ret ); }, ```
</code></pre>

<h4 id="guid">guid</h4>
<p>一个全局的guid，用于生成独立id，每次被使用后自增</p>

<h4 id="proxy">proxy</h4>
<p>使用闭包的方式将对象绑定到函数的作用域链顶端，curry化的实现</p>

<p>```javascript
proxy: function( fn, context ) {
    var tmp, args, proxy;</p>

<pre><code>if ( typeof context === "string" ) {
    tmp = fn[ context ];
    context = fn;
    fn = tmp;
}

// Quick check to determine if target is callable, in the spec
// this throws a TypeError, but we will just return undefined.
/*必须是函数*/
if ( !jQuery.isFunction( fn ) ) {
    return undefined;
}

// Simulated bind
/*提取出参数*/
args = slice.call( arguments, 2 );
/*创建闭包，这个闭包使用了当前作用域的这些对象*/
proxy = function() {
    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
};

// Set the guid of unique handler to the same of original handler, so it can be removed
/*给代理增加一个自增的guid*/
proxy.guid = fn.guid = fn.guid || jQuery.guid++;
/*返回代理*/
return proxy; }, ```
</code></pre>

<h4 id="section-1">其他</h4>
<p>没啥好说的，看名字就知道了
```javascript
now: Date.now,</p>

<p>support: support
```</p>

<h2 id="section-2">类型判断</h2>
<p>####生成class2type
首先是生成class2type，使用了比较巧妙的方法，对一个字符串进行切分，然后使用<code>jQuery.each</code>方法来建立class2type</p>

<p><code>javascript
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});
</code></p>

<h4 id="section-3">判断类数组</h4>
<p>判断是否是类数组对象，主要是根据是否含有大于等于0的length属性判断，含有length属性也可能是function，表明参数个数，也可能是window，需要排除</p>

<p>```javascript
function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );</p>

<pre><code>if ( type === "function" || jQuery.isWindow( obj ) ) {
    return false;
}

if ( obj.nodeType === 1 &amp;&amp; length ) {
    return true;
}

return type === "array" || length === 0 ||
    typeof length === "number" &amp;&amp; length &gt; 0 &amp;&amp; ( length - 1 ) in obj; } ```
</code></pre>

<h2 id="section-4">总结</h2>
<p>这一部分主要是申明了extend方法和一些在jq对象上的核心函数，以及相当多的类型判断相关</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/08/read-jq-src-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 修正了一下博客的RSS ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/05/fixed-rss.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 05 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>把页面换成Angular+ngRoute，所有的URL都改成ngRoute的URL形式，但忘记修改RSS中的URL了，导致订阅之后跳转出了问题，这里修复了一下这个bug</p>

<p>另外将订阅从摘要订阅修改成了全文订阅，这样虽然生成的XML文件更大，但使用起来还是要友好一些</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/05/fixed-rss.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 修正了一下博客的RSS ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/05/fixed-rss.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 05 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>把页面换成Angular+ngRoute，所有的URL都改成ngRoute的URL形式，但忘记修改RSS中的URL了，导致订阅之后跳转出了问题，这里修复了一下这个bug</p>

<p>另外将订阅从摘要订阅修改成了全文订阅，这样虽然生成的XML文件更大，但使用起来还是要友好一些</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/05/fixed-rss.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ Google的HTML/CSS样式指南 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/04/google-style-guide.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 04 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>

<h2 id="section">通用样式规范</h2>
<p>###使用相对协议
```html
<!-- 不推荐使用 -->
<script src="http://www.google.com/js/gweb/analytics/autotrack.js"></script></p>

<!-- 推荐使用 -->
<script src="//www.google.com/js/gweb/analytics/autotrack.js"></script>

<p>```</p>

<h3 id="htmltab">HTML文件中一个tab两个空格</h3>
<p>老调重弹，不要混合使用tab和空格
```html</p>
<ul>
  <li>Fantastic
  <li>Great


.example {
  color: blue;
}
```

###仅使用小写
所有代码应该使用小写，比如HTML元素的名称、属性、属性值（除了text/CDATA）。CSS的选择器、属性、属性值等等

```html
<!-- 不推荐使用 -->
<a href="/">Home</a>

<!-- 推荐使用 -->
<img src="google.png" alt="Google" />
```

```css
<!-- 不推荐使用 -->
color: #E5E5E5;

<!-- 推荐使用 -->
color: #e5e5e5;
```

###不要有后缀的空格
```html
<!-- 不推荐使用 -->
<p>What?_

<!-- 推荐使用 -->
<p>Yes please.
```

###使用UTF-8编码
保证编辑器的编码字符集为UTF-8，同时在文档中添加`<meta charset="utf-8" />`

###在必要的时候，在合适的地方添加注释
用注释来表明元素的范围以及它的用途

###仅使用TODO来添加todo任务

##HTML样式规范
###使用HTML5文档类型
使用`&lt;!DOCTYPE html&gt;`来声明文档类型，建议使用`text/html`来定义HTML文件的MIME类型，不要使用`application/xhtml+xml`来定义。在编写HTML时，空元素可以不必闭合，如`<br />`不必写成`<br />`

###使用HTML验证器进行验证
尽量使用HTML验证器验证过的代码
```html
<!-- 不推荐使用 -->
<title>Test</title>
<article>This is only a test.

<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<meta charset="utf-8" />
<title>Test</title>
<article>This is only a test.</article>
```

###根据用途使用元素
使用元素时应当根据元素的作用来选择适当的标签，`<h1>`~`<h6>`用来表示头，`<p>`元素表示段落，`<a>`元素表示超链接等等。根据用途使用元素对可访问性，重用和代码效率等有很重要的帮助
```html
<!-- 不推荐使用 -->
<div onclick="goToRecommendations();">All recommendations</div>

<!-- 推荐使用 -->
<a href="recommendations/">All recommendations</a>
```

###对于多媒体元素，提供替换文本（alt）
对于多媒体元素，像图片，视频，动画对象如canvas等等，应该为其提供有意义的替换文本（alt），同时尽可能为视频和音频提供副本（不同格式）和字幕

这同样关乎到可访问性，当盲人用户需要通过image等获得信息时，可以转而通过alt中的文字来获得信息

```html
<!-- 不推荐使用 -->
<img src="spreadsheet.png" />

<!-- 推荐使用 -->
<img src="spreadsheet.png" alt="Spreadsheet screenshot." />
```

###将结构、表现、行为三者分离
严格将结构（标记），表现（样式）和行为（脚本）进行分离解耦，使他们之间相互独立

具体做法就是将HTML文档和模板中仅包含HTML，样式妨碍CSS中，而行为相关代码放在脚本中

这样更易于网页的维护和重用

```html
<!-- 不推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>HTML sucks</title>
<link rel="stylesheet" href="base.css" media="screen" />
<link rel="stylesheet" href="grid.css" media="screen" />
<link rel="stylesheet" href="print.css" media="print" />
<h1 style="font-size: 1em;">HTML sucks</h1>
<p>I’ve read about this on a few sites but now I’m sure:
  <u>HTML is stupid!!1</u>
<center>I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!</center>
  
<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>My first CSS-only redesign</title>
<link rel="stylesheet" href="default.css" />
<h1>My first CSS-only redesign</h1>
<p>I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
<p>It’s awesome!
```

###避免引用实体
可以直接使用UTF-8等字符集中的字符替代实体，除了一些在HTML中有特殊意义的字符（如`&lt;`和`&amp;`）需要使用实体代替以外，尽量不要使用实体

```html
<!-- 不推荐使用 -->
The currency symbol for the Euro is &ldquo;&eur;&rdquo;.

<!-- 推荐使用 -->
The currency symbol for the Euro is “€”.
```

###省略可选标签
出于降低文档大小和代码可读性考虑，可以将可选标签省略。HTML5定义了一套[可选标签规范](http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-omission)，标明哪些元素时可选的

```html
<!-- 不推荐使用 -->
&lt;!DOCTYPE html&gt;
<html>
  <head>
    <title>Spending money, spending bytes</title>
  </head>
  <body>
    <p>Sic.</p>
  </body>
</html>

<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>Saving money, saving bytes</title>
<p>Qed.
```

###省略样式表和脚本的type属性
```html
<!-- 不推荐使用 -->
<link rel="stylesheet" href="//www.google.com/css/maia.css" type="text/css" />
<script src="//www.google.com/js/gweb/analytics/autotrack.js" type="text/javascript"></script>

<!-- 推荐使用 -->
<link rel="stylesheet" href="//www.google.com/css/maia.css" />
<script src="//www.google.com/js/gweb/analytics/autotrack.js"></script>
```

###块级元素占用一行且合理缩进
每个块级元素，列表项、表格元素单独占用一行，并为每个子元素提供适当的缩进（两个空格）

```html
<!-- 推荐使用 -->
<blockquote>
  <p><em>Space</em>, the final frontier.</p>
</blockquote>
<ul>
  <li>Moe
  <li>Larry
  <li>Curly

<table>
  <thead>
    <tr>
      <th scope="col">Income
      <th scope="col">Taxes
  <tbody>
    <tr>
      <td>$ 5.00
      <td>$ 4.50

```

###属性值使用双引号包裹
```html
<!-- 不推荐使用 -->
<a class="maia-button maia-button-secondary">Sign in</a>

<!-- 推荐使用 -->
<a class="maia-button maia-button-secondary">Sign in</a>
```

##CSS样式规范
###使用验证过的CSS代码
除非CSS验证器有bug或需要专有语法，否则使用验证过的CSS代码

###使用有意义的ID和类命名
命名应当反映出元素的用途。详细命名规则可以看[NEC的CSS命名规则](http://nec.netease.com/standard/css-name.html)

```css
/* 不推荐使用 */
#yee-1901 {}
.button-green {}
.clear {}

/* 推荐使用 */
#gallery {}
#login {}
.video {}
.aux {}
.alt {}
```

###使用简短但不失描述性的ID和类命名
```css
/* 不推荐使用 */
#navigation {}
.atr {}

/* 推荐使用 */
#nav {}
.author {}
```

###避免在元素选择器之后使用使用ID和类选择器
```css
/* 不推荐使用 */
ul#example {}
div.error {}

/* 推荐使用 */
#example {}
.error {}
```

###尽可能对属性进行合并
很多属性（padding、margin、background、font、border等等）都是可以合并的，尽可能合并他们

```css
/* 不推荐使用 */
border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;

/* 推荐使用 */
border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
```

###属性值为0时不要携带单位
```css
margin: 0;
padding: 0;
```

###小数的整数部分为0时，省略整数部分
```css
font-size: .8em;
```

###颜色为16进制表示时进行缩写
```css
/* 不推荐使用 */
color: #eebbcc;

/* 推荐使用 */
color: #ebc;
```

###ID和类命名添加前缀表示命名空间
同NEC的命名方式，或者通过模块名来定义前缀

##CSS格式规范
###CSS属性申明顺序
可以按照字典序进行排序，方便查找，但同一属性的不同实现声明在一起，且按照私有实现在前，W3C标准在后的顺序排列

ps：属性顺序排列有另一种说法是：定位相关（position、float、display、top、left、right、bottom、z-index等）在前，随后是盒子模型相关（width、height、padding、margin、border等等），随后是背景相关（background，background-image等等），然后是文字相关（colr，line-height、font等等），然后是一些其他属性（border-radius，opacity等等），最后是动画属性（transition、animation等）

```css
background: fuchsia;
border: 1px solid;
-moz-border-radius: 4px;
-webkit-border-radius: 4px;
border-radius: 4px;
color: black;
text-align: center;
text-indent: 2em;
```

###代码块缩进
所有申明都应该有适当的缩进，就算`@media`媒体查询也不例外
```css
@media screen, projection {

  html {
    background: #fff;
    color: #444;
  }

}
```

###所有属性之后都加上分号
虽然最后一个属性可以不加分号，但建议都加上
```css
/* 不推荐使用 */
.test {
  display: block;
  height: 100px
}

/* 推荐使用 */
.test {
  display: block;
  height: 100px;
}
```

###属性名后加上个空格
```css
/* 不推荐使用 */
h3 {
  font-weight:bold;
}

/* 推荐使用 */
h3 {
  font-weight: bold;
}
```

###选择器群组各占一行
```css
/* 不推荐使用 */
a:focus, a:active {
  position: relative; top: 1px;
}

/* 推荐使用 */
h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
```

###在两个不同的声明中添加回车来区分
```css
html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
```

###在CSS中省略引号，只在必要时候使用单引号
```css
/* 不推荐使用 */
@import url("//www.google.com/css/maia.css");

html {
  font-family: "open sans", arial, sans-serif;
}

/* 推荐使用 */
@import url(//www.google.com/css/maia.css);

html {
  font-family: 'open sans', arial, sans-serif;
}
```

###通过注释分割代码
通过注释将代码分割成多个分组，注释之后另起一行

```css
/* Header */

#adw-header {}

/* Footer */

#adw-footer {}

/* Gallery */

.adw-gallery {}
```

##总结
大致上粗略的看了一遍Google的HTML和CSS规范，概括的细节还是比较多的。从中也能看出Google对文档大小的重视，基本上都是能省则省，能用一个字符绝不用两个。其很多地方还是非常值得参考的


</td></td></tr></tbody></th></th></tr></thead></table></li></li></li></ul></p></p></p></p></a></p></h6></h1></article></p></p></li></li></ul>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/04/google-style-guide.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ Google的HTML/CSS样式指南 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/04/google-style-guide.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 04 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前读过网易的NEC，以及百度的前端编码规范，感觉自己HTML和CSS代码写的很烂，这里又读了一下Google的style guide，发现有很多地方值得学习补充，在这里大致上翻译一下</p>

<h2 id="section">通用样式规范</h2>
<p>###使用相对协议
```html
<!-- 不推荐使用 -->
<script src="http://www.google.com/js/gweb/analytics/autotrack.js"></script></p>

<!-- 推荐使用 -->
<script src="//www.google.com/js/gweb/analytics/autotrack.js"></script>

<p>```</p>

<h3 id="htmltab">HTML文件中一个tab两个空格</h3>
<p>老调重弹，不要混合使用tab和空格
```html</p>
<ul>
  <li>Fantastic
  <li>Great


.example {
  color: blue;
}
```

###仅使用小写
所有代码应该使用小写，比如HTML元素的名称、属性、属性值（除了text/CDATA）。CSS的选择器、属性、属性值等等

```html
<!-- 不推荐使用 -->
<a href="/">Home</a>

<!-- 推荐使用 -->
<img src="google.png" alt="Google" />
```

```css
<!-- 不推荐使用 -->
color: #E5E5E5;

<!-- 推荐使用 -->
color: #e5e5e5;
```

###不要有后缀的空格
```html
<!-- 不推荐使用 -->
<p>What?_

<!-- 推荐使用 -->
<p>Yes please.
```

###使用UTF-8编码
保证编辑器的编码字符集为UTF-8，同时在文档中添加`<meta charset="utf-8" />`

###在必要的时候，在合适的地方添加注释
用注释来表明元素的范围以及它的用途

###仅使用TODO来添加todo任务

##HTML样式规范
###使用HTML5文档类型
使用`&lt;!DOCTYPE html&gt;`来声明文档类型，建议使用`text/html`来定义HTML文件的MIME类型，不要使用`application/xhtml+xml`来定义。在编写HTML时，空元素可以不必闭合，如`<br />`不必写成`<br />`

###使用HTML验证器进行验证
尽量使用HTML验证器验证过的代码
```html
<!-- 不推荐使用 -->
<title>Test</title>
<article>This is only a test.

<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<meta charset="utf-8" />
<title>Test</title>
<article>This is only a test.</article>
```

###根据用途使用元素
使用元素时应当根据元素的作用来选择适当的标签，`<h1>`~`<h6>`用来表示头，`<p>`元素表示段落，`<a>`元素表示超链接等等。根据用途使用元素对可访问性，重用和代码效率等有很重要的帮助
```html
<!-- 不推荐使用 -->
<div onclick="goToRecommendations();">All recommendations</div>

<!-- 推荐使用 -->
<a href="recommendations/">All recommendations</a>
```

###对于多媒体元素，提供替换文本（alt）
对于多媒体元素，像图片，视频，动画对象如canvas等等，应该为其提供有意义的替换文本（alt），同时尽可能为视频和音频提供副本（不同格式）和字幕

这同样关乎到可访问性，当盲人用户需要通过image等获得信息时，可以转而通过alt中的文字来获得信息

```html
<!-- 不推荐使用 -->
<img src="spreadsheet.png" />

<!-- 推荐使用 -->
<img src="spreadsheet.png" alt="Spreadsheet screenshot." />
```

###将结构、表现、行为三者分离
严格将结构（标记），表现（样式）和行为（脚本）进行分离解耦，使他们之间相互独立

具体做法就是将HTML文档和模板中仅包含HTML，样式妨碍CSS中，而行为相关代码放在脚本中

这样更易于网页的维护和重用

```html
<!-- 不推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>HTML sucks</title>
<link rel="stylesheet" href="base.css" media="screen" />
<link rel="stylesheet" href="grid.css" media="screen" />
<link rel="stylesheet" href="print.css" media="print" />
<h1 style="font-size: 1em;">HTML sucks</h1>
<p>I’ve read about this on a few sites but now I’m sure:
  <u>HTML is stupid!!1</u>
<center>I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!</center>
  
<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>My first CSS-only redesign</title>
<link rel="stylesheet" href="default.css" />
<h1>My first CSS-only redesign</h1>
<p>I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
<p>It’s awesome!
```

###避免引用实体
可以直接使用UTF-8等字符集中的字符替代实体，除了一些在HTML中有特殊意义的字符（如`&lt;`和`&amp;`）需要使用实体代替以外，尽量不要使用实体

```html
<!-- 不推荐使用 -->
The currency symbol for the Euro is &ldquo;&eur;&rdquo;.

<!-- 推荐使用 -->
The currency symbol for the Euro is “€”.
```

###省略可选标签
出于降低文档大小和代码可读性考虑，可以将可选标签省略。HTML5定义了一套[可选标签规范](http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-omission)，标明哪些元素时可选的

```html
<!-- 不推荐使用 -->
&lt;!DOCTYPE html&gt;
<html>
  <head>
    <title>Spending money, spending bytes</title>
  </head>
  <body>
    <p>Sic.</p>
  </body>
</html>

<!-- 推荐使用 -->
&lt;!DOCTYPE html&gt;
<title>Saving money, saving bytes</title>
<p>Qed.
```

###省略样式表和脚本的type属性
```html
<!-- 不推荐使用 -->
<link rel="stylesheet" href="//www.google.com/css/maia.css" type="text/css" />
<script src="//www.google.com/js/gweb/analytics/autotrack.js" type="text/javascript"></script>

<!-- 推荐使用 -->
<link rel="stylesheet" href="//www.google.com/css/maia.css" />
<script src="//www.google.com/js/gweb/analytics/autotrack.js"></script>
```

###块级元素占用一行且合理缩进
每个块级元素，列表项、表格元素单独占用一行，并为每个子元素提供适当的缩进（两个空格）

```html
<!-- 推荐使用 -->
<blockquote>
  <p><em>Space</em>, the final frontier.</p>
</blockquote>
<ul>
  <li>Moe
  <li>Larry
  <li>Curly

<table>
  <thead>
    <tr>
      <th scope="col">Income
      <th scope="col">Taxes
  <tbody>
    <tr>
      <td>$ 5.00
      <td>$ 4.50

```

###属性值使用双引号包裹
```html
<!-- 不推荐使用 -->
<a class="maia-button maia-button-secondary">Sign in</a>

<!-- 推荐使用 -->
<a class="maia-button maia-button-secondary">Sign in</a>
```

##CSS样式规范
###使用验证过的CSS代码
除非CSS验证器有bug或需要专有语法，否则使用验证过的CSS代码

###使用有意义的ID和类命名
命名应当反映出元素的用途。详细命名规则可以看[NEC的CSS命名规则](http://nec.netease.com/standard/css-name.html)

```css
/* 不推荐使用 */
#yee-1901 {}
.button-green {}
.clear {}

/* 推荐使用 */
#gallery {}
#login {}
.video {}
.aux {}
.alt {}
```

###使用简短但不失描述性的ID和类命名
```css
/* 不推荐使用 */
#navigation {}
.atr {}

/* 推荐使用 */
#nav {}
.author {}
```

###避免在元素选择器之后使用使用ID和类选择器
```css
/* 不推荐使用 */
ul#example {}
div.error {}

/* 推荐使用 */
#example {}
.error {}
```

###尽可能对属性进行合并
很多属性（padding、margin、background、font、border等等）都是可以合并的，尽可能合并他们

```css
/* 不推荐使用 */
border-top-style: none;
font-family: palatino, georgia, serif;
font-size: 100%;
line-height: 1.6;
padding-bottom: 2em;
padding-left: 1em;
padding-right: 1em;
padding-top: 0;

/* 推荐使用 */
border-top: 0;
font: 100%/1.6 palatino, georgia, serif;
padding: 0 1em 2em;
```

###属性值为0时不要携带单位
```css
margin: 0;
padding: 0;
```

###小数的整数部分为0时，省略整数部分
```css
font-size: .8em;
```

###颜色为16进制表示时进行缩写
```css
/* 不推荐使用 */
color: #eebbcc;

/* 推荐使用 */
color: #ebc;
```

###ID和类命名添加前缀表示命名空间
同NEC的命名方式，或者通过模块名来定义前缀

##CSS格式规范
###CSS属性申明顺序
可以按照字典序进行排序，方便查找，但同一属性的不同实现声明在一起，且按照私有实现在前，W3C标准在后的顺序排列

ps：属性顺序排列有另一种说法是：定位相关（position、float、display、top、left、right、bottom、z-index等）在前，随后是盒子模型相关（width、height、padding、margin、border等等），随后是背景相关（background，background-image等等），然后是文字相关（colr，line-height、font等等），然后是一些其他属性（border-radius，opacity等等），最后是动画属性（transition、animation等）

```css
background: fuchsia;
border: 1px solid;
-moz-border-radius: 4px;
-webkit-border-radius: 4px;
border-radius: 4px;
color: black;
text-align: center;
text-indent: 2em;
```

###代码块缩进
所有申明都应该有适当的缩进，就算`@media`媒体查询也不例外
```css
@media screen, projection {

  html {
    background: #fff;
    color: #444;
  }

}
```

###所有属性之后都加上分号
虽然最后一个属性可以不加分号，但建议都加上
```css
/* 不推荐使用 */
.test {
  display: block;
  height: 100px
}

/* 推荐使用 */
.test {
  display: block;
  height: 100px;
}
```

###属性名后加上个空格
```css
/* 不推荐使用 */
h3 {
  font-weight:bold;
}

/* 推荐使用 */
h3 {
  font-weight: bold;
}
```

###选择器群组各占一行
```css
/* 不推荐使用 */
a:focus, a:active {
  position: relative; top: 1px;
}

/* 推荐使用 */
h1,
h2,
h3 {
  font-weight: normal;
  line-height: 1.2;
}
```

###在两个不同的声明中添加回车来区分
```css
html {
  background: #fff;
}

body {
  margin: auto;
  width: 50%;
}
```

###在CSS中省略引号，只在必要时候使用单引号
```css
/* 不推荐使用 */
@import url("//www.google.com/css/maia.css");

html {
  font-family: "open sans", arial, sans-serif;
}

/* 推荐使用 */
@import url(//www.google.com/css/maia.css);

html {
  font-family: 'open sans', arial, sans-serif;
}
```

###通过注释分割代码
通过注释将代码分割成多个分组，注释之后另起一行

```css
/* Header */

#adw-header {}

/* Footer */

#adw-footer {}

/* Gallery */

.adw-gallery {}
```

##总结
大致上粗略的看了一遍Google的HTML和CSS规范，概括的细节还是比较多的。从中也能看出Google对文档大小的重视，基本上都是能省则省，能用一个字符绝不用两个。其很多地方还是非常值得参考的


</td></td></tr></tbody></th></th></tr></thead></table></li></li></li></ul></p></p></p></p></a></p></h6></h1></article></p></p></li></li></ul>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/04/google-style-guide.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的MV*模式 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/05/03/javascript-mvc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 03 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>虽然在做J2EE的时候就已经对MVC有一定的了解，但平常经常听到的MVVM和MVP模式却完全无法理解是什么意思，《JavaScript设计模式》一书中对MVC、MVP、MVVM做了一个详尽的解释，这里记录了一下上面的知识并做了一个简述，正好在学Angular，这些知识结合Angular一起也更加清晰具体了</p>

<h2 id="mvc">MVC</h2>
<p>MVC是一种架构设计模式，它将应用分割成业务数据（Model）、用户界面（View）、控制逻辑（Controller）三个部分，其架构图大致是这个样子：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvc.png" alt="MVC架构图" /></p>

<h3 id="model">Model（模型）</h3>
<p>Model管理应用程序的数据，Model主要与业务数据相关，其不涉及控制层和表示层逻辑。当Model改变时，它会通过Observer模式（Publish/Subscribe）通知观察它的View，一个Model可以有多个观察它的View。</p>

<h4 id="modelviewcontroller">Model与View和Controller的关系</h4>
<p>Model本身不涉及View和Controller的逻辑，它只在乎业务数据模型，并提供相应的接口对其内部数据进行CRUD操作</p>

<h3 id="view">View（视图）</h3>
<p>视图用于将Model中的业务数据进行展示。在Smalltalk的MVC中，视图通常是绘制和维护位图，而在浏览器中，View通常是负责DOM元素的操作。</p>

<h4 id="viewmodel">View与Model的关系</h4>
<p>当一个Model改变时，它会通知所有观察这个Model的View，而这个View在收到通知之后，根据Model中的数据进行相应的更新。
####View与Controller的关系
用于也可以和View（视图）进行交互，包括读取和编辑Model的数据，但由于View是表示层，但一般不使用View直接对Model中的数据进行修改，这个修改过程通常交给Controller来做。View在与用户交互时，在用户操作之后，View不会去了解下一步做什么，而是将用户操作交给Controller来做决定</p>

<h4 id="section">视图与模板</h4>
<p>使用structs+JSP的开发者（或是Express+jade之类的），容易误以为JSP这样的模板就是View视图，但实际上模板只是部分（也可能是全部）View的声明方式，通过模板的规范来生成View，但不代表View的全部。比如Angular中，使用带指令（如<code>ng-hide</code>,<code>ng-show</code>,<code>ng-repeat</code>）的模板来生成DOM节点，其属于View，但实际上如果在Angular中根据scope的属性方法来修改DOM节点（如<code>$scope.$watch</code>），这也属于View范畴</p>

<h3 id="controller">Controller（控制器）</h3>
<p>Controller中介于Model和View之间，当用户与View进行交互，操作了View之后，它负责更新Model</p>

<h4 id="controllermodel">Controller与Model</h4>
<p>Controller根据View与用户的交互，来直接对Model进行操作。</p>

<h4 id="controllerview">Controller与View</h4>
<p>事实上可以理解为Controller为View的策略模式的一个实现。View只是负责与用户交互，其具体应该做的工作交给Controller来决定</p>

<h3 id="mvc-1">MVC模式总结</h3>
<p>MVC将应用程序功能模块化，分离出Model、View和Controller三个部分，互相解耦，使得整体维护更加容易。MVC依赖Observer模式（或是Publish/Subscribe实现）来实现它的核心通信</p>

<hr />
<p>##MVP
MVP模式（模型-视图-表示器）是MVC设计模式的一种衍生模式，专注于改进表示逻辑。MVP中的P为Presenter（表示器），它包含用于View的用户界面业务逻辑的组件，与MVC中不同的是，在Model进行改变之后，它不会直接通知View，而是将修改封装为事件（Events）来通知Presenter，Persenter来与View通信，具体的架构图如下所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvp.png" alt="MVP模式架构图" /></p>

<h3 id="presenter">Presenter（表示器）</h3>
<p>Presenter与Controller相同的是，其依旧介于Model和View之间，但不同的地方在于，在MVC中，Model在改变后会直接通知View而不会经过Controller，在MVP中，Model会将其改变封装成一个事件（或是主题），通过Publish/Subscribe模式来传递给Presenter，然后Presenter将更新交给View</p>

<h4 id="presenterview">Presenter与View的关系</h4>
<p>Presenter与View的关系与MVC中Controller与View的关系大体相同，但增加了将Model的修改交给View的职责，数据通过调用View的接口来传递</p>

<h4 id="presentermodel">Presenter与Model的关系</h4>
<p>Presenter与Modle是一个典型的Pubsub，Presenter作为Subscriber，其订阅了Model的修改事件（主题）。而Model作为Publisher在其数据进行修改后，触发这个事件</p>

<h3 id="mvp">MVP模式总结</h3>
<p>MVP通过将MVC的Model和View的关系进行改变，使得Model和View进一步解耦，这样Presenter所担任的工作也就相对于MVC中的仅对Model进行更新而有所增加。各个组件直接的数据通信也更易于通过Presenter进行把控</p>

<hr />
<p>##MVVM
MVVM模式(模型-视图-视图模型)是一种基于MVC和MVP的架构模式，它试图更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离。它采用了MVP中View和Model的解耦方式，而在View和ViewModel之间也通过Pubsub模式和数据绑定来进行通信，其架构图如下所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvvm.png" alt="MVVM架构图" /></p>

<h3 id="viewmodel-1">ViewModel（视图模型）</h3>
<p>与MVP中的Presenter一样，MVVM中的ViewModel依旧介于View和Model之间。可以将其作为一个专门的Controller，充当数据的转换器，将Model的信息进行适合View的信息，从这个层面上，Viewodel更应该被看做另一个Model。</p>

<h4 id="viewmodelmodel">ViewModel与Model</h4>
<p>ViewModel与Model在通信方式上与MVP几乎没什么差异，但ViewModel在指责上不再只是将Model中的数据传递给View，其将处理View中的显示逻辑，对Model中的业务数据根据需要进行包装，包装成适配View的数据模型</p>

<h4 id="viewmodelview">ViewModel与View</h4>
<p>与Controller和Presenter所不关心显示逻辑不同的是，ViewModel会处理大部分显示逻辑，并暴露一些方法用于保持View的状态。来源于Model的数据会根据显示逻辑进行包装后，通过Pubsub模式与View进行通信，这里View作为Subscriber而ViewModel作为Publisher。而View层将数据传递给ViewModel则是通过了数据绑定的形式，View处理自己的用户界面事件，必要时将他们映射到ViewModel中</p>

<h3 id="mvvm">MVVM总结</h3>
<p>MVVM专注于将UI开发从应用程序业务逻辑与行为分离，通过ViewModel为UI开发提供了更加友好的数据，使得UI开发更加容易。但需要注意的是用于实现数据绑定可能产生大量的标记，且MVVM并不适合UI简单的情况</p>

<hr />
<p>##总结
现有的一些前端框架如Backbone，Angular的等等都是基于MVC模式来进行模块的划分和相互通信的。理解MVC模式在JavaScript中的应用时理解这些库实现方式的基础</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/05/03/javascript-mvc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的MV*模式 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/05/03/javascript-mvc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 03 May 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>虽然在做J2EE的时候就已经对MVC有一定的了解，但平常经常听到的MVVM和MVP模式却完全无法理解是什么意思，《JavaScript设计模式》一书中对MVC、MVP、MVVM做了一个详尽的解释，这里记录了一下上面的知识并做了一个简述，正好在学Angular，这些知识结合Angular一起也更加清晰具体了</p>

<h2 id="mvc">MVC</h2>
<p>MVC是一种架构设计模式，它将应用分割成业务数据（Model）、用户界面（View）、控制逻辑（Controller）三个部分，其架构图大致是这个样子：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvc.png" alt="MVC架构图" /></p>

<h3 id="model">Model（模型）</h3>
<p>Model管理应用程序的数据，Model主要与业务数据相关，其不涉及控制层和表示层逻辑。当Model改变时，它会通过Observer模式（Publish/Subscribe）通知观察它的View，一个Model可以有多个观察它的View。</p>

<h4 id="modelviewcontroller">Model与View和Controller的关系</h4>
<p>Model本身不涉及View和Controller的逻辑，它只在乎业务数据模型，并提供相应的接口对其内部数据进行CRUD操作</p>

<h3 id="view">View（视图）</h3>
<p>视图用于将Model中的业务数据进行展示。在Smalltalk的MVC中，视图通常是绘制和维护位图，而在浏览器中，View通常是负责DOM元素的操作。</p>

<h4 id="viewmodel">View与Model的关系</h4>
<p>当一个Model改变时，它会通知所有观察这个Model的View，而这个View在收到通知之后，根据Model中的数据进行相应的更新。
####View与Controller的关系
用于也可以和View（视图）进行交互，包括读取和编辑Model的数据，但由于View是表示层，但一般不使用View直接对Model中的数据进行修改，这个修改过程通常交给Controller来做。View在与用户交互时，在用户操作之后，View不会去了解下一步做什么，而是将用户操作交给Controller来做决定</p>

<h4 id="section">视图与模板</h4>
<p>使用structs+JSP的开发者（或是Express+jade之类的），容易误以为JSP这样的模板就是View视图，但实际上模板只是部分（也可能是全部）View的声明方式，通过模板的规范来生成View，但不代表View的全部。比如Angular中，使用带指令（如<code>ng-hide</code>,<code>ng-show</code>,<code>ng-repeat</code>）的模板来生成DOM节点，其属于View，但实际上如果在Angular中根据scope的属性方法来修改DOM节点（如<code>$scope.$watch</code>），这也属于View范畴</p>

<h3 id="controller">Controller（控制器）</h3>
<p>Controller中介于Model和View之间，当用户与View进行交互，操作了View之后，它负责更新Model</p>

<h4 id="controllermodel">Controller与Model</h4>
<p>Controller根据View与用户的交互，来直接对Model进行操作。</p>

<h4 id="controllerview">Controller与View</h4>
<p>事实上可以理解为Controller为View的策略模式的一个实现。View只是负责与用户交互，其具体应该做的工作交给Controller来决定</p>

<h3 id="mvc-1">MVC模式总结</h3>
<p>MVC将应用程序功能模块化，分离出Model、View和Controller三个部分，互相解耦，使得整体维护更加容易。MVC依赖Observer模式（或是Publish/Subscribe实现）来实现它的核心通信</p>

<hr />
<p>##MVP
MVP模式（模型-视图-表示器）是MVC设计模式的一种衍生模式，专注于改进表示逻辑。MVP中的P为Presenter（表示器），它包含用于View的用户界面业务逻辑的组件，与MVC中不同的是，在Model进行改变之后，它不会直接通知View，而是将修改封装为事件（Events）来通知Presenter，Persenter来与View通信，具体的架构图如下所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvp.png" alt="MVP模式架构图" /></p>

<h3 id="presenter">Presenter（表示器）</h3>
<p>Presenter与Controller相同的是，其依旧介于Model和View之间，但不同的地方在于，在MVC中，Model在改变后会直接通知View而不会经过Controller，在MVP中，Model会将其改变封装成一个事件（或是主题），通过Publish/Subscribe模式来传递给Presenter，然后Presenter将更新交给View</p>

<h4 id="presenterview">Presenter与View的关系</h4>
<p>Presenter与View的关系与MVC中Controller与View的关系大体相同，但增加了将Model的修改交给View的职责，数据通过调用View的接口来传递</p>

<h4 id="presentermodel">Presenter与Model的关系</h4>
<p>Presenter与Modle是一个典型的Pubsub，Presenter作为Subscriber，其订阅了Model的修改事件（主题）。而Model作为Publisher在其数据进行修改后，触发这个事件</p>

<h3 id="mvp">MVP模式总结</h3>
<p>MVP通过将MVC的Model和View的关系进行改变，使得Model和View进一步解耦，这样Presenter所担任的工作也就相对于MVC中的仅对Model进行更新而有所增加。各个组件直接的数据通信也更易于通过Presenter进行把控</p>

<hr />
<p>##MVVM
MVVM模式(模型-视图-视图模型)是一种基于MVC和MVP的架构模式，它试图更清晰的将用户界面（UI）开发从应用程序的业务逻辑与行为中分离。它采用了MVP中View和Model的解耦方式，而在View和ViewModel之间也通过Pubsub模式和数据绑定来进行通信，其架构图如下所示：</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-3-javascript-mvc-mvvm.png" alt="MVVM架构图" /></p>

<h3 id="viewmodel-1">ViewModel（视图模型）</h3>
<p>与MVP中的Presenter一样，MVVM中的ViewModel依旧介于View和Model之间。可以将其作为一个专门的Controller，充当数据的转换器，将Model的信息进行适合View的信息，从这个层面上，Viewodel更应该被看做另一个Model。</p>

<h4 id="viewmodelmodel">ViewModel与Model</h4>
<p>ViewModel与Model在通信方式上与MVP几乎没什么差异，但ViewModel在指责上不再只是将Model中的数据传递给View，其将处理View中的显示逻辑，对Model中的业务数据根据需要进行包装，包装成适配View的数据模型</p>

<h4 id="viewmodelview">ViewModel与View</h4>
<p>与Controller和Presenter所不关心显示逻辑不同的是，ViewModel会处理大部分显示逻辑，并暴露一些方法用于保持View的状态。来源于Model的数据会根据显示逻辑进行包装后，通过Pubsub模式与View进行通信，这里View作为Subscriber而ViewModel作为Publisher。而View层将数据传递给ViewModel则是通过了数据绑定的形式，View处理自己的用户界面事件，必要时将他们映射到ViewModel中</p>

<h3 id="mvvm">MVVM总结</h3>
<p>MVVM专注于将UI开发从应用程序业务逻辑与行为分离，通过ViewModel为UI开发提供了更加友好的数据，使得UI开发更加容易。但需要注意的是用于实现数据绑定可能产生大量的标记，且MVVM并不适合UI简单的情况</p>

<hr />
<p>##总结
现有的一些前端框架如Backbone，Angular的等等都是基于MVC模式来进行模块的划分和相互通信的。理解MVC模式在JavaScript中的应用时理解这些库实现方式的基础</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/05/03/javascript-mvc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 谁说前端面试简单我咬谁，汪汪汪！ ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/30/interview-overview.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 30 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>今天面完了最后一面，基本上都是等（bei）待（tai）状态了，也不打算再投新的了，这里把笔试面试中遇到的点总结一下，废话不说，上树~</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/gwuyo" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>大致上分了一下知识点，不过还是不够精细，毕竟每个知识点都详细深入很复杂（很多我也不懂）…</p>

<p>底下是找实习的一些感想，不想听感想只想看干货的到这里可以点跳转了~</p>

<h2 id="section">理想与现实的差距</h2>
<p>本科时候太过堕落，没有实习过，现在回想起来相当的后悔。当时看找实习并不难，一直以为找实习很简单，也就面试一下，态度端正就能进。但经过这几周的笔试面试经历，发现和我以前想的完全不一样。并不是所有投简历的人都有面试机会，而面试也是层层筛选，甚至听说某公司产品最后都到5面副总裁面了，瞬间吓尿了。公司招收暑期实习都尽量希望实习生能留下来，留下来也许会容易很多，实习期也算是培训成本，自然笔试面试的要求就提高了</p>

<h2 id="section-1">学院派的狭隘</h2>
<p>身为一个没有实习经历的学生，我对前端的认知主要来源于身边的其他人以及一些浅显的书本。在之前，我一直认为前端工程师只需要会写点HTML，会写点CSS，会写点JS完成一些交互就行了。主要学习的也就是JS和CSS的基础，自己实现的东西很少。当时主要就是用了用jQuery，没用其它框架了。而为了实习面试和笔试，更加专注于像js语言本身的坑，css布局等问题上了，认为面试也就问问这些，但实际上完全不是这么回事。面试官虽然会问基础，但他们似乎对上层更感兴趣。模块化，设计模式，异步控制，框架实现，代码组织和管理，项目自动化构建和测试等等，有些在学校里开发时候可能完全不会接触到，如果不是经常逛社区逛博客，可能听都没听过。但这些却是是在企业的工程里常用的，甚至认为是基础的东西，但我所看的一些书本中不会讲这些，或者讲了也不过是概要略过罢了。幸好平常有逛社区，耳濡目染的了解一点基础知识。有一些自己还写过demo，简单的用过。但自己试验性的使用，在没有长期使用需求的情况下，不会去深入地了解，可能一个月不用就忘得干干净净了（比如我的less）。而到面试的时候，面试官问基础也许还能糊弄，而一旦问深了，就只能回答不知道了，面试结果也不会太好</p>

<h2 id="section-2">漫漫前端路</h2>
<p>说句老实话，本科时候完全没有接触前端，更不会想到自己未来会选择前端这条路。到了大四下学期天天刷算法题（现在全忘干净了…），以为自己以后也会成为算法工程师。结果后来进了实验室做SSH，只是零散的接触前端。 真正决定以后从事前端工作也是在研二。在之前有对自己未来做一个规划，毕竟研究生以来一直做Java和SSH，也曾考虑过是否以后从事Java后台研发。但放弃这个想法而决定专职从事前端的契机，应该是接触css3的动画和变换开始的。当时出于好奇，去研究了一下css3的animation，看到网上大牛们实现的效果，直接吓尿。那些炫酷的效果完全改变了我对网页的理解。之前一直以为网页的作用不过是简单的数据展示和交互，而css3的动画效果所带来的体验直接击碎了那错误的想法。我喜欢看得见的东西，喜欢刷题时候红丝的AC，喜欢QT做出来的界面，自然也喜欢网页上炫酷的效果。于是乎我决定自己也要做出同样炫酷的网页，从此走上了前端之路。如今找实习投的岗位都是Web前端开发，以前的同学知道后都非常吃惊，他们也没想到我会从事前端，还有人劝我别做前端没有前途，应该做Android，做IOS（当然做这些也和有前途）。还有的学长认为前端很简单，说只有技术不行的才会做前端，对于这样的观点，我只能呵呵了，毕竟不做前端的人永远不会知道前端水有多深</p>

<h2 id="section-3">结语</h2>
<p>找实习也终于结束了，虽然结果还没定下来，不过我也改变不了了。终于可以不用失眠睡不好觉了，也可以静下心来看看书写写代码了。最近学了Angular感受到了MVVM框架的强大，无奈练手机会不多。虽然把博客全改成Angular了，但也只是用到其中的部分功能，像自定义指令之类的完全没有去用，还是需要多写一写。另外买了司徒正美的新书《JavaScript框架设计》，里面的知识点很多，各种框架的源代码也很多，正在慢慢啃，慢慢吸收，进度相当缓慢，也需要一段时间吧。另外还计划看《jQuery技术内幕》，估计得到两三周之后了吧</p>

<p>这两天的状态大概是这个样子：
<img src="http://skyinlayerblog.qiniudn.com/blog/img/sleepydog.jpg" alt="死狗" /></p>

<p>五一假期好好休息休息，听一听歌吧~</p>

<embed src="http://www.xiami.com/widget/30211350_1770830087/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent" />
<p> &lt;/embed&gt;</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/30/interview-overview.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 谁说前端面试简单我咬谁，汪汪汪！ ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/30/interview-overview.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 30 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>今天面完了最后一面，基本上都是等（bei）待（tai）状态了，也不打算再投新的了，这里把笔试面试中遇到的点总结一下，废话不说，上树~</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/gwuyo" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>大致上分了一下知识点，不过还是不够精细，毕竟每个知识点都详细深入很复杂（很多我也不懂）…</p>

<p>底下是找实习的一些感想，不想听感想只想看干货的到这里可以点跳转了~</p>

<h2 id="section">理想与现实的差距</h2>
<p>本科时候太过堕落，没有实习过，现在回想起来相当的后悔。当时看找实习并不难，一直以为找实习很简单，也就面试一下，态度端正就能进。但经过这几周的笔试面试经历，发现和我以前想的完全不一样。并不是所有投简历的人都有面试机会，而面试也是层层筛选，甚至听说某公司产品最后都到5面副总裁面了，瞬间吓尿了。公司招收暑期实习都尽量希望实习生能留下来，留下来也许会容易很多，实习期也算是培训成本，自然笔试面试的要求就提高了</p>

<h2 id="section-1">学院派的狭隘</h2>
<p>身为一个没有实习经历的学生，我对前端的认知主要来源于身边的其他人以及一些浅显的书本。在之前，我一直认为前端工程师只需要会写点HTML，会写点CSS，会写点JS完成一些交互就行了。主要学习的也就是JS和CSS的基础，自己实现的东西很少。当时主要就是用了用jQuery，没用其它框架了。而为了实习面试和笔试，更加专注于像js语言本身的坑，css布局等问题上了，认为面试也就问问这些，但实际上完全不是这么回事。面试官虽然会问基础，但他们似乎对上层更感兴趣。模块化，设计模式，异步控制，框架实现，代码组织和管理，项目自动化构建和测试等等，有些在学校里开发时候可能完全不会接触到，如果不是经常逛社区逛博客，可能听都没听过。但这些却是是在企业的工程里常用的，甚至认为是基础的东西，但我所看的一些书本中不会讲这些，或者讲了也不过是概要略过罢了。幸好平常有逛社区，耳濡目染的了解一点基础知识。有一些自己还写过demo，简单的用过。但自己试验性的使用，在没有长期使用需求的情况下，不会去深入地了解，可能一个月不用就忘得干干净净了（比如我的less）。而到面试的时候，面试官问基础也许还能糊弄，而一旦问深了，就只能回答不知道了，面试结果也不会太好</p>

<h2 id="section-2">漫漫前端路</h2>
<p>说句老实话，本科时候完全没有接触前端，更不会想到自己未来会选择前端这条路。到了大四下学期天天刷算法题（现在全忘干净了…），以为自己以后也会成为算法工程师。结果后来进了实验室做SSH，只是零散的接触前端。 真正决定以后从事前端工作也是在研二。在之前有对自己未来做一个规划，毕竟研究生以来一直做Java和SSH，也曾考虑过是否以后从事Java后台研发。但放弃这个想法而决定专职从事前端的契机，应该是接触css3的动画和变换开始的。当时出于好奇，去研究了一下css3的animation，看到网上大牛们实现的效果，直接吓尿。那些炫酷的效果完全改变了我对网页的理解。之前一直以为网页的作用不过是简单的数据展示和交互，而css3的动画效果所带来的体验直接击碎了那错误的想法。我喜欢看得见的东西，喜欢刷题时候红丝的AC，喜欢QT做出来的界面，自然也喜欢网页上炫酷的效果。于是乎我决定自己也要做出同样炫酷的网页，从此走上了前端之路。如今找实习投的岗位都是Web前端开发，以前的同学知道后都非常吃惊，他们也没想到我会从事前端，还有人劝我别做前端没有前途，应该做Android，做IOS（当然做这些也和有前途）。还有的学长认为前端很简单，说只有技术不行的才会做前端，对于这样的观点，我只能呵呵了，毕竟不做前端的人永远不会知道前端水有多深</p>

<h2 id="section-3">结语</h2>
<p>找实习也终于结束了，虽然结果还没定下来，不过我也改变不了了。终于可以不用失眠睡不好觉了，也可以静下心来看看书写写代码了。最近学了Angular感受到了MVVM框架的强大，无奈练手机会不多。虽然把博客全改成Angular了，但也只是用到其中的部分功能，像自定义指令之类的完全没有去用，还是需要多写一写。另外买了司徒正美的新书《JavaScript框架设计》，里面的知识点很多，各种框架的源代码也很多，正在慢慢啃，慢慢吸收，进度相当缓慢，也需要一段时间吧。另外还计划看《jQuery技术内幕》，估计得到两三周之后了吧</p>

<p>这两天的状态大概是这个样子：
<img src="http://skyinlayerblog.qiniudn.com/blog/img/sleepydog.jpg" alt="死狗" /></p>

<p>五一假期好好休息休息，听一听歌吧~</p>

<embed src="http://www.xiami.com/widget/30211350_1770830087/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent" />
<p> &lt;/embed&gt;</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/30/interview-overview.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 有没有感觉有一些变化？ ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/26/new-page2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 26 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>如果你是曾经来过天镶博客的朋友，肯定会感觉到很大的不同，博客换页面啦！连续六天没有更新博客了，除了各种面试和项目上的事情以外，闲暇时间都在写这个新页面，也就没有写博文了。经过3天半的努力，新页面也终于做出来了~</p>

<h2 id="section">之前的页面</h2>
<p>###失败的模仿
之前的页面是模仿<a href="http://www.csszengarden.com/220//">CSS禅意花园的220号作品</a>做的，虽然CSS什么都是自己写的（无耻地盗用了别人的素材图片），而且做成了响应式的，但模仿出来并不很像。其背景上巨大的字一开始以为是图片，结果是通过文字加mask实现的…但mask的跨浏览器支持很不好，于是乎就放弃了</p>

<h3 id="section-1">缺乏层次感</h3>
<p>由于缺少背景内容，用单纯的颜色去实现就会有一种没经过装修的毛坯房的感觉（而且北京还是灰色的）。于是去网上找了个纹理贴上去，这样背景比单纯的颜色要好一些。但整个页面都是同样的纹理平铺，所有的组件基本上没有太大的区分度，缺乏层次感</p>

<h3 id="section-2">左上角的空洞</h3>
<p>之前的页面左上角也没什么东西可放，而左上角区域也是网页最重要的区域，整个页面总感觉缺了什么，比较空洞。最初想弄几个图片或者用CSS画点什么放在左上角区域，但实践了一下发现丑的可怕，于是乎就放弃了…</p>

<h3 id="section-3">网速的桎梏</h3>
<p>开发之前那个页面的时候，基本没有使用图片，效果都使用CSS实现，背景纹理也是几百B的纹理，这一切都是因为整站搭载在Github上，访问速度较慢。最早一版本使用的html5up的网页，一个纹理60+k，慢的吐血，第二版也就长心眼了，但这个心眼也成了开发时的枷锁
###Jekyll做了太多
之前博客的所有文件都是使用Jekyll生成的静态HTML页面，站点的维系就在于静态页面之间的相互跳转，分页什么的都很不方便（虽然实现了）</p>

<h2 id="section-4">刚出炉的包子更好吃</h2>
<p>###Angular，不一样的开发模式
最近刚学的Angular，其MVVM模式、动态模板、双向绑定、路由功能等等都让我大开眼界。于是乎就决定通过Angular来重新实现这个博客，顺带练练手，使用ngRoute路由来将整个博客做成单页应用，文章列表等等都由Angular动态加载。这样Jekyll不再涉及页面具体的逻辑，只需要生成博客中需要的json、xml以及文章的html等资源文件就可以了。而且使用Angular的filter去实现搜索功能简直爽翻啦~</p>

<h3 id="cdn">CDN，飞一般的感觉</h3>
<p>上一版本的博客页面一个最大的问题就是，担心加载速度。放在github上，GFW常年抽风，所有的资源文件（JS、CSS、字体、图片）等等都放在github上，各种慢。在中间写Gitbook的时候，慢的都想砸电脑了，一个js就600k。偶然间尝试使用<a href="http://www.staticfile.org/">七牛的CDN</a>，加载上面的jQuery、ace等库，速度提升显著。将库文件全部改成CDN提供后，又在七牛上申请了免费的云空间。新博客页面把使用的资源都放在七牛的云空间上，比之前要快得多，也敢使用大图片和矢量图标之类的</p>

<h3 id="grunt">Grunt，自动化构建的利器</h3>
<p>Grunt这个东西其实在上一版就已经使用了，通过使用Grunt的各种插件，将博客的编译，开启本地服务器，上传到Github等等都封装到一个命令，一行命令就可以完成整个博客的构建。同时打破了Jekyll的文件目录形式，自己组织源码文件夹，然后通过Grunt来进行文件的复制生成等等。这样管理资源也变得更加容易了</p>

<h3 id="section-5">新样式，新感觉</h3>
<p>虽然一直在努力看一些设计的书和博客，学习网页设计，但无奈审美太乡村非主流。之前的页面配色真心不咋地（虽然现在还是不咋地），一直觉得一个不会网页设计的前端工程师不能算一个真正的前端工程师，于是乎就到处去参照别人的网页，吸取一些好看的网页的设计思路，然后对其进行模仿。新的页面参考了很多页面，后续也会进行更多的改进（不排除闲得无聊再重写一个的可能）。相对于之前的页面，也算换换口味吧</p>

<h2 id="section-6">最后</h2>
<p>最近各种面试被虐的心力憔悴，而且还各种pending没有结果，偷闲换个页面转换一下心情，在这里祝愿自己能早点收到offer吧</p>

<p>这里贴一张小白的微笑，勉励一下自己吧~</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-4-26-new-page2/flag.jpg" alt="小白的微笑" title="小白的微笑" /></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/26/new-page2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 有没有感觉有一些变化？ ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/26/new-page2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 26 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>如果你是曾经来过天镶博客的朋友，肯定会感觉到很大的不同，博客换页面啦！连续六天没有更新博客了，除了各种面试和项目上的事情以外，闲暇时间都在写这个新页面，也就没有写博文了。经过3天半的努力，新页面也终于做出来了~</p>

<h2 id="section">之前的页面</h2>
<p>###失败的模仿
之前的页面是模仿<a href="http://www.csszengarden.com/220//">CSS禅意花园的220号作品</a>做的，虽然CSS什么都是自己写的（无耻地盗用了别人的素材图片），而且做成了响应式的，但模仿出来并不很像。其背景上巨大的字一开始以为是图片，结果是通过文字加mask实现的…但mask的跨浏览器支持很不好，于是乎就放弃了</p>

<h3 id="section-1">缺乏层次感</h3>
<p>由于缺少背景内容，用单纯的颜色去实现就会有一种没经过装修的毛坯房的感觉（而且北京还是灰色的）。于是去网上找了个纹理贴上去，这样背景比单纯的颜色要好一些。但整个页面都是同样的纹理平铺，所有的组件基本上没有太大的区分度，缺乏层次感</p>

<h3 id="section-2">左上角的空洞</h3>
<p>之前的页面左上角也没什么东西可放，而左上角区域也是网页最重要的区域，整个页面总感觉缺了什么，比较空洞。最初想弄几个图片或者用CSS画点什么放在左上角区域，但实践了一下发现丑的可怕，于是乎就放弃了…</p>

<h3 id="section-3">网速的桎梏</h3>
<p>开发之前那个页面的时候，基本没有使用图片，效果都使用CSS实现，背景纹理也是几百B的纹理，这一切都是因为整站搭载在Github上，访问速度较慢。最早一版本使用的html5up的网页，一个纹理60+k，慢的吐血，第二版也就长心眼了，但这个心眼也成了开发时的枷锁
###Jekyll做了太多
之前博客的所有文件都是使用Jekyll生成的静态HTML页面，站点的维系就在于静态页面之间的相互跳转，分页什么的都很不方便（虽然实现了）</p>

<h2 id="section-4">刚出炉的包子更好吃</h2>
<p>###Angular，不一样的开发模式
最近刚学的Angular，其MVVM模式、动态模板、双向绑定、路由功能等等都让我大开眼界。于是乎就决定通过Angular来重新实现这个博客，顺带练练手，使用ngRoute路由来将整个博客做成单页应用，文章列表等等都由Angular动态加载。这样Jekyll不再涉及页面具体的逻辑，只需要生成博客中需要的json、xml以及文章的html等资源文件就可以了。而且使用Angular的filter去实现搜索功能简直爽翻啦~</p>

<h3 id="cdn">CDN，飞一般的感觉</h3>
<p>上一版本的博客页面一个最大的问题就是，担心加载速度。放在github上，GFW常年抽风，所有的资源文件（JS、CSS、字体、图片）等等都放在github上，各种慢。在中间写Gitbook的时候，慢的都想砸电脑了，一个js就600k。偶然间尝试使用<a href="http://www.staticfile.org/">七牛的CDN</a>，加载上面的jQuery、ace等库，速度提升显著。将库文件全部改成CDN提供后，又在七牛上申请了免费的云空间。新博客页面把使用的资源都放在七牛的云空间上，比之前要快得多，也敢使用大图片和矢量图标之类的</p>

<h3 id="grunt">Grunt，自动化构建的利器</h3>
<p>Grunt这个东西其实在上一版就已经使用了，通过使用Grunt的各种插件，将博客的编译，开启本地服务器，上传到Github等等都封装到一个命令，一行命令就可以完成整个博客的构建。同时打破了Jekyll的文件目录形式，自己组织源码文件夹，然后通过Grunt来进行文件的复制生成等等。这样管理资源也变得更加容易了</p>

<h3 id="section-5">新样式，新感觉</h3>
<p>虽然一直在努力看一些设计的书和博客，学习网页设计，但无奈审美太乡村非主流。之前的页面配色真心不咋地（虽然现在还是不咋地），一直觉得一个不会网页设计的前端工程师不能算一个真正的前端工程师，于是乎就到处去参照别人的网页，吸取一些好看的网页的设计思路，然后对其进行模仿。新的页面参考了很多页面，后续也会进行更多的改进（不排除闲得无聊再重写一个的可能）。相对于之前的页面，也算换换口味吧</p>

<h2 id="section-6">最后</h2>
<p>最近各种面试被虐的心力憔悴，而且还各种pending没有结果，偷闲换个页面转换一下心情，在这里祝愿自己能早点收到offer吧</p>

<p>这里贴一张小白的微笑，勉励一下自己吧~</p>

<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-4-26-new-page2/flag.jpg" alt="小白的微笑" title="小白的微笑" /></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/26/new-page2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的设计模式 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/20/js-design-patterns.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 20 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">读书笔记连接</h3>
<p>读书笔记详细内容请看：<a href="/gitbook/jsDesignPatterns/README.html">读书笔记连接</a></p>

<h3 id="section-1">读书</h3>
<p>最近博客更新的不是很频繁，这并不代表我一直都在摸鱼。实际上还是有看一些书的，也做了读书笔记。
###书评
这几天在看《JavaScript设计模式》这本书，里面主要就是讲述了“四人帮”的设计模式在JavaScript中的应用和实现。之前使用Angular发现里面有太多的设计模式，而以前看的关于设计模式的东西也忘得差不多了，看这本书正好帮我找回了以前对于常见设计模式的理解，更是学到了如何使用JavaScript实现这些设计模式。</p>

<p>关于《JavaScript设计模式》这本书，虽然翻译者是汤姆大叔，但说实话，翻译的很蛋疼。读起来不是太好懂。更蛋疼的是，虽然还只看了一半，却发现很多代码中的错误。除了很多代码缩进恶心，还有很多地方代码甚至连到了一起，中间空格被吃掉了</p>

<h3 id="gitbook">Gitbook</h3>
<p>由于读书笔记总是会记录比较多，而且在读时还会自己去实现其中的例子，如果全部发到博客上的话，缩成两到三篇文章由太长，每个模式都单独写一篇又容易刷屏，把其他的文章全部顶掉。所以决定把它们都放在gitbook上，也就是左下角侧边栏的“读书笔记”里面。之前的《CSS禅意花园》和《Don’t make me think》的读书笔记也都放在里面了。未来如果有读书笔记应该也会放在里面吧</p>

<h3 id="section-2">优化</h3>
<p>其实Gitbook这个东西加了有一段时间了，但是因为它的css文件、字体文件和js文件太大（200+k和600+k），放在github上无奈速度太慢，所以也就没怎么用了。最近看了看他模块内部的结构，发现其代码不是动态生成的，这个CSS和JS都是静态的，果断将其丢到了七牛云存储上，而它使用的诸如ace等库也改成了七牛提供的CDN，速度飙升。在把所有图片都丢到七牛上之后，终于可以勉强使用了（也是勉强使用，有时候还是很慢）。如果可以的话，后面把所有博客的图片都丢到七牛上</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/20/js-design-patterns.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的设计模式 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/20/js-design-patterns.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 20 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">读书笔记连接</h3>
<p>读书笔记详细内容请看：<a href="/gitbook/jsDesignPatterns/README.html">读书笔记连接</a></p>

<h3 id="section-1">读书</h3>
<p>最近博客更新的不是很频繁，这并不代表我一直都在摸鱼。实际上还是有看一些书的，也做了读书笔记。
###书评
这几天在看《JavaScript设计模式》这本书，里面主要就是讲述了“四人帮”的设计模式在JavaScript中的应用和实现。之前使用Angular发现里面有太多的设计模式，而以前看的关于设计模式的东西也忘得差不多了，看这本书正好帮我找回了以前对于常见设计模式的理解，更是学到了如何使用JavaScript实现这些设计模式。</p>

<p>关于《JavaScript设计模式》这本书，虽然翻译者是汤姆大叔，但说实话，翻译的很蛋疼。读起来不是太好懂。更蛋疼的是，虽然还只看了一半，却发现很多代码中的错误。除了很多代码缩进恶心，还有很多地方代码甚至连到了一起，中间空格被吃掉了</p>

<h3 id="gitbook">Gitbook</h3>
<p>由于读书笔记总是会记录比较多，而且在读时还会自己去实现其中的例子，如果全部发到博客上的话，缩成两到三篇文章由太长，每个模式都单独写一篇又容易刷屏，把其他的文章全部顶掉。所以决定把它们都放在gitbook上，也就是左下角侧边栏的“读书笔记”里面。之前的《CSS禅意花园》和《Don’t make me think》的读书笔记也都放在里面了。未来如果有读书笔记应该也会放在里面吧</p>

<h3 id="section-2">优化</h3>
<p>其实Gitbook这个东西加了有一段时间了，但是因为它的css文件、字体文件和js文件太大（200+k和600+k），放在github上无奈速度太慢，所以也就没怎么用了。最近看了看他模块内部的结构，发现其代码不是动态生成的，这个CSS和JS都是静态的，果断将其丢到了七牛云存储上，而它使用的诸如ace等库也改成了七牛提供的CDN，速度飙升。在把所有图片都丢到七牛上之后，终于可以勉强使用了（也是勉强使用，有时候还是很慢）。如果可以的话，后面把所有博客的图片都丢到七牛上</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/20/js-design-patterns.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的继承 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/18/javascript-inherit.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 18 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="new">new都干了些什么</h2>
<hr />
<p>###大致流程
通过new创建的对象，大致过程如下：</p>

<ol>
  <li>首先创建个Object</li>
  <li>修改这个对象的<code>__proto__</code>，使其指向构造函数的<code>prototype</code></li>
  <li>将这个对象交给构造函数的<code>this</code>，调用构造函数</li>
  <li>如果构造函数没有return，那么返回这个对象。否则构造函数返回return语句后面的内容</li>
</ol>

<h3 id="section">模拟一下</h3>
<p>我们可以通过在Function.prototype上创建个新方法来模拟new：
<code>javascript
Function.prototype.__new__ = function(){
    var newObj;
    var resultObj;
    newObj = {};
    newObj.__proto__ = this.prototype;
    resultObj = this.apply(newObj, arguments);
    return (typeof resultObj === 'object' &amp;&amp; resultObj) || newObj;
};
</code></p>

<h2 id="constructor">constructor的问题</h2>
<p>在创建一个函数时，会为这个函数增加一个<code>prototype</code>属性指向一个对象，而这个<code>prototype</code>对象内有一个属性就是<code>constructor</code>，这样在使用构造函数创建一个新对象时，新对象的<code>__proto__</code>自然指向含有<code>constructor</code>的构造函数的<code>prototype</code>对象。但当更换了这个构造函数的<code>prototype</code>，一切就不一样了。比如如下代码</p>

<p><code>javascript
function A(){}
A.prototype = {}
console.log(new A().constructor)
//输出：function Object() { [native code] } 
</code>
这里并没有输出<code>function A(){}</code>。因为A的<code>prototype</code>对象已经被重写了，其为一个Object实例，A的<code>prototype</code>对象中不包含<code>constructor</code>属性。而输出Object构造函数是因为Object实例的<code>__proto__</code>指向<code>function Object(){}</code>的prototype属性，而它内部有constructor：</p>

<p><code>javascript
var tmp = new A();
console.log(tmp.__proto__.hasOwnProperty("constructor"));
//输出：false
console.log(tmp.__proto__.__proto__.hasOwnProperty("constructor"));
//输出：true
</code></p>

<p>所以，如果直接使用通过修改<code>prototype</code>的方式实现继承，这将导致<code>constructor</code>不正确，比如如下代码：
<code>javascript
function Parent(){}
function Child(){}
Child.prototype = new Parent();
console.log(new Child().constructor);
//输出：function Parent(){} 
</code></p>

<p>如果想要<code>new Child().constructor</code>指向Child，我们需要显示的修改其<code>prototype</code>的<code>constructor</code>：
<code>javascript
function Parent(){}
function Child(){}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
console.log(new Child().constructor);
//输出：function Child(){}
</code></p>

<h2 id="section-1">继承方法</h2>
<p>###直接继承
这种方式也就是上面的例子了：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
function Child(){
    this.childName = "child";
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出如下图
</code>
整个childIst对象如下图所示：</p>

<p><img src="http://skyinlayer.com/img/js_inherit/1.png" alt="直接继承时的对象" /></p>

<p>这种方式实现简单，这种方式有如下特点：
1. 所有子类实例共用一个父类实例，节省空间
2. 父类的所有属性都会被暴露给子类
3. 父类的属性子类无法直接修改，只能覆盖
4. 无法实现多继承</p>

<h3 id="objectcreate">Object.create方式</h3>
<p>在ECMAScript5中新增了<code>Object.create</code>方法用于实现继承，其大致实现如下（不考虑属性添加）：</p>

<p><code>javascript
Object.prototype.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};
</code></p>

<p>所以一种可行的继承方式变成如下这样：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
function Child(){
    this.childName = "child";
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：如下图所示
</code></p>

<p><img src="http://skyinlayer.com/img/js_inherit/2.png" alt="Object.create继承时的对象" /></p>

<p>没有parentName属性，因为这种方式实现的继承并没有创建父类实例，而是通过一个临时函数复制了父类的<code>prototype</code>来创建。这样的话父类不在其<code>prototype</code>中的属性不会被复制到临时构造函数中，这些属性对子类是不可见的</p>

<p>这种继承方式的特点是：
1. 父类仅其prototype上的属性对子类可见
2. 同样无法多继承
3. 所有子类实例公用的一个父类实例
4. ES5方法，兼容性，ie9+，不兼容时需要polyfill</p>

<p>这种通过创建一个临时对象的方式可以用在很多地方，只要需要隐藏父类自身属性的场景都可以用到</p>

<h3 id="section-2">复制属性实现继承——共用原型</h3>
<p>传统的类继承，子类实例不会共享父类实例，每一个子类实例拥有自己的父类实例。而JS中并没有这样的继承方式，可以通过将父类的所有值拷贝给子类实例的方式来实现继承：</p>

<p><code>javascript
function Parent() {
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
};
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
Child.prototype = Parent.prototype;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：见下图
</code>
子类实例的结构图如下所示：</p>

<p><img src="http://skyinlayer.com/img/js_inherit/3.png" alt="复制属性，共用原型时的对象" /></p>

<p>这种方式，通过<code>Parent.apply(this)</code>将子类实例传递给父类构造函数，让父类构造函数将其属性写入子类之中，这里只复制了父类<code>this</code>上的属性，没有复制原型上的属性。然后再子类构造函数中定义子类属性，若与父类属性同名，将会覆盖父类属性。最后将子类构造函数指向父类构造函数的<code>prototype</code>，使得子类实例拥有父类实例的原型链</p>

<p>这种方式继承有如下特点：
1. 子类属性覆盖掉了父类属性，同时每个子类实例可修改其父类属性而不影响到其他对象
2. 可以通过<code>delete</code>来对父类不想要暴露的属性进行删除
3. 每个子类实例拥有自己的父类属性
4. 子类与父类同名属性发生覆盖，覆盖后无法再获取覆盖前的父类属性值
5. 由于父类和子类共享<code>prototype</code>，若修改子类的<code>prototype</code>属性会影响到所有继承于父类的子类，所以不能修改</p>

<h3 id="section-3">复制属性实现继承——不共用原型</h3>
<p>可通过修改上述方法实现不共用原型的方式：
<code>javascript
function Parent() {
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
};
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/4.png" alt="复制属性，不共用原型时的对象" /></p>

<p>还是通过原型链的方式，这样子类实例就有可修改的父类属性了。但这样会重复调用父类构造函数，导致创建重复属性（比如parentName）浪费内存空间，但这样就去除了上面的共用构造函数<code>prototype</code>所带来的问题。</p>

<h3 id="section-4">扁平复制</h3>
<p>由于继承的目标就是让子类拥有父类的特性，那么最为简单粗暴的方法，就是把父类的所有属性和方法全部复制到子类上去：</p>

<p><code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    var parentIst = new Parent();
    var item;
    for(item in parentIst) {
        this[item] = parentIst[item];
    }
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：见下图
</code></p>

<p><img src="http://skyinlayer.com/img/js_inherit/5.png" alt="扁平复制所有属性时的对象" /></p>

<p>这种方式实现的继承比较扁平，由于没有使用原型继承，其原型链层数不会增加，有如下特点：
1. 可以实现多继承
2. 会发生属性覆盖，被覆盖的属性无法获得
3. <code>instanceof</code>操作符无法检测父类
4. 子类实例拥有所有父类实例的所有属性，且可修改和删除
5. 父类所有属性均进入到子类中（可能后面会被覆盖，可以通过<code>Object.create</code>所提供的方式修改实现）</p>

<h3 id="section-5">隐藏属性的扁平复制——仅复制父类原型属性</h3>
<p>考虑到属性隐藏，可以使用Object.create的方式来进行属性隐藏，那么代码就变成下面这样了：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    var tmpFn = function(){};
    var tmpFnIst;
    var item;
    tmpFn.prototype = Parent.prototype;
    tmpFnIst = new tmpFn();
    for(item in tmpFnIst) {
        this[item] = tmpFnIst[item];
    }
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/6.png" alt="扁平复制父类原型属性时的对象" /></p>

<p>可以看到，通过临时构造函数，将父类中不在其<code>prototype</code>中的属性进行了隐藏</p>

<h3 id="section-6">隐藏属性的扁平复制——仅复制父类自身属性</h3>
<p><code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/7.png" alt="扁平复制父类自身属性的对象" /></p>

<p>这种方式和上面方式刚好相反，仅仅复制父类自身方法，而不复制其原型链上的方法</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/18/javascript-inherit.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript的继承 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/18/javascript-inherit.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 18 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="new">new都干了些什么</h2>
<hr />
<p>###大致流程
通过new创建的对象，大致过程如下：</p>

<ol>
  <li>首先创建个Object</li>
  <li>修改这个对象的<code>__proto__</code>，使其指向构造函数的<code>prototype</code></li>
  <li>将这个对象交给构造函数的<code>this</code>，调用构造函数</li>
  <li>如果构造函数没有return，那么返回这个对象。否则构造函数返回return语句后面的内容</li>
</ol>

<h3 id="section">模拟一下</h3>
<p>我们可以通过在Function.prototype上创建个新方法来模拟new：
<code>javascript
Function.prototype.__new__ = function(){
    var newObj;
    var resultObj;
    newObj = {};
    newObj.__proto__ = this.prototype;
    resultObj = this.apply(newObj, arguments);
    return (typeof resultObj === 'object' &amp;&amp; resultObj) || newObj;
};
</code></p>

<h2 id="constructor">constructor的问题</h2>
<p>在创建一个函数时，会为这个函数增加一个<code>prototype</code>属性指向一个对象，而这个<code>prototype</code>对象内有一个属性就是<code>constructor</code>，这样在使用构造函数创建一个新对象时，新对象的<code>__proto__</code>自然指向含有<code>constructor</code>的构造函数的<code>prototype</code>对象。但当更换了这个构造函数的<code>prototype</code>，一切就不一样了。比如如下代码</p>

<p><code>javascript
function A(){}
A.prototype = {}
console.log(new A().constructor)
//输出：function Object() { [native code] } 
</code>
这里并没有输出<code>function A(){}</code>。因为A的<code>prototype</code>对象已经被重写了，其为一个Object实例，A的<code>prototype</code>对象中不包含<code>constructor</code>属性。而输出Object构造函数是因为Object实例的<code>__proto__</code>指向<code>function Object(){}</code>的prototype属性，而它内部有constructor：</p>

<p><code>javascript
var tmp = new A();
console.log(tmp.__proto__.hasOwnProperty("constructor"));
//输出：false
console.log(tmp.__proto__.__proto__.hasOwnProperty("constructor"));
//输出：true
</code></p>

<p>所以，如果直接使用通过修改<code>prototype</code>的方式实现继承，这将导致<code>constructor</code>不正确，比如如下代码：
<code>javascript
function Parent(){}
function Child(){}
Child.prototype = new Parent();
console.log(new Child().constructor);
//输出：function Parent(){} 
</code></p>

<p>如果想要<code>new Child().constructor</code>指向Child，我们需要显示的修改其<code>prototype</code>的<code>constructor</code>：
<code>javascript
function Parent(){}
function Child(){}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
console.log(new Child().constructor);
//输出：function Child(){}
</code></p>

<h2 id="section-1">继承方法</h2>
<p>###直接继承
这种方式也就是上面的例子了：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
function Child(){
    this.childName = "child";
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出如下图
</code>
整个childIst对象如下图所示：</p>

<p><img src="http://skyinlayer.com/img/js_inherit/1.png" alt="直接继承时的对象" /></p>

<p>这种方式实现简单，这种方式有如下特点：
1. 所有子类实例共用一个父类实例，节省空间
2. 父类的所有属性都会被暴露给子类
3. 父类的属性子类无法直接修改，只能覆盖
4. 无法实现多继承</p>

<h3 id="objectcreate">Object.create方式</h3>
<p>在ECMAScript5中新增了<code>Object.create</code>方法用于实现继承，其大致实现如下（不考虑属性添加）：</p>

<p><code>javascript
Object.prototype.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};
</code></p>

<p>所以一种可行的继承方式变成如下这样：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
function Child(){
    this.childName = "child";
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：如下图所示
</code></p>

<p><img src="http://skyinlayer.com/img/js_inherit/2.png" alt="Object.create继承时的对象" /></p>

<p>没有parentName属性，因为这种方式实现的继承并没有创建父类实例，而是通过一个临时函数复制了父类的<code>prototype</code>来创建。这样的话父类不在其<code>prototype</code>中的属性不会被复制到临时构造函数中，这些属性对子类是不可见的</p>

<p>这种继承方式的特点是：
1. 父类仅其prototype上的属性对子类可见
2. 同样无法多继承
3. 所有子类实例公用的一个父类实例
4. ES5方法，兼容性，ie9+，不兼容时需要polyfill</p>

<p>这种通过创建一个临时对象的方式可以用在很多地方，只要需要隐藏父类自身属性的场景都可以用到</p>

<h3 id="section-2">复制属性实现继承——共用原型</h3>
<p>传统的类继承，子类实例不会共享父类实例，每一个子类实例拥有自己的父类实例。而JS中并没有这样的继承方式，可以通过将父类的所有值拷贝给子类实例的方式来实现继承：</p>

<p><code>javascript
function Parent() {
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
};
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
Child.prototype = Parent.prototype;
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：见下图
</code>
子类实例的结构图如下所示：</p>

<p><img src="http://skyinlayer.com/img/js_inherit/3.png" alt="复制属性，共用原型时的对象" /></p>

<p>这种方式，通过<code>Parent.apply(this)</code>将子类实例传递给父类构造函数，让父类构造函数将其属性写入子类之中，这里只复制了父类<code>this</code>上的属性，没有复制原型上的属性。然后再子类构造函数中定义子类属性，若与父类属性同名，将会覆盖父类属性。最后将子类构造函数指向父类构造函数的<code>prototype</code>，使得子类实例拥有父类实例的原型链</p>

<p>这种方式继承有如下特点：
1. 子类属性覆盖掉了父类属性，同时每个子类实例可修改其父类属性而不影响到其他对象
2. 可以通过<code>delete</code>来对父类不想要暴露的属性进行删除
3. 每个子类实例拥有自己的父类属性
4. 子类与父类同名属性发生覆盖，覆盖后无法再获取覆盖前的父类属性值
5. 由于父类和子类共享<code>prototype</code>，若修改子类的<code>prototype</code>属性会影响到所有继承于父类的子类，所以不能修改</p>

<h3 id="section-3">复制属性实现继承——不共用原型</h3>
<p>可通过修改上述方法实现不共用原型的方式：
<code>javascript
function Parent() {
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
};
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/4.png" alt="复制属性，不共用原型时的对象" /></p>

<p>还是通过原型链的方式，这样子类实例就有可修改的父类属性了。但这样会重复调用父类构造函数，导致创建重复属性（比如parentName）浪费内存空间，但这样就去除了上面的共用构造函数<code>prototype</code>所带来的问题。</p>

<h3 id="section-4">扁平复制</h3>
<p>由于继承的目标就是让子类拥有父类的特性，那么最为简单粗暴的方法，就是把父类的所有属性和方法全部复制到子类上去：</p>

<p><code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    var parentIst = new Parent();
    var item;
    for(item in parentIst) {
        this[item] = parentIst[item];
    }
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst instanceof Child);
//输出：true
console.log(childIst instanceof Parent);
//输出：true
console.log(childIst.constructor);
//输出：function Child(){}
console.log(childIst);
//输出：见下图
</code></p>

<p><img src="http://skyinlayer.com/img/js_inherit/5.png" alt="扁平复制所有属性时的对象" /></p>

<p>这种方式实现的继承比较扁平，由于没有使用原型继承，其原型链层数不会增加，有如下特点：
1. 可以实现多继承
2. 会发生属性覆盖，被覆盖的属性无法获得
3. <code>instanceof</code>操作符无法检测父类
4. 子类实例拥有所有父类实例的所有属性，且可修改和删除
5. 父类所有属性均进入到子类中（可能后面会被覆盖，可以通过<code>Object.create</code>所提供的方式修改实现）</p>

<h3 id="section-5">隐藏属性的扁平复制——仅复制父类原型属性</h3>
<p>考虑到属性隐藏，可以使用Object.create的方式来进行属性隐藏，那么代码就变成下面这样了：
<code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    var tmpFn = function(){};
    var tmpFnIst;
    var item;
    tmpFn.prototype = Parent.prototype;
    tmpFnIst = new tmpFn();
    for(item in tmpFnIst) {
        this[item] = tmpFnIst[item];
    }
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/6.png" alt="扁平复制父类原型属性时的对象" /></p>

<p>可以看到，通过临时构造函数，将父类中不在其<code>prototype</code>中的属性进行了隐藏</p>

<h3 id="section-6">隐藏属性的扁平复制——仅复制父类自身属性</h3>
<p><code>javascript
function Parent(){
    this.parentName = "parent";
}
Parent.prototype.getName = function(){
    return this.parentName;
}
function Child(){
    Parent.apply(this, arguments);
    this.childName = "child";
}
var childIst = new Child();
console.log(childIst);
//输出：见下图
</code>
<img src="http://skyinlayer.com/img/js_inherit/7.png" alt="扁平复制父类自身属性的对象" /></p>

<p>这种方式和上面方式刚好相反，仅仅复制父类自身方法，而不复制其原型链上的方法</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/18/javascript-inherit.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ HTTP协议状态码备忘 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/16/http-code.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">100~199——信息性状态码</h3>
<p>####100——continue（继续）
说明收到了请求的初始部分，请客户端继续。
####101——switching protocols（协议更换）
说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</p>

<hr />
<p>###200~299——成功状态码
####200——OK（请求成功）
请求没问题，实体的主体部分包括了所请求的资源
####201——Created（对象已创建）
用于创建服务器对象的请求（如PUT）。相应实体主体部分中应该包含额各种已创建的资源的URL。Location首部包含的则是最具体的引用
####202——Accepted（请求被接受）
请求已被接受，但服务器还未对其执行任何动作。且不保证服务器能够完成这个请求。
####203——Non-Authoritative Infomation
实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者没有对它所发送的资源有关的元信息进行验证，就会出现这种情况
####204——No Content
响应报文中包含若干首部和一个状态行，但没有实体的主体部分
####205——Reset Content
负责告知浏览器清除当前页面中的所有HTML表单元素
####206——Partial Content
成功执行了一个部分或Range（范围）请求。必须包含Content-Range、Date以及ETag或Content-Location首部</p>

<hr />
<p>###300~399——重定向状态码
####300——Multiple Choices
客户端请求一个实际指向多个资源的URL时会返回这个状态码，返回这个状态码时会带有一个选项列表，这样用户就可以选择他所希望的一项了
####301——Moved Permanently
在请求的URL已被移除时使用。响应的Location首部应当包含资源现在所处的URL
####302——Found
与301类似，但客户端使用Location首部给出URL来临时定位资源。将来的请求仍应当使用老的URL
####303——See Other
告知客户端应当使用另一个URL来获取资源。新的URL位于响应报文的Location首部，主要目的是允许POST请求的相应将客户端定向到某个资源上去
####304——Not Modified
客户端可以通过所包含的的请求首部，使其请求变成有条件的。带有这个状态码的相应不应该包含实体的主体部分
####305——Use Proxy
用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出
####307——Temporary Redirect
与301类似，但客户端使用Location首部给出URL来临时定位资源。将来的请求仍应当使用老的URL</p>

<h3 id="section-1">302、303、307之前的区别</h3>
<p>当HTTP/1.0客户端发起一个POST请求，并在响应中收到302重定向状态码时，它会接受Location首部的重定向URL，并向那个URL发起一个GET请求（不是POST请求）</p>

<p>而HTTP/1.1则使用303状态码完成同样的行为</p>

<p>对于HTTP/1.1客户端，用307状态码取代302状态码来进行临时重定向，这样302状态码就能被保留个给HTTP/1.0客户端使用了</p>

<hr />
<p>###400~499——客户端错误状态码
####400——Bad Request（请求错误）
告知用户它发送了一个错误的请求
####401——Unauthorized（未授权）
与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证
####402——Payment Required（需付费）
####403——Forbidden（请求被拒绝）
用于说明请求被服务器拒绝了。可以通过主题部分来描述拒绝原因。但一般是在服务器不想说明拒绝原因时使用这个状态码
####404——Not Found（资源未找到）
用于说明服务器无法找到所请求的URL
####405——Method Not Allowed（方法不被允许）
发起的请求中带有所请求的URL不支持的方法。在响应的ALlow首部，告诉客户端所请求的资源可使用哪些方法
####406——Not Acceptable（无法接受）
客户端可以指定参数来说明它们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码
####407——Proxy Authentication Required（代理服务器未认证）
要求对资源进行认证代理服务器
####408——Request Timeout（请求超时）
如果客户端完成请求所花的时间太长，服务器可以回送此状态码
####409——Conflict（指令冲突）
用于说明请求可能在资源上引发一些冲突。服务器担心请求引发冲突时，返回此代码
####410——Gone（已移除）
服务器曾经拥有过此资源，但已经移除了
####411——Length Required（必须携带长度）
服务器要求在请求报文中包含Content-Length首部
####412——Precondition Failed（不符合请求条件）
客户端发起了条件请求，而其中一个条件失败了
####413——Request Entity Too Large（请求实体过大）
客户端所发送的请求主体部分比服务器所能够或希望处理的要长
####414——Request URI Too Long（请求URL过长）
客户端所发请求中的请求URL比服务器能够或希望处理的要长
####415——Unsupported Media Type（媒体不被支持）
服务器无法理解或无法支持客户端所发实体的内容类型
####416——Requested Range Not Satisfiable（请求的范围无法被满足）
请求报文请求的是某个资源的某个范围，而此范围无效或无法满足
####417——Expection Failed（无法满足期望）
请求的Expect请求首部包含了一个期望，但服务器无法满足此期望</p>

<hr />
<p>###500~599——服务器错误状态码
####500——Internal Server Error（服务器内部错误）
服务器遇到一个妨碍它为请求提供服务的错误
####501——Not Implemented（请求超出能力范围）
客户端发起的请求超出服务器的能力范围
####502——Bad Gateway（错误的网关）
作为代理或网关使用的服务器从请求响应链的下一条链路上收到一条伪响应
####503——Service Unavailable（服务不可用）
服务器现在无法为请求提供服务，但将来可以
####504——Gateway Timeout（网关超时）
响应来自一个网关或代理，他们在等待另一服务器对齐请求进行响应时超时了
####505——HTTP Version Not Supported（HTTP协议版本不正确）
服务器收到的请求使用了它无法或不愿支持的版本</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/16/http-code.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ HTTP协议状态码备忘 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/16/http-code.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">100~199——信息性状态码</h3>
<p>####100——continue（继续）
说明收到了请求的初始部分，请客户端继续。
####101——switching protocols（协议更换）
说明服务器正在根据客户端的指定，将协议切换成update首部所列的协议</p>

<hr />
<p>###200~299——成功状态码
####200——OK（请求成功）
请求没问题，实体的主体部分包括了所请求的资源
####201——Created（对象已创建）
用于创建服务器对象的请求（如PUT）。相应实体主体部分中应该包含额各种已创建的资源的URL。Location首部包含的则是最具体的引用
####202——Accepted（请求被接受）
请求已被接受，但服务器还未对其执行任何动作。且不保证服务器能够完成这个请求。
####203——Non-Authoritative Infomation
实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者没有对它所发送的资源有关的元信息进行验证，就会出现这种情况
####204——No Content
响应报文中包含若干首部和一个状态行，但没有实体的主体部分
####205——Reset Content
负责告知浏览器清除当前页面中的所有HTML表单元素
####206——Partial Content
成功执行了一个部分或Range（范围）请求。必须包含Content-Range、Date以及ETag或Content-Location首部</p>

<hr />
<p>###300~399——重定向状态码
####300——Multiple Choices
客户端请求一个实际指向多个资源的URL时会返回这个状态码，返回这个状态码时会带有一个选项列表，这样用户就可以选择他所希望的一项了
####301——Moved Permanently
在请求的URL已被移除时使用。响应的Location首部应当包含资源现在所处的URL
####302——Found
与301类似，但客户端使用Location首部给出URL来临时定位资源。将来的请求仍应当使用老的URL
####303——See Other
告知客户端应当使用另一个URL来获取资源。新的URL位于响应报文的Location首部，主要目的是允许POST请求的相应将客户端定向到某个资源上去
####304——Not Modified
客户端可以通过所包含的的请求首部，使其请求变成有条件的。带有这个状态码的相应不应该包含实体的主体部分
####305——Use Proxy
用来说明必须通过一个代理来访问资源，代理的位置由Location首部给出
####307——Temporary Redirect
与301类似，但客户端使用Location首部给出URL来临时定位资源。将来的请求仍应当使用老的URL</p>

<h3 id="section-1">302、303、307之前的区别</h3>
<p>当HTTP/1.0客户端发起一个POST请求，并在响应中收到302重定向状态码时，它会接受Location首部的重定向URL，并向那个URL发起一个GET请求（不是POST请求）</p>

<p>而HTTP/1.1则使用303状态码完成同样的行为</p>

<p>对于HTTP/1.1客户端，用307状态码取代302状态码来进行临时重定向，这样302状态码就能被保留个给HTTP/1.0客户端使用了</p>

<hr />
<p>###400~499——客户端错误状态码
####400——Bad Request（请求错误）
告知用户它发送了一个错误的请求
####401——Unauthorized（未授权）
与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证
####402——Payment Required（需付费）
####403——Forbidden（请求被拒绝）
用于说明请求被服务器拒绝了。可以通过主题部分来描述拒绝原因。但一般是在服务器不想说明拒绝原因时使用这个状态码
####404——Not Found（资源未找到）
用于说明服务器无法找到所请求的URL
####405——Method Not Allowed（方法不被允许）
发起的请求中带有所请求的URL不支持的方法。在响应的ALlow首部，告诉客户端所请求的资源可使用哪些方法
####406——Not Acceptable（无法接受）
客户端可以指定参数来说明它们愿意接受什么类型的实体。服务器没有与客户端可接受的URL相匹配的资源时，使用此代码
####407——Proxy Authentication Required（代理服务器未认证）
要求对资源进行认证代理服务器
####408——Request Timeout（请求超时）
如果客户端完成请求所花的时间太长，服务器可以回送此状态码
####409——Conflict（指令冲突）
用于说明请求可能在资源上引发一些冲突。服务器担心请求引发冲突时，返回此代码
####410——Gone（已移除）
服务器曾经拥有过此资源，但已经移除了
####411——Length Required（必须携带长度）
服务器要求在请求报文中包含Content-Length首部
####412——Precondition Failed（不符合请求条件）
客户端发起了条件请求，而其中一个条件失败了
####413——Request Entity Too Large（请求实体过大）
客户端所发送的请求主体部分比服务器所能够或希望处理的要长
####414——Request URI Too Long（请求URL过长）
客户端所发请求中的请求URL比服务器能够或希望处理的要长
####415——Unsupported Media Type（媒体不被支持）
服务器无法理解或无法支持客户端所发实体的内容类型
####416——Requested Range Not Satisfiable（请求的范围无法被满足）
请求报文请求的是某个资源的某个范围，而此范围无效或无法满足
####417——Expection Failed（无法满足期望）
请求的Expect请求首部包含了一个期望，但服务器无法满足此期望</p>

<hr />
<p>###500~599——服务器错误状态码
####500——Internal Server Error（服务器内部错误）
服务器遇到一个妨碍它为请求提供服务的错误
####501——Not Implemented（请求超出能力范围）
客户端发起的请求超出服务器的能力范围
####502——Bad Gateway（错误的网关）
作为代理或网关使用的服务器从请求响应链的下一条链路上收到一条伪响应
####503——Service Unavailable（服务不可用）
服务器现在无法为请求提供服务，但将来可以
####504——Gateway Timeout（网关超时）
响应来自一个网关或代理，他们在等待另一服务器对齐请求进行响应时超时了
####505——HTTP Version Not Supported（HTTP协议版本不正确）
服务器收到的请求使用了它无法或不愿支持的版本</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/16/http-code.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ HTTP协议的一些基础知识 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/16/http-base.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="http">HTTP通信简要步骤：</h2>
<ol>
  <li>浏览器从URL中解析出服务器的主机名</li>
  <li>浏览器将服务器的主机名转换成服务器的IP地址</li>
  <li>浏览器将端口号从URL中解析出来</li>
  <li>浏览器建立一条与Web服务器的TCP连接</li>
  <li>浏览器向服务器发送一条HTTP请求报文</li>
  <li>服务器想浏览器回送一条HTTP响应报文</li>
  <li>关闭连接，浏览器显示文档</li>
</ol>

<hr />
<p>##Web组件结构
###代理
位于客户端和服务器之间，接受所有客户端的HTTP请求，并将这些请求转发给服务器
###缓存
Web缓存或代理缓存是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了
###网关
一种特殊的服务器，作为其他服务器的中间实体使用通常用于将HTTP流量转换成其他的协议
###隧道
隧道建立起来之后，就会在两条连接黄子健对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据
###Agent代理（用户代理）
用户代理代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理</p>

<hr />
<p>##URL
###URL语法
```</p>
<scheme>://<user>:<password>@<host>:<post>/<path>;<params>?<query>#<frag>
```
###组成部分
1. 方案（scheme）：访问服务器获取资源用的协议
2. 用户（user）：某些方案访问资源需要用户名
3. 密码（password）：欧诺个户名后面可能要包含的密码，以冒号分隔
4. 主机（host）：资源宿主服务器的主机名或IP地址
5. 端口（post）：资源宿主服务器正在监听的端口号，很多方案有自己的默认端口（HTTP为80，HTTPS为443）
6. 路径（PATH）：服务器上资源的本地名，由一个斜杠将其与前面的URL组件分离开来
7. 参数（params）：某些方案会用这个组件来指定输入参数
8. 查询（query）：某些方案会用这个组件传递参数
9. 片段（frag）：一小片或一部分资源的名字，不会发送给服务器，在客户端内部使用

###常见方案
1. http：超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符，默认端口80
2. https：与http唯一区别在于https使用了网景的SSL。默认端口为443
3. mailto：指向的是E-mail地址，mailto URL的格式与标准的URL的格式不同
4. ftp：文件传输协议URL可以用来从FTP服务器上下载或上载文件，并获取FTP服务器上的目录结构内容的列表
5. rtsp、rtspu：RTSP URL是可以通过实时流传输协议解析的音/视频媒体资源的标识符
6. file：表示一台指定主机上可直接访问的文件
7. news：用来访问一些特定的文章或新闻组
8. telnet：用于访问交互式业务

---
##HTTP报文
###报文组成
1. 起始行
2. 首部块
3. 可选的包含数据的主体部分

起始行和首部就是由行分割的ASCII文本，每行都以一个由两个字符组成的行终止符CRLF组成（一个回车-13和一个换行符-10）
##报文分类
两大类：
1. 请求报文：客户端发向服务器
2. 响应报文：服务器发向客户端

---
##起始行
###请求行
请求报文的起始行，包含了一个方法和一个URL
###响应行
响应报文的起始行，包含了响应报文所使用的HTTP版本、数字状态码、以及描述状态码的原因短语
###方法
请求的起始行以方法开始，用来告知服务器要做什么
###状态码
位于响应的起始行中，告诉客户端发生了什么事情
###原因短语
响应的起始行中的最后一个组件，为状态码提供文本形式的解释
###版本号
以HTTP/x.y的形式出现在请求和响应报文的起始行中

---
##首部
跟在起始行后面呃就是零个、一个或多个HTTP首部字段。本质上来说它们只是一些名/值对的列表
###首部分类
1. 通用首部：可以出现在请求报文中，也可以出现在响应报文中
2. 请求首部：提供更多关于请求的信息
3. 响应首部：提供更多关于响应的信息
4. 实体首部：描述主体的长度和内容，或者资源自身
5. 扩展首部：规范中没有定义的新首部

---
##HTTP方法
###安全方法
GET和HEAD方法是安全方法，他们不会再服务器上产生什么结果
###GET
最常用的方法，通常用于请求服务器发送某个资源
###HEAD
与GET行为相似，但服务器在响应中只返回首部，不会返回实体的主体部分，这样允许客户端在未获取实际资源的情况下，对资源首部进行检查，可以：
1. 在不获取资源的情况下了解资源的情况
2. 通过查看响应中的状态码，看看某个对象是否存在
3. 通过查看首部，测试资源是否被修改

###PUT
与GET相反，PUT方法向服务器写入文档。语义就是让服务器用请求的主体部分来创建一个由所请求URL命名的新文档，如果已经存在呃话，就替换它
###POST
起初用来向服务器输入数据，现在通常用它来支持HTML的表单
###TRACE
客户端发起一个请求时，请求可能要穿过防火墙、代理、网关或其他一一些应用程序。每个中间节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。

TRACE请求不能带有实体的主题部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本
###OPTIONS
请求WEB服务器告知其支持的各种功能
###DELETE
请服务器删除请求URL所指定的资源，但不保证一定会被执行
---
##首部
###通用首部
请求报文和响应报文都可以使用的首部，有：
1. Connection：允许客户端和服务器指定与请求/响应连接有关的选项
2. Date：提供日期和时间标志，说明报文什么时候创建的
3. MIME-Version：给出了发送端使用的MIME版本
4. Trailer：如果报文采用了分块传输编码方式，可以用这个首部列出位于报文拖挂部分的首部集合
5. Transfer-Encoding：告知接受端为了保证报文的可靠传输，对报文采用了什么编码方式
6. Update：给出发送端可能想要升级使用的新版本或协议
7. Via：显示豹纹经过的中间节点（代理、网关）
8. Cache-Control：用于随报文传送缓存指示
9. Pragma：另一种随报文传送指示的方式，但并不专用于缓存

###请求首部
只在请求报文中有意义，有：
1. Client-IP：客户端及其的IP
2. FROM：客户端用户的E-mail地址
3. Host：接受请求的服务器主机名和端口号
4. Referer：包含当前请求URI的文档的URL
5. UA-Color：客户端显示器的显示颜色有关的信息
6. UA-CPU：给出客户端CPU的类型或制造商
7. UA-Disp：客户端显示器（屏幕）能力相关信息
8. UA-OS：客户端机器上的操作系统名称及版本
9. UA-Pixels：客户端显示器的像素信息
10. User-Agent：发起请求的应用程序名称

Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，告诉服务器它们想要什么，可以使用什么，以及他们不想要什么：
1. Accept：告诉服务器能够发送哪些媒体类型
2. Accept-Charset：告诉服务器能够发送哪些字符集
3. Accept-Encoding：告诉服务器能发送哪些编码方式
4. Accept-Language：告诉服务器能够发送哪些语言
5. TE：告诉服务器可以使用那些扩展传输编码

条件请求首部在客户端希望为请求加上某些限制时使用，要求服务器在队请求进行响应之前，确保某个条件为真：
1. Expect：允许客户端列出某请求所要求的服务器行为
2. If-Match：如果实体标记与文档当前的实体标记想匹配，就获取这份文档
3. If-Modified-Since：除非在某个指定的日期之后资源被修改过，否则就限制这个请求
4. If-None-Match：如果提供的实体标记与当前文档的实体标记不相符，就获取文档
5. If-Range：允许对文档的某个范围进行条件请求
6. If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
7. Range：如果服务器支持范围请求，就请求资源的指定范围

安全请求首部有：
1. Authorization：包含了客户端提供了服务器，以便对其自身进行认证的数据
2. Cookie：客户端用它向服务器传送一个令牌，它并不是真正的安全受不，但却是隐含了安全功能
3. Cookie2：用来说明请求端支持的cookie版本

代理请求首部：
1. Max-Forward：在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数，与TRACE方法一同使用
2. Proxy-Authorization：与Authorization首部相同，但这个首部是与代理进行认证时使用的
3. Proxy-Connection：与Connection首部相同，但这个首部是与代理建立连接时使用的

###响应首部
响应报文有自己的首部集，为客户端提供一些额外的响应信息：
1. Age：响应持续时间
2. Public：服务器为其资源支持的请求方法列表
3. Retry-After：如果资源不可用，在此日期或时间重试
4. Server：服务器应用程序软件的名称和版本
5. Title：对HTML来说，就是HTML文档的源端给出的标题
6. Warning：比原因短语中更详细一些的警告报文

协商首部，如果资源有多重白哦是方法，可以使用协商首部为服务器和客户端提供对资源进行协商的能力：
1. Accept-Ranges：对此资源来说，服务器可接受的范围类型
2. Vary：服务器查看其他首部的列表，可能会使响应发生变化

安全响应首部：
1. Proxy-Authenticate：来自代理的对客户端的质询列表
2. Set-Cookie：不是真正的安全首部，但隐含安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识
3. Set-Cookie2：与Set-Cookie相似
4. WWW-Authenticate：来自服务器呃对客户端的质询列表

###实体首部
实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法：
1. Allow：列出了可以对此实体执行的请求方法
2. Location：告知客户端实体实际上位于何处

内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息：
1. Content-Base：解析主题中的相对URL是使用的基础URL
2. Content-Encoding：对主体执行的任意编码方式
3. Content-Language：理解主题时最适合使用的自然语言
4. Content-Length：主体的长度和尺寸
5. Content-Location：资源实际所处的位置
6. Content-MD5：主体的MD5校验和
7. Content-Range：在整个资源中此实体表示的字节范围
8. Content-Type：主题的对象类型

实体缓存首部提供了与被缓存实体有关的信息：
1. ETag：与此实体相关的实体标记
2. Expires：实体不再有效，要从原始的源端再次获取此实体的日期和时间
3. Last-Modified：这个实体最后一次被修改的日期和时间

</frag></query></params></path></post></host></password></user></scheme>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/16/http-base.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ HTTP协议的一些基础知识 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/16/http-base.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="http">HTTP通信简要步骤：</h2>
<ol>
  <li>浏览器从URL中解析出服务器的主机名</li>
  <li>浏览器将服务器的主机名转换成服务器的IP地址</li>
  <li>浏览器将端口号从URL中解析出来</li>
  <li>浏览器建立一条与Web服务器的TCP连接</li>
  <li>浏览器向服务器发送一条HTTP请求报文</li>
  <li>服务器想浏览器回送一条HTTP响应报文</li>
  <li>关闭连接，浏览器显示文档</li>
</ol>

<hr />
<p>##Web组件结构
###代理
位于客户端和服务器之间，接受所有客户端的HTTP请求，并将这些请求转发给服务器
###缓存
Web缓存或代理缓存是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来，下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了
###网关
一种特殊的服务器，作为其他服务器的中间实体使用通常用于将HTTP流量转换成其他的协议
###隧道
隧道建立起来之后，就会在两条连接黄子健对原始数据进行盲转发的HTTP应用程序。HTTP隧道通常用来在一条或多条HTTP连接上转发非HTTP数据，转发时不会窥探数据
###Agent代理（用户代理）
用户代理代表用户发起HTTP请求的客户端程序。所有发布Web请求的应用程序都是HTTP Agent代理</p>

<hr />
<p>##URL
###URL语法
```</p>
<scheme>://<user>:<password>@<host>:<post>/<path>;<params>?<query>#<frag>
```
###组成部分
1. 方案（scheme）：访问服务器获取资源用的协议
2. 用户（user）：某些方案访问资源需要用户名
3. 密码（password）：欧诺个户名后面可能要包含的密码，以冒号分隔
4. 主机（host）：资源宿主服务器的主机名或IP地址
5. 端口（post）：资源宿主服务器正在监听的端口号，很多方案有自己的默认端口（HTTP为80，HTTPS为443）
6. 路径（PATH）：服务器上资源的本地名，由一个斜杠将其与前面的URL组件分离开来
7. 参数（params）：某些方案会用这个组件来指定输入参数
8. 查询（query）：某些方案会用这个组件传递参数
9. 片段（frag）：一小片或一部分资源的名字，不会发送给服务器，在客户端内部使用

###常见方案
1. http：超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符，默认端口80
2. https：与http唯一区别在于https使用了网景的SSL。默认端口为443
3. mailto：指向的是E-mail地址，mailto URL的格式与标准的URL的格式不同
4. ftp：文件传输协议URL可以用来从FTP服务器上下载或上载文件，并获取FTP服务器上的目录结构内容的列表
5. rtsp、rtspu：RTSP URL是可以通过实时流传输协议解析的音/视频媒体资源的标识符
6. file：表示一台指定主机上可直接访问的文件
7. news：用来访问一些特定的文章或新闻组
8. telnet：用于访问交互式业务

---
##HTTP报文
###报文组成
1. 起始行
2. 首部块
3. 可选的包含数据的主体部分

起始行和首部就是由行分割的ASCII文本，每行都以一个由两个字符组成的行终止符CRLF组成（一个回车-13和一个换行符-10）
##报文分类
两大类：
1. 请求报文：客户端发向服务器
2. 响应报文：服务器发向客户端

---
##起始行
###请求行
请求报文的起始行，包含了一个方法和一个URL
###响应行
响应报文的起始行，包含了响应报文所使用的HTTP版本、数字状态码、以及描述状态码的原因短语
###方法
请求的起始行以方法开始，用来告知服务器要做什么
###状态码
位于响应的起始行中，告诉客户端发生了什么事情
###原因短语
响应的起始行中的最后一个组件，为状态码提供文本形式的解释
###版本号
以HTTP/x.y的形式出现在请求和响应报文的起始行中

---
##首部
跟在起始行后面呃就是零个、一个或多个HTTP首部字段。本质上来说它们只是一些名/值对的列表
###首部分类
1. 通用首部：可以出现在请求报文中，也可以出现在响应报文中
2. 请求首部：提供更多关于请求的信息
3. 响应首部：提供更多关于响应的信息
4. 实体首部：描述主体的长度和内容，或者资源自身
5. 扩展首部：规范中没有定义的新首部

---
##HTTP方法
###安全方法
GET和HEAD方法是安全方法，他们不会再服务器上产生什么结果
###GET
最常用的方法，通常用于请求服务器发送某个资源
###HEAD
与GET行为相似，但服务器在响应中只返回首部，不会返回实体的主体部分，这样允许客户端在未获取实际资源的情况下，对资源首部进行检查，可以：
1. 在不获取资源的情况下了解资源的情况
2. 通过查看响应中的状态码，看看某个对象是否存在
3. 通过查看首部，测试资源是否被修改

###PUT
与GET相反，PUT方法向服务器写入文档。语义就是让服务器用请求的主体部分来创建一个由所请求URL命名的新文档，如果已经存在呃话，就替换它
###POST
起初用来向服务器输入数据，现在通常用它来支持HTML的表单
###TRACE
客户端发起一个请求时，请求可能要穿过防火墙、代理、网关或其他一一些应用程序。每个中间节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成什么样子。

TRACE请求不能带有实体的主题部分。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本
###OPTIONS
请求WEB服务器告知其支持的各种功能
###DELETE
请服务器删除请求URL所指定的资源，但不保证一定会被执行
---
##首部
###通用首部
请求报文和响应报文都可以使用的首部，有：
1. Connection：允许客户端和服务器指定与请求/响应连接有关的选项
2. Date：提供日期和时间标志，说明报文什么时候创建的
3. MIME-Version：给出了发送端使用的MIME版本
4. Trailer：如果报文采用了分块传输编码方式，可以用这个首部列出位于报文拖挂部分的首部集合
5. Transfer-Encoding：告知接受端为了保证报文的可靠传输，对报文采用了什么编码方式
6. Update：给出发送端可能想要升级使用的新版本或协议
7. Via：显示豹纹经过的中间节点（代理、网关）
8. Cache-Control：用于随报文传送缓存指示
9. Pragma：另一种随报文传送指示的方式，但并不专用于缓存

###请求首部
只在请求报文中有意义，有：
1. Client-IP：客户端及其的IP
2. FROM：客户端用户的E-mail地址
3. Host：接受请求的服务器主机名和端口号
4. Referer：包含当前请求URI的文档的URL
5. UA-Color：客户端显示器的显示颜色有关的信息
6. UA-CPU：给出客户端CPU的类型或制造商
7. UA-Disp：客户端显示器（屏幕）能力相关信息
8. UA-OS：客户端机器上的操作系统名称及版本
9. UA-Pixels：客户端显示器的像素信息
10. User-Agent：发起请求的应用程序名称

Accept首部为客户端提供了一种将其喜好和能力告知服务器的方式，告诉服务器它们想要什么，可以使用什么，以及他们不想要什么：
1. Accept：告诉服务器能够发送哪些媒体类型
2. Accept-Charset：告诉服务器能够发送哪些字符集
3. Accept-Encoding：告诉服务器能发送哪些编码方式
4. Accept-Language：告诉服务器能够发送哪些语言
5. TE：告诉服务器可以使用那些扩展传输编码

条件请求首部在客户端希望为请求加上某些限制时使用，要求服务器在队请求进行响应之前，确保某个条件为真：
1. Expect：允许客户端列出某请求所要求的服务器行为
2. If-Match：如果实体标记与文档当前的实体标记想匹配，就获取这份文档
3. If-Modified-Since：除非在某个指定的日期之后资源被修改过，否则就限制这个请求
4. If-None-Match：如果提供的实体标记与当前文档的实体标记不相符，就获取文档
5. If-Range：允许对文档的某个范围进行条件请求
6. If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求
7. Range：如果服务器支持范围请求，就请求资源的指定范围

安全请求首部有：
1. Authorization：包含了客户端提供了服务器，以便对其自身进行认证的数据
2. Cookie：客户端用它向服务器传送一个令牌，它并不是真正的安全受不，但却是隐含了安全功能
3. Cookie2：用来说明请求端支持的cookie版本

代理请求首部：
1. Max-Forward：在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数，与TRACE方法一同使用
2. Proxy-Authorization：与Authorization首部相同，但这个首部是与代理进行认证时使用的
3. Proxy-Connection：与Connection首部相同，但这个首部是与代理建立连接时使用的

###响应首部
响应报文有自己的首部集，为客户端提供一些额外的响应信息：
1. Age：响应持续时间
2. Public：服务器为其资源支持的请求方法列表
3. Retry-After：如果资源不可用，在此日期或时间重试
4. Server：服务器应用程序软件的名称和版本
5. Title：对HTML来说，就是HTML文档的源端给出的标题
6. Warning：比原因短语中更详细一些的警告报文

协商首部，如果资源有多重白哦是方法，可以使用协商首部为服务器和客户端提供对资源进行协商的能力：
1. Accept-Ranges：对此资源来说，服务器可接受的范围类型
2. Vary：服务器查看其他首部的列表，可能会使响应发生变化

安全响应首部：
1. Proxy-Authenticate：来自代理的对客户端的质询列表
2. Set-Cookie：不是真正的安全首部，但隐含安全功能，可以在客户端设置一个令牌，以便服务器对客户端进行标识
3. Set-Cookie2：与Set-Cookie相似
4. WWW-Authenticate：来自服务器呃对客户端的质询列表

###实体首部
实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法：
1. Allow：列出了可以对此实体执行的请求方法
2. Location：告知客户端实体实际上位于何处

内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息：
1. Content-Base：解析主题中的相对URL是使用的基础URL
2. Content-Encoding：对主体执行的任意编码方式
3. Content-Language：理解主题时最适合使用的自然语言
4. Content-Length：主体的长度和尺寸
5. Content-Location：资源实际所处的位置
6. Content-MD5：主体的MD5校验和
7. Content-Range：在整个资源中此实体表示的字节范围
8. Content-Type：主题的对象类型

实体缓存首部提供了与被缓存实体有关的信息：
1. ETag：与此实体相关的实体标记
2. Expires：实体不再有效，要从原始的源端再次获取此实体的日期和时间
3. Last-Modified：这个实体最后一次被修改的日期和时间

</frag></query></params></path></post></host></password></user></scheme>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/16/http-base.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 垂直居中之vertical-align详解 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/13/vertical-align.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 13 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="vertical-align">vertical-align</h2>
<p>属性<code>vertical-align</code>影响一个内联级元素（inline-level element）垂直方向上的布局。具体适用于<code>display</code>值为<code>inline</code>,<code>inline-block</code>或<code>table-cell</code>的元素。</p>

<p>其可选的值有：
- baseline
- middle
- sub
- super
- text-top
- text-bottom
- percentage
- length
- top
- bottom</p>

<p>其中除了bottom和top外，这些值是相对于父内联元素（或父块包含元素）来说的。对于内联非替换元素来说，被用来布局的子元素盒子的高度由其子元素的<code>line-height</code>属性来确定。而对于不是内联非替换元素的其他元素来说，子元素盒子则是其margin box。</p>

<p>举个例子来表现子元素为inline和inline-block时的不同：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child1"&gt;child1&lt;/div&gt;
    &lt;div class="child child2"&gt;child2&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
&lt;/div&gt;
</code>
```css
.ctn-block {
    display: block;
    background-color: #bbb;
}</p>

<p>.ctn-block span {
    font-size: 50px;
    line-height: 200px;
}</p>

<p>.ctn-block .child {
    margin: 10px 0;
    border: 10px solid bisque;
    font-size: 32px;
    vertical-align: top;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child1 {
    display: inline;
}
.ctn-block .child2 {
    display: inline-block;
}
```
效果图如下：
<img src="http://lingyu.wang/img/verticalalign/1.png" alt="Alt text" /></p>

<p>可以看到，inline元素只会将其content box用来定位，而inline-block元素则会将将其margin box用来定位。结合inline元素的特性，就很好理解了</p>

<p>除了bottom和top外，其他根据父内联元素（或父块包含元素）来确定。这句话下面会给出实例</p>

<h2 id="baseline">baseline的确定</h2>
<p>###什么是baseline
<img src="http://lingyu.wang/img/verticalalign/2.png" alt="Alt text" /></p>

<p>这里大写字母<code>G</code>底端的那条线，即为baseline</p>

<p>下面以如下代码为基础，来比较<code>vertical-align</code>值不同时的效果：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
&lt;/div&gt;
</code>
```css
.ctn-block {
    display: block;
    background-color: #bbb;
    line-height: 200px;
    font-size: 50px;
}</p>

<p>.ctn-block .child1 {
    display: inline-block;
    width: 100px;
    height: 100px;
    margin: 10px 0;</p>

<pre><code>/*vertical-align: baseline;*/

background-color: aliceblue; } ```
</code></pre>

<p>这里<code>.ctn-block</code>为父元素，<code>.child1</code>为子元素，父元素的baseline根据规则，为最后一个line box的baseline，也就是说其baseline为如下红线：</p>

<p><img src="http://lingyu.wang/img/verticalalign/3.png" alt="Alt text" /></p>

<p>而由于子元素为<code>display: inline-block</code>，其内部没有内容，也没有line box，所以根据如下计算规则:</p>

<blockquote>
  <p>如果它内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界</p>
</blockquote>

<p>那么，它的baseline就是其margin-bottom边界，如红线所示：</p>

<p><img src="http://lingyu.wang/img/verticalalign/4.png" alt="Alt text" /></p>

<h3 id="baseline-1">元素的baseline</h3>
<p>inline-table元素的baseline是它table第一行的baseline</p>

<p>inline-block元素的baseline是他普通流中最后一个line box的baseline。如果它内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界</p>

<p>如果想要了解更多关于baseline的详细的信息，可以参照<a href="http://dev.w3.org/csswg/css-inline/#baseline">W3C标准css-inline的baseline部分</a></p>

<p>更多关于baseline的确定方式可以参照<a href="http://dev.w3.org/csswg/css-align/#baseline-rules">W3C标准css-align的baseline-rules部分</a></p>

<h3 id="line-boxbaseline">line box的baseline</h3>
<blockquote>
  <p>CSS 2.1 does not define the position of the line box’s baseline </p>
</blockquote>

<p>CSS 2.1没有定义baseline具体的位置。但经过测试，在chrome中，line box的baseline为其中所有inline-level元素（vertical值不为top或bottom）的baseline中位置最下面的一个basenline。如果vertical值为middle，其baseline为元素中点所在水平线
比如如下例子：</p>

<p><code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child-1"&gt;&lt;/div&gt;
    &lt;div class="child child-2"&gt;ggggggggggggggggggggggggggggggggggg&lt;/div&gt;
    &lt;div class="child child-3"&gt;ggggggggggggggggggggggggggggggggggggggggggggggggg&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.ctn-block {
    width: 400px;
    display: block;
    background-color: #bbb;
}</p>

<p>.ctn-block .child {
    display: inline-block;
    width: 100px;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child-1 {
    height: 100px;
}
.ctn-block .child-2 {
    height: 200px;
}
.ctn-block .child-3 {
    height: 350px;
}
```</p>

<p>可以看到布局效果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/5.png" alt="Alt text" /></p>

<p>由于child-1没有内容，其baseline为其margin-bottom外边界，而child-2和child-3的baseline则是其内部最后一个line box的baseline，而由于其设定为<code>vertical-align:baseline</code>，child-1的baseline处在最下面，child-2和child-3的baseline均与child-1的baseline对齐</p>

<p>增加child-3的内容：</p>

<p><img src="http://lingyu.wang/img/verticalalign/6.png" alt="Alt text" /></p>

<p>布局发生改变，child-1和child-2的baseline都对齐child-3的baseline了</p>

<h2 id="vertical-align-1">vertical-align不同值之间的表现</h2>
<p>###baseline
将子元素盒子的baseline与父盒子的baseline对齐。如果这个元素盒子没有baseline，将这个盒子的底margin边界与父盒子的baseline对齐</p>

<blockquote>
  <p>From W3C: Align the baseline of the box with the baseline of the parent box. If the box does not have a baseline, align the bottom margin edge with the parent’s baseline.</p>
</blockquote>

<p>vertical-align默认就是baseline，所以这里会将子元素和父盒子的baseline对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/7.png" alt="Alt text" /></p>

<h3 id="middle">middle</h3>
<p>将子元素盒子的垂直中点与 父盒子的baseline加上父盒子的x-height的一半位置 对齐</p>

<blockquote>
  <p>From W3C: Align the vertical midpoint of the box with the baseline of the parent box plus half the x-height of the parent.</p>
</blockquote>

<p>这里子元素盒子的垂直中点还是比较容易确定的，父盒子的baseline之前也确定了，但这里需要通过x-height进行计算：</p>

<blockquote>
  <p>From W3C: The x-height is, roughly, the height of lowercase letters such as a, c, m, or o. Fonts that have the same size (and thus the same em) may vary wildly in the size of their lowercase letters</p>
</blockquote>

<p>其实x-height就是字体的x字母的高度</p>

<p>为了方便，将内容换成”Xx”，由于X(无论大小写)下边界都是顶着baseline的，而小写字母”x”这种上下对称的字母，其中点所在的水平直线就是子元素中点所需要对齐的直线了：</p>

<p><img src="http://lingyu.wang/img/verticalalign/8.png" alt="Alt text" /></p>

<h3 id="text-top">text-top</h3>
<p>将盒子的顶端（margin-top边界）与父盒子的文本区域顶端对齐</p>

<blockquote>
  <p>From W3C: Align the top of the box with the top of the parent’s content area</p>
</blockquote>

<p>这里盒子的顶端（margin-top上边界）很好确定，而父盒子的文本区域顶端又是哪里？</p>

<p><img src="http://lingyu.wang/img/verticalalign/9.png" alt="Alt text" /></p>

<p>审查一下文本，可以看到，蓝色的区域上边界就是文本区域：</p>

<p><img src="http://lingyu.wang/img/verticalalign/10.png" alt="Alt text" /></p>

<p>这样就很好理解了，而可以看到对齐结果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/11.png" alt="Alt text" /></p>

<p>子元素盒子的margin-top上边界很好的和文本区域上边界对齐了</p>

<h3 id="text-bottom">text-bottom</h3>
<p>将盒子的底端（margin-bottom边界）与父盒子的文本区域底端对齐</p>

<blockquote>
  <p>From W3C: Align the bottom of the box with the bottom of the parent’s content area</p>
</blockquote>

<p>有了上面的text-top的实例，这里就很好理解了，不过换个方向罢了，将子元素的margin-bottom和文本区域的下边界对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/12.png" alt="Alt text" /></p>

<h3 id="sub">sub</h3>
<p>将子元素盒子的baseline降低，到适当的父盒子的下标位置</p>

<blockquote>
  <p>From W3C: Lower the baseline of the box to the proper position for subscripts of the parent’s box.</p>
</blockquote>

<p>子元素的baseline已经确定了，就是其margin-bottom下边界，但是父盒子的下标位置不太好理解…首先需要了解下标这个概念，我们可以通过<code>&lt;sub&gt;</code>标签为文字添加下标，将<code>&lt;span&gt;</code>中的内容修改为<code>Gg&lt;sub&gt;Gg&lt;/sub&gt;</code>，就会有如下效果：</p>

<p><img src="http://lingyu.wang/img/verticalalign/13.png" alt="Alt text" /></p>

<p>既然下标也是一段文字，其也有上述的三条线，文本区域上边界，文本区域下边界，baseline。这里是根据下标的baseline对齐的，也就是说，对齐下标中<code>G</code>字母的底部:</p>

<p><img src="http://lingyu.wang/img/verticalalign/14.png" alt="Alt text" /></p>

<h3 id="super">super</h3>
<p>将子元素盒子的baseline升高，到适当的父盒子的上标位置</p>

<blockquote>
  <p>From W3C: Raise the baseline of the box to the proper position for superscripts of the parent’s box.</p>
</blockquote>

<p>与sub对应，super提升到上标内容的baseline处，首先通过<code>&lt;sup&gt;</code>标签创建上标：</p>

<p><img src="http://lingyu.wang/img/verticalalign/15.png" alt="Alt text" /></p>

<p>也是三条线，和上面基准一样，将子元素的baseline对齐上标的baseline：</p>

<p><img src="http://lingyu.wang/img/verticalalign/16.png" alt="Alt text" /></p>

<h3 id="percentagelength">percentage和length</h3>
<p>首先看看percentage（百分比）：</p>

<p>升高（正值）或降低（负值）子元素盒子，具体的升高/降低数值由父盒子的line-height的值乘以百分比值计算得出。如果百分比为0%，那么和<code>vertical-align:baseline</code>没有区别
&gt; From W3C: Raise (positive value) or lower (negative value) the box by this distance (a percentage of the ‘line-height’ value). The value ‘0%’ means the same as ‘baseline’.</p>

<p>这个还是相当好理解的，就是相当于baseline升高或降低，具体数值为百分比乘以父盒子的line-height值，比如这里的例子，父盒子的line-height为200px，所以设定为25%的使用应当上移50px:</p>

<p><img src="http://lingyu.wang/img/verticalalign/17.png" alt="Alt text" /></p>

<p>并不是很直观，给它加上一个<code>transfrom: translate(0, 50px)</code>（相对下移50px）,它又移到那个熟悉的位置了：</p>

<p><img src="http://lingyu.wang/img/verticalalign/18.png" alt="Alt text" /></p>

<p>接下来看看length：</p>

<p>升高（正值）或降低（负值）子元素盒子。值为升高/降低的距离，如果为0，那么和<code>vertical-align:baseline</code>没有区别</p>

<blockquote>
  <p>From W3C: Raise (positive value) or lower (negative value) the box by this distance. The value ‘0cm’ means the same as ‘baseline’.</p>
</blockquote>

<p>以我们最常用的px作为单位，设定<code>vertical-align:50px</code>，效果就和上面百分比为25%效果一样了（200px * 25% = 50px）。这里就不做例子了</p>

<h3 id="vertical-alignline-box">vertical-align与line box</h3>
<p>当<code>vertical-align</code>设置为top和bottom时，其就不是按照baseline进行定位了，而是根据line box进行定位。子元素盒子的顶部和底部也就是其上下margin外边界。而line box则是IFC中定义了一套规范，其高度计算如下：</p>

<ol>
  <li>计算出line box内部的每个内联盒子的高度。对于替换元素、inline-block元素和inline-table元素，他们的高度是整个margin box的高度。而对于内联盒子，值是他们的line-height属性。</li>
  <li>内联盒子在垂直方向上根据他们的vertival-align属性来分布。当值为top或bottom时，他们必须以最小化line box高度的方式排布。如果那个盒子足够高，就会撑开line box</li>
  <li>line box的高度是最上面盒子的顶端到最下面盒子的底端的值</li>
</ol>

<p>比如之前的例子，父盒子的<code>line-height</code>为200px，而其中的<code>span</code>包含文字，所以根据第一条规则将line box的高度撑开到200px</p>

<p>如果设定子元素<code>height: 200px;</code>,<code>vertical-align: baseline</code>，那么可以看到整个父容器被撑开：</p>

<p><img src="http://lingyu.wang/img/verticalalign/19.png" alt="Alt text" /></p>

<p>由于根据上面的<code>vertical-align: baseline</code>进行垂直定位，规则并没有变。而由于规则3，line box的高度需要包含所有的内容，所以整个line box被撑开</p>

<p>而如果在后面加一个元素：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
    &lt;div class="big"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
<code>css
.ctn-block .big {
    display: inline-block;
    width: 100px;
    height: 400px;
    vertical-align: top;
    background-color: antiquewhite;
}
</code></p>

<p>可以看到效果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/20.png" alt="Alt text" /></p>

<p>由于规则2的计算，line box被这个big元素撑开，达到400px，如果我们将其降低到200px：</p>

<p><img src="http://lingyu.wang/img/verticalalign/21.png" alt="Alt text" /></p>

<p>则会由于其高度不够已有的高度，line box没有被撑开，这个big元素由于<code>vertical-align: top</code>而在line box顶端显示</p>

<h3 id="top">top</h3>
<p>将子元素盒子的顶部和其所在的line box顶部对齐</p>

<blockquote>
  <p>From W3C: Align the top of the aligned subtree with the top of the line box.</p>
</blockquote>

<p>由之前所说，<code>vertical-align:top</code>将会让子元素盒子顶部与line box顶部对齐，而如果line box的高度小于子元素的高度，line box将会被撑开。我们先用一个高度较高的元素撑开line box，然后看看效果：</p>

<p><code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;div class="big"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
<code>css
.ctn-block .child1 {
    display: inline-block;
    width: 100px;
    height: 100px;
    margin: 10px 0;
    vertical-align: top;
    background-color: aliceblue;
}
.ctn-block .big {
    display: inline-block;
    width: 100px;
    height: 200px;
    vertical-align: top;
    background-color: antiquewhite;
}
</code></p>

<p><img src="http://lingyu.wang/img/verticalalign/22.png" alt="Alt text" /></p>

<p>可以看到，big子元素撑开了line box，而child1的margin-top外边界紧贴在line box的顶端</p>

<h3 id="bottom">bottom</h3>
<p>将子元素盒子的底部和其所在的line box底部对齐</p>

<blockquote>
  <p>From W3C: Align the bottom of the aligned subtree with the bottom of the line box.</p>
</blockquote>

<p>和top类似，由于big用于撑开line box，可以不必修改其<code>vertical-align</code>的值，仅修改child1为<code>vertical-align: bottom;</code>：</p>

<p><img src="http://lingyu.wang/img/verticalalign/23.png" alt="Alt text" /></p>

<h2 id="vertical-align-middle">vertical-align: middle让元素下移而不居中的问题分析</h2>
<p>###问题
现在有三个inline-block块，高度分别为100px，200px，300px，想让高度为100px的块垂直居中，于是写出了如下代码：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child-1"&gt;&lt;/div&gt;
    &lt;div class="child child-2"&gt;&lt;/div&gt;
    &lt;div class="child child-3"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.ctn-block {
    display: inline-block;
    background-color: #bbb;
}</p>

<p>.ctn-block .child {
    display: block;
    width: 100px;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child-1 {
    height: 100px;
    vertical-align: middle;
}
.ctn-block .child-2 {
    height: 200px;
}
.ctn-block .child-3 {
    height: 300px;
}
```</p>

<p>结果却只能得到如下效果：</p>

<p><img src="http://lingyu.wang/img/verticalalign/24.png" alt="Alt text" /></p>

<p>child-1元素下移了，但是却没有居中。</p>

<h3 id="section">原因</h3>
<p>从上面可以知道，<code>vertical-align: middle</code>的定位方式是：将子元素盒子的垂直中点与 父盒子的baseline加上父盒子的x-height的一半位置 对齐。</p>

<p>子元素的垂直中点还是比较好算的，而父盒子的baseline加上父盒子的x-height一半位置又是什么呢？</p>

<p>首先计算父盒子的baseline：三个子元素的baseline走在一条直线上，就是child-2和child-3的底部</p>

<p>然后加上父盒子的x-height：由于默认font-size是16px，而<code>font-family: sans-serif</code>，而其x-height的一半大概3-4px</p>

<p>综上，大致按照如下方式对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/25.png" alt="Alt text" /></p>

<h3 id="section-1">解决</h3>
<p>一种方式是将最高的元素设为<code>vertical-align: middle</code></p>

<p>然后将想要居中的也设定为<code>vertical-align: middle</code>,其他的根据需要设定<code>vertical-align: top/bottom</code></p>

<p>由于设定为<code>vertical-align: middle</code>后，这个元素的对于line box来说，baseline就是其中线。而其他元素全部设定为<code>vertical-align: top/bottom</code>后，他们不影响line box的baseline，所以再将需要设定垂直居中的元素也设定为<code>vertical-align: middle</code>，他们的baseline必然在最高元素的baseline之上，所以会被强制下移，进行居中</p>

<h3 id="section-2">衍生的一种可行的垂直居中方案</h3>
<p>为父容器设定一个伪元素<code>::after</code>，其高度为父元素的高度，<code>display:inline-block</code>，将其设定为<code>vertical-align: middle</code>即可撑开line box，同时line box的baseline为父元素高度一半的位置。然后设定子元素<code>vertical-align: middle</code>，即可实现居中</p>

<p><code>html
&lt;div class="g-ctn"&gt;
    &lt;div class="g-mn"&gt;
        &lt;p&gt;这是内容区&lt;/p&gt;
        &lt;p style="font-size: 3em;"&gt;这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话&lt;/p&gt;
    &lt;/div&gt;
    &lt;!--[if lt IE 8]&gt;&lt;span&gt;&lt;/span&gt;&lt;![endif]--&gt;
&lt;/div&gt;
</code>
```css
.g-ctn {
    height: 800px;
    width: 100%;
    text-align: center;
}</p>

<p>.g-ctn:after,.g-ctn span{
    display:inline-block;
    *display:inline;
    *zoom:1;
    width:0;
    height:100%;
    vertical-align:middle;
}
.g-ctn:after{
    content:’’;
}</p>

<p>.g-ctn .g-mn{
    display:inline-block;
    *display:inline;
    *zoom:1;
    width: 80%;
    max-height: 80%;
    max-width: 1000px;
    vertical-align:middle;
    overflow: auto;
}
```</p>

<p>这里需要使用一些hack，由于IE8-不支持<code>::after</code>伪元素，所以需要一个span来替代。而display: inline-block亦需要hack。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/13/vertical-align.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 垂直居中之vertical-align详解 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/13/vertical-align.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 13 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="vertical-align">vertical-align</h2>
<p>属性<code>vertical-align</code>影响一个内联级元素（inline-level element）垂直方向上的布局。具体适用于<code>display</code>值为<code>inline</code>,<code>inline-block</code>或<code>table-cell</code>的元素。</p>

<p>其可选的值有：
- baseline
- middle
- sub
- super
- text-top
- text-bottom
- percentage
- length
- top
- bottom</p>

<p>其中除了bottom和top外，这些值是相对于父内联元素（或父块包含元素）来说的。对于内联非替换元素来说，被用来布局的子元素盒子的高度由其子元素的<code>line-height</code>属性来确定。而对于不是内联非替换元素的其他元素来说，子元素盒子则是其margin box。</p>

<p>举个例子来表现子元素为inline和inline-block时的不同：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child1"&gt;child1&lt;/div&gt;
    &lt;div class="child child2"&gt;child2&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
&lt;/div&gt;
</code>
```css
.ctn-block {
    display: block;
    background-color: #bbb;
}</p>

<p>.ctn-block span {
    font-size: 50px;
    line-height: 200px;
}</p>

<p>.ctn-block .child {
    margin: 10px 0;
    border: 10px solid bisque;
    font-size: 32px;
    vertical-align: top;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child1 {
    display: inline;
}
.ctn-block .child2 {
    display: inline-block;
}
```
效果图如下：
<img src="http://lingyu.wang/img/verticalalign/1.png" alt="Alt text" /></p>

<p>可以看到，inline元素只会将其content box用来定位，而inline-block元素则会将将其margin box用来定位。结合inline元素的特性，就很好理解了</p>

<p>除了bottom和top外，其他根据父内联元素（或父块包含元素）来确定。这句话下面会给出实例</p>

<h2 id="baseline">baseline的确定</h2>
<p>###什么是baseline
<img src="http://lingyu.wang/img/verticalalign/2.png" alt="Alt text" /></p>

<p>这里大写字母<code>G</code>底端的那条线，即为baseline</p>

<p>下面以如下代码为基础，来比较<code>vertical-align</code>值不同时的效果：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
&lt;/div&gt;
</code>
```css
.ctn-block {
    display: block;
    background-color: #bbb;
    line-height: 200px;
    font-size: 50px;
}</p>

<p>.ctn-block .child1 {
    display: inline-block;
    width: 100px;
    height: 100px;
    margin: 10px 0;</p>

<pre><code>/*vertical-align: baseline;*/

background-color: aliceblue; } ```
</code></pre>

<p>这里<code>.ctn-block</code>为父元素，<code>.child1</code>为子元素，父元素的baseline根据规则，为最后一个line box的baseline，也就是说其baseline为如下红线：</p>

<p><img src="http://lingyu.wang/img/verticalalign/3.png" alt="Alt text" /></p>

<p>而由于子元素为<code>display: inline-block</code>，其内部没有内容，也没有line box，所以根据如下计算规则:</p>

<blockquote>
  <p>如果它内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界</p>
</blockquote>

<p>那么，它的baseline就是其margin-bottom边界，如红线所示：</p>

<p><img src="http://lingyu.wang/img/verticalalign/4.png" alt="Alt text" /></p>

<h3 id="baseline-1">元素的baseline</h3>
<p>inline-table元素的baseline是它table第一行的baseline</p>

<p>inline-block元素的baseline是他普通流中最后一个line box的baseline。如果它内部没有line box或它的overflow属性不是visible，那么baseline将是这个inline-block元素的底margin边界</p>

<p>如果想要了解更多关于baseline的详细的信息，可以参照<a href="http://dev.w3.org/csswg/css-inline/#baseline">W3C标准css-inline的baseline部分</a></p>

<p>更多关于baseline的确定方式可以参照<a href="http://dev.w3.org/csswg/css-align/#baseline-rules">W3C标准css-align的baseline-rules部分</a></p>

<h3 id="line-boxbaseline">line box的baseline</h3>
<blockquote>
  <p>CSS 2.1 does not define the position of the line box’s baseline </p>
</blockquote>

<p>CSS 2.1没有定义baseline具体的位置。但经过测试，在chrome中，line box的baseline为其中所有inline-level元素（vertical值不为top或bottom）的baseline中位置最下面的一个basenline。如果vertical值为middle，其baseline为元素中点所在水平线
比如如下例子：</p>

<p><code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child-1"&gt;&lt;/div&gt;
    &lt;div class="child child-2"&gt;ggggggggggggggggggggggggggggggggggg&lt;/div&gt;
    &lt;div class="child child-3"&gt;ggggggggggggggggggggggggggggggggggggggggggggggggg&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.ctn-block {
    width: 400px;
    display: block;
    background-color: #bbb;
}</p>

<p>.ctn-block .child {
    display: inline-block;
    width: 100px;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child-1 {
    height: 100px;
}
.ctn-block .child-2 {
    height: 200px;
}
.ctn-block .child-3 {
    height: 350px;
}
```</p>

<p>可以看到布局效果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/5.png" alt="Alt text" /></p>

<p>由于child-1没有内容，其baseline为其margin-bottom外边界，而child-2和child-3的baseline则是其内部最后一个line box的baseline，而由于其设定为<code>vertical-align:baseline</code>，child-1的baseline处在最下面，child-2和child-3的baseline均与child-1的baseline对齐</p>

<p>增加child-3的内容：</p>

<p><img src="http://lingyu.wang/img/verticalalign/6.png" alt="Alt text" /></p>

<p>布局发生改变，child-1和child-2的baseline都对齐child-3的baseline了</p>

<h2 id="vertical-align-1">vertical-align不同值之间的表现</h2>
<p>###baseline
将子元素盒子的baseline与父盒子的baseline对齐。如果这个元素盒子没有baseline，将这个盒子的底margin边界与父盒子的baseline对齐</p>

<blockquote>
  <p>From W3C: Align the baseline of the box with the baseline of the parent box. If the box does not have a baseline, align the bottom margin edge with the parent’s baseline.</p>
</blockquote>

<p>vertical-align默认就是baseline，所以这里会将子元素和父盒子的baseline对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/7.png" alt="Alt text" /></p>

<h3 id="middle">middle</h3>
<p>将子元素盒子的垂直中点与 父盒子的baseline加上父盒子的x-height的一半位置 对齐</p>

<blockquote>
  <p>From W3C: Align the vertical midpoint of the box with the baseline of the parent box plus half the x-height of the parent.</p>
</blockquote>

<p>这里子元素盒子的垂直中点还是比较容易确定的，父盒子的baseline之前也确定了，但这里需要通过x-height进行计算：</p>

<blockquote>
  <p>From W3C: The x-height is, roughly, the height of lowercase letters such as a, c, m, or o. Fonts that have the same size (and thus the same em) may vary wildly in the size of their lowercase letters</p>
</blockquote>

<p>其实x-height就是字体的x字母的高度</p>

<p>为了方便，将内容换成”Xx”，由于X(无论大小写)下边界都是顶着baseline的，而小写字母”x”这种上下对称的字母，其中点所在的水平直线就是子元素中点所需要对齐的直线了：</p>

<p><img src="http://lingyu.wang/img/verticalalign/8.png" alt="Alt text" /></p>

<h3 id="text-top">text-top</h3>
<p>将盒子的顶端（margin-top边界）与父盒子的文本区域顶端对齐</p>

<blockquote>
  <p>From W3C: Align the top of the box with the top of the parent’s content area</p>
</blockquote>

<p>这里盒子的顶端（margin-top上边界）很好确定，而父盒子的文本区域顶端又是哪里？</p>

<p><img src="http://lingyu.wang/img/verticalalign/9.png" alt="Alt text" /></p>

<p>审查一下文本，可以看到，蓝色的区域上边界就是文本区域：</p>

<p><img src="http://lingyu.wang/img/verticalalign/10.png" alt="Alt text" /></p>

<p>这样就很好理解了，而可以看到对齐结果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/11.png" alt="Alt text" /></p>

<p>子元素盒子的margin-top上边界很好的和文本区域上边界对齐了</p>

<h3 id="text-bottom">text-bottom</h3>
<p>将盒子的底端（margin-bottom边界）与父盒子的文本区域底端对齐</p>

<blockquote>
  <p>From W3C: Align the bottom of the box with the bottom of the parent’s content area</p>
</blockquote>

<p>有了上面的text-top的实例，这里就很好理解了，不过换个方向罢了，将子元素的margin-bottom和文本区域的下边界对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/12.png" alt="Alt text" /></p>

<h3 id="sub">sub</h3>
<p>将子元素盒子的baseline降低，到适当的父盒子的下标位置</p>

<blockquote>
  <p>From W3C: Lower the baseline of the box to the proper position for subscripts of the parent’s box.</p>
</blockquote>

<p>子元素的baseline已经确定了，就是其margin-bottom下边界，但是父盒子的下标位置不太好理解…首先需要了解下标这个概念，我们可以通过<code>&lt;sub&gt;</code>标签为文字添加下标，将<code>&lt;span&gt;</code>中的内容修改为<code>Gg&lt;sub&gt;Gg&lt;/sub&gt;</code>，就会有如下效果：</p>

<p><img src="http://lingyu.wang/img/verticalalign/13.png" alt="Alt text" /></p>

<p>既然下标也是一段文字，其也有上述的三条线，文本区域上边界，文本区域下边界，baseline。这里是根据下标的baseline对齐的，也就是说，对齐下标中<code>G</code>字母的底部:</p>

<p><img src="http://lingyu.wang/img/verticalalign/14.png" alt="Alt text" /></p>

<h3 id="super">super</h3>
<p>将子元素盒子的baseline升高，到适当的父盒子的上标位置</p>

<blockquote>
  <p>From W3C: Raise the baseline of the box to the proper position for superscripts of the parent’s box.</p>
</blockquote>

<p>与sub对应，super提升到上标内容的baseline处，首先通过<code>&lt;sup&gt;</code>标签创建上标：</p>

<p><img src="http://lingyu.wang/img/verticalalign/15.png" alt="Alt text" /></p>

<p>也是三条线，和上面基准一样，将子元素的baseline对齐上标的baseline：</p>

<p><img src="http://lingyu.wang/img/verticalalign/16.png" alt="Alt text" /></p>

<h3 id="percentagelength">percentage和length</h3>
<p>首先看看percentage（百分比）：</p>

<p>升高（正值）或降低（负值）子元素盒子，具体的升高/降低数值由父盒子的line-height的值乘以百分比值计算得出。如果百分比为0%，那么和<code>vertical-align:baseline</code>没有区别
&gt; From W3C: Raise (positive value) or lower (negative value) the box by this distance (a percentage of the ‘line-height’ value). The value ‘0%’ means the same as ‘baseline’.</p>

<p>这个还是相当好理解的，就是相当于baseline升高或降低，具体数值为百分比乘以父盒子的line-height值，比如这里的例子，父盒子的line-height为200px，所以设定为25%的使用应当上移50px:</p>

<p><img src="http://lingyu.wang/img/verticalalign/17.png" alt="Alt text" /></p>

<p>并不是很直观，给它加上一个<code>transfrom: translate(0, 50px)</code>（相对下移50px）,它又移到那个熟悉的位置了：</p>

<p><img src="http://lingyu.wang/img/verticalalign/18.png" alt="Alt text" /></p>

<p>接下来看看length：</p>

<p>升高（正值）或降低（负值）子元素盒子。值为升高/降低的距离，如果为0，那么和<code>vertical-align:baseline</code>没有区别</p>

<blockquote>
  <p>From W3C: Raise (positive value) or lower (negative value) the box by this distance. The value ‘0cm’ means the same as ‘baseline’.</p>
</blockquote>

<p>以我们最常用的px作为单位，设定<code>vertical-align:50px</code>，效果就和上面百分比为25%效果一样了（200px * 25% = 50px）。这里就不做例子了</p>

<h3 id="vertical-alignline-box">vertical-align与line box</h3>
<p>当<code>vertical-align</code>设置为top和bottom时，其就不是按照baseline进行定位了，而是根据line box进行定位。子元素盒子的顶部和底部也就是其上下margin外边界。而line box则是IFC中定义了一套规范，其高度计算如下：</p>

<ol>
  <li>计算出line box内部的每个内联盒子的高度。对于替换元素、inline-block元素和inline-table元素，他们的高度是整个margin box的高度。而对于内联盒子，值是他们的line-height属性。</li>
  <li>内联盒子在垂直方向上根据他们的vertival-align属性来分布。当值为top或bottom时，他们必须以最小化line box高度的方式排布。如果那个盒子足够高，就会撑开line box</li>
  <li>line box的高度是最上面盒子的顶端到最下面盒子的底端的值</li>
</ol>

<p>比如之前的例子，父盒子的<code>line-height</code>为200px，而其中的<code>span</code>包含文字，所以根据第一条规则将line box的高度撑开到200px</p>

<p>如果设定子元素<code>height: 200px;</code>,<code>vertical-align: baseline</code>，那么可以看到整个父容器被撑开：</p>

<p><img src="http://lingyu.wang/img/verticalalign/19.png" alt="Alt text" /></p>

<p>由于根据上面的<code>vertical-align: baseline</code>进行垂直定位，规则并没有变。而由于规则3，line box的高度需要包含所有的内容，所以整个line box被撑开</p>

<p>而如果在后面加一个元素：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;span&gt;Gg&lt;/span&gt;
    &lt;div class="big"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
<code>css
.ctn-block .big {
    display: inline-block;
    width: 100px;
    height: 400px;
    vertical-align: top;
    background-color: antiquewhite;
}
</code></p>

<p>可以看到效果如下：</p>

<p><img src="http://lingyu.wang/img/verticalalign/20.png" alt="Alt text" /></p>

<p>由于规则2的计算，line box被这个big元素撑开，达到400px，如果我们将其降低到200px：</p>

<p><img src="http://lingyu.wang/img/verticalalign/21.png" alt="Alt text" /></p>

<p>则会由于其高度不够已有的高度，line box没有被撑开，这个big元素由于<code>vertical-align: top</code>而在line box顶端显示</p>

<h3 id="top">top</h3>
<p>将子元素盒子的顶部和其所在的line box顶部对齐</p>

<blockquote>
  <p>From W3C: Align the top of the aligned subtree with the top of the line box.</p>
</blockquote>

<p>由之前所说，<code>vertical-align:top</code>将会让子元素盒子顶部与line box顶部对齐，而如果line box的高度小于子元素的高度，line box将会被撑开。我们先用一个高度较高的元素撑开line box，然后看看效果：</p>

<p><code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child1"&gt;&lt;/div&gt;
    &lt;div class="big"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
<code>css
.ctn-block .child1 {
    display: inline-block;
    width: 100px;
    height: 100px;
    margin: 10px 0;
    vertical-align: top;
    background-color: aliceblue;
}
.ctn-block .big {
    display: inline-block;
    width: 100px;
    height: 200px;
    vertical-align: top;
    background-color: antiquewhite;
}
</code></p>

<p><img src="http://lingyu.wang/img/verticalalign/22.png" alt="Alt text" /></p>

<p>可以看到，big子元素撑开了line box，而child1的margin-top外边界紧贴在line box的顶端</p>

<h3 id="bottom">bottom</h3>
<p>将子元素盒子的底部和其所在的line box底部对齐</p>

<blockquote>
  <p>From W3C: Align the bottom of the aligned subtree with the bottom of the line box.</p>
</blockquote>

<p>和top类似，由于big用于撑开line box，可以不必修改其<code>vertical-align</code>的值，仅修改child1为<code>vertical-align: bottom;</code>：</p>

<p><img src="http://lingyu.wang/img/verticalalign/23.png" alt="Alt text" /></p>

<h2 id="vertical-align-middle">vertical-align: middle让元素下移而不居中的问题分析</h2>
<p>###问题
现在有三个inline-block块，高度分别为100px，200px，300px，想让高度为100px的块垂直居中，于是写出了如下代码：
<code>html
&lt;div class="ctn-block"&gt;
    &lt;div class="child child-1"&gt;&lt;/div&gt;
    &lt;div class="child child-2"&gt;&lt;/div&gt;
    &lt;div class="child child-3"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.ctn-block {
    display: inline-block;
    background-color: #bbb;
}</p>

<p>.ctn-block .child {
    display: block;
    width: 100px;
    background-color: aliceblue;
}</p>

<p>.ctn-block .child-1 {
    height: 100px;
    vertical-align: middle;
}
.ctn-block .child-2 {
    height: 200px;
}
.ctn-block .child-3 {
    height: 300px;
}
```</p>

<p>结果却只能得到如下效果：</p>

<p><img src="http://lingyu.wang/img/verticalalign/24.png" alt="Alt text" /></p>

<p>child-1元素下移了，但是却没有居中。</p>

<h3 id="section">原因</h3>
<p>从上面可以知道，<code>vertical-align: middle</code>的定位方式是：将子元素盒子的垂直中点与 父盒子的baseline加上父盒子的x-height的一半位置 对齐。</p>

<p>子元素的垂直中点还是比较好算的，而父盒子的baseline加上父盒子的x-height一半位置又是什么呢？</p>

<p>首先计算父盒子的baseline：三个子元素的baseline走在一条直线上，就是child-2和child-3的底部</p>

<p>然后加上父盒子的x-height：由于默认font-size是16px，而<code>font-family: sans-serif</code>，而其x-height的一半大概3-4px</p>

<p>综上，大致按照如下方式对齐：</p>

<p><img src="http://lingyu.wang/img/verticalalign/25.png" alt="Alt text" /></p>

<h3 id="section-1">解决</h3>
<p>一种方式是将最高的元素设为<code>vertical-align: middle</code></p>

<p>然后将想要居中的也设定为<code>vertical-align: middle</code>,其他的根据需要设定<code>vertical-align: top/bottom</code></p>

<p>由于设定为<code>vertical-align: middle</code>后，这个元素的对于line box来说，baseline就是其中线。而其他元素全部设定为<code>vertical-align: top/bottom</code>后，他们不影响line box的baseline，所以再将需要设定垂直居中的元素也设定为<code>vertical-align: middle</code>，他们的baseline必然在最高元素的baseline之上，所以会被强制下移，进行居中</p>

<h3 id="section-2">衍生的一种可行的垂直居中方案</h3>
<p>为父容器设定一个伪元素<code>::after</code>，其高度为父元素的高度，<code>display:inline-block</code>，将其设定为<code>vertical-align: middle</code>即可撑开line box，同时line box的baseline为父元素高度一半的位置。然后设定子元素<code>vertical-align: middle</code>，即可实现居中</p>

<p><code>html
&lt;div class="g-ctn"&gt;
    &lt;div class="g-mn"&gt;
        &lt;p&gt;这是内容区&lt;/p&gt;
        &lt;p style="font-size: 3em;"&gt;这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话这是一大串的废话&lt;/p&gt;
    &lt;/div&gt;
    &lt;!--[if lt IE 8]&gt;&lt;span&gt;&lt;/span&gt;&lt;![endif]--&gt;
&lt;/div&gt;
</code>
```css
.g-ctn {
    height: 800px;
    width: 100%;
    text-align: center;
}</p>

<p>.g-ctn:after,.g-ctn span{
    display:inline-block;
    *display:inline;
    *zoom:1;
    width:0;
    height:100%;
    vertical-align:middle;
}
.g-ctn:after{
    content:’’;
}</p>

<p>.g-ctn .g-mn{
    display:inline-block;
    *display:inline;
    *zoom:1;
    width: 80%;
    max-height: 80%;
    max-width: 1000px;
    vertical-align:middle;
    overflow: auto;
}
```</p>

<p>这里需要使用一些hack，由于IE8-不支持<code>::after</code>伪元素，所以需要一个span来替代。而display: inline-block亦需要hack。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/13/vertical-align.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ Good Good Study, Day Day Upward！ ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/06/play-fish.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 06 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>上周过得特别累，好不容易有个三天假期闲暇下来了。没有了看书和总结之前题目的欲望，于是乎就跑去逛<a href="http://codepen.io/">codepen</a>。看着国外各种大牛在上面发布的效果，就想自己也写一些类似的小效果玩一玩。搭好了grunt环境（autoprefixer+watch），两天的摸鱼旅程就这样开始了</p>

<h3 id="section">第一条鱼</h3>
<p>之前做阿里的在线笔试的时候有遇到让写一个下拉菜单。之前就有考虑有没有方法不使用js去写（世界上没有叫IE的浏览器）。尝试着用纯CSS写了一个，加了些简单的动画效果，丢到codepen上去了</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/hDbrd" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-1">第二条鱼</h3>
<p>摸完第一条鱼，感觉不够尽兴。于是开始考虑摸第二条，但不知道弄点什么。正好逛codepen有个人实现了一个圆形confirm框，就决定自己实现一个。实现完成之后，加了些动画，于是就有了下面这个</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/mvdcH" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-2">第三条鱼</h3>
<p>显然前面两个小玩意还是不能满足我摸鱼的欲望。看到codepen上有个人画了个脸，于是就决定自己画一个更复杂一点的。颜色都是用的别人的配色，不过自己加上了头发的实现以及眼睛和嘴巴的动画。弄出了这么一个快乐的小逗逼</p>

<iframe style="width: 100%; height: 800px" src="http://cdpn.io/ktcFB" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-3">第四条鱼</h3>
<p>今天起床也是啥也不想干，于是就考虑摸第四条鱼。看到网上的自行车照片，觉得画一个简单的卡通自行车也不算难，就开始动手画自行车了。这样就有了最后一条鱼：一个破烂自行车。摸鱼之旅也就告一段落了</p>

<iframe style="width: 100%; height: 500px" src="http://cdpn.io/EDwsf" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-4">总结</h3>
<p>摸完鱼心情舒畅，该回归正轨了，之前说的总结阿里在线笔试题的工作还没做完呢。等有看到一些其他的我能力范围之内的动画效果时，再继续摸鱼吧…</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/06/play-fish.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ Good Good Study, Day Day Upward！ ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/06/play-fish.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 06 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>上周过得特别累，好不容易有个三天假期闲暇下来了。没有了看书和总结之前题目的欲望，于是乎就跑去逛<a href="http://codepen.io/">codepen</a>。看着国外各种大牛在上面发布的效果，就想自己也写一些类似的小效果玩一玩。搭好了grunt环境（autoprefixer+watch），两天的摸鱼旅程就这样开始了</p>

<h3 id="section">第一条鱼</h3>
<p>之前做阿里的在线笔试的时候有遇到让写一个下拉菜单。之前就有考虑有没有方法不使用js去写（世界上没有叫IE的浏览器）。尝试着用纯CSS写了一个，加了些简单的动画效果，丢到codepen上去了</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/hDbrd" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-1">第二条鱼</h3>
<p>摸完第一条鱼，感觉不够尽兴。于是开始考虑摸第二条，但不知道弄点什么。正好逛codepen有个人实现了一个圆形confirm框，就决定自己实现一个。实现完成之后，加了些动画，于是就有了下面这个</p>

<iframe style="width: 100%; height: 600px" src="http://cdpn.io/mvdcH" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-2">第三条鱼</h3>
<p>显然前面两个小玩意还是不能满足我摸鱼的欲望。看到codepen上有个人画了个脸，于是就决定自己画一个更复杂一点的。颜色都是用的别人的配色，不过自己加上了头发的实现以及眼睛和嘴巴的动画。弄出了这么一个快乐的小逗逼</p>

<iframe style="width: 100%; height: 800px" src="http://cdpn.io/ktcFB" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-3">第四条鱼</h3>
<p>今天起床也是啥也不想干，于是就考虑摸第四条鱼。看到网上的自行车照片，觉得画一个简单的卡通自行车也不算难，就开始动手画自行车了。这样就有了最后一条鱼：一个破烂自行车。摸鱼之旅也就告一段落了</p>

<iframe style="width: 100%; height: 500px" src="http://cdpn.io/EDwsf" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-4">总结</h3>
<p>摸完鱼心情舒畅，该回归正轨了，之前说的总结阿里在线笔试题的工作还没做完呢。等有看到一些其他的我能力范围之内的动画效果时，再继续摸鱼吧…</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/06/play-fish.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 阿里巴巴前端笔试题（1-10） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/04/04/alibaba-fe-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 04 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第一题</h2>
<p>###题面
说出以下函数的作用是？空白区域应该填写什么？
<code>javascript
// define  
(function (window) {  
    function fn(str) {  
        this.str = str;  
    }  
    fn.prototype.format = function () {  
        var arg = ______;  
        return this.str.replace(_______, function (a, b) {  
            return arg[b] || '';  
        });  
    }  
    window.fn = fn;  
})(window);  
// use  
(function(){  
    var t = new fn('&lt;p&gt;&lt;a href="{0}"&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;');
    console.log( t.format('http://www.alibaba.com', 'Alibaba', 'Welcome') );  
})();  
</code></p>

<h3 id="section-1">解答</h3>
<p>看题面就是，类似于写一个模板引擎。将模板里的<code>{1}</code>之类的占位符替换成传给它的参数。所以arg应该就是arguments。但是由于arg不是数组，而是一个类数组对象。所以需要进行一些转换，比较常规的转换方式如下：
<code>javascript
var arg = Array.prototype.slice.call(arguments, 0);
</code>
等号右边也就是第一空的答案了</p>

<p>第二空则是要通过正则找出占位符，并根据占位符内的数字将其替换成arg数组内的字符串，说实话replace方法的第二个参数为函数的情况很少遇到，这里就是考的这个，最初想法是直接用全局正则匹配一下：
<code>javascript
return this.str.replace(/\{\d+\}/g, function (a, b) {  
    return arg[b] || '';  
}); 
</code>
这样，但是穿进去之后发现不太对，因为b参数是正则匹配到的字符串在完整字符串中的位置。于是去查了一下W3C：
&gt; 该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。</p>

<p>这里显然是因为没有子表达式，所以直接b成了声明的匹配在stringObject中出现的位置。这样就好说了，与模式中字表达式匹配，那加一个子表达式进去，变成这样：
<code>javascript
return this.str.replace(/\{(\d+)\}/g, function (a, b) {  
    return arg[b] || '';  
}); 
</code>
跑一下，齐活，输出<code>&lt;p&gt;&lt;a href="http://www.alibaba.com"&gt;Alibaba&lt;/a&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;/p&gt; </code></p>

<h2 id="section-2">第二题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/9.png" alt="第二题题面" /></p>

<h3 id="section-3">解答</h3>
<p>这题由于时间不太够，就没有写可执行代码，主要是涉及cookie操作。可以分成用户第一次进入检测，用户点击我知道了检测两个行为来分别处理：</p>

<p>第一次进入的时候，首先判断cookie中是否有今天已来过标记，没有记录就写进一个标记，同时由于同一天不显示，所以这个写入带标记的cookie的过期时间应该为1天，这里标记为visited：
<code>javascript
if(document.cookie.indexOf(visited) === -1){
    document.cookie = 'visited=' + escape('1') + ';expires=' + new Date((new Date().getTime() + 24 * 3600 * 1000)).toGMTString();
    showTips();
}
</code></p>

<p>点不再访问的时候，应该运行如下代码：
<code>javascript
document.cookie = 'visited=' + escape('1') + ';expires=' + new Date((new Date().getTime() +  100 * 365 * 24 * 3600 * 1000)).toGMTString();
</code>
这样设定一个100年才过期的cookie，就相当于永久不显示了</p>

<h2 id="section-4">第三题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/10.png" alt="第3题题面" /></p>

<h3 id="section-5">解答</h3>
<p>在ul的li上绑点击事件，典型的事件代理的题，要输出index，所以需要提前进行一些提前处理：
```javascript
(function(){
    var nav = document.getElementById(“nav”);
    var liList = nav.children;</p>

<pre><code>function bindEvent(ele, event, callback) {
    if (ele.attachEvent) {
        ele.attachEvent("on" + event, function(event) {
            event = event || window.event;
            event.target = event.target || event.srcElement;
            callback(event);
        });
    } else {
        ele.addEventListener(event, callback, false);
    }
};

bindEvent(nav, "click", function(event) {
    var target = event.target;
    var a;
    var i, m;
    if (target.tagName.toLowerCase() === "li") {
        a = target.children[0];
        for (i = 0, m = liList.length; i &lt; m; i++) {
            if (liList[i] === event.target) {
                console.log(i + 1);
                console.log(a.getAttribute("href"));
                console.log(a.innerText);
            }
        }
    }
}); }()); ``` 这个事件代理的思想就是，在ul上采用冒泡机制绑定点击事件，在回调函数中使用event.target(IE底下会说)判断是否是li节点，如果是，则输出需要的数字
</code></pre>

<p>这里说要支持（该死的）IE，于是多了好几个点：
- IE的事件绑定需要用attachEvent，而不能直接用addEventListener，所以需要额外处理
- 老版本的event不是又函数传入，而是写在window里面，所以也需要做一个兼容
- 老版本的IE中，并没有event.target，所以取而代之的是event.srcElement
- IE6、7、8使用数组的slice方法会报错，同时也无法使用indexOf，所以要么把这两个方法重新实现，要么直接通过遍历的方式来处理，我这里直接采用遍历的方式（因为重新实现代码加长很多）
- 去死吧IE</p>

<h2 id="section-6">第四题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/11.png" alt="第4题题面" /></p>

<h3 id="section-7">解答</h3>
<p>妈蛋被坑了，没看到还要写出其框内内容，写了个绝对定位就交了，呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵</p>

<p>及其简单的绝对定位题，里面的内容分成两块，一块是左边的二维码，一块是右边的文字部分。左边浮动，右边触发bfc</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/27hGA/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-8">第五题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/12.png" alt="第5题题面" /></p>

<h3 id="section-9">解答</h3>
<p>这题是作文…完全答不全，这里的答案不一定对，都是网上摘抄的</p>

<p>可以分成两个部分进行阐述： 1. http连接建立  2.对网页及其资源进行请求</p>

<p>http建立经过如下步骤：
1. 浏览器获得url后，对其通过DNS进行解析，转换成ip地址，以及添加上响应的端口（如果没有显式指定，默认80）
2. 浏览器通过三步握手与这个服务器建立TCP连接
3. 在连接建立后，发送一个HTTP请求报文，里面包含了请求的资源的URL，请求方法，参数等等信息
4. 服务器接收到请求报文后进行处理，返回一个包含请求资源内容的响应报文
5. 浏览器关闭这个TCP连接（在HTTP1.1中不会进行关闭，除非进行显式的connection=close，而HTTP1.0中，则会关闭，可以通过keepAlive指定不关闭）</p>

<p>对网页的资源请求：
1. 浏览器的url框获得url后，通过上述的方式获得HTML文档，获得完成后触发document.onload事件
2. 解析HTML文档，然后按照HTML文档结构从上往下开始请求资源（批量4-8）
3. 请求CSS样式表，当样式表到来的时候，将会拿它和之前已经到来的样式表进行合并和解析，修改渲染树，对页面进行回流和重绘
4. <code>&lt;scirpt&gt;</code>所添加的脚本在执行完成之前，会阻塞后续的HTML进行解析。而如果通过src添加外链的方式来引入js脚本，那么在请求、下载、解析、运行所有过程完成之前，都不会进行后续HTML的解析
5. 如果通过javascript添加script标签的方式加载，将会异步进行加载</p>

<h2 id="section-10">第六题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/13.png" alt="第6题题面" />
###解答
这题本来不难，一个下拉框，可以只用html+css实现，活用一下css的伪类就行了，至于那个小箭头用after伪元素画一下问题不大，代码如下，测试了一下能到IE7：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/ZQ5Jd/1/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>但是底下的要求，直接让我吐血，支持IE6+…就这一句话得加多少乱七八糟的兼容….IE6不支持子元素选择器，去掉之。IE6没hover，去掉之。另外小箭头肯定不能用border画了，懒得弄图片了，补上js代码。结果如下：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/ZQ5Jd/4/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-11">第七题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/14.png" alt="第7题题面" /></p>

<h3 id="section-12">解答</h3>
<p>表单序列化，获取表单中的元素然后获取他们的值，拼接成字符串，挺有意思的一道题</p>

<p>通过form.elements可以获得所有的元素，顺序遍历一遍就好，需要注意的是checkbox和radio的checked状态，另外除了input以外，还有select和textarea（这里可能考虑不全）</p>

<p><code>javascript
function serialize(form) {
    var params = [];
    var elements = form.elements;
    var i, m;
    var input;
    for (i = 0, m = elements.length; i &lt; m; i++) {
        input = elements[i];
        if (input.tagName.toLowerCase() === "input") {
            switch (input.type) {
                case "radio":
                case "checkbox":
                    if (!input.checked) {
                        break;
                    }
                default:
                    if (input.disabled == false &amp;&amp; input.name.length) {
                        params.push(encodeURI(input.name) + "=" + encodeURI(input.value));
                    }
            }
        } else if (input.tagName.toLowerCase() === "textarea" || input.tagName.toLowerCase() === "select") {
            if (input.disabled == false &amp;&amp; input.name.length) {
                params.push(encodeURI(input.name) + "=" + encodeURI(input.value));
            }
        }
    }
    return params.join("&amp;");
};
</code></p>

<h2 id="section-13">第八题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/15.png" alt="第8题题面" />
###解答
数组去重…这还只是扁平数组，不难，去哪儿那题是嵌套数组。不过它竟然要自己构造数组。去重的话直接用一个Object做标记就行。也可以考虑直接用indexOf判断，不过效率会降低
```javascript
var array = [];
var i;</p>

<p>function getRandomNumberString() {
    return Math.floor(Math.random() * 100) + ‘’;
};</p>

<p>for (i = 0; i &lt; 100; i++) {
    array.push(getRandomNumberString());
}</p>

<p>function unique(array) {
    var result = [];
    var uniObj = {};
    var i, tmp;
    for (i = array.length; i–;) {
        tmp = parseInt(array[i]);
        if (!uniObj[tmp]) {
            result.push(tmp);
            uniObj[tmp] = 1;
        }
    }
    return result;
}</p>

<p>console.log(unique(array));
```</p>

<h2 id="section-14">第九题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/16.png" alt="第9题题面" /></p>

<h3 id="section-15">解答</h3>
<p>竟然会有这种题，好吧</p>

<p>第一个地方是浏览器嗅探。这里使用了无关属性<code>document.all</code>来嗅探IE，这样并不好。应该直接使用方法来嗅探，所以将其改为<code>window.attachEvent</code></p>

<p>第二个地方是事件对象未处理，我也是后来才知道的，自己只写了第一条就交了。这里由于老式IE对event和event.target不支持，所以需要进行兼容</p>

<p>第三个地方，记得提升变量申明</p>

<p>总体修改代码如下：
<code>javascript
var addListener;
if (window.addEventListener) {
    addListener = function(el, type, listener, useCapture) {
        el.addEventListener(type, listener, useCapture);
    };
} else if (window.attachEvent) {
    addListener = function(el, type, listener) {
        el.attachEvent("on" + type, function(event) {
            event = event || window.event;
            event.target = event.target || event.srcElement;
            listener.apply(el, [event]);
        });
    };
}
</code></p>

<h2 id="section-16">第十题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/17.png" alt="第10题题面" /></p>

<h3 id="section-17">解答</h3>
<p>呵呵，还能不能愉快的答题了<code>(╯‵□′)╯︵┻━┻</code></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/04/04/alibaba-fe-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 阿里巴巴前端笔试题（1-10） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/04/04/alibaba-fe-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 04 Apr 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第一题</h2>
<p>###题面
说出以下函数的作用是？空白区域应该填写什么？
<code>javascript
// define  
(function (window) {  
    function fn(str) {  
        this.str = str;  
    }  
    fn.prototype.format = function () {  
        var arg = ______;  
        return this.str.replace(_______, function (a, b) {  
            return arg[b] || '';  
        });  
    }  
    window.fn = fn;  
})(window);  
// use  
(function(){  
    var t = new fn('&lt;p&gt;&lt;a href="{0}"&gt;{1}&lt;/a&gt;&lt;span&gt;{2}&lt;/span&gt;&lt;/p&gt;');
    console.log( t.format('http://www.alibaba.com', 'Alibaba', 'Welcome') );  
})();  
</code></p>

<h3 id="section-1">解答</h3>
<p>看题面就是，类似于写一个模板引擎。将模板里的<code>{1}</code>之类的占位符替换成传给它的参数。所以arg应该就是arguments。但是由于arg不是数组，而是一个类数组对象。所以需要进行一些转换，比较常规的转换方式如下：
<code>javascript
var arg = Array.prototype.slice.call(arguments, 0);
</code>
等号右边也就是第一空的答案了</p>

<p>第二空则是要通过正则找出占位符，并根据占位符内的数字将其替换成arg数组内的字符串，说实话replace方法的第二个参数为函数的情况很少遇到，这里就是考的这个，最初想法是直接用全局正则匹配一下：
<code>javascript
return this.str.replace(/\{\d+\}/g, function (a, b) {  
    return arg[b] || '';  
}); 
</code>
这样，但是穿进去之后发现不太对，因为b参数是正则匹配到的字符串在完整字符串中的位置。于是去查了一下W3C：
&gt; 该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。</p>

<p>这里显然是因为没有子表达式，所以直接b成了声明的匹配在stringObject中出现的位置。这样就好说了，与模式中字表达式匹配，那加一个子表达式进去，变成这样：
<code>javascript
return this.str.replace(/\{(\d+)\}/g, function (a, b) {  
    return arg[b] || '';  
}); 
</code>
跑一下，齐活，输出<code>&lt;p&gt;&lt;a href="http://www.alibaba.com"&gt;Alibaba&lt;/a&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;/p&gt; </code></p>

<h2 id="section-2">第二题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/9.png" alt="第二题题面" /></p>

<h3 id="section-3">解答</h3>
<p>这题由于时间不太够，就没有写可执行代码，主要是涉及cookie操作。可以分成用户第一次进入检测，用户点击我知道了检测两个行为来分别处理：</p>

<p>第一次进入的时候，首先判断cookie中是否有今天已来过标记，没有记录就写进一个标记，同时由于同一天不显示，所以这个写入带标记的cookie的过期时间应该为1天，这里标记为visited：
<code>javascript
if(document.cookie.indexOf(visited) === -1){
    document.cookie = 'visited=' + escape('1') + ';expires=' + new Date((new Date().getTime() + 24 * 3600 * 1000)).toGMTString();
    showTips();
}
</code></p>

<p>点不再访问的时候，应该运行如下代码：
<code>javascript
document.cookie = 'visited=' + escape('1') + ';expires=' + new Date((new Date().getTime() +  100 * 365 * 24 * 3600 * 1000)).toGMTString();
</code>
这样设定一个100年才过期的cookie，就相当于永久不显示了</p>

<h2 id="section-4">第三题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/10.png" alt="第3题题面" /></p>

<h3 id="section-5">解答</h3>
<p>在ul的li上绑点击事件，典型的事件代理的题，要输出index，所以需要提前进行一些提前处理：
```javascript
(function(){
    var nav = document.getElementById(“nav”);
    var liList = nav.children;</p>

<pre><code>function bindEvent(ele, event, callback) {
    if (ele.attachEvent) {
        ele.attachEvent("on" + event, function(event) {
            event = event || window.event;
            event.target = event.target || event.srcElement;
            callback(event);
        });
    } else {
        ele.addEventListener(event, callback, false);
    }
};

bindEvent(nav, "click", function(event) {
    var target = event.target;
    var a;
    var i, m;
    if (target.tagName.toLowerCase() === "li") {
        a = target.children[0];
        for (i = 0, m = liList.length; i &lt; m; i++) {
            if (liList[i] === event.target) {
                console.log(i + 1);
                console.log(a.getAttribute("href"));
                console.log(a.innerText);
            }
        }
    }
}); }()); ``` 这个事件代理的思想就是，在ul上采用冒泡机制绑定点击事件，在回调函数中使用event.target(IE底下会说)判断是否是li节点，如果是，则输出需要的数字
</code></pre>

<p>这里说要支持（该死的）IE，于是多了好几个点：
- IE的事件绑定需要用attachEvent，而不能直接用addEventListener，所以需要额外处理
- 老版本的event不是又函数传入，而是写在window里面，所以也需要做一个兼容
- 老版本的IE中，并没有event.target，所以取而代之的是event.srcElement
- IE6、7、8使用数组的slice方法会报错，同时也无法使用indexOf，所以要么把这两个方法重新实现，要么直接通过遍历的方式来处理，我这里直接采用遍历的方式（因为重新实现代码加长很多）
- 去死吧IE</p>

<h2 id="section-6">第四题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/11.png" alt="第4题题面" /></p>

<h3 id="section-7">解答</h3>
<p>妈蛋被坑了，没看到还要写出其框内内容，写了个绝对定位就交了，呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵呵</p>

<p>及其简单的绝对定位题，里面的内容分成两块，一块是左边的二维码，一块是右边的文字部分。左边浮动，右边触发bfc</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/27hGA/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-8">第五题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/12.png" alt="第5题题面" /></p>

<h3 id="section-9">解答</h3>
<p>这题是作文…完全答不全，这里的答案不一定对，都是网上摘抄的</p>

<p>可以分成两个部分进行阐述： 1. http连接建立  2.对网页及其资源进行请求</p>

<p>http建立经过如下步骤：
1. 浏览器获得url后，对其通过DNS进行解析，转换成ip地址，以及添加上响应的端口（如果没有显式指定，默认80）
2. 浏览器通过三步握手与这个服务器建立TCP连接
3. 在连接建立后，发送一个HTTP请求报文，里面包含了请求的资源的URL，请求方法，参数等等信息
4. 服务器接收到请求报文后进行处理，返回一个包含请求资源内容的响应报文
5. 浏览器关闭这个TCP连接（在HTTP1.1中不会进行关闭，除非进行显式的connection=close，而HTTP1.0中，则会关闭，可以通过keepAlive指定不关闭）</p>

<p>对网页的资源请求：
1. 浏览器的url框获得url后，通过上述的方式获得HTML文档，获得完成后触发document.onload事件
2. 解析HTML文档，然后按照HTML文档结构从上往下开始请求资源（批量4-8）
3. 请求CSS样式表，当样式表到来的时候，将会拿它和之前已经到来的样式表进行合并和解析，修改渲染树，对页面进行回流和重绘
4. <code>&lt;scirpt&gt;</code>所添加的脚本在执行完成之前，会阻塞后续的HTML进行解析。而如果通过src添加外链的方式来引入js脚本，那么在请求、下载、解析、运行所有过程完成之前，都不会进行后续HTML的解析
5. 如果通过javascript添加script标签的方式加载，将会异步进行加载</p>

<h2 id="section-10">第六题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/13.png" alt="第6题题面" />
###解答
这题本来不难，一个下拉框，可以只用html+css实现，活用一下css的伪类就行了，至于那个小箭头用after伪元素画一下问题不大，代码如下，测试了一下能到IE7：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/ZQ5Jd/1/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>但是底下的要求，直接让我吐血，支持IE6+…就这一句话得加多少乱七八糟的兼容….IE6不支持子元素选择器，去掉之。IE6没hover，去掉之。另外小箭头肯定不能用border画了，懒得弄图片了，补上js代码。结果如下：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/ZQ5Jd/4/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-11">第七题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/14.png" alt="第7题题面" /></p>

<h3 id="section-12">解答</h3>
<p>表单序列化，获取表单中的元素然后获取他们的值，拼接成字符串，挺有意思的一道题</p>

<p>通过form.elements可以获得所有的元素，顺序遍历一遍就好，需要注意的是checkbox和radio的checked状态，另外除了input以外，还有select和textarea（这里可能考虑不全）</p>

<p><code>javascript
function serialize(form) {
    var params = [];
    var elements = form.elements;
    var i, m;
    var input;
    for (i = 0, m = elements.length; i &lt; m; i++) {
        input = elements[i];
        if (input.tagName.toLowerCase() === "input") {
            switch (input.type) {
                case "radio":
                case "checkbox":
                    if (!input.checked) {
                        break;
                    }
                default:
                    if (input.disabled == false &amp;&amp; input.name.length) {
                        params.push(encodeURI(input.name) + "=" + encodeURI(input.value));
                    }
            }
        } else if (input.tagName.toLowerCase() === "textarea" || input.tagName.toLowerCase() === "select") {
            if (input.disabled == false &amp;&amp; input.name.length) {
                params.push(encodeURI(input.name) + "=" + encodeURI(input.value));
            }
        }
    }
    return params.join("&amp;");
};
</code></p>

<h2 id="section-13">第八题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/15.png" alt="第8题题面" />
###解答
数组去重…这还只是扁平数组，不难，去哪儿那题是嵌套数组。不过它竟然要自己构造数组。去重的话直接用一个Object做标记就行。也可以考虑直接用indexOf判断，不过效率会降低
```javascript
var array = [];
var i;</p>

<p>function getRandomNumberString() {
    return Math.floor(Math.random() * 100) + ‘’;
};</p>

<p>for (i = 0; i &lt; 100; i++) {
    array.push(getRandomNumberString());
}</p>

<p>function unique(array) {
    var result = [];
    var uniObj = {};
    var i, tmp;
    for (i = array.length; i–;) {
        tmp = parseInt(array[i]);
        if (!uniObj[tmp]) {
            result.push(tmp);
            uniObj[tmp] = 1;
        }
    }
    return result;
}</p>

<p>console.log(unique(array));
```</p>

<h2 id="section-14">第九题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/16.png" alt="第9题题面" /></p>

<h3 id="section-15">解答</h3>
<p>竟然会有这种题，好吧</p>

<p>第一个地方是浏览器嗅探。这里使用了无关属性<code>document.all</code>来嗅探IE，这样并不好。应该直接使用方法来嗅探，所以将其改为<code>window.attachEvent</code></p>

<p>第二个地方是事件对象未处理，我也是后来才知道的，自己只写了第一条就交了。这里由于老式IE对event和event.target不支持，所以需要进行兼容</p>

<p>第三个地方，记得提升变量申明</p>

<p>总体修改代码如下：
<code>javascript
var addListener;
if (window.addEventListener) {
    addListener = function(el, type, listener, useCapture) {
        el.addEventListener(type, listener, useCapture);
    };
} else if (window.attachEvent) {
    addListener = function(el, type, listener) {
        el.attachEvent("on" + type, function(event) {
            event = event || window.event;
            event.target = event.target || event.srcElement;
            listener.apply(el, [event]);
        });
    };
}
</code></p>

<h2 id="section-16">第十题</h2>
<p>###题面
<img src="http://skyinlayer.com/img/fe_interview/17.png" alt="第10题题面" /></p>

<h3 id="section-17">解答</h3>
<p>呵呵，还能不能愉快的答题了<code>(╯‵□′)╯︵┻━┻</code></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/04/04/alibaba-fe-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS布局相关基础知识 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/31/css-layout.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 31 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="containing-block">包含块（containing block）的定义</h2>
<p>元素盒子的位置和大小通常需要通过一个确定的矩形来计算，这个矩形就是包含块，其定义如下：
1. 根元素的包含块是一个被称为原始包含块（initial containing block）的矩形。它由视口确定，对于分页媒体来说就是页区域。它的direction属性时和根元素的一样
2. 对于其他元素，如果元素的position是relative或static，包含块由其最近的块级祖先的内边距（content edge）来确定
3. 如果元素时position:fixed，那么包含块就是连续媒体的视口或是分页媒体的页区域
4. 如果元素的position属性时absolute，包含那块将根据最近的position属性为非static的祖先元素来确定，有如下规则
    - 当那个祖先元素是一个内联元素时，包含块需要根据祖先元素的direction属性来确定
        -  如果direction是ltr，那么包含块的左上顶点将是祖先元素的第一个盒子的左上顶点，而包含块的右下顶点将是祖先元素最后一个盒子的右下顶点
        -  如果direction是rtl，那么包含块的右上顶点将是祖先元素的第一个盒子的右上顶点，而包含块的左下顶点将是祖先元素最后一个盒子的左下顶点
    - 如果祖先元素是块状元素，那么它的包含块将是这个祖先元素的padding edge
    - 如果没有这么一个祖先元素，则包含块就是原始包含块</p>

<p>分页媒体中，绝对定位元素会被定位在其自己的包含块中，而无视任何分页（就好像整个文档是连续的）。这可能导致元素被分开到多页中</p>

<h2 id="section">浮动</h2>
<p>一个浮动的盒子首先会根据文档流定位，然后尽可能的往左移或者往右移，直到它的外边界（margin边界）碰到了包含块边界或其他浮动元素的外边界。如果在一个line box中，浮动盒子的顶部外边界将与当前的line box的顶部对齐</p>

<p>如果水平方向上没有足够的空间以容纳浮动元素，它将向下移动，直到它能被容纳或没有更多的浮动元素（If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present.不知如何翻译）</p>

<p>由于浮动元素不在文档流内，其前后的未定位的元素将当做它不存在（脱离文档流）。但是，当前的line box和其后面被浮动元素缩短的line box将会为这个浮动的元素创建空间</p>

<p>一个line box在垂直位置满足如下四个条件时，被定义为紧邻着浮动元素，line box会被缩短：
1. 在linx box的顶部边界位置或其下方
2. 在line box的底部边界位置或其上方
3. 在浮动元素的上margin边界之下
4. 在浮动元素的下margin边界之上</p>

<p>如果一个被缩短的line box太小而不足以容纳任何内容，那么这个line box将会被向下移动（它的宽度也将重新计算），直到某些内容能够展现或不再被浮动影响。任何与浮动元素在一行的元素将会在浮动元素的另外一边重新排列。也就是说，如果内联盒子被放置在一个float：left元素的左边，那么它将移动到float元素的右边。而rtl模式和float:right则相反</p>

<p>一个触发了BFC的元素不能与同一BFC下的任何浮动元素重叠。如果有必要，这些元素可以被实现为清除浮动，但如果有足够的空间，可以被放置在浮动元素之后。他们甚至能被浮动元素挤压变得更窄</p>

<p>浮动元素的margin不会和相邻盒子的margin重叠。一个浮动元素能与正常流中的其他元素重叠。当这种情况发生时，浮动元素将被渲染在未定位的文档流内的块状元素之前，文档流的内联元素之后</p>

<p>clear清除浮动，意思是确定当前元素不能与哪个方向的浮动元素相邻。触发了BFC的元素和浮动元素本身的clear属性将无效</p>

<p>另外使用clear清除浮动或由于被挤压而到下面时，设置margin-top是无效的，需要先使用一个div清除浮动，或是在上面一个元素设定margin-bottom</p>

<p><img src="http://lingyu.wang/img/layout/1.png" alt="清除浮动元素margin-top无效的解释1" /></p>

<p><img src="http://lingyu.wang/img/layout/2.png" alt="清除浮动元素margin-top无效的解释2" /></p>

<p><img src="http://lingyu.wang/img/layout/3.png" alt="清除浮动元素margin-top无效的解释3" /></p>

<h2 id="section-1">定位</h2>
<p>CSS中一个盒子的定位可以通过如下三种定位模式：
1. 文档流：文档流包括块级元素的块级格式和内联元素的内联格式，以及relative和sticky定位
2. 浮动：浮动模式下，一个盒子起初定位在文档流中，然后被从文档流中拿出向左或向右移动。内容会包围在浮动元素的边上
3. 绝对定位：在绝对定位模式下，一个盒子会从文档流中完全脱离，并根据定位所属的包含块进行定位</p>

<p>当一个元素时浮动的，或者绝对定位或者是根元素，那么就称它脱离文档流。一个元素没脱离文档流的话就被称为流内元素（in-flow）</p>

<h2 id="relative-positioning">相对定位（relative positioning）</h2>
<p>当一个盒子通过文档流或浮动定位，那么它能通过position:relative设定一个相对的偏移。这就是相对定位。为一个相对定位的盒子设定偏移不会影响到其他盒子。这也意味着相对定位的盒子会和其他盒子重叠。然而，当一个父元素设定了overflow的值为auto和scroll，而其中的子元素设定了相对偏移而溢出父元素，那么父元素应当扩张滚动条，让用户能通过滚动条看到设定相对偏移的子元素的内容。</p>

<p>一个相对定位的盒子保持它在文档流之中的大小，包括它的换行以及原本为它保留的空间</p>

<p>一个相对定位的盒子建立一个新的包含块，这个可以为其内部的绝对定位元素创建一个包含块</p>

<p>使用left和right属性能够水平方向移动盒子，而不用改变其大小。left将盒子右移，而right将盒子左移。left = -right
- 如果left和right都是auto，那么他们的值都是0
- 如果left是auto，将使用-right值
- 如果rifht是auto，将使用-left值
- 如果都不是auto，就会形成一个过渡约束，那么就有一个值必须被忽略。如果direction属性为ltr，left将优先于left被使用。如果direction是rtl，那么right将优先</p>

<p>top和bottom属性上下移动盒子而不改变其大小。top将盒子向下移，而bottom将盒子向上移。top=-bottom
- 如果都是auto，那么值都是0
- 如果有一个是auto，那么它的值将是另外一个的负数
- 如果都不是auto，那么bottom将被忽略</p>

<h2 id="section-2">绝对定位</h2>
<p>在绝对定位模型中，一个盒子根据它所在的包含块（containing block）计算偏移。绝对定位的元素将完全从文档流中脱离而不会影响到其他元素。同时它自身也会为其内部的绝对定位元素（absolute）子孙元素和文档流元素建立一个包含块。但是一个绝对定位元素的内容不会受其他盒子的影响。他们会根据盒子所具有的的堆叠等级（z-index）来掩盖其他盒子（或者被其他盒子所掩盖）</p>

<h3 id="absolute">非替换元素的绝对定位（absolute，</h3>
<p>page，fixed）宽度计算
对所有能使用的影响宽度的值有如下限制：
&gt; ‘left’ + ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + width + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ + ‘right’ = 包含块的宽度</p>

<p>如果left、width和right都是auto，那么将把margin-left和margin-right中值为auto的替换成0。如果建立包含块属性的direction属性为ltr，那么设定left属性为静态定位时的值，然后根据下面的3号规则来确定。如果direction属性为rtl，那么设定right属性为静态定位时的值，然后根据下面的1号规则来确定。</p>

<p>如果left、width和right都不是auto：如果margin-left和margin-right为auto，会根据如下规则解析整个等式计算出两个margin的值，margin-left和margin-right的值相等。如果他们都是负数，当包含块的direction为ltr时，设定margin-left为0，然后计算margin-right，若包含块的direction为rtl时，设定margin-right为0，然后计算margin-left。如果margin-left和margin-right只有一个是auto，那么可以根据等式计算出为auto的margin的值。如果值被过度约束，在direction为ltr时忽略right值，在为rtl时忽略left值。</p>

<p>否则，将margin-left和margin-right中为auto的值替换成0，并选则如下6条中的一条执行：
1. 如果left和width都是auto，而right不是auto，那么width将会扩展尽可能收缩，然后计算left值
2. 如果left和right为auto，而width不是auto，那么如果创建包含块的元素direction属性为ltr，设定left为静态定位时的值然后计算出right，如果direction属性为rtl，设定right为静态定位时的值然后计算出left。
3. 如果width和right都是auto，而left不是auto，那么width会背尽可能收缩，然后计算出right
4. 如果left是auto，width和right都不是auto，直接算出left
5. 如果width是auto，left和right都说不是auto，直接算出width
6. 如果right是auto，width和left都不是auto，直接算出right</p>

<h3 id="absolute-1">非替换元素的绝对定位（absolute，</h3>
<p>page，fixed）高度计算
对所有能够使用的影响高度的值有如下限制：
&gt; ‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度</p>

<p>如果top、height、bottom都是auto，首先将margin-top和margin-bottom中为auto的替换为0，然后设定top为静态定位中的值，然后使用下面的3号规定来确定</p>

<p>如果top、height、bottom都不是auto，如果margin-top和margin-bottom都是auto，那么根据等式计算出margin-top和margin-bottom的值，他们俩相等。如果margin-top和margin-bottom只有一个是auto，解析等式直接算出为auto的值即可。如果出现了过度限制，那么忽略bottom的值，然后计算得到bottom值</p>

<p>否则，替换margin-top和margin-bottom中的auto为0，按照下面的规则计算：
1. 如果top、height都是auto，而bottom不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top
2. 如果top、bottom都是auto，而height不是auto，那么设定top为静态定位时的初始值，然后计算出bottom
3. 如果height和bottom都是auto，而top不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top
4. 如果top是auto，而height和bottom不是auto，那么直接算出top
5. 如果height是auto，top和bottom不是auto，那么直接算出height
6. 如果bottom是auto，top和height不是auto，那么直接算出bottom</p>

<h2 id="normal-flow">Normal flow（文档流）</h2>
<p>在文档流中的盒子属于一个格式上下文，可以是BFC（块级格式上下文）或是IFC（内联格式上下文）。</p>

<h3 id="bfcblock-formatting-context">BFC（Block formatting context）</h3>
<p>浮动元素，绝对定位元素，一些块容器元素（display为inline-block，table-celss，table-captions等），或设定了overflow不为visible的元素都会创建BFC</p>

<p>BFC中，盒子将被垂直的一个接一个的从父元素的包含块（containing block）的顶部向下排列。盒子之间的垂直距离由盒子的垂直margin来确定。而相邻的块级元素元元素的margin会发生重叠（collapse）</p>

<p>BFC中，每个盒子的做外边界（左margin边界）触碰到父元素的包含块的左边界（如果是从右往左，则反过来）。就算表现浮动时也是一样，除非盒子建立一个新的BFC。</p>

<h3 id="ifcinline-formatting-context">IFC（Inline formatting context）</h3>
<p>在IFC中，盒子一个接一个的在父元素的包含块中水平布局。水平margin、border、padding将会影响布局，而纵向的则不会。盒子在纵向布局上采用了完全不同的方式：他们的底部或顶部可以相互对齐，或他们内部的文本可以以一个基准线进行对齐。这个包含了一行的多个盒子的矩形区域成为一个行盒子（line box）。</p>

<p>line box的宽度足以包含其内部所有元素。而它的高度则可能比它所包含的最高的盒子还要高。如果一个盒子高度不足以达到line box的高度，我们就可以使用vertical-align来确定它的位置。当很多内联盒子无法被一个line box水平包裹时，它们将分布在两个或者多个垂直堆叠的line box中。这样一个段落实际上就被分成了很多垂直方向分布的line box了。line box在垂直方向上没有间隔，也不会重叠</p>

<p>一般情况下，一个line box的宽度与父元素包含块的宽度相同，line box会顶在父元素包含块的左边界和右边界。一般情况下，在同一个内联格式上下文中，所有的line box的宽度是一样的。但如果出现了浮动的话，水平宽度也会由于浮动而变化。在同一个内联格式上下文中的line box的高度经常很多样，其根据line box内部包含的子元素来确定的（如果都是文字的话没什么区别，但是又是偶会包含一些图片）</p>

<p>当一个内联盒子超出了line box的宽度，那么它被分割到多个盒子中，而这些盒子将被分配到多个line box中。如果一个内敛盒子不能被分割，那么这个内联盒子将溢出其所在的line box</p>

<p>当一个内联盒子被拆分，margin、border、padding在分割的地方不会有视觉效果</p>

<p>内联盒子也可以由于unicode-bidi和direction的设定被拆分到多个统一line box中。</p>

<p>line box的创建是根据需要的内容大小来的。line box不包含文字，也没有留白，没有margin、padding、border，并且不以一个保留的0高度的（被当做不存在）line box而结束</p>

<p>line box的高度有如下计算方式：
1. 计算出line box内部的每个内联盒子的高度。对于替换元素、inline-block元素和inline-table元素，他们的高度是整个margin box的高度。而对于内联盒子，值是他们的line-height属性。
2. 内联盒子在垂直方向上根据他们的vertival-align属性来分布。当值为top或bottom时，他们必须以最小化line box高度的方式排布。如果那个盒子足够高，就会撑开line box
3. line box的height属性是最上面盒子的顶端到最下面盒子的底端的值</p>

<p>空的inline元素元素会生成空的内联盒子。但这些盒子一样有自己的margin、padding、border以及一个line heihgt，一样会影响行盒的计算</p>

<h2 id="displaypositionfloat">display，position和float相互关系</h2>
<p>这桑格元素都会影响盒子的生成和布局，他们有如下相互影响的规则：
1. 如果display是none，那么position和float不会起作用。这个元素压根就不会生成盒子
2. 如果display不是none，如果position的值为absolute，page或者fixed，而float值为left或right，那么盒子会绝对定位同时float值将被设为none。display属性将根据下面这张表来确定。由于使用了绝对定位，盒子的位置由其top、right、botton、left属性和盒子所属的包含块确定
3. 否则，如果float不是none。那么盒子将是浮动定位，而且display属性将按照如下表格确定
4. 否则，如果盒子是根元素，display属性将按照如下表格确定
5. 否则，将运用display属性</p>

<p><img src="http://lingyu.wang/img/layout/4.png" alt="display属性转换表" /></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/31/css-layout.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS布局相关基础知识 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/31/css-layout.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 31 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="containing-block">包含块（containing block）的定义</h2>
<p>元素盒子的位置和大小通常需要通过一个确定的矩形来计算，这个矩形就是包含块，其定义如下：
1. 根元素的包含块是一个被称为原始包含块（initial containing block）的矩形。它由视口确定，对于分页媒体来说就是页区域。它的direction属性时和根元素的一样
2. 对于其他元素，如果元素的position是relative或static，包含块由其最近的块级祖先的内边距（content edge）来确定
3. 如果元素时position:fixed，那么包含块就是连续媒体的视口或是分页媒体的页区域
4. 如果元素的position属性时absolute，包含那块将根据最近的position属性为非static的祖先元素来确定，有如下规则
    - 当那个祖先元素是一个内联元素时，包含块需要根据祖先元素的direction属性来确定
        -  如果direction是ltr，那么包含块的左上顶点将是祖先元素的第一个盒子的左上顶点，而包含块的右下顶点将是祖先元素最后一个盒子的右下顶点
        -  如果direction是rtl，那么包含块的右上顶点将是祖先元素的第一个盒子的右上顶点，而包含块的左下顶点将是祖先元素最后一个盒子的左下顶点
    - 如果祖先元素是块状元素，那么它的包含块将是这个祖先元素的padding edge
    - 如果没有这么一个祖先元素，则包含块就是原始包含块</p>

<p>分页媒体中，绝对定位元素会被定位在其自己的包含块中，而无视任何分页（就好像整个文档是连续的）。这可能导致元素被分开到多页中</p>

<h2 id="section">浮动</h2>
<p>一个浮动的盒子首先会根据文档流定位，然后尽可能的往左移或者往右移，直到它的外边界（margin边界）碰到了包含块边界或其他浮动元素的外边界。如果在一个line box中，浮动盒子的顶部外边界将与当前的line box的顶部对齐</p>

<p>如果水平方向上没有足够的空间以容纳浮动元素，它将向下移动，直到它能被容纳或没有更多的浮动元素（If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present.不知如何翻译）</p>

<p>由于浮动元素不在文档流内，其前后的未定位的元素将当做它不存在（脱离文档流）。但是，当前的line box和其后面被浮动元素缩短的line box将会为这个浮动的元素创建空间</p>

<p>一个line box在垂直位置满足如下四个条件时，被定义为紧邻着浮动元素，line box会被缩短：
1. 在linx box的顶部边界位置或其下方
2. 在line box的底部边界位置或其上方
3. 在浮动元素的上margin边界之下
4. 在浮动元素的下margin边界之上</p>

<p>如果一个被缩短的line box太小而不足以容纳任何内容，那么这个line box将会被向下移动（它的宽度也将重新计算），直到某些内容能够展现或不再被浮动影响。任何与浮动元素在一行的元素将会在浮动元素的另外一边重新排列。也就是说，如果内联盒子被放置在一个float：left元素的左边，那么它将移动到float元素的右边。而rtl模式和float:right则相反</p>

<p>一个触发了BFC的元素不能与同一BFC下的任何浮动元素重叠。如果有必要，这些元素可以被实现为清除浮动，但如果有足够的空间，可以被放置在浮动元素之后。他们甚至能被浮动元素挤压变得更窄</p>

<p>浮动元素的margin不会和相邻盒子的margin重叠。一个浮动元素能与正常流中的其他元素重叠。当这种情况发生时，浮动元素将被渲染在未定位的文档流内的块状元素之前，文档流的内联元素之后</p>

<p>clear清除浮动，意思是确定当前元素不能与哪个方向的浮动元素相邻。触发了BFC的元素和浮动元素本身的clear属性将无效</p>

<p>另外使用clear清除浮动或由于被挤压而到下面时，设置margin-top是无效的，需要先使用一个div清除浮动，或是在上面一个元素设定margin-bottom</p>

<p><img src="http://lingyu.wang/img/layout/1.png" alt="清除浮动元素margin-top无效的解释1" /></p>

<p><img src="http://lingyu.wang/img/layout/2.png" alt="清除浮动元素margin-top无效的解释2" /></p>

<p><img src="http://lingyu.wang/img/layout/3.png" alt="清除浮动元素margin-top无效的解释3" /></p>

<h2 id="section-1">定位</h2>
<p>CSS中一个盒子的定位可以通过如下三种定位模式：
1. 文档流：文档流包括块级元素的块级格式和内联元素的内联格式，以及relative和sticky定位
2. 浮动：浮动模式下，一个盒子起初定位在文档流中，然后被从文档流中拿出向左或向右移动。内容会包围在浮动元素的边上
3. 绝对定位：在绝对定位模式下，一个盒子会从文档流中完全脱离，并根据定位所属的包含块进行定位</p>

<p>当一个元素时浮动的，或者绝对定位或者是根元素，那么就称它脱离文档流。一个元素没脱离文档流的话就被称为流内元素（in-flow）</p>

<h2 id="relative-positioning">相对定位（relative positioning）</h2>
<p>当一个盒子通过文档流或浮动定位，那么它能通过position:relative设定一个相对的偏移。这就是相对定位。为一个相对定位的盒子设定偏移不会影响到其他盒子。这也意味着相对定位的盒子会和其他盒子重叠。然而，当一个父元素设定了overflow的值为auto和scroll，而其中的子元素设定了相对偏移而溢出父元素，那么父元素应当扩张滚动条，让用户能通过滚动条看到设定相对偏移的子元素的内容。</p>

<p>一个相对定位的盒子保持它在文档流之中的大小，包括它的换行以及原本为它保留的空间</p>

<p>一个相对定位的盒子建立一个新的包含块，这个可以为其内部的绝对定位元素创建一个包含块</p>

<p>使用left和right属性能够水平方向移动盒子，而不用改变其大小。left将盒子右移，而right将盒子左移。left = -right
- 如果left和right都是auto，那么他们的值都是0
- 如果left是auto，将使用-right值
- 如果rifht是auto，将使用-left值
- 如果都不是auto，就会形成一个过渡约束，那么就有一个值必须被忽略。如果direction属性为ltr，left将优先于left被使用。如果direction是rtl，那么right将优先</p>

<p>top和bottom属性上下移动盒子而不改变其大小。top将盒子向下移，而bottom将盒子向上移。top=-bottom
- 如果都是auto，那么值都是0
- 如果有一个是auto，那么它的值将是另外一个的负数
- 如果都不是auto，那么bottom将被忽略</p>

<h2 id="section-2">绝对定位</h2>
<p>在绝对定位模型中，一个盒子根据它所在的包含块（containing block）计算偏移。绝对定位的元素将完全从文档流中脱离而不会影响到其他元素。同时它自身也会为其内部的绝对定位元素（absolute）子孙元素和文档流元素建立一个包含块。但是一个绝对定位元素的内容不会受其他盒子的影响。他们会根据盒子所具有的的堆叠等级（z-index）来掩盖其他盒子（或者被其他盒子所掩盖）</p>

<h3 id="absolute">非替换元素的绝对定位（absolute，</h3>
<p>page，fixed）宽度计算
对所有能使用的影响宽度的值有如下限制：
&gt; ‘left’ + ‘margin-left’ + ‘border-left-width’ + ‘padding-left’ + width + ‘padding-right’ + ‘border-right-width’ + ‘margin-right’ + ‘right’ = 包含块的宽度</p>

<p>如果left、width和right都是auto，那么将把margin-left和margin-right中值为auto的替换成0。如果建立包含块属性的direction属性为ltr，那么设定left属性为静态定位时的值，然后根据下面的3号规则来确定。如果direction属性为rtl，那么设定right属性为静态定位时的值，然后根据下面的1号规则来确定。</p>

<p>如果left、width和right都不是auto：如果margin-left和margin-right为auto，会根据如下规则解析整个等式计算出两个margin的值，margin-left和margin-right的值相等。如果他们都是负数，当包含块的direction为ltr时，设定margin-left为0，然后计算margin-right，若包含块的direction为rtl时，设定margin-right为0，然后计算margin-left。如果margin-left和margin-right只有一个是auto，那么可以根据等式计算出为auto的margin的值。如果值被过度约束，在direction为ltr时忽略right值，在为rtl时忽略left值。</p>

<p>否则，将margin-left和margin-right中为auto的值替换成0，并选则如下6条中的一条执行：
1. 如果left和width都是auto，而right不是auto，那么width将会扩展尽可能收缩，然后计算left值
2. 如果left和right为auto，而width不是auto，那么如果创建包含块的元素direction属性为ltr，设定left为静态定位时的值然后计算出right，如果direction属性为rtl，设定right为静态定位时的值然后计算出left。
3. 如果width和right都是auto，而left不是auto，那么width会背尽可能收缩，然后计算出right
4. 如果left是auto，width和right都不是auto，直接算出left
5. 如果width是auto，left和right都说不是auto，直接算出width
6. 如果right是auto，width和left都不是auto，直接算出right</p>

<h3 id="absolute-1">非替换元素的绝对定位（absolute，</h3>
<p>page，fixed）高度计算
对所有能够使用的影响高度的值有如下限制：
&gt; ‘top’ + ‘margin-top’ + ‘border-top-width’ + ‘padding-top’ + ‘height’ + ‘padding-bottom’ + ‘border-bottom-width’ + ‘margin-bottom’ + ‘bottom’ = 包含块的高度</p>

<p>如果top、height、bottom都是auto，首先将margin-top和margin-bottom中为auto的替换为0，然后设定top为静态定位中的值，然后使用下面的3号规定来确定</p>

<p>如果top、height、bottom都不是auto，如果margin-top和margin-bottom都是auto，那么根据等式计算出margin-top和margin-bottom的值，他们俩相等。如果margin-top和margin-bottom只有一个是auto，解析等式直接算出为auto的值即可。如果出现了过度限制，那么忽略bottom的值，然后计算得到bottom值</p>

<p>否则，替换margin-top和margin-bottom中的auto为0，按照下面的规则计算：
1. 如果top、height都是auto，而bottom不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top
2. 如果top、bottom都是auto，而height不是auto，那么设定top为静态定位时的初始值，然后计算出bottom
3. 如果height和bottom都是auto，而top不是auto，高度将根据元素内部高度计算得出（<a href="http://dev.w3.org/csswg/css-position/#root-height">计算规则在这里</a>），然后算出top
4. 如果top是auto，而height和bottom不是auto，那么直接算出top
5. 如果height是auto，top和bottom不是auto，那么直接算出height
6. 如果bottom是auto，top和height不是auto，那么直接算出bottom</p>

<h2 id="normal-flow">Normal flow（文档流）</h2>
<p>在文档流中的盒子属于一个格式上下文，可以是BFC（块级格式上下文）或是IFC（内联格式上下文）。</p>

<h3 id="bfcblock-formatting-context">BFC（Block formatting context）</h3>
<p>浮动元素，绝对定位元素，一些块容器元素（display为inline-block，table-celss，table-captions等），或设定了overflow不为visible的元素都会创建BFC</p>

<p>BFC中，盒子将被垂直的一个接一个的从父元素的包含块（containing block）的顶部向下排列。盒子之间的垂直距离由盒子的垂直margin来确定。而相邻的块级元素元元素的margin会发生重叠（collapse）</p>

<p>BFC中，每个盒子的做外边界（左margin边界）触碰到父元素的包含块的左边界（如果是从右往左，则反过来）。就算表现浮动时也是一样，除非盒子建立一个新的BFC。</p>

<h3 id="ifcinline-formatting-context">IFC（Inline formatting context）</h3>
<p>在IFC中，盒子一个接一个的在父元素的包含块中水平布局。水平margin、border、padding将会影响布局，而纵向的则不会。盒子在纵向布局上采用了完全不同的方式：他们的底部或顶部可以相互对齐，或他们内部的文本可以以一个基准线进行对齐。这个包含了一行的多个盒子的矩形区域成为一个行盒子（line box）。</p>

<p>line box的宽度足以包含其内部所有元素。而它的高度则可能比它所包含的最高的盒子还要高。如果一个盒子高度不足以达到line box的高度，我们就可以使用vertical-align来确定它的位置。当很多内联盒子无法被一个line box水平包裹时，它们将分布在两个或者多个垂直堆叠的line box中。这样一个段落实际上就被分成了很多垂直方向分布的line box了。line box在垂直方向上没有间隔，也不会重叠</p>

<p>一般情况下，一个line box的宽度与父元素包含块的宽度相同，line box会顶在父元素包含块的左边界和右边界。一般情况下，在同一个内联格式上下文中，所有的line box的宽度是一样的。但如果出现了浮动的话，水平宽度也会由于浮动而变化。在同一个内联格式上下文中的line box的高度经常很多样，其根据line box内部包含的子元素来确定的（如果都是文字的话没什么区别，但是又是偶会包含一些图片）</p>

<p>当一个内联盒子超出了line box的宽度，那么它被分割到多个盒子中，而这些盒子将被分配到多个line box中。如果一个内敛盒子不能被分割，那么这个内联盒子将溢出其所在的line box</p>

<p>当一个内联盒子被拆分，margin、border、padding在分割的地方不会有视觉效果</p>

<p>内联盒子也可以由于unicode-bidi和direction的设定被拆分到多个统一line box中。</p>

<p>line box的创建是根据需要的内容大小来的。line box不包含文字，也没有留白，没有margin、padding、border，并且不以一个保留的0高度的（被当做不存在）line box而结束</p>

<p>line box的高度有如下计算方式：
1. 计算出line box内部的每个内联盒子的高度。对于替换元素、inline-block元素和inline-table元素，他们的高度是整个margin box的高度。而对于内联盒子，值是他们的line-height属性。
2. 内联盒子在垂直方向上根据他们的vertival-align属性来分布。当值为top或bottom时，他们必须以最小化line box高度的方式排布。如果那个盒子足够高，就会撑开line box
3. line box的height属性是最上面盒子的顶端到最下面盒子的底端的值</p>

<p>空的inline元素元素会生成空的内联盒子。但这些盒子一样有自己的margin、padding、border以及一个line heihgt，一样会影响行盒的计算</p>

<h2 id="displaypositionfloat">display，position和float相互关系</h2>
<p>这桑格元素都会影响盒子的生成和布局，他们有如下相互影响的规则：
1. 如果display是none，那么position和float不会起作用。这个元素压根就不会生成盒子
2. 如果display不是none，如果position的值为absolute，page或者fixed，而float值为left或right，那么盒子会绝对定位同时float值将被设为none。display属性将根据下面这张表来确定。由于使用了绝对定位，盒子的位置由其top、right、botton、left属性和盒子所属的包含块确定
3. 否则，如果float不是none。那么盒子将是浮动定位，而且display属性将按照如下表格确定
4. 否则，如果盒子是根元素，display属性将按照如下表格确定
5. 否则，将运用display属性</p>

<p><img src="http://lingyu.wang/img/layout/4.png" alt="display属性转换表" /></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/31/css-layout.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript隐式类型转换 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/30/js-type-convert.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 30 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">对象转原始值</h2>
<p>###对象转布尔
对象转Boolean很简单，所有对象都是true</p>

<p>举个栗子：
```javascript
&gt; !!new Boolean(false)
true</p>

<blockquote>
  <p>if(new Boolean(false)){
    console.log(true);
  } else {
    console.log(false);
  }
true
```</p>
</blockquote>

<h3 id="section-1">对象转字符串</h3>
<p>对象转字符串经过如下步骤：
- 如果对象有toString()方法，则调用toString()。如果toString()返回一个原始值，那么将这个值转为字符串（如果它不是字符串的话），并返回
- 如果对象没有toString()方法，或者调用toString()方法返回的不是一个原始值，那么调用valueOf()方法。 如果valueOf()方法返回的是原始值，那么将它转换为字符串，并返回
- 如果无法从toString()或valueOf()获得一个原始值，那么将抛出一个类型错误异常</p>

<p>来个栗子：
```javascript
function Obj(){}
Obj.prototype.toString = function(){return “callToString”}
Obj.prototype.valueOf = function(){return “callValueOf”}
var data = {
    “callToString” : “callToString”,
    “callValueOf” : “callValueOf”
};</p>

<p>console.log(data[new Obj()]);//输出”callToString”</p>

<p>Obj.prototype.toString = function(){return {};}</p>

<p>console.log(data[new Obj()]);//输出”callValueOf”
```</p>

<h3 id="section-2">对象转数字</h3>
<p>对象转数字经过如下步骤：
- 如果对象有valueOf()方法，后者返回一个原始值，那么将这个原始值转换为数字并返回
- 如果对象没有valueOf()方法，或返的不是一个原始值，尝试toString()方法。如果有toString()方法，且返回一个原始值，那么将其转换成数字并返回
- 如果无法从valueOf()或toString()获得一个原始值，那么将抛出一个类型错误异常</p>

<p>```javascript
function Obj() {}
Obj.prototype.toString = function() {
    return “20”
};</p>

<p>console.log(new Obj() * 1);//输出20</p>

<p>Obj.prototype.valueOf = function() {
    return “10”
};</p>

<p>console.log(new Obj() * 1);//输出10
```
由这个栗子可以看到，转数字时会优先尝试valueOf()方法，然后尝试toString()方法，虽然获得的原始类型都是字符串，但会将字符串转换为数字</p>

<h2 id="section-3">运算符与隐式类型转换</h2>
<p>###“+”运算符
“+”运算符的行为如下：
- 如果其中一个操作数是对象，那么会将对象转换为原始值类型（Date通过toString方法，其他对象依次尝试valueOf和toString()）
- 如果对象转换到原始值后，其中一个是字符串，那么另一个也被转成字符串，进行字符串连接
- 否则两个操作数都将转换为数字（或NaN），然后想加</p>

<p>```javascript
function Obj(){}
Obj.prototype.valueOf = function(){
    return “234”;
};</p>

<p>console.log(123 + new Obj());//输出”123234”</p>

<p>Obj.prototype.valueOf = function(){
    return 234;
};</p>

<p>console.log(123 + new Obj());//输出”357”</p>

<p>Obj.prototype.valueOf = function(){
    return true;
};</p>

<p>console.log(123 + new Obj());//输出”124”</p>

<p>console.log(123 + new Date());//输出”123Sun Mar 30 2014 12:53:02 GMT+0800 (中国标准时间)”
```</p>

<h3 id="section-4">其他算数运算符</h3>
<p>乘法(*)，除法(/)，取模(%)，减法(-)，以及一元算数运算符（+，-，++，–）都是在需要的时候将操作数转化为数字，就是根据上面先尝试valueOf，后尝试toString的方式来转换。如果有一个操作数是NaN，那么运算结果也是NaN</p>

<h3 id="section-5">位运算符</h3>
<p>位运算符需要它的操作数是整数，这些整数表示32位整型而不是64位浮点数，所以在进行位运算之前，首先将操作数转换为数字，然后转换为32位整型，之后进行操作。而NaN，Infinity和-Infinity都转换成0。</p>

<h3 id="section-6">关系表达式</h3>
<p>严格相等（===）不会进行类型转换，而使用相等（==）会进行隐式的类型转换。严格相等会比较类型和值，类型不一致的两个值肯定不相等，具体规则如下：- 两个值类型不同，他们不相等
- 都是null或都是undefined，他们不相等
- 都是布尔true或布尔false，他们相等
- 有一个值是NaN，那么不相等，NaN也不等于自身
- 都位数字时，且他们值相等，那么相等，0与-0相等
- 两个值都为字符串，如果他们长度或内容不同，则不相等
- 两个值都引用对象、数组或函数，如果它们引用同一个对象，他们相等，否则不相等</p>

<p>举一些栗子来验证一下：
```javascript
&gt; ({}) === ({})
false</p>

<blockquote>
  <p>[] === []
false</p>
</blockquote>

<blockquote>
  <p>var a, b;
a = b = {};
a === b
true</p>
</blockquote>

<blockquote>
  <p>NaN === NaN
false</p>
</blockquote>

<blockquote>
  <p>null === undefined
false</p>
</blockquote>

<blockquote>
  <p>0 === -0
true</p>
</blockquote>

<blockquote>
  <p>Infinity === Infinity
true</p>
</blockquote>

<blockquote>
  <p>Infinity === -Infinity
false
```</p>
</blockquote>

<p>相等运算符（==）会进行隐式类型转换，规则如下：
- 如果两个操作数类型相等，则和上面严格相等的比较规则一样
- 如果其中一个值是null，另一个是undefined，他们相等
- 如果一个是数字，另一个是字符串，则会先将字符串转为数字再比较
- 如果其中一个是布尔类型，也会将其转换为数字，然后在比较，true转换为1，false转换为0
- 如果一个值为对象，另一个值为数字或字符串，那么像将其转换为原始值。JavaScript语言核心的内置类会优先尝试valueOf，然后尝试toString。但Date类只是用toString转换
- 其他不同类型之间的比较均不相等</p>

<p>举一些栗子：
```javascript
&gt; null == undefined
true</p>

<blockquote>
  <p>({}) == ({})
false</p>
</blockquote>

<blockquote>
  <p>[] == []
false</p>
</blockquote>

<blockquote>
  <p>“123” == 123
true</p>
</blockquote>

<blockquote>
  <p>true == “1”
true</p>
</blockquote>

<blockquote>
  <p>NaN == NaN
false</p>
</blockquote>

<blockquote>
  <p>function Obj(){}
Obj.prototype.toString = function(){return “tostring”;}
Obj.prototype.valueOf = function(){return “valueof”;}
new Obj() == “valueof”
true</p>
</blockquote>

<blockquote>
  <p>Infinity == Infinity
true</p>
</blockquote>

<blockquote>
  <p>Infinity == -Infinity
false
```
##比较运算符
小于、大于，小于等于、大于等于这些比较运算符的操作数可能是任意类型，但只有数字和字符串才能真正进行比较操作，所以会对其进行转换：
- 如果操作数是对象，那么这个对象会转换为原始值，同样有限使用valueOf，然后使用toString
- 对象转换为原始值后，如果都是字符串，按照字典序比较
- 如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行比较，0与-0相等，Infinity比任何数字都大（除了Infinity本身），-Infinity比任何数字都小，如果其中一个操作数是NaN，比较操作符返回false</p>
</blockquote>

<p>举几个栗子：
```javascript
&gt; NaN &lt; 1
false</p>

<blockquote>
  <p>NaN &gt; 1
false</p>
</blockquote>

<blockquote>
  <p>Infinity &lt; Infinity
fasle</p>
</blockquote>

<blockquote>
  <p>Infinity &gt; Infinity
false</p>
</blockquote>

<blockquote>
  <p>Infinity &gt; -Infinity
true</p>
</blockquote>

<blockquote>
  <p>“a” &lt; “b”
true</p>
</blockquote>

<blockquote>
  <p>“abcd” &lt; “abce”
true
```</p>
</blockquote>

<h3 id="in">in运算符</h3>
<p>in运算符永远期望左操作数是字符串，右操作数是一个对象，所以左操作数会隐式类型转换：
```javascript
function Obj(){}
Obj.prototype.toString = function(){return “callToString”}
Obj.prototype.valueOf = function(){return “callValueOf”}
var data = {
    “callToString” : “callToString”
};</p>

<p>console.log(new Obj() in data);//输出true</p>

<p>Obj.prototype.toString = function(){return {};}</p>

<p>console.log(new Obj() in data);//输出false</p>

<p>data.callValueOf = “callValueOf”;</p>

<p>console.log(new Obj() in data);//输出true
```
第一个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得callToString字符串，而它在data对象中存在，所以输出true</p>

<p>第二个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得一个对象，不是原始值，于是尝试valueOf方法，获得callValueOf字符串，而它在data对象中不存在，所以输出false</p>

<p>第三个console和第二个console过程一样，不过这一次data中存在callValueOf字符串，所以输出true</p>

<h3 id="instanceof">instanceof运算符</h3>
<p>instanceof运算符总是希望左操作数是一个对象，右操作数是一个函数。instanceof一次检查左操作数的对象的原型链的VO，如果存在右操作数函数的prototype存在于左操作数对象的原型链上，那么返回true，否则返回false</p>

<h3 id="section-7">逻辑表达式</h3>
<p>逻辑操作符实际上并不总是作用于Boolean类型，它是根据左右操作数是真值还是假值来判定的</p>

<p>假值包括：
- false
- null
- undefined
- 0
- -0
- NaN
- “”</p>

<p>除了假值以外的所有值都是真值</p>

<p>逻辑&amp;&amp;运算符中，如果左操作数是假值，那么不计算右操作数，直接返回左操作数（短路）。如果左操作符是真值，返回右操作数
```javascript
var a,b;
a = null;
b = “something”;
console.log(a &amp;&amp; b);//输出null</p>

<p>a = “something”;
b = null;
console.log(a &amp;&amp; b);//输出null</p>

<p>a = “something”;
b = “otherthing”;
console.log(a &amp;&amp; b);//输出”otherthing”
```</p>

<p>逻辑||运算符也是一样会出现短路，不过短路的条件时左值为真值。所以当左操作数为真值时，不计算右操作数而直接返回左操作数，否则返回右操作数
```javascript
var a,b;
a = “something”;
b = null;
console.log(a || b);//输出”something”</p>

<p>a = null;
b = null;
console.log(a || b);//输出null</p>

<p>a = null;
b = “something”;
console.log(a || b);//输出”something”
```</p>

<p>逻辑非（!）是一元运算符，它会先将操作数转换为布尔值（真值转true，假值转false）：
```javascript
&gt; !””
true</p>

<blockquote>
  <p>!NaN
true</p>
</blockquote>

<blockquote>
  <p>!”a”
false
<code>
一般我们需要将任意类型根据其真假值转换为Boolean时，可以使用如下方式：
</code>javascript
result = !!param;
```</p>
</blockquote>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/30/js-type-convert.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript隐式类型转换 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/30/js-type-convert.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 30 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">对象转原始值</h2>
<p>###对象转布尔
对象转Boolean很简单，所有对象都是true</p>

<p>举个栗子：
```javascript
&gt; !!new Boolean(false)
true</p>

<blockquote>
  <p>if(new Boolean(false)){
    console.log(true);
  } else {
    console.log(false);
  }
true
```</p>
</blockquote>

<h3 id="section-1">对象转字符串</h3>
<p>对象转字符串经过如下步骤：
- 如果对象有toString()方法，则调用toString()。如果toString()返回一个原始值，那么将这个值转为字符串（如果它不是字符串的话），并返回
- 如果对象没有toString()方法，或者调用toString()方法返回的不是一个原始值，那么调用valueOf()方法。 如果valueOf()方法返回的是原始值，那么将它转换为字符串，并返回
- 如果无法从toString()或valueOf()获得一个原始值，那么将抛出一个类型错误异常</p>

<p>来个栗子：
```javascript
function Obj(){}
Obj.prototype.toString = function(){return “callToString”}
Obj.prototype.valueOf = function(){return “callValueOf”}
var data = {
    “callToString” : “callToString”,
    “callValueOf” : “callValueOf”
};</p>

<p>console.log(data[new Obj()]);//输出”callToString”</p>

<p>Obj.prototype.toString = function(){return {};}</p>

<p>console.log(data[new Obj()]);//输出”callValueOf”
```</p>

<h3 id="section-2">对象转数字</h3>
<p>对象转数字经过如下步骤：
- 如果对象有valueOf()方法，后者返回一个原始值，那么将这个原始值转换为数字并返回
- 如果对象没有valueOf()方法，或返的不是一个原始值，尝试toString()方法。如果有toString()方法，且返回一个原始值，那么将其转换成数字并返回
- 如果无法从valueOf()或toString()获得一个原始值，那么将抛出一个类型错误异常</p>

<p>```javascript
function Obj() {}
Obj.prototype.toString = function() {
    return “20”
};</p>

<p>console.log(new Obj() * 1);//输出20</p>

<p>Obj.prototype.valueOf = function() {
    return “10”
};</p>

<p>console.log(new Obj() * 1);//输出10
```
由这个栗子可以看到，转数字时会优先尝试valueOf()方法，然后尝试toString()方法，虽然获得的原始类型都是字符串，但会将字符串转换为数字</p>

<h2 id="section-3">运算符与隐式类型转换</h2>
<p>###“+”运算符
“+”运算符的行为如下：
- 如果其中一个操作数是对象，那么会将对象转换为原始值类型（Date通过toString方法，其他对象依次尝试valueOf和toString()）
- 如果对象转换到原始值后，其中一个是字符串，那么另一个也被转成字符串，进行字符串连接
- 否则两个操作数都将转换为数字（或NaN），然后想加</p>

<p>```javascript
function Obj(){}
Obj.prototype.valueOf = function(){
    return “234”;
};</p>

<p>console.log(123 + new Obj());//输出”123234”</p>

<p>Obj.prototype.valueOf = function(){
    return 234;
};</p>

<p>console.log(123 + new Obj());//输出”357”</p>

<p>Obj.prototype.valueOf = function(){
    return true;
};</p>

<p>console.log(123 + new Obj());//输出”124”</p>

<p>console.log(123 + new Date());//输出”123Sun Mar 30 2014 12:53:02 GMT+0800 (中国标准时间)”
```</p>

<h3 id="section-4">其他算数运算符</h3>
<p>乘法(*)，除法(/)，取模(%)，减法(-)，以及一元算数运算符（+，-，++，–）都是在需要的时候将操作数转化为数字，就是根据上面先尝试valueOf，后尝试toString的方式来转换。如果有一个操作数是NaN，那么运算结果也是NaN</p>

<h3 id="section-5">位运算符</h3>
<p>位运算符需要它的操作数是整数，这些整数表示32位整型而不是64位浮点数，所以在进行位运算之前，首先将操作数转换为数字，然后转换为32位整型，之后进行操作。而NaN，Infinity和-Infinity都转换成0。</p>

<h3 id="section-6">关系表达式</h3>
<p>严格相等（===）不会进行类型转换，而使用相等（==）会进行隐式的类型转换。严格相等会比较类型和值，类型不一致的两个值肯定不相等，具体规则如下：- 两个值类型不同，他们不相等
- 都是null或都是undefined，他们不相等
- 都是布尔true或布尔false，他们相等
- 有一个值是NaN，那么不相等，NaN也不等于自身
- 都位数字时，且他们值相等，那么相等，0与-0相等
- 两个值都为字符串，如果他们长度或内容不同，则不相等
- 两个值都引用对象、数组或函数，如果它们引用同一个对象，他们相等，否则不相等</p>

<p>举一些栗子来验证一下：
```javascript
&gt; ({}) === ({})
false</p>

<blockquote>
  <p>[] === []
false</p>
</blockquote>

<blockquote>
  <p>var a, b;
a = b = {};
a === b
true</p>
</blockquote>

<blockquote>
  <p>NaN === NaN
false</p>
</blockquote>

<blockquote>
  <p>null === undefined
false</p>
</blockquote>

<blockquote>
  <p>0 === -0
true</p>
</blockquote>

<blockquote>
  <p>Infinity === Infinity
true</p>
</blockquote>

<blockquote>
  <p>Infinity === -Infinity
false
```</p>
</blockquote>

<p>相等运算符（==）会进行隐式类型转换，规则如下：
- 如果两个操作数类型相等，则和上面严格相等的比较规则一样
- 如果其中一个值是null，另一个是undefined，他们相等
- 如果一个是数字，另一个是字符串，则会先将字符串转为数字再比较
- 如果其中一个是布尔类型，也会将其转换为数字，然后在比较，true转换为1，false转换为0
- 如果一个值为对象，另一个值为数字或字符串，那么像将其转换为原始值。JavaScript语言核心的内置类会优先尝试valueOf，然后尝试toString。但Date类只是用toString转换
- 其他不同类型之间的比较均不相等</p>

<p>举一些栗子：
```javascript
&gt; null == undefined
true</p>

<blockquote>
  <p>({}) == ({})
false</p>
</blockquote>

<blockquote>
  <p>[] == []
false</p>
</blockquote>

<blockquote>
  <p>“123” == 123
true</p>
</blockquote>

<blockquote>
  <p>true == “1”
true</p>
</blockquote>

<blockquote>
  <p>NaN == NaN
false</p>
</blockquote>

<blockquote>
  <p>function Obj(){}
Obj.prototype.toString = function(){return “tostring”;}
Obj.prototype.valueOf = function(){return “valueof”;}
new Obj() == “valueof”
true</p>
</blockquote>

<blockquote>
  <p>Infinity == Infinity
true</p>
</blockquote>

<blockquote>
  <p>Infinity == -Infinity
false
```
##比较运算符
小于、大于，小于等于、大于等于这些比较运算符的操作数可能是任意类型，但只有数字和字符串才能真正进行比较操作，所以会对其进行转换：
- 如果操作数是对象，那么这个对象会转换为原始值，同样有限使用valueOf，然后使用toString
- 对象转换为原始值后，如果都是字符串，按照字典序比较
- 如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行比较，0与-0相等，Infinity比任何数字都大（除了Infinity本身），-Infinity比任何数字都小，如果其中一个操作数是NaN，比较操作符返回false</p>
</blockquote>

<p>举几个栗子：
```javascript
&gt; NaN &lt; 1
false</p>

<blockquote>
  <p>NaN &gt; 1
false</p>
</blockquote>

<blockquote>
  <p>Infinity &lt; Infinity
fasle</p>
</blockquote>

<blockquote>
  <p>Infinity &gt; Infinity
false</p>
</blockquote>

<blockquote>
  <p>Infinity &gt; -Infinity
true</p>
</blockquote>

<blockquote>
  <p>“a” &lt; “b”
true</p>
</blockquote>

<blockquote>
  <p>“abcd” &lt; “abce”
true
```</p>
</blockquote>

<h3 id="in">in运算符</h3>
<p>in运算符永远期望左操作数是字符串，右操作数是一个对象，所以左操作数会隐式类型转换：
```javascript
function Obj(){}
Obj.prototype.toString = function(){return “callToString”}
Obj.prototype.valueOf = function(){return “callValueOf”}
var data = {
    “callToString” : “callToString”
};</p>

<p>console.log(new Obj() in data);//输出true</p>

<p>Obj.prototype.toString = function(){return {};}</p>

<p>console.log(new Obj() in data);//输出false</p>

<p>data.callValueOf = “callValueOf”;</p>

<p>console.log(new Obj() in data);//输出true
```
第一个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得callToString字符串，而它在data对象中存在，所以输出true</p>

<p>第二个console时，首先将<code>new Obj()</code>创建的对象转换为字符串，先尝试toString方法，获得一个对象，不是原始值，于是尝试valueOf方法，获得callValueOf字符串，而它在data对象中不存在，所以输出false</p>

<p>第三个console和第二个console过程一样，不过这一次data中存在callValueOf字符串，所以输出true</p>

<h3 id="instanceof">instanceof运算符</h3>
<p>instanceof运算符总是希望左操作数是一个对象，右操作数是一个函数。instanceof一次检查左操作数的对象的原型链的VO，如果存在右操作数函数的prototype存在于左操作数对象的原型链上，那么返回true，否则返回false</p>

<h3 id="section-7">逻辑表达式</h3>
<p>逻辑操作符实际上并不总是作用于Boolean类型，它是根据左右操作数是真值还是假值来判定的</p>

<p>假值包括：
- false
- null
- undefined
- 0
- -0
- NaN
- “”</p>

<p>除了假值以外的所有值都是真值</p>

<p>逻辑&amp;&amp;运算符中，如果左操作数是假值，那么不计算右操作数，直接返回左操作数（短路）。如果左操作符是真值，返回右操作数
```javascript
var a,b;
a = null;
b = “something”;
console.log(a &amp;&amp; b);//输出null</p>

<p>a = “something”;
b = null;
console.log(a &amp;&amp; b);//输出null</p>

<p>a = “something”;
b = “otherthing”;
console.log(a &amp;&amp; b);//输出”otherthing”
```</p>

<p>逻辑||运算符也是一样会出现短路，不过短路的条件时左值为真值。所以当左操作数为真值时，不计算右操作数而直接返回左操作数，否则返回右操作数
```javascript
var a,b;
a = “something”;
b = null;
console.log(a || b);//输出”something”</p>

<p>a = null;
b = null;
console.log(a || b);//输出null</p>

<p>a = null;
b = “something”;
console.log(a || b);//输出”something”
```</p>

<p>逻辑非（!）是一元运算符，它会先将操作数转换为布尔值（真值转true，假值转false）：
```javascript
&gt; !””
true</p>

<blockquote>
  <p>!NaN
true</p>
</blockquote>

<blockquote>
  <p>!”a”
false
<code>
一般我们需要将任意类型根据其真假值转换为Boolean时，可以使用如下方式：
</code>javascript
result = !!param;
```</p>
</blockquote>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/30/js-type-convert.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript补充篇） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/28/performance-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h1 id="javascript">JavaScript性能优化补充篇</h1>

<p>来自《高性能JavaScript》</p>

<h2 id="javascript-1">JavaScript文件加载</h2>
<p>管理浏览器中的JavaScript代码是一个棘手的问题，因为代码执行会阻塞浏览器，比如界面绘制。每次遇到<code>&lt;script&gt;</code>标签，浏览器都会停下来等待代码下载并执行，然偶再继续处理其他部分。我们可以通过如下几种方法来减少JavaScript文件对性能的影响</p>

<h3 id="js">将JS文件放在页面底部</h3>
<p>将所有<code>&lt;script&gt;</code>标签放置在页面的底部，紧靠body关闭标签<code>&lt;/body&gt;</code>的上方。这样可以保证页面在脚本运行之前完成解析</p>

<h3 id="js-1">将JS文件打包</h3>
<p>将JS文件打包，页面的<code>&lt;script&gt;</code>标签越少，页面的加载速度越快，响应也越迅速。无论外部脚本文件还是内敛代码都是如此</p>

<h3 id="section">使用非阻塞方式下载</h3>
<ol>
  <li>在<code>&lt;script&gt;</code>标签中添加<code>defer</code>属性</li>
  <li>动态创建<code>&lt;script&gt;</code>元素，用它下载并执行代码</li>
  <li>用XHR对象下载代码，并注入到页面中</li>
</ol>

<h2 id="section-1">数据访问</h2>
<p>###四种访问方式
在JavaScript中，数据存储位置可以对代码整体性能产生重要影响，有四种数据访问类型：直接量，变量，数组项，对象成员，这些访问方式性能不同</p>

<p>直接量和局部变量访问速度很快，而数组项和对象成员需要更长的时间</p>

<h3 id="section-2">作用域链和闭包的访问速度</h3>
<p>在函数内部访问变量时，会顺着作用域链向上查找，直到找到为止，这也意味着作用域链越长，平均的查找时间也就越长。而像with和try-catch会增加作用域链的长度，所以也会降低性能。由此可以得知，访问全局变量很慢，因为他们在作用域链的最后一环</p>

<h3 id="section-3">原型链访问</h3>
<p>访问对象的属性的时候，我们有时候会需要遍历原型链，这也意味着原型链越长，查找元素的平均效率就越低，变量所在的原型在原型链中越深，访问越慢</p>

<h2 id="dom">DOM</h2>
<p>当浏览器下载完所有的HTML、JavaScript、CSS、图片之后，它会解析文件并创建两个内部数据结构：一棵DOM树和一棵渲染树</p>

<p>每个需要被显示的DOM树节点在渲染树中至少有一个节点（隐藏的DOM节点自然在渲染树中没有节点），渲染树上的点被称为框或者盒，根据CSS模型定义，将页面元素看做一个具有填充、边距、边框和位置的盒。一旦DOM树和渲染树构造完毕，浏览器就可以绘制页面上的元素了。</p>

<p>当DOM改变影响到元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性。如果这个元素的改变影响到其他元素，浏览器会使渲染树上收到影响的部分失效，然后重构渲染树。这就是回流（也叫重排版）。重排版完成时，浏览器在一个重绘进程中重新绘制屏幕上受影响的部分</p>

<p>当然并不是所有DOM改变都会影响到几何属性，比如改变背景颜色之类的，这种情况下就只会触发重绘</p>

<p>回流和重绘都是负担很重的操作，会导致浏览器阻塞，所以需要尽可能避免</p>

<h3 id="section-4">何时触发回流</h3>
<ol>
  <li>添加或删除可见的DOM元素</li>
  <li>元素位置的改变</li>
  <li>元素尺寸的改变（border、padding、margin、height、width）</li>
  <li>内容改变</li>
  <li>最初页面渲染</li>
  <li>浏览器窗口改变尺寸</li>
</ol>

<h3 id="section-5">查询并刷新渲染树的改变</h3>
<p>因为计算量与每次回流有关，大多数浏览器会通过一个渲染队列来进行优化。但是用JavaScript获取一些DOM属性时，会（不由自主地）强迫队列中的所有渲染事件前不完成。比如获取如下属性：
* offsetTop, offsetLeft, offsetWidth, offsetHeight
* scrollTop, scrollLeft, scrollWidth, scrollHeight
* clientTop, clientLeft, clientWidth, clientHeight
* getComputedStyle() （在IE中为currentStyle）</p>

<p>为了让这些属性返回正确的值，浏览器不得不运行渲染队列中所有的渲染事件，这样才能保证值的正确。所以尽量减少这些属性的访问</p>

<h2 id="section-6">判断</h2>
<p>###if-else
多个if-else执行的时候，其会顺序检索每一个条件，直到所有条件检索完或检索到匹配的条件。所以我们可以通过树的形式组织if语句，如下面代码：
<code>javascript
if(con === 1) {return result1;}
else if(con === 2) {return result2;}
else if(con === 3) {return result3;}
else if(con === 4) {return result4;}
else if(con === 5) {return result5;}
else if(con === 6) {return result6;}
else if(con === 7) {return result7;}
else if(con === 8) {return result8;}
else if(con === 9) {return result9;}
</code>
这段代码就会依次判断con是否等于1,2,3,4,5,6,7,8,9，如果是9的话，就会判断9次，我们可以将其改为：
<code>javascript
if (con &lt;= 3){
    if(con === 1) {return result1;}
    else if(con === 2) {return result2;}
    else {return result3;}
} else if(con &gt; 3 &amp;&amp; con &lt;= 6){
    if(con === 4) {return result4;}
    else if(con === 5) {return result5;}
    else {return result6;}
} else if(con &lt;= 9){
    if(con === 7) {return result7;}
    else if(con === 8) {return result8;}
    else {return result9;}
}
</code>
这样我们通过三叉树的形式，就可以减少查找次数了，比如这里查找9次，分别判断 0~3,3~6,6~9,7,8,9，只需要6次</p>

<p>if-else除了通过这种树形组织编码以外，还有一个优化的地方。由于其顺序判断的逻辑，我们可以根据概率来，将概率比较大的判断放在前面，概率较小的放在后面，这样也可以减少平均查找长度</p>

<h3 id="switch">switch</h3>
<p>事实证明，大多数情况下switch比if-else更快，但是只有条件题数量很大的时候，才能明显更快。if-else在条件增加时，所带来的性能负担要高于switch，因此建议使用switch。不过switch只是用来判断几个不同的离散值，并没有if-else能判断离散值或值域那样的灵活性</p>

<h3 id="section-7">打表法</h3>
<p>可以使用打表的形式来做，把所有的处理函数放在一个数组中，然后将条件作为键，这种方法比switch和if-else都要快，而且在新增条件时，不会带来额外的性能开销</p>

<h2 id="section-8">递归</h2>
<p>很多算法都是递归实现，由于递归会多次触发函数调用，而函数调用也是需要开销的（比如创建运行期上下文、压运行期栈、创建AO、复制作用域链、销毁AO、弾栈等等），所以尽量将递归转变为循环。而运行期栈在很多浏览器中也有深度限制，当到达运行期栈的最大深度时，浏览器有各自的处理方式，但都是按照错误进行处理</p>

<h2 id="section-9">字符串</h2>
<p>###不同的拼接方法
字符串拼接有很多不同的方法：
1. 使用<code>+</code>直接拼接
2. 使用<code>+=</code>拼接
3. 使用<code>Array.join()</code>拼接
4. 使用<code>String.concat()</code>拼接
###使用加号拼接
使用<code>+</code>和<code>+=</code>时，不同的浏览器会做不同程度的优化，如果在IE7和他之前的浏览器，优化做的不好，比如如下操作：
<code>javascript
str += "one" + "two"
</code>
实际上会执行如下步骤：
1. 内存中创建一个临时变量
2. 将这个临时变量赋值成”onetow”
3. 临时字符串与str拼接
4. 将结果赋予str</p>

<p>而如果改成如下这样：
<code>javascript
str += "one"
str += "two"
</code>
这样就可以避免创建临时字符串，可一定程度加快性能</p>

<p>或者使用如下方式：
<code>javascript
str = str + "one" + "two"
</code></p>

<p>但是如果使用下面这种方式：
<code>javascript
str = "one" + str + "two"
</code>
则无法确定是否有优化。不同的浏览器分配内存方式不一样，IE以外的浏览器，会尝试扩展表达式左端字符串的内存，然后简单的将第二个字符串拷到它的尾部，这样就会创建一个临时字符串存放<code>one{str原本内容}</code>,导致性能降低</p>

<h3 id="section-10">浏览器优化</h3>
<p>很多浏览器会在编译时对连续相加的字符串进行拼接，以此来对运行时优化，比如：
<code>javascript
str += "one" + "two"
</code>
会被优化成
<code>javascript
str += "onetwo"
</code></p>

<h3 id="ie7-">IE7-中的字符串连接</h3>
<p>IE7-中使用<code>+</code>和<code>+=</code>连接很慢，而使用<code>Array.join()</code>方式则快得多，这也是IE7-浏览器中唯一高效的连接大量字符串的途径</p>

<h3 id="stringconcat">String.concat</h3>
<p>这种方法很慢，尽量不要使用</p>

<h2 id="section-11">正则表达式优化</h2>
<p>###正则表达式的工作原理
正则表达式处理经过如下几个步骤：
1. 编译
2. 设置起始位置
3. 匹配每个正则表达式的字元
4. 匹配成功或失败</p>

<p>正则表达式实现中，回溯是基本组成部分。它代价昂贵，且容易失控。回溯是正则表达式性能的唯一因素</p>

<p>正则表达式在匹配时，会在一个有多个分支的地方建立标记点，然后从左到右遍历所有的分支，如果分支符合，就会前进道下一个标记点，如果所有分支都不符合，就会回溯到上一个标记点，尝试上一标记点的其他分支。在尝试上一标记点的其它分支时，这一标记点如果需要，还会全部重新尝试</p>

<h3 id="section-12">回溯失控</h3>
<p>当一个正则表达式占用浏览器上秒，或者更长时间，很有肯那个就是回溯失控了，原因很有可能是出现了<code>.*?</code>这种非贪婪匹配，导致几乎每一个字符都会被作为标记点进行尝试</p>

<p>此类问题的解决办法是尽可能具体地指出分隔符之间的字符匹配形式，或者使用前瞻表达式</p>

<h3 id="section-13">嵌套量词导致性能下降</h3>
<p>嵌套量词可能极大的加大分支的数量，比如一个正则表达式<code>A+A+B</code>显然没有<code>AA+B</code>好，比如匹配<code>AAAAAAAAAAAAAAB</code>时，前者产生的分支要比后者多得多</p>

<h3 id="section-14">一些建议</h3>
<ol>
  <li>关注如何让匹配更快失败：正则表达式慢往往不是因为成功慢，而是失败慢，因为失败会查找所有的情况</li>
  <li>以简单的，必须的字元开始：这样可以加快失败的匹配，如果这个开始字元都不匹配，后面的标记点就不会被匹配了</li>
  <li>编写两次模板，使他们后面的资源互相排斥：当字元与邻近的子表达式能够重叠匹配时，路径将显著正价，所以需要将其具体化</li>
  <li>减少分之数量，缩小它们的范围：直接使用正则表达式中已有的类（如<code>\w</code>,<code>\d</code>）比使用<code>|</code>要快</li>
  <li>使用非捕获分组：捕获分组花费时间和内存用于记录后向引用，而使用后非捕获性分组则避免这种开销</li>
  <li>将正则表达式分层，先捕获感兴趣的文字，然后再使用新的正则表达式处理</li>
  <li>暴露所需的字元，尽量简单地判断出那些必须的字元</li>
  <li>使用适当的量词，贪婪量词和懒惰量词在匹配同样字符串时过程是不同的，在确保正确的前提下，选择回溯次数更少的量词可以提高性能</li>
  <li>将正则表达式赋给变量，以重用他们。正则表达式创建时，需要对他们进行编译，这个编译也会有额外的开销</li>
  <li>将复杂的正则表达式拆分成简单的片段，避免使用一个表达式做太多的工作，可以通过两个或多个正则表达式来解决</li>
</ol>

<h2 id="ui">UI线程相关</h2>
<p>建议的一次JavaScript执行时间不超过100ms（最好在50ms）以内，可以通过setTimeout和setInterval来将任务进行分解，加入到UI线程中。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p>

<h2 id="ajax">AJAX</h2>
<p>AJAX获取数据时，可以使用POST或者GET方法</p>

<p>如果请求不改变服务器状态指示返回数据，应该使用GET。GET请求会被缓存，如果多次提取相同的数据会提高性能</p>

<p>而当URL和请求的参数长度超过2048个字符的时候才使用POST提取数据</p>

<h3 id="xhrmxhr">多部分XHR（MXHR）</h3>
<p>多部分XHR允许使用一个HTTP请求获取多个资源，我们可以将资源打包成一个特定分隔符定界的大字符串，从服务器发送到客户端，JavaScript处理这些大字符串，然后根据它自身的类型和信息解析出每个资源</p>

<p>需要注意的是AJAX不会在浏览器中进行缓存，自然使用MXHR也不会缓存，在一些静态资源上使用这种方式其实并不太好。但是如果每次都确实需要去获取，分多个请求发送会更慢。</p>

<h3 id="img">IMG灯标</h3>
<p>我们可以通过创建一个Image对象，将src设为一个脚本文件的URL，img元素我们并不需要插入到DOM中，这种形式称为IMG灯标</p>

<p>这种方式适用于GET请求，且服务器获得数据后不必返回数据给浏览器的情况</p>

<p>同时我们可以在Image的load事件中监听服务端是否成功接受了数据</p>

<h3 id="section-15">数据格式</h3>
<ul>
  <li>XML：支持广泛但解析效率低，而且相当冗长</li>
  <li>JSON： 小巧，轻便，解析速度较快</li>
  <li>JSONP：使用JavaScript解释器进行解析，解析速度极快，数据量只比JSON多一点点（函数名称和括号）</li>
  <li>HTML：无需解析，数据冗长</li>
  <li>自定义格式：自己解析，慢而易出错，数据长度可以很短</li>
</ul>

<h2 id="section-16">其他</h2>
<ul>
  <li>不要使用eval以及其类似</li>
  <li>使用字面量</li>
  <li>避免重复工作，检测浏览器时，保存首次检测结果即可</li>
  <li>考虑位操作</li>
  <li>使用原声方法，因为他们是C++写的</li>
  <li>文件预处理，压缩（gzip）、合并、uglify</li>
  <li>尝试CDN</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/28/performance-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript补充篇） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/28/performance-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h1 id="javascript">JavaScript性能优化补充篇</h1>

<p>来自《高性能JavaScript》</p>

<h2 id="javascript-1">JavaScript文件加载</h2>
<p>管理浏览器中的JavaScript代码是一个棘手的问题，因为代码执行会阻塞浏览器，比如界面绘制。每次遇到<code>&lt;script&gt;</code>标签，浏览器都会停下来等待代码下载并执行，然偶再继续处理其他部分。我们可以通过如下几种方法来减少JavaScript文件对性能的影响</p>

<h3 id="js">将JS文件放在页面底部</h3>
<p>将所有<code>&lt;script&gt;</code>标签放置在页面的底部，紧靠body关闭标签<code>&lt;/body&gt;</code>的上方。这样可以保证页面在脚本运行之前完成解析</p>

<h3 id="js-1">将JS文件打包</h3>
<p>将JS文件打包，页面的<code>&lt;script&gt;</code>标签越少，页面的加载速度越快，响应也越迅速。无论外部脚本文件还是内敛代码都是如此</p>

<h3 id="section">使用非阻塞方式下载</h3>
<ol>
  <li>在<code>&lt;script&gt;</code>标签中添加<code>defer</code>属性</li>
  <li>动态创建<code>&lt;script&gt;</code>元素，用它下载并执行代码</li>
  <li>用XHR对象下载代码，并注入到页面中</li>
</ol>

<h2 id="section-1">数据访问</h2>
<p>###四种访问方式
在JavaScript中，数据存储位置可以对代码整体性能产生重要影响，有四种数据访问类型：直接量，变量，数组项，对象成员，这些访问方式性能不同</p>

<p>直接量和局部变量访问速度很快，而数组项和对象成员需要更长的时间</p>

<h3 id="section-2">作用域链和闭包的访问速度</h3>
<p>在函数内部访问变量时，会顺着作用域链向上查找，直到找到为止，这也意味着作用域链越长，平均的查找时间也就越长。而像with和try-catch会增加作用域链的长度，所以也会降低性能。由此可以得知，访问全局变量很慢，因为他们在作用域链的最后一环</p>

<h3 id="section-3">原型链访问</h3>
<p>访问对象的属性的时候，我们有时候会需要遍历原型链，这也意味着原型链越长，查找元素的平均效率就越低，变量所在的原型在原型链中越深，访问越慢</p>

<h2 id="dom">DOM</h2>
<p>当浏览器下载完所有的HTML、JavaScript、CSS、图片之后，它会解析文件并创建两个内部数据结构：一棵DOM树和一棵渲染树</p>

<p>每个需要被显示的DOM树节点在渲染树中至少有一个节点（隐藏的DOM节点自然在渲染树中没有节点），渲染树上的点被称为框或者盒，根据CSS模型定义，将页面元素看做一个具有填充、边距、边框和位置的盒。一旦DOM树和渲染树构造完毕，浏览器就可以绘制页面上的元素了。</p>

<p>当DOM改变影响到元素的几何属性（宽和高），浏览器就需要重新计算元素的几何属性。如果这个元素的改变影响到其他元素，浏览器会使渲染树上收到影响的部分失效，然后重构渲染树。这就是回流（也叫重排版）。重排版完成时，浏览器在一个重绘进程中重新绘制屏幕上受影响的部分</p>

<p>当然并不是所有DOM改变都会影响到几何属性，比如改变背景颜色之类的，这种情况下就只会触发重绘</p>

<p>回流和重绘都是负担很重的操作，会导致浏览器阻塞，所以需要尽可能避免</p>

<h3 id="section-4">何时触发回流</h3>
<ol>
  <li>添加或删除可见的DOM元素</li>
  <li>元素位置的改变</li>
  <li>元素尺寸的改变（border、padding、margin、height、width）</li>
  <li>内容改变</li>
  <li>最初页面渲染</li>
  <li>浏览器窗口改变尺寸</li>
</ol>

<h3 id="section-5">查询并刷新渲染树的改变</h3>
<p>因为计算量与每次回流有关，大多数浏览器会通过一个渲染队列来进行优化。但是用JavaScript获取一些DOM属性时，会（不由自主地）强迫队列中的所有渲染事件前不完成。比如获取如下属性：
* offsetTop, offsetLeft, offsetWidth, offsetHeight
* scrollTop, scrollLeft, scrollWidth, scrollHeight
* clientTop, clientLeft, clientWidth, clientHeight
* getComputedStyle() （在IE中为currentStyle）</p>

<p>为了让这些属性返回正确的值，浏览器不得不运行渲染队列中所有的渲染事件，这样才能保证值的正确。所以尽量减少这些属性的访问</p>

<h2 id="section-6">判断</h2>
<p>###if-else
多个if-else执行的时候，其会顺序检索每一个条件，直到所有条件检索完或检索到匹配的条件。所以我们可以通过树的形式组织if语句，如下面代码：
<code>javascript
if(con === 1) {return result1;}
else if(con === 2) {return result2;}
else if(con === 3) {return result3;}
else if(con === 4) {return result4;}
else if(con === 5) {return result5;}
else if(con === 6) {return result6;}
else if(con === 7) {return result7;}
else if(con === 8) {return result8;}
else if(con === 9) {return result9;}
</code>
这段代码就会依次判断con是否等于1,2,3,4,5,6,7,8,9，如果是9的话，就会判断9次，我们可以将其改为：
<code>javascript
if (con &lt;= 3){
    if(con === 1) {return result1;}
    else if(con === 2) {return result2;}
    else {return result3;}
} else if(con &gt; 3 &amp;&amp; con &lt;= 6){
    if(con === 4) {return result4;}
    else if(con === 5) {return result5;}
    else {return result6;}
} else if(con &lt;= 9){
    if(con === 7) {return result7;}
    else if(con === 8) {return result8;}
    else {return result9;}
}
</code>
这样我们通过三叉树的形式，就可以减少查找次数了，比如这里查找9次，分别判断 0~3,3~6,6~9,7,8,9，只需要6次</p>

<p>if-else除了通过这种树形组织编码以外，还有一个优化的地方。由于其顺序判断的逻辑，我们可以根据概率来，将概率比较大的判断放在前面，概率较小的放在后面，这样也可以减少平均查找长度</p>

<h3 id="switch">switch</h3>
<p>事实证明，大多数情况下switch比if-else更快，但是只有条件题数量很大的时候，才能明显更快。if-else在条件增加时，所带来的性能负担要高于switch，因此建议使用switch。不过switch只是用来判断几个不同的离散值，并没有if-else能判断离散值或值域那样的灵活性</p>

<h3 id="section-7">打表法</h3>
<p>可以使用打表的形式来做，把所有的处理函数放在一个数组中，然后将条件作为键，这种方法比switch和if-else都要快，而且在新增条件时，不会带来额外的性能开销</p>

<h2 id="section-8">递归</h2>
<p>很多算法都是递归实现，由于递归会多次触发函数调用，而函数调用也是需要开销的（比如创建运行期上下文、压运行期栈、创建AO、复制作用域链、销毁AO、弾栈等等），所以尽量将递归转变为循环。而运行期栈在很多浏览器中也有深度限制，当到达运行期栈的最大深度时，浏览器有各自的处理方式，但都是按照错误进行处理</p>

<h2 id="section-9">字符串</h2>
<p>###不同的拼接方法
字符串拼接有很多不同的方法：
1. 使用<code>+</code>直接拼接
2. 使用<code>+=</code>拼接
3. 使用<code>Array.join()</code>拼接
4. 使用<code>String.concat()</code>拼接
###使用加号拼接
使用<code>+</code>和<code>+=</code>时，不同的浏览器会做不同程度的优化，如果在IE7和他之前的浏览器，优化做的不好，比如如下操作：
<code>javascript
str += "one" + "two"
</code>
实际上会执行如下步骤：
1. 内存中创建一个临时变量
2. 将这个临时变量赋值成”onetow”
3. 临时字符串与str拼接
4. 将结果赋予str</p>

<p>而如果改成如下这样：
<code>javascript
str += "one"
str += "two"
</code>
这样就可以避免创建临时字符串，可一定程度加快性能</p>

<p>或者使用如下方式：
<code>javascript
str = str + "one" + "two"
</code></p>

<p>但是如果使用下面这种方式：
<code>javascript
str = "one" + str + "two"
</code>
则无法确定是否有优化。不同的浏览器分配内存方式不一样，IE以外的浏览器，会尝试扩展表达式左端字符串的内存，然后简单的将第二个字符串拷到它的尾部，这样就会创建一个临时字符串存放<code>one{str原本内容}</code>,导致性能降低</p>

<h3 id="section-10">浏览器优化</h3>
<p>很多浏览器会在编译时对连续相加的字符串进行拼接，以此来对运行时优化，比如：
<code>javascript
str += "one" + "two"
</code>
会被优化成
<code>javascript
str += "onetwo"
</code></p>

<h3 id="ie7-">IE7-中的字符串连接</h3>
<p>IE7-中使用<code>+</code>和<code>+=</code>连接很慢，而使用<code>Array.join()</code>方式则快得多，这也是IE7-浏览器中唯一高效的连接大量字符串的途径</p>

<h3 id="stringconcat">String.concat</h3>
<p>这种方法很慢，尽量不要使用</p>

<h2 id="section-11">正则表达式优化</h2>
<p>###正则表达式的工作原理
正则表达式处理经过如下几个步骤：
1. 编译
2. 设置起始位置
3. 匹配每个正则表达式的字元
4. 匹配成功或失败</p>

<p>正则表达式实现中，回溯是基本组成部分。它代价昂贵，且容易失控。回溯是正则表达式性能的唯一因素</p>

<p>正则表达式在匹配时，会在一个有多个分支的地方建立标记点，然后从左到右遍历所有的分支，如果分支符合，就会前进道下一个标记点，如果所有分支都不符合，就会回溯到上一个标记点，尝试上一标记点的其他分支。在尝试上一标记点的其它分支时，这一标记点如果需要，还会全部重新尝试</p>

<h3 id="section-12">回溯失控</h3>
<p>当一个正则表达式占用浏览器上秒，或者更长时间，很有肯那个就是回溯失控了，原因很有可能是出现了<code>.*?</code>这种非贪婪匹配，导致几乎每一个字符都会被作为标记点进行尝试</p>

<p>此类问题的解决办法是尽可能具体地指出分隔符之间的字符匹配形式，或者使用前瞻表达式</p>

<h3 id="section-13">嵌套量词导致性能下降</h3>
<p>嵌套量词可能极大的加大分支的数量，比如一个正则表达式<code>A+A+B</code>显然没有<code>AA+B</code>好，比如匹配<code>AAAAAAAAAAAAAAB</code>时，前者产生的分支要比后者多得多</p>

<h3 id="section-14">一些建议</h3>
<ol>
  <li>关注如何让匹配更快失败：正则表达式慢往往不是因为成功慢，而是失败慢，因为失败会查找所有的情况</li>
  <li>以简单的，必须的字元开始：这样可以加快失败的匹配，如果这个开始字元都不匹配，后面的标记点就不会被匹配了</li>
  <li>编写两次模板，使他们后面的资源互相排斥：当字元与邻近的子表达式能够重叠匹配时，路径将显著正价，所以需要将其具体化</li>
  <li>减少分之数量，缩小它们的范围：直接使用正则表达式中已有的类（如<code>\w</code>,<code>\d</code>）比使用<code>|</code>要快</li>
  <li>使用非捕获分组：捕获分组花费时间和内存用于记录后向引用，而使用后非捕获性分组则避免这种开销</li>
  <li>将正则表达式分层，先捕获感兴趣的文字，然后再使用新的正则表达式处理</li>
  <li>暴露所需的字元，尽量简单地判断出那些必须的字元</li>
  <li>使用适当的量词，贪婪量词和懒惰量词在匹配同样字符串时过程是不同的，在确保正确的前提下，选择回溯次数更少的量词可以提高性能</li>
  <li>将正则表达式赋给变量，以重用他们。正则表达式创建时，需要对他们进行编译，这个编译也会有额外的开销</li>
  <li>将复杂的正则表达式拆分成简单的片段，避免使用一个表达式做太多的工作，可以通过两个或多个正则表达式来解决</li>
</ol>

<h2 id="ui">UI线程相关</h2>
<p>建议的一次JavaScript执行时间不超过100ms（最好在50ms）以内，可以通过setTimeout和setInterval来将任务进行分解，加入到UI线程中。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p>

<h2 id="ajax">AJAX</h2>
<p>AJAX获取数据时，可以使用POST或者GET方法</p>

<p>如果请求不改变服务器状态指示返回数据，应该使用GET。GET请求会被缓存，如果多次提取相同的数据会提高性能</p>

<p>而当URL和请求的参数长度超过2048个字符的时候才使用POST提取数据</p>

<h3 id="xhrmxhr">多部分XHR（MXHR）</h3>
<p>多部分XHR允许使用一个HTTP请求获取多个资源，我们可以将资源打包成一个特定分隔符定界的大字符串，从服务器发送到客户端，JavaScript处理这些大字符串，然后根据它自身的类型和信息解析出每个资源</p>

<p>需要注意的是AJAX不会在浏览器中进行缓存，自然使用MXHR也不会缓存，在一些静态资源上使用这种方式其实并不太好。但是如果每次都确实需要去获取，分多个请求发送会更慢。</p>

<h3 id="img">IMG灯标</h3>
<p>我们可以通过创建一个Image对象，将src设为一个脚本文件的URL，img元素我们并不需要插入到DOM中，这种形式称为IMG灯标</p>

<p>这种方式适用于GET请求，且服务器获得数据后不必返回数据给浏览器的情况</p>

<p>同时我们可以在Image的load事件中监听服务端是否成功接受了数据</p>

<h3 id="section-15">数据格式</h3>
<ul>
  <li>XML：支持广泛但解析效率低，而且相当冗长</li>
  <li>JSON： 小巧，轻便，解析速度较快</li>
  <li>JSONP：使用JavaScript解释器进行解析，解析速度极快，数据量只比JSON多一点点（函数名称和括号）</li>
  <li>HTML：无需解析，数据冗长</li>
  <li>自定义格式：自己解析，慢而易出错，数据长度可以很短</li>
</ul>

<h2 id="section-16">其他</h2>
<ul>
  <li>不要使用eval以及其类似</li>
  <li>使用字面量</li>
  <li>避免重复工作，检测浏览器时，保存首次检测结果即可</li>
  <li>考虑位操作</li>
  <li>使用原声方法，因为他们是C++写的</li>
  <li>文件预处理，压缩（gzip）、合并、uglify</li>
  <li>尝试CDN</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/28/performance-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript一些基础知识简介 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/28/js-basis.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">作用域链基础知识</h2>
<p>###作用域链
每一个JavaScript函数都会被表示为一个函数对象，它和其他对象一样，拥有自己的属性，其中有一些是JavaScript引擎所使用的内部属性，不允许外部访问，<code>[[scope]]</code>就是其中一个</p>

<h3 id="scope">scope属性</h3>
<p>内部<code>[[scope]]</code>属性包含一个函数被创建的作用域对象的集合，被称为作用域链。它决定函数可以访问哪些属性。作用域链中的每个对象都被称为一个VO（Variable Object），每个VO都以“键值对”的形式存在。当一个函数创建以后，它的作用域链就会被填充，这些对象代表创建此函数的环境中可访问的数据。</p>

<h3 id="section-1">创建运行期上下文</h3>
<p>在函数运行时，会创建一个内部对象，称为运行期上下文（Execution Context，也叫EC），这个运行期上下文在创建后回访制在“运行期栈”中，和其他语言的函数调用的栈类似。一个运行期上下文定义了一个函数运行时的环境。函数的每次运行都会创建一个运行期上下文，每次创建的运行期上下文相互独立。当函数执行完毕时，运行期上下文就会被销毁</p>

<h3 id="section-2">复制作用域链</h3>
<p>一个运行期上下文有自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，并将所运行函数的<code>[[scope]]</code>中的VO对象按照顺序复制到运行期上下文自己的作用域链中</p>

<h3 id="ao">AO对象的创建</h3>
<p>在复制完函数的作用域链之后，就会创建一个被称为AO（Activation Object）的对象，这个对象包含了以下内容：
1. this
2. 局部变量
3. 命名参数
4. arguments集合</p>

<p>创建完成AO对象后，它江北推入作用域链的最前端。作用域链被销毁时，AO也会一并销毁</p>

<h3 id="section-3">标示符解析</h3>
<p>函数运行过程中，每遇到一个变量，标识符都需要决定需要从哪里获得数据。这个搜索过程会顺着运行期上下文的作用域链来查找。大致上流程如下：
1. 索引一个AO或VO
2. 查找其中的局部变量
3. 查找其中的命名参数
4. 如果没找到，查找下一个AO或VO，如果有则转到1，否则转到5
5. 输出标识符未定义</p>

<h3 id="withtry-catch">with和try-catch改变作用域链</h3>
<p>一般来说，运行期上下文的作用域链是不会被改变的。但是使用<code>with</code>和<code>try-catch</code>可以对作用域链进行临时改变。</p>

<p>with所做的就是在作用域链前端再插入一个VO，with所指定的对象的所有属性，都会被插入到这个VO中。由此，访问with所指定的对象的属性速度将会加快，但由于增长了作用域链的长度，访问其他属性将会减慢。所以使用with不如直接使用一个变量来暂存with所指定的对象</p>

<p>try-catch中的catch块也有相同的效果，在catch块中，会将异常对象构造成一个VO，插入到运行时上下文的作用域链的最前端。同样会加长作用域链，导致性能下降。解决办法就是在catch块中调用一个处理函数，所有的逻辑放在处理函数之中。</p>

<h2 id="section-4">闭包</h2>
<p>闭包的强大在于它允许函数访问局部范围之外的数据。当一个函数被执行时，会创建一个AO，而如果在函数执行时创建了闭包，当前运行期上下文的作用域链将复制到闭包的作用域链中</p>

<p>由于闭包的作用域链与运行期上下文作用域链中的引用相同，这也就是说在函数的AO与运行期上下文一同销毁时，由于闭包的存在，AO中的对象依旧早闭包的作用域链中被引用，导致JavaScript的垃圾回收器认为AO中的对象已然是活对象，而不会对其进行垃圾回收。所以闭包将会导致更多的内存开销</p>

<h2 id="section-5">原型链</h2>
<p>###原型
我们都知道JavaScript是基于对象的语言，原型是对象的基础。一个对象通过内部属性绑定到它的原型，在一些浏览器如FF，Safari，Chrome中可以使用<code>__proto__</code>来访问对象的原型。当创建一个内置类型的实例时，这些实例自动拥有一个Object作为它们的原型</p>

<h3 id="section-6">创建对象</h3>
<p>在对象被创建时，对象的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>属性，而如果一个函数没有指定prototype属性，那么这个属性将默认为一个空的<code>Object</code>，而<code>Object.prototype.__proto__</code>为<code>null</code></p>

<p>比如如下情况：
<code>javascript
&gt; function A(){}
&gt; new A().__proto__ === A.prototype
true
&gt; A.prototype.__proto__
Object {}
&gt; A.prototype.__proto__.__proto__
null
</code></p>

<h3 id="section-7">原型链</h3>
<p>由此，我们可以将一个构造好的对象传递给另一个需要构造的对象的构造函数的<code>prototype</code>属性，这样新构造函数所构造的对象的<code>__proto__</code>自然就指向之前构造好的对象了。这就是原型链</p>

<p>当查找一个对象的属性的时候，如果遍历对象当前的所有属性，如果不存在，就会顺着原型链一层一层遍历原型链上的对象，直到查找成功</p>

<p>比如如下实例：
<code>javascript
&gt; function A(){this.a = "In A"}
&gt; A.prototype = {ap : "In A.prototype"};
&gt; function B(){this.b = "In B"}
&gt; B.prototype = new A()
&gt; var b = new B()
&gt; console.log(b.a)
"In A"
&gt; console.log(b.ap)
"In A.prototype"
&gt; console.log(b.b)
"In B"
</code>
这里由于将A的实例复制给了B构造函数的<code>prototype</code>属性，所以B的实例的<code>__proto__</code>就指向这个A的实例</p>

<p>在查找a属性的时候，首先在这个B的实例中查找，发现没有，顺着原型链到达A实例，发现了这个属性，输出，所以为<code>"In A"</code></p>

<p>在查找ap属性的时候，首先在B的实例中查找，发现没有，顺着原型链到达A实例，发现没有，顺着原型链达到A.prototype的对象，发现属性，所以输出<code>"In A.prototype"</code></p>

<p>在查找b属性的时候，在B的实例中查找，找到了，所以直接输出<code>"In B"</code></p>

<h3 id="section-8">基于原型的继承</h3>
<p>上面可以看到，其实就是一种继承的方式。JavaScript中的继承就是使用这种原型继承方式来实现的。上例中B继承了A，一般情况下我们希望使用<code>instanceof</code>来确定对象是哪种对象。比如使用<code>instanceof</code>检测B的实例时，无论是检测B还是A还是Object，都应该返回true</p>

<p><code>object instanceof constructor</code>的实际行为是检测<code>constructor.prototype</code>是否存在于<code>object</code>的原型链上</p>

<p><code>javascript
&gt; function A(){};
&gt; function B(){};
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b instanceof A
true
&gt; b instanceof B
true
&gt; b instanceof Object
true
</code></p>

<h3 id="constructor">constructor属性</h3>
<p>上例可以看到使用<code>instanceof</code>属性可以进行检测，而对象中还有一个constructor属性，指向其构造函数</p>

<p><code>javascript
&gt; function A (){}
&gt; new A().__proto__.constructor === A
true
</code></p>

<p>constructor这个属性是在创建构造函数时赋值到构造函数的prototype属性中的。而这时，这个constructor指向这个构造函数本身</p>

<p><code>javascript
&gt; function A(){}
&gt; A === A.prototype.constructor
true
</code></p>

<p>而上面我们说了，在使用构造函数创建实例的时候，会将构造函数的<code>prototype</code>属性传递给实例的<code>__proto__</code>属性，所以实例的constructor属性就能指向自己的构造函数了</p>

<p>然而，当我们使用了如上面A和B的继承方式时，就变化了：
<code>javascript
&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b.constructor
function A(){}
</code>
输出的是构造函数A而不是构造函数B</p>

<p>这是因为B的prototype属性已经被覆盖成<code>new A()</code>所创建的A的实例，A的实例中，constructor属性指向的自然是A构造函数。具体的索引过程如下：
1. 查找b对象的constructor属性，没找到
2. 查找<code>b.__proto__</code>对象，也就是<code>new A()</code>所创建的A实例，没有找到
3. 查找A实例的<code>__proto__</code>对象，也就是<code>A.prototype</code>，找到了constructor属性，返回</p>

<p>如果这样继承，就容易出现错误，所以我们需要手动将B构造函数赋值给它自己的<code>prototype</code>属性，将上面的继承改成如下这样：
<code>javascript
&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; B.prototype.constructor = B;
&gt; var b = new B();
&gt; b.constructor
function B(){}
</code></p>

<p>这样就是我们想要的结果了</p>

<h3 id="section-9">一些其他的乱七八糟</h3>
<p>JavaScript除了该死的constructor以外，还有一些坑，比如Array.prototype其实是个数组实例：
<code>javascript
&gt; Array.prototype
[]
</code></p>

<h2 id="ui">UI线程</h2>
<p>###基础概念
大多数浏览器只有一个单独的处理线程，它由两个任务共享：JavaScript任务和用户界面更新任务，每个时刻只有一个操作得以执行。当JavaScript代码执行时，用户界面就会被“锁定”，反过来也是一样。他们所共享的这个线程就被称为UI线程</p>

<p>比如一次按钮点击，会依次将按钮样式改变、按钮点击时需要运行的JavaScript代码、代码中的UI改变依次加入到UI线程中</p>

<h3 id="section-10">浏览器的限制</h3>
<p>浏览器除了会限制运行期栈的深度以外，还会限制长时间执行脚本。不同的浏览器判断脚本执行时间过长的方法不一样，有的是通过时间来判断，有的是通过运行语句的条数判断</p>

<h3 id="section-11">应当运行多久</h3>
<p>一个单一的JavaScript操作所使用的最大时间应该是100ms，如果用户100ms之内无法收到接口呃响应，用户就会认为自己与接口断开了</p>

<h3 id="section-12">定时相关</h3>
<p>JavaScript中有两种定时器，<code>setTimeout</code>和<code>setInterval</code>，使用它们能将较长的任务分解成较短的任务</p>

<p>使用定时器时，比如如下代码：
<code>javascript
setTimeout(function(){
    //do something
}, 250);
</code>
在这句<code>setTimeout</code>指令执行后的250ms（不一定精确），将函数加入到UI线程中。需要注意的是，这里不是立刻加入UI线程中，而是到了时间才加入。</p>

<blockquote>
  <p>另外我曾看过一篇文章，讲述的是setTimeout和setInterval执行后，会将其内设定到时需要执行的代码放入一个红黑树中，而每次执行时会从红黑树中挑选出当前最先需要执行的代码，放入UI线程中，同时维护红黑树。这个概念不太明确，有待考证</p>
</blockquote>

<p>这样我们可以看到，只有当前任务执行完之后，才有可能去执行UI队列中的其他任务，所以如下代码：
<code>javascript
console.log(1);
setTimeout(function() {
    console.log(2);
}, 0);
console.log(3);
</code>
输出的结果实际上是132</p>

<h3 id="section-13">定时器的精度问题</h3>
<p>JavaScript的定时器往往不太准确（当然requestAnimationFrame要精确得多），快慢大约几毫秒。而此外最小定时器延时的设定也会影响运行，在IE中建议的最小值为25ms</p>

<h3 id="section-14">定时器分解任务</h3>
<p>我们可以将任务分解成一系列子任务，然后将其分别通过定时器加入到UI线程中，以此来保证每个子任务运行时间不超过100ms（最好是不超过50ms），让UI更新和响应任务也能够及时处理。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/28/js-basis.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript一些基础知识简介 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/28/js-basis.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">作用域链基础知识</h2>
<p>###作用域链
每一个JavaScript函数都会被表示为一个函数对象，它和其他对象一样，拥有自己的属性，其中有一些是JavaScript引擎所使用的内部属性，不允许外部访问，<code>[[scope]]</code>就是其中一个</p>

<h3 id="scope">scope属性</h3>
<p>内部<code>[[scope]]</code>属性包含一个函数被创建的作用域对象的集合，被称为作用域链。它决定函数可以访问哪些属性。作用域链中的每个对象都被称为一个VO（Variable Object），每个VO都以“键值对”的形式存在。当一个函数创建以后，它的作用域链就会被填充，这些对象代表创建此函数的环境中可访问的数据。</p>

<h3 id="section-1">创建运行期上下文</h3>
<p>在函数运行时，会创建一个内部对象，称为运行期上下文（Execution Context，也叫EC），这个运行期上下文在创建后回访制在“运行期栈”中，和其他语言的函数调用的栈类似。一个运行期上下文定义了一个函数运行时的环境。函数的每次运行都会创建一个运行期上下文，每次创建的运行期上下文相互独立。当函数执行完毕时，运行期上下文就会被销毁</p>

<h3 id="section-2">复制作用域链</h3>
<p>一个运行期上下文有自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，并将所运行函数的<code>[[scope]]</code>中的VO对象按照顺序复制到运行期上下文自己的作用域链中</p>

<h3 id="ao">AO对象的创建</h3>
<p>在复制完函数的作用域链之后，就会创建一个被称为AO（Activation Object）的对象，这个对象包含了以下内容：
1. this
2. 局部变量
3. 命名参数
4. arguments集合</p>

<p>创建完成AO对象后，它江北推入作用域链的最前端。作用域链被销毁时，AO也会一并销毁</p>

<h3 id="section-3">标示符解析</h3>
<p>函数运行过程中，每遇到一个变量，标识符都需要决定需要从哪里获得数据。这个搜索过程会顺着运行期上下文的作用域链来查找。大致上流程如下：
1. 索引一个AO或VO
2. 查找其中的局部变量
3. 查找其中的命名参数
4. 如果没找到，查找下一个AO或VO，如果有则转到1，否则转到5
5. 输出标识符未定义</p>

<h3 id="withtry-catch">with和try-catch改变作用域链</h3>
<p>一般来说，运行期上下文的作用域链是不会被改变的。但是使用<code>with</code>和<code>try-catch</code>可以对作用域链进行临时改变。</p>

<p>with所做的就是在作用域链前端再插入一个VO，with所指定的对象的所有属性，都会被插入到这个VO中。由此，访问with所指定的对象的属性速度将会加快，但由于增长了作用域链的长度，访问其他属性将会减慢。所以使用with不如直接使用一个变量来暂存with所指定的对象</p>

<p>try-catch中的catch块也有相同的效果，在catch块中，会将异常对象构造成一个VO，插入到运行时上下文的作用域链的最前端。同样会加长作用域链，导致性能下降。解决办法就是在catch块中调用一个处理函数，所有的逻辑放在处理函数之中。</p>

<h2 id="section-4">闭包</h2>
<p>闭包的强大在于它允许函数访问局部范围之外的数据。当一个函数被执行时，会创建一个AO，而如果在函数执行时创建了闭包，当前运行期上下文的作用域链将复制到闭包的作用域链中</p>

<p>由于闭包的作用域链与运行期上下文作用域链中的引用相同，这也就是说在函数的AO与运行期上下文一同销毁时，由于闭包的存在，AO中的对象依旧早闭包的作用域链中被引用，导致JavaScript的垃圾回收器认为AO中的对象已然是活对象，而不会对其进行垃圾回收。所以闭包将会导致更多的内存开销</p>

<h2 id="section-5">原型链</h2>
<p>###原型
我们都知道JavaScript是基于对象的语言，原型是对象的基础。一个对象通过内部属性绑定到它的原型，在一些浏览器如FF，Safari，Chrome中可以使用<code>__proto__</code>来访问对象的原型。当创建一个内置类型的实例时，这些实例自动拥有一个Object作为它们的原型</p>

<h3 id="section-6">创建对象</h3>
<p>在对象被创建时，对象的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>属性，而如果一个函数没有指定prototype属性，那么这个属性将默认为一个空的<code>Object</code>，而<code>Object.prototype.__proto__</code>为<code>null</code></p>

<p>比如如下情况：
<code>javascript
&gt; function A(){}
&gt; new A().__proto__ === A.prototype
true
&gt; A.prototype.__proto__
Object {}
&gt; A.prototype.__proto__.__proto__
null
</code></p>

<h3 id="section-7">原型链</h3>
<p>由此，我们可以将一个构造好的对象传递给另一个需要构造的对象的构造函数的<code>prototype</code>属性，这样新构造函数所构造的对象的<code>__proto__</code>自然就指向之前构造好的对象了。这就是原型链</p>

<p>当查找一个对象的属性的时候，如果遍历对象当前的所有属性，如果不存在，就会顺着原型链一层一层遍历原型链上的对象，直到查找成功</p>

<p>比如如下实例：
<code>javascript
&gt; function A(){this.a = "In A"}
&gt; A.prototype = {ap : "In A.prototype"};
&gt; function B(){this.b = "In B"}
&gt; B.prototype = new A()
&gt; var b = new B()
&gt; console.log(b.a)
"In A"
&gt; console.log(b.ap)
"In A.prototype"
&gt; console.log(b.b)
"In B"
</code>
这里由于将A的实例复制给了B构造函数的<code>prototype</code>属性，所以B的实例的<code>__proto__</code>就指向这个A的实例</p>

<p>在查找a属性的时候，首先在这个B的实例中查找，发现没有，顺着原型链到达A实例，发现了这个属性，输出，所以为<code>"In A"</code></p>

<p>在查找ap属性的时候，首先在B的实例中查找，发现没有，顺着原型链到达A实例，发现没有，顺着原型链达到A.prototype的对象，发现属性，所以输出<code>"In A.prototype"</code></p>

<p>在查找b属性的时候，在B的实例中查找，找到了，所以直接输出<code>"In B"</code></p>

<h3 id="section-8">基于原型的继承</h3>
<p>上面可以看到，其实就是一种继承的方式。JavaScript中的继承就是使用这种原型继承方式来实现的。上例中B继承了A，一般情况下我们希望使用<code>instanceof</code>来确定对象是哪种对象。比如使用<code>instanceof</code>检测B的实例时，无论是检测B还是A还是Object，都应该返回true</p>

<p><code>object instanceof constructor</code>的实际行为是检测<code>constructor.prototype</code>是否存在于<code>object</code>的原型链上</p>

<p><code>javascript
&gt; function A(){};
&gt; function B(){};
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b instanceof A
true
&gt; b instanceof B
true
&gt; b instanceof Object
true
</code></p>

<h3 id="constructor">constructor属性</h3>
<p>上例可以看到使用<code>instanceof</code>属性可以进行检测，而对象中还有一个constructor属性，指向其构造函数</p>

<p><code>javascript
&gt; function A (){}
&gt; new A().__proto__.constructor === A
true
</code></p>

<p>constructor这个属性是在创建构造函数时赋值到构造函数的prototype属性中的。而这时，这个constructor指向这个构造函数本身</p>

<p><code>javascript
&gt; function A(){}
&gt; A === A.prototype.constructor
true
</code></p>

<p>而上面我们说了，在使用构造函数创建实例的时候，会将构造函数的<code>prototype</code>属性传递给实例的<code>__proto__</code>属性，所以实例的constructor属性就能指向自己的构造函数了</p>

<p>然而，当我们使用了如上面A和B的继承方式时，就变化了：
<code>javascript
&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; var b = new B();
&gt; b.constructor
function A(){}
</code>
输出的是构造函数A而不是构造函数B</p>

<p>这是因为B的prototype属性已经被覆盖成<code>new A()</code>所创建的A的实例，A的实例中，constructor属性指向的自然是A构造函数。具体的索引过程如下：
1. 查找b对象的constructor属性，没找到
2. 查找<code>b.__proto__</code>对象，也就是<code>new A()</code>所创建的A实例，没有找到
3. 查找A实例的<code>__proto__</code>对象，也就是<code>A.prototype</code>，找到了constructor属性，返回</p>

<p>如果这样继承，就容易出现错误，所以我们需要手动将B构造函数赋值给它自己的<code>prototype</code>属性，将上面的继承改成如下这样：
<code>javascript
&gt; function A(){}
&gt; function B(){}
&gt; B.prototype = new A();
&gt; B.prototype.constructor = B;
&gt; var b = new B();
&gt; b.constructor
function B(){}
</code></p>

<p>这样就是我们想要的结果了</p>

<h3 id="section-9">一些其他的乱七八糟</h3>
<p>JavaScript除了该死的constructor以外，还有一些坑，比如Array.prototype其实是个数组实例：
<code>javascript
&gt; Array.prototype
[]
</code></p>

<h2 id="ui">UI线程</h2>
<p>###基础概念
大多数浏览器只有一个单独的处理线程，它由两个任务共享：JavaScript任务和用户界面更新任务，每个时刻只有一个操作得以执行。当JavaScript代码执行时，用户界面就会被“锁定”，反过来也是一样。他们所共享的这个线程就被称为UI线程</p>

<p>比如一次按钮点击，会依次将按钮样式改变、按钮点击时需要运行的JavaScript代码、代码中的UI改变依次加入到UI线程中</p>

<h3 id="section-10">浏览器的限制</h3>
<p>浏览器除了会限制运行期栈的深度以外，还会限制长时间执行脚本。不同的浏览器判断脚本执行时间过长的方法不一样，有的是通过时间来判断，有的是通过运行语句的条数判断</p>

<h3 id="section-11">应当运行多久</h3>
<p>一个单一的JavaScript操作所使用的最大时间应该是100ms，如果用户100ms之内无法收到接口呃响应，用户就会认为自己与接口断开了</p>

<h3 id="section-12">定时相关</h3>
<p>JavaScript中有两种定时器，<code>setTimeout</code>和<code>setInterval</code>，使用它们能将较长的任务分解成较短的任务</p>

<p>使用定时器时，比如如下代码：
<code>javascript
setTimeout(function(){
    //do something
}, 250);
</code>
在这句<code>setTimeout</code>指令执行后的250ms（不一定精确），将函数加入到UI线程中。需要注意的是，这里不是立刻加入UI线程中，而是到了时间才加入。</p>

<blockquote>
  <p>另外我曾看过一篇文章，讲述的是setTimeout和setInterval执行后，会将其内设定到时需要执行的代码放入一个红黑树中，而每次执行时会从红黑树中挑选出当前最先需要执行的代码，放入UI线程中，同时维护红黑树。这个概念不太明确，有待考证</p>
</blockquote>

<p>这样我们可以看到，只有当前任务执行完之后，才有可能去执行UI队列中的其他任务，所以如下代码：
<code>javascript
console.log(1);
setTimeout(function() {
    console.log(2);
}, 0);
console.log(3);
</code>
输出的结果实际上是132</p>

<h3 id="section-13">定时器的精度问题</h3>
<p>JavaScript的定时器往往不太准确（当然requestAnimationFrame要精确得多），快慢大约几毫秒。而此外最小定时器延时的设定也会影响运行，在IE中建议的最小值为25ms</p>

<h3 id="section-14">定时器分解任务</h3>
<p>我们可以将任务分解成一系列子任务，然后将其分别通过定时器加入到UI线程中，以此来保证每个子任务运行时间不超过100ms（最好是不超过50ms），让UI更新和响应任务也能够及时处理。其实这个思想和JavaScript引擎的垃圾回收器的迭代处理相似</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/28/js-basis.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 漫谈前端开发中的SEO ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/27/seo.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 27 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="seo">什么是SEO</h2>
<p>SEO全称是搜索引擎优化，是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的排名的方式。SEO为了从搜索引擎获得更多的免费流量，从网站结构、内容建设方案、用户活动传播、页面结构等进行合理规划，使网站更适合搜索引擎检索。</p>

<h2 id="seohtml">SEO相关的HTML标签</h2>
<p>###title
<code>&lt;title&gt;页面的标题&lt;/title&gt;</code>，必须有的东西，非常之重要
###keyrowds
<code>&lt;meta name="keywords" content="keyWord1,keyWord2"/&gt;</code>，定义为搜索引擎提供的关键字列表，页面的呃主关键词都可以列举在这里
###description
<code>&lt;meta name="description" content="页面描述"&gt;</code>。这一部分告诉搜索引擎当前网页的主要内容，对有些搜索引擎的排名影响不大（如百度）但是对用户体验方面还是很有用的</p>

<h3 id="robots">robots</h3>
<p><code>&lt;meta name="Robots" content="nofollow"/&gt;</code>，告诉搜索引擎哪些页面需要索引，哪些页面则不需要，它对页面上的所有标签生效，包括站内站外。比如nofollow属性，如果在a标签上加上了nofollow，如<code>&lt;a rel="external nofollow" href=""&gt;锚文本&lt;/a&gt;</code>，搜索引擎将不会抓取这个连接，这样可以防止权重分散到一些无关页面。</p>

<p>content中的参数可以设定为<code>all</code>,<code>none</code>,<code>index</code>,<code>noindex</code>,<code>follow</code>,<code>nofollow</code>，默认为all。</p>

<h3 id="h1">H1</h3>
<p><code>&lt;h1&gt;标题&lt;/h1&gt;</code>，告诉搜索引擎一段文字的标题，h1标题的权重较大，而h2、h3、h4对搜索引擎没有多大价值，加上可以增加用户体验</p>

<h3 id="alttitle">alt和title</h3>
<p>尽量在img标签中加入alt属性如<code>&lt;img src="" alt="这里加上关键词"/&gt;</code>，alt会影响搜索排名</p>

<p>而a标签中的title也是一样，虽然效果微弱</p>

<h3 id="html">语义化HTML</h3>
<p>在HTML5中新增了很多语义化的HTML5元素，如<code>&lt;header&gt;</code>,<code>&lt;section&gt;</code>,<code>&lt;footer&gt;</code>,<code>&lt;article&gt;</code>,<code>&lt;aside&gt;</code>,<code>&lt;nav&gt;</code>等等，这些语义化元素能帮助搜索引擎快速过滤掉不重要的信息，而从中快速提取出网页的主题内容，同时语义化的HTML也能够有较强的可访问性</p>

<h2 id="section">对搜索引擎不友好的示例</h2>
<ol>
  <li>网页中大量采用图片或者Flash等富媒体形式，没有可以检索的文本信息</li>
  <li>网页没有标题，或者标题中不包含有效关键字</li>
  <li>正文中有效关键词比较少（小于文章的2%~8%）</li>
  <li>网站导航系统让搜索引擎看不懂</li>
  <li>大量动态网页让搜索引擎无法检索</li>
  <li>没有被其他已经被搜索引擎收录的网站所链接</li>
  <li>网站中充值大量欺骗搜索引擎的垃圾信息，如过渡页，桥页、颜色与背景色相同的文字</li>
  <li>网站中缺少原创内容，完全照搬别人的内容</li>
</ol>

<h2 id="section-1">一些好的建议</h2>
<p>###保持文章原创性
保持文章的原创性才不会被网络蜘蛛所唾弃，由于搜索引擎中已经保存了大量的数据，经过比对后，如果当前页面与已存在搜索引擎中的页面的相似度过高，将降低当前页面的权重。所以我们需要保持网页内文章的原创性。一般情况下至少要保持与其他文章的30%的不同</p>

<h3 id="section-2">关键字的堆砌</h3>
<p>众所周知，在网页中的<code>meta</code>标签中定义<code>keywors</code>对搜索引擎来说非常重要。而搜索中的关键词也应当堆砌在标题和正文中。其中标题由于字数有限，应当尽可能的出现较多的关键词，而正文中关键词也应当占有一定比重（2%~8%）。另外在文章中应当保持关键词的统一性，一个名称有多种叫法的时候尽量只是用其中的一种。同时出现在正文中的关键词应当加粗或家斜体来进行区分，让搜索引擎优先考虑</p>

<h3 id="section-3">标题</h3>
<p>标题不应当太长，最好不超过15个汉字，其中尽量多的堆砌关键词，同时保证标题新颖，符合用户的搜索习惯。尽量将主关键词放在标题的前半部分</p>

<h3 id="section-4">文章摘要</h3>
<p>在文章摘要中必须包含关键词，尽可能的重复页面的关键词，但是不要堆积，一般来说重复三遍没有问题。同时文章摘要的文字没有严格的字数要求，但一般以80-100字为宜</p>

<h3 id="section-5">正文内容</h3>
<p>正文内容需要保持原创性，同时在前100字中（或是首段）最好能出现关键词。同时需要保持文章的长度，如果文章过长，应当采用分页的方式，一般一页的长度在1000字以下。短的文章有助于搜索引擎提取和分析。在正文中需要一定的关键词堆叠（2%~8%）</p>

<h3 id="ajaxflash">AJAX和FLASH</h3>
<p>在开发中经常会使用Flash创建绚丽的导航，但实际上Flash导航中的链接是无法被网络蜘蛛抓取到的。而AJAX也是一样，因为AJAX是动态加载的，所以它不易被搜索引擎所抓取。所以尽量避免过度使用AJAX和FLASH，尤其不要将重要的内容通过AJAX和FLASH加载。如果网站有较多AJAX加载的内容话，可以提供一个非AJAX加载的静态替代网页</p>

<h3 id="section-6">图片和链接</h3>
<p>我们可以把网络蜘蛛看做一个基于文字的浏览器，它无法获取到图片内部的信息。因此，如果需要通过图片传达比较重要的信息的话，需要将信息写在<code>alt</code>属性中，传达给搜索引擎。链接也可以通过类似的<code>title</code>属性来添加相应的说明。在<code>alt</code>和<code>title</code>中给与精确的描述，并尽可能的输入关键词，这样能告诉搜索引擎图片和链接是做什么的</p>

<h2 id="section-7">参考文章</h2>
<p><a href="http://baike.baidu.com/link?url=RtgwJhMXAZh7_7BWXlvu9CXZV4JnoytnMWXlyAhLfgAKgPPoG6-vAooSYfFIBuM-">百度百科：SEO</a></p>

<p><a href="http://www.daqianduan.com/1808.html">站内SEO规范</a></p>

<p><a href="http://www.yangzblog.com/internet/webfeSEO.html">网页前端制作中的SEO</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/27/seo.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 漫谈前端开发中的SEO ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/27/seo.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 27 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="seo">什么是SEO</h2>
<p>SEO全称是搜索引擎优化，是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的排名的方式。SEO为了从搜索引擎获得更多的免费流量，从网站结构、内容建设方案、用户活动传播、页面结构等进行合理规划，使网站更适合搜索引擎检索。</p>

<h2 id="seohtml">SEO相关的HTML标签</h2>
<p>###title
<code>&lt;title&gt;页面的标题&lt;/title&gt;</code>，必须有的东西，非常之重要
###keyrowds
<code>&lt;meta name="keywords" content="keyWord1,keyWord2"/&gt;</code>，定义为搜索引擎提供的关键字列表，页面的呃主关键词都可以列举在这里
###description
<code>&lt;meta name="description" content="页面描述"&gt;</code>。这一部分告诉搜索引擎当前网页的主要内容，对有些搜索引擎的排名影响不大（如百度）但是对用户体验方面还是很有用的</p>

<h3 id="robots">robots</h3>
<p><code>&lt;meta name="Robots" content="nofollow"/&gt;</code>，告诉搜索引擎哪些页面需要索引，哪些页面则不需要，它对页面上的所有标签生效，包括站内站外。比如nofollow属性，如果在a标签上加上了nofollow，如<code>&lt;a rel="external nofollow" href=""&gt;锚文本&lt;/a&gt;</code>，搜索引擎将不会抓取这个连接，这样可以防止权重分散到一些无关页面。</p>

<p>content中的参数可以设定为<code>all</code>,<code>none</code>,<code>index</code>,<code>noindex</code>,<code>follow</code>,<code>nofollow</code>，默认为all。</p>

<h3 id="h1">H1</h3>
<p><code>&lt;h1&gt;标题&lt;/h1&gt;</code>，告诉搜索引擎一段文字的标题，h1标题的权重较大，而h2、h3、h4对搜索引擎没有多大价值，加上可以增加用户体验</p>

<h3 id="alttitle">alt和title</h3>
<p>尽量在img标签中加入alt属性如<code>&lt;img src="" alt="这里加上关键词"/&gt;</code>，alt会影响搜索排名</p>

<p>而a标签中的title也是一样，虽然效果微弱</p>

<h3 id="html">语义化HTML</h3>
<p>在HTML5中新增了很多语义化的HTML5元素，如<code>&lt;header&gt;</code>,<code>&lt;section&gt;</code>,<code>&lt;footer&gt;</code>,<code>&lt;article&gt;</code>,<code>&lt;aside&gt;</code>,<code>&lt;nav&gt;</code>等等，这些语义化元素能帮助搜索引擎快速过滤掉不重要的信息，而从中快速提取出网页的主题内容，同时语义化的HTML也能够有较强的可访问性</p>

<h2 id="section">对搜索引擎不友好的示例</h2>
<ol>
  <li>网页中大量采用图片或者Flash等富媒体形式，没有可以检索的文本信息</li>
  <li>网页没有标题，或者标题中不包含有效关键字</li>
  <li>正文中有效关键词比较少（小于文章的2%~8%）</li>
  <li>网站导航系统让搜索引擎看不懂</li>
  <li>大量动态网页让搜索引擎无法检索</li>
  <li>没有被其他已经被搜索引擎收录的网站所链接</li>
  <li>网站中充值大量欺骗搜索引擎的垃圾信息，如过渡页，桥页、颜色与背景色相同的文字</li>
  <li>网站中缺少原创内容，完全照搬别人的内容</li>
</ol>

<h2 id="section-1">一些好的建议</h2>
<p>###保持文章原创性
保持文章的原创性才不会被网络蜘蛛所唾弃，由于搜索引擎中已经保存了大量的数据，经过比对后，如果当前页面与已存在搜索引擎中的页面的相似度过高，将降低当前页面的权重。所以我们需要保持网页内文章的原创性。一般情况下至少要保持与其他文章的30%的不同</p>

<h3 id="section-2">关键字的堆砌</h3>
<p>众所周知，在网页中的<code>meta</code>标签中定义<code>keywors</code>对搜索引擎来说非常重要。而搜索中的关键词也应当堆砌在标题和正文中。其中标题由于字数有限，应当尽可能的出现较多的关键词，而正文中关键词也应当占有一定比重（2%~8%）。另外在文章中应当保持关键词的统一性，一个名称有多种叫法的时候尽量只是用其中的一种。同时出现在正文中的关键词应当加粗或家斜体来进行区分，让搜索引擎优先考虑</p>

<h3 id="section-3">标题</h3>
<p>标题不应当太长，最好不超过15个汉字，其中尽量多的堆砌关键词，同时保证标题新颖，符合用户的搜索习惯。尽量将主关键词放在标题的前半部分</p>

<h3 id="section-4">文章摘要</h3>
<p>在文章摘要中必须包含关键词，尽可能的重复页面的关键词，但是不要堆积，一般来说重复三遍没有问题。同时文章摘要的文字没有严格的字数要求，但一般以80-100字为宜</p>

<h3 id="section-5">正文内容</h3>
<p>正文内容需要保持原创性，同时在前100字中（或是首段）最好能出现关键词。同时需要保持文章的长度，如果文章过长，应当采用分页的方式，一般一页的长度在1000字以下。短的文章有助于搜索引擎提取和分析。在正文中需要一定的关键词堆叠（2%~8%）</p>

<h3 id="ajaxflash">AJAX和FLASH</h3>
<p>在开发中经常会使用Flash创建绚丽的导航，但实际上Flash导航中的链接是无法被网络蜘蛛抓取到的。而AJAX也是一样，因为AJAX是动态加载的，所以它不易被搜索引擎所抓取。所以尽量避免过度使用AJAX和FLASH，尤其不要将重要的内容通过AJAX和FLASH加载。如果网站有较多AJAX加载的内容话，可以提供一个非AJAX加载的静态替代网页</p>

<h3 id="section-6">图片和链接</h3>
<p>我们可以把网络蜘蛛看做一个基于文字的浏览器，它无法获取到图片内部的信息。因此，如果需要通过图片传达比较重要的信息的话，需要将信息写在<code>alt</code>属性中，传达给搜索引擎。链接也可以通过类似的<code>title</code>属性来添加相应的说明。在<code>alt</code>和<code>title</code>中给与精确的描述，并尽可能的输入关键词，这样能告诉搜索引擎图片和链接是做什么的</p>

<h2 id="section-7">参考文章</h2>
<p><a href="http://baike.baidu.com/link?url=RtgwJhMXAZh7_7BWXlvu9CXZV4JnoytnMWXlyAhLfgAKgPPoG6-vAooSYfFIBuM-">百度百科：SEO</a></p>

<p><a href="http://www.daqianduan.com/1808.html">站内SEO规范</a></p>

<p><a href="http://www.yangzblog.com/internet/webfeSEO.html">网页前端制作中的SEO</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/27/seo.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript篇） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/25/performance-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">优化循环</h2>
<p>如果现在有个一个<code>data[]</code>数组，需要对其进行遍历，应当怎么做？最简单的代码是：
<code>javascript
for (var i = 0; i &lt; data.length; i++) {
    //do someting
}
</code>
这里每次循环开始前都需要判断i是否小于<code>data.length</code>，JavaScript并不会对<code>data.length</code>进行缓存，而是每次比较都会进行一次取值。如我们所知，JavaScript数组其实是一个对象，里面有个length属性，所以这里实际上就是取得对象的属性。如果直接使用变量的话就会少一次索引对象，如果数组的元素很多，效率提升还是很可观的。所以我们通常将代码改成如下所示：
<code>javascript
for(var i = 0, m = data.length; i &lt; m; i++) {
    //do someting
}
</code>
这里多加了一个变量m用于存放<code>data.length</code>属性，这样就可以在每次循环时，减少一次索引对象，但是代价是增加了一个变量的空间，如果遍历不要求顺序，我们甚至可以不用m这个变量存储长度，在不要求顺序的时候可以使用如下代码：
<code>javascript
for(var i = data.length; i--; ) {
    //do someting
}
</code>
当然我们可以使用while来替代：
<code>javascript
var i = data.length;
while(i--) {
    //do someting
}
</code>
这样就可只使用一个变量了</p>

<h2 id="section-1">运算结果缓存</h2>
<p>由于JavaScript中的函数也是对象（JavaScript中一切都是对象），所以我们可以给函数添加任意的属性。这也就为我们提供符合备忘录模式的缓存运算结果的功能，比如我们有一个需要大量运算才能得出结果的函数如下：
<code>javascript
function calculator(params) {
    //大量的耗时的计算 
    return result;
}
</code>
如果其中不涉及随机，参数一样时所返回的结果一致，我们就可以将运算结果进行缓存从而避免重复的计算：
<code>javascript
function calculator(params) {
    var cacheKey = JSON.stringify(params);
    var cache = calculator.cache = calculator.cache || {};
    if(typeof cache[cacheKey] !== 'undefined') {
        return cache[cacheKey];
    }
    //大量耗时的计算
    cache[cacheKey] = result;
    return result;
}
</code>
这里将参数转化为JSON字符串作为key，如果这个参数已经被计算过，那么就直接返回，否则进行计算。计算完毕后再添加入cache中，如果需要，可以直接查看cache的内容：<code>calculator.cache</code></p>

<p>这是一种典型的空间换时间的方式，由于浏览器的页面存活时间一般不会很长，占用的内存会很快被释放（当然也有例外，比如一些WEB应用），所以可以通过这种空间换时间的方式来减少响应时间，提升用户体验。这种方式并不适用于如下场合：
1. 相同参数可能产生不同结果的情况（包含随机数之类的）
2. 运算结果占用特别多内存的情况</p>

<h2 id="section-2">不要在循环中创建函数</h2>
<p>这个很好理解，每创建一个函数对象是需要大批量空间的。所以在一个循环中创建函数是很不明智的，尽量将函数移动到循环之前创建，比如如下代码：
<code>javascript
for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], function(data){
        //do something
    });
}
</code>
就可以修改为：
<code>javascript
var handler = function(data){
    //do something
};
for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], handler);
}
</code></p>

<h2 id="section-3">让垃圾回收器回收那些不再需要的对象</h2>
<p>之前我曾在 <a href="http://lingyu.wang#/art/blog/2014/03/19/v8-gc/">浅谈V8引擎中的垃圾回收机制</a> 中讲到了V8引擎如何进行垃圾回收。可以从中看到，如果长时间保存对象，老生代中占用的空间将增大，每次在老生代中的垃圾回收过程将会相当漫长。而垃圾回收器判断一个对象为活对象还是死对象，是按照是否有活对象或根对象含有对它的引用来判定的。如果有根对象或者活对象引用了这个对象，它将被判定为活对象。所以我们需要通过手动消除这些引用来让垃圾回收器对回收这些对象。
###delete
一种方式是通过<code>delete</code>方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储（详细请见<a href="http://newhtml.net/v8-object-representation/">V8 之旅：对象表示</a>），不利于JavaScript引擎的优化，所以尽量减少使用
###null
另一种方式是通过将值设为null来消除引用。通过将变量或对象的属性设为null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用<code>delete</code>要好
###全局对象
另外需要注意的是，垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收。而全局对象就是根对象，所以全局作用域中的变量将会一直存在
###事件处理器的回收
在平常写代码的时候，我们经常会给一个DOM节点绑定事件处理器，但有时候我们不需要这些事件处理器后，就不管它们了，它们默默的在内存中保存着。所以在某些DOM节点绑定的事件处理器不需要后，我们应当销毁它们。同时绑定的时候也尽量使用事件代理的方式进行绑定，以免造成多次重复的绑定导致内存空间的浪费，事件代理可见<a href="http://skyinlayer.com/blog/2014/03/25/performance-1/">前端性能优化（DOM操作篇）</a>
###闭包导致的内存泄露
JavaScript的闭包可以说即是“天使”又是“魔鬼”，它“天使”的一面是我们可以通过它突破作用域的限制，而其魔鬼的一面就是和容易导致内存泄露，比如如下情况：
<code>javascript
var result = (function() {
    var small = {};
    var big = new Array(10000000);
    //do something
    return function(){
        if(big.indexOf("someValue") !== -1) {
            return null;
        } else {
            return small;
        }
    }
})();
</code>
这里，创建了一个闭包。使得返回的函数存储在result中，而result函数能够访问其作用域内的small对象和big对象。由于big对象和small对象都可能被访问，所以垃圾回收器不会去碰这两个对象，它们不会被回收。我们将上述代码改成如下形式：
<code>javascript
var result = (function() {
    var small = {};
    var big = new Array(10000000);
    var hasSomeValue;
    //do something
    hasSomeValue = big.indexOf("someValue") !== -1;
    return function(){
        if(hasSomeValue) {
            return null;
        } else {
            return small;
        }
    }
})();
</code>
这样，函数内部只能够访问到hasSomeValue变量和small变量了，big没有办法通过任何形式被访问到，垃圾回收器将会对其进行回收，节省了大量的内存。</p>

<h2 id="evalwith">慎用eval和with</h2>
<p>Douglas Crockford将eval比作魔鬼，确实在很多方面我们可以找到更好地替代方式。使用它时需要在运行时调用解释引擎对<code>eval()</code>函数内部的字符串进行解释运行，这需要消耗大量的时间。像<code>Function</code>、<code>setInterval</code>、<code>setTimeout</code>也是类似的</p>

<p>Douglas Crockford也不建议使用with，with会降低性能，通过with包裹的代码块，作用域链将会额外增加一层，降低索引效率</p>

<h2 id="section-4">对象的优化</h2>
<p>###缓存需要被使用的对象
JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。我们可以通过最快的方式代替最慢的方式：
<code>javascript
var body = document.body;
var maxLength = someArray.length;
//...
</code>
需要考虑，作用域链和原型链中的对象索引。如果作用域链和原型链较长，也需要对所需要的变量继续缓存，否则沿着作用域链和原型链向上查找时也会额外消耗时间</p>

<h3 id="section-5">缓存正则表达式对象</h3>
<p>需要注意，正则表达式对象的创建非常消耗时间，尽量不要在循环中创建正则表达式，尽可能多的对正则表达式对象进行复用</p>

<h3 id="section-6">考虑对象和数组</h3>
<p>在JavaScript中我们可以使用两种存放数据：对象和数组。由于JavaScript数组可以存放任意类型数据这样的灵活性，导致我们经常需要考虑何时使用数组，何时使用对象。我们应当在如下情况下做出考虑：
1. 存储一串相同类型的对象，应当使用数组
2. 存储一堆键值对，值的类型多样，应当使用对象
3. 所有值都是通过整数索引，应当使用数组</p>

<h3 id="section-7">数组使用时的优化</h3>
<ol>
  <li>往数组中插入混合类型很容易降低数组使用的效率，尽量保持数组中元素的类型一致</li>
  <li>如果使用稀疏数组，它的元素访问将远慢于满数组的元素访问。因为V8为了节省空间，会将稀疏数组通过字典方式保存在内存中，节约了空间，但增加了访问时间</li>
</ol>

<h3 id="section-8">对象的拷贝</h3>
<p>需要注意的是，JavaScript遍历对象和数组时，使用<code>for...in</code>的效率相当低，所以在拷贝对象时，如果已知需要被拷贝的对象的属性，通过直接赋值的方式比使用<code>for...in</code>方式要来得快，我们可以通过定一个拷贝构造函数来实现，比如如下代码：
<code>javascript
function copy(source){
    var result = {};
    var item;
    for(item in source) {
        result[item] = source[item];
    }
    return result;
}
var backup = copy(source);
</code>
可修改为：
<code>javascript
function copy(source){
    this.property1 = source.property1;
    this.property2 = source.property2;
    this.property3 = source.property3;
    //...
}
var backup = new copy(source);
</code></p>

<h3 id="section-9">字面量代替构造函数</h3>
<p>JavaScript可以通过字面量来构造对象，比如通过<code>[]</code>构造一个数组，<code>{}</code>构造一个对象，<code>/regexp/</code>构造一个正则表达式，我们应当尽力使用字面量来构造对象，因为字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器，所以字面量略微要快一点点。</p>

<h2 id="ajax">缓存AJAX</h2>
<p>曾经听过一个访问时间比较（当然不精确）：
* cpu cache ≈ 100 * 寄存器
* 内存 ≈ 100 * cpu cache
* 外存 ≈ 100 * 内存
* 网络 ≈ 100 * 外存</p>

<p>可看到访问网络资源是相当慢的，而AJAX就是JavaScript访问网络资源的方式，所以对一些AJAX结果进行缓存，可以大大减少响应时间。那么如何缓存AJAX结果呢</p>

<h3 id="section-10">函数缓存</h3>
<p>我们可以使用前面缓存复杂计算函数结果的方式进行缓存，通过在函数对象上构造cache对象，原理一样，这里略过。这种方式是精确到函数，而不精确到请求</p>

<h3 id="section-11">本地缓存</h3>
<p>HTML5提供了本地缓存sessionStorage和localStorage，区别就是前者在浏览器关闭后会自动释放，而后者则是永久的，不会被释放。它提供的缓存大小以MB为单位，比cookie（4KB）要大得多，所以我们可以根据AJAX数据的存活时间来判断是存放在sessionStorage还是localStorage当中，在这里以存储到sessionStorage中为例(localStorage只需把第一行的<code>window.sessionStorage</code>修改为<code>window.localStorage</code>)：
<code>javascript
function(data, url, type, callback){
    var storage = window.sessionStorage;
    var key = JSON.stringify({
        url : url,
        type : type,
        data : data
    });
    var result = storage.getItem(key);
    var xhr;
    if (result) {
        callback.call(null, result);
    } else {
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status === 200){
                    storage.setItem(key, xhr.responseText);
                    callback.call(null, xhr.responseText);
                } else {
                }
            }
        };
        xhr.open(type, url, async);
        xhr.send(data);
    }
};
</code></p>

<h2 id="section-12">使用布尔表达式的短路</h2>
<p>在很多语言中，如果bool表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行，比如如下代码
```javascript
function calCondition(params) {
    var result;
    //do lots of work
    return !!result;
}</p>

<p>if(otherCondition &amp;&amp; calCondition(someParams)) {
    console.log(true);
} else {
    console.log(false);
}
```
这里首先会计算<code>otherCondition</code>的值，如果它为false，那么整个正则表达式就为false了，后续的需要消耗大量时间的<code>calCondition()</code>函数就不会被调用和计算了，节省了时间</p>

<h2 id="section-13">使用原生方法</h2>
<p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如<code>Math</code>之类的原生对象和方法</p>

<h2 id="section-14">字符串拼接</h2>
<p>在IE和FF下，使用直接<code>+=</code>的方式或是<code>+</code>的方式进行字符串拼接，将会很慢。我们可以通过Array的<code>join()</code>方法进行字符串拼接。不过并不是所有浏览器都是这样，现在很多浏览器使用<code>+=</code>比join()方法还要快</p>

<h2 id="web-worker">使用web worker</h2>
<p>web worker是HTML5提出的一项新技术，通过多线程的方式为JavaScript提供并行计算的能力，通过message的方式进行相互之间的信息传递，我还没有仔细研究过</p>

<h2 id="javascript">JavaScript文件的优化</h2>
<p>###使用CDN
在编写JavaScript代码中，我们经常会使用库（jQuery等等），这些JS库通常不会对其进行更改，我们可以将这些库文件放在CDN（内容分发网络上），这样能大大减少响应时间</p>

<h3 id="javascript-1">压缩与合并JavaScript文件</h3>
<p>在网络中传输JS文件，文件越长，需要的时间越多。所以在上线前，通常都会对JS文件进行压缩，去掉其中的注释、回车、不必要的空格等多余内容，如果通过uglify的算法，还可以缩减变量名和函数名，从而将JS代码压缩，节约传输时的带宽。另外经常也会将JavaScript代码合并，使所有代码在一个文件之中，这样就能够减少HTTP的请求次数。合并的原理和sprite技术相同</p>

<h3 id="application-cache">使用Application Cache缓存</h3>
<p>这个在之前的文章<a href="http://skyinlayer.com/blog/2014/02/20/application-cache/">前端性能优化（Application Cache篇）</a>中已有描述，就不赘述了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/25/performance-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（JavaScript篇） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/25/performance-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">优化循环</h2>
<p>如果现在有个一个<code>data[]</code>数组，需要对其进行遍历，应当怎么做？最简单的代码是：
<code>javascript
for (var i = 0; i &lt; data.length; i++) {
    //do someting
}
</code>
这里每次循环开始前都需要判断i是否小于<code>data.length</code>，JavaScript并不会对<code>data.length</code>进行缓存，而是每次比较都会进行一次取值。如我们所知，JavaScript数组其实是一个对象，里面有个length属性，所以这里实际上就是取得对象的属性。如果直接使用变量的话就会少一次索引对象，如果数组的元素很多，效率提升还是很可观的。所以我们通常将代码改成如下所示：
<code>javascript
for(var i = 0, m = data.length; i &lt; m; i++) {
    //do someting
}
</code>
这里多加了一个变量m用于存放<code>data.length</code>属性，这样就可以在每次循环时，减少一次索引对象，但是代价是增加了一个变量的空间，如果遍历不要求顺序，我们甚至可以不用m这个变量存储长度，在不要求顺序的时候可以使用如下代码：
<code>javascript
for(var i = data.length; i--; ) {
    //do someting
}
</code>
当然我们可以使用while来替代：
<code>javascript
var i = data.length;
while(i--) {
    //do someting
}
</code>
这样就可只使用一个变量了</p>

<h2 id="section-1">运算结果缓存</h2>
<p>由于JavaScript中的函数也是对象（JavaScript中一切都是对象），所以我们可以给函数添加任意的属性。这也就为我们提供符合备忘录模式的缓存运算结果的功能，比如我们有一个需要大量运算才能得出结果的函数如下：
<code>javascript
function calculator(params) {
    //大量的耗时的计算 
    return result;
}
</code>
如果其中不涉及随机，参数一样时所返回的结果一致，我们就可以将运算结果进行缓存从而避免重复的计算：
<code>javascript
function calculator(params) {
    var cacheKey = JSON.stringify(params);
    var cache = calculator.cache = calculator.cache || {};
    if(typeof cache[cacheKey] !== 'undefined') {
        return cache[cacheKey];
    }
    //大量耗时的计算
    cache[cacheKey] = result;
    return result;
}
</code>
这里将参数转化为JSON字符串作为key，如果这个参数已经被计算过，那么就直接返回，否则进行计算。计算完毕后再添加入cache中，如果需要，可以直接查看cache的内容：<code>calculator.cache</code></p>

<p>这是一种典型的空间换时间的方式，由于浏览器的页面存活时间一般不会很长，占用的内存会很快被释放（当然也有例外，比如一些WEB应用），所以可以通过这种空间换时间的方式来减少响应时间，提升用户体验。这种方式并不适用于如下场合：
1. 相同参数可能产生不同结果的情况（包含随机数之类的）
2. 运算结果占用特别多内存的情况</p>

<h2 id="section-2">不要在循环中创建函数</h2>
<p>这个很好理解，每创建一个函数对象是需要大批量空间的。所以在一个循环中创建函数是很不明智的，尽量将函数移动到循环之前创建，比如如下代码：
<code>javascript
for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], function(data){
        //do something
    });
}
</code>
就可以修改为：
<code>javascript
var handler = function(data){
    //do something
};
for(var i = 0, m = data.length; i &lt; m; i++) {
    handlerData(data[i], handler);
}
</code></p>

<h2 id="section-3">让垃圾回收器回收那些不再需要的对象</h2>
<p>之前我曾在 <a href="http://lingyu.wang#/art/blog/2014/03/19/v8-gc/">浅谈V8引擎中的垃圾回收机制</a> 中讲到了V8引擎如何进行垃圾回收。可以从中看到，如果长时间保存对象，老生代中占用的空间将增大，每次在老生代中的垃圾回收过程将会相当漫长。而垃圾回收器判断一个对象为活对象还是死对象，是按照是否有活对象或根对象含有对它的引用来判定的。如果有根对象或者活对象引用了这个对象，它将被判定为活对象。所以我们需要通过手动消除这些引用来让垃圾回收器对回收这些对象。
###delete
一种方式是通过<code>delete</code>方式来消除对象中的键值对，从而消除引用。但这种方式并不提倡，它会改变对象的结构，可能导致引擎中对对象的存储方式变更，降级为字典方式进行存储（详细请见<a href="http://newhtml.net/v8-object-representation/">V8 之旅：对象表示</a>），不利于JavaScript引擎的优化，所以尽量减少使用
###null
另一种方式是通过将值设为null来消除引用。通过将变量或对象的属性设为null，可以消除引用，使原本引用的对象成为一个“孤岛”，然后在垃圾回收的时候对其进行回收。这种方式不会改变对象的结构，比使用<code>delete</code>要好
###全局对象
另外需要注意的是，垃圾回收器认为根对象永远是活对象，永远不会对其进行垃圾回收。而全局对象就是根对象，所以全局作用域中的变量将会一直存在
###事件处理器的回收
在平常写代码的时候，我们经常会给一个DOM节点绑定事件处理器，但有时候我们不需要这些事件处理器后，就不管它们了，它们默默的在内存中保存着。所以在某些DOM节点绑定的事件处理器不需要后，我们应当销毁它们。同时绑定的时候也尽量使用事件代理的方式进行绑定，以免造成多次重复的绑定导致内存空间的浪费，事件代理可见<a href="http://skyinlayer.com/blog/2014/03/25/performance-1/">前端性能优化（DOM操作篇）</a>
###闭包导致的内存泄露
JavaScript的闭包可以说即是“天使”又是“魔鬼”，它“天使”的一面是我们可以通过它突破作用域的限制，而其魔鬼的一面就是和容易导致内存泄露，比如如下情况：
<code>javascript
var result = (function() {
    var small = {};
    var big = new Array(10000000);
    //do something
    return function(){
        if(big.indexOf("someValue") !== -1) {
            return null;
        } else {
            return small;
        }
    }
})();
</code>
这里，创建了一个闭包。使得返回的函数存储在result中，而result函数能够访问其作用域内的small对象和big对象。由于big对象和small对象都可能被访问，所以垃圾回收器不会去碰这两个对象，它们不会被回收。我们将上述代码改成如下形式：
<code>javascript
var result = (function() {
    var small = {};
    var big = new Array(10000000);
    var hasSomeValue;
    //do something
    hasSomeValue = big.indexOf("someValue") !== -1;
    return function(){
        if(hasSomeValue) {
            return null;
        } else {
            return small;
        }
    }
})();
</code>
这样，函数内部只能够访问到hasSomeValue变量和small变量了，big没有办法通过任何形式被访问到，垃圾回收器将会对其进行回收，节省了大量的内存。</p>

<h2 id="evalwith">慎用eval和with</h2>
<p>Douglas Crockford将eval比作魔鬼，确实在很多方面我们可以找到更好地替代方式。使用它时需要在运行时调用解释引擎对<code>eval()</code>函数内部的字符串进行解释运行，这需要消耗大量的时间。像<code>Function</code>、<code>setInterval</code>、<code>setTimeout</code>也是类似的</p>

<p>Douglas Crockford也不建议使用with，with会降低性能，通过with包裹的代码块，作用域链将会额外增加一层，降低索引效率</p>

<h2 id="section-4">对象的优化</h2>
<p>###缓存需要被使用的对象
JavaScript获取数据的性能有如下顺序（从快到慢）：变量获取 &gt; 数组下标获取（对象的整数索引获取） &gt; 对象属性获取（对象非整数索引获取）。我们可以通过最快的方式代替最慢的方式：
<code>javascript
var body = document.body;
var maxLength = someArray.length;
//...
</code>
需要考虑，作用域链和原型链中的对象索引。如果作用域链和原型链较长，也需要对所需要的变量继续缓存，否则沿着作用域链和原型链向上查找时也会额外消耗时间</p>

<h3 id="section-5">缓存正则表达式对象</h3>
<p>需要注意，正则表达式对象的创建非常消耗时间，尽量不要在循环中创建正则表达式，尽可能多的对正则表达式对象进行复用</p>

<h3 id="section-6">考虑对象和数组</h3>
<p>在JavaScript中我们可以使用两种存放数据：对象和数组。由于JavaScript数组可以存放任意类型数据这样的灵活性，导致我们经常需要考虑何时使用数组，何时使用对象。我们应当在如下情况下做出考虑：
1. 存储一串相同类型的对象，应当使用数组
2. 存储一堆键值对，值的类型多样，应当使用对象
3. 所有值都是通过整数索引，应当使用数组</p>

<h3 id="section-7">数组使用时的优化</h3>
<ol>
  <li>往数组中插入混合类型很容易降低数组使用的效率，尽量保持数组中元素的类型一致</li>
  <li>如果使用稀疏数组，它的元素访问将远慢于满数组的元素访问。因为V8为了节省空间，会将稀疏数组通过字典方式保存在内存中，节约了空间，但增加了访问时间</li>
</ol>

<h3 id="section-8">对象的拷贝</h3>
<p>需要注意的是，JavaScript遍历对象和数组时，使用<code>for...in</code>的效率相当低，所以在拷贝对象时，如果已知需要被拷贝的对象的属性，通过直接赋值的方式比使用<code>for...in</code>方式要来得快，我们可以通过定一个拷贝构造函数来实现，比如如下代码：
<code>javascript
function copy(source){
    var result = {};
    var item;
    for(item in source) {
        result[item] = source[item];
    }
    return result;
}
var backup = copy(source);
</code>
可修改为：
<code>javascript
function copy(source){
    this.property1 = source.property1;
    this.property2 = source.property2;
    this.property3 = source.property3;
    //...
}
var backup = new copy(source);
</code></p>

<h3 id="section-9">字面量代替构造函数</h3>
<p>JavaScript可以通过字面量来构造对象，比如通过<code>[]</code>构造一个数组，<code>{}</code>构造一个对象，<code>/regexp/</code>构造一个正则表达式，我们应当尽力使用字面量来构造对象，因为字面量是引擎直接解释执行的，而如果使用构造函数的话，需要调用一个内部构造器，所以字面量略微要快一点点。</p>

<h2 id="ajax">缓存AJAX</h2>
<p>曾经听过一个访问时间比较（当然不精确）：
* cpu cache ≈ 100 * 寄存器
* 内存 ≈ 100 * cpu cache
* 外存 ≈ 100 * 内存
* 网络 ≈ 100 * 外存</p>

<p>可看到访问网络资源是相当慢的，而AJAX就是JavaScript访问网络资源的方式，所以对一些AJAX结果进行缓存，可以大大减少响应时间。那么如何缓存AJAX结果呢</p>

<h3 id="section-10">函数缓存</h3>
<p>我们可以使用前面缓存复杂计算函数结果的方式进行缓存，通过在函数对象上构造cache对象，原理一样，这里略过。这种方式是精确到函数，而不精确到请求</p>

<h3 id="section-11">本地缓存</h3>
<p>HTML5提供了本地缓存sessionStorage和localStorage，区别就是前者在浏览器关闭后会自动释放，而后者则是永久的，不会被释放。它提供的缓存大小以MB为单位，比cookie（4KB）要大得多，所以我们可以根据AJAX数据的存活时间来判断是存放在sessionStorage还是localStorage当中，在这里以存储到sessionStorage中为例(localStorage只需把第一行的<code>window.sessionStorage</code>修改为<code>window.localStorage</code>)：
<code>javascript
function(data, url, type, callback){
    var storage = window.sessionStorage;
    var key = JSON.stringify({
        url : url,
        type : type,
        data : data
    });
    var result = storage.getItem(key);
    var xhr;
    if (result) {
        callback.call(null, result);
    } else {
        xhr.onreadystatechange = function(){
            if(xhr.readyState === 4){
                if(xhr.status === 200){
                    storage.setItem(key, xhr.responseText);
                    callback.call(null, xhr.responseText);
                } else {
                }
            }
        };
        xhr.open(type, url, async);
        xhr.send(data);
    }
};
</code></p>

<h2 id="section-12">使用布尔表达式的短路</h2>
<p>在很多语言中，如果bool表达式的值已经能通过前面的条件确定，那么后面的判断条件将不再会执行，比如如下代码
```javascript
function calCondition(params) {
    var result;
    //do lots of work
    return !!result;
}</p>

<p>if(otherCondition &amp;&amp; calCondition(someParams)) {
    console.log(true);
} else {
    console.log(false);
}
```
这里首先会计算<code>otherCondition</code>的值，如果它为false，那么整个正则表达式就为false了，后续的需要消耗大量时间的<code>calCondition()</code>函数就不会被调用和计算了，节省了时间</p>

<h2 id="section-13">使用原生方法</h2>
<p>在JavaScript中，大多数原生方法是使用C++编写的，比js写的方法要快得多，所以尽量使用诸如<code>Math</code>之类的原生对象和方法</p>

<h2 id="section-14">字符串拼接</h2>
<p>在IE和FF下，使用直接<code>+=</code>的方式或是<code>+</code>的方式进行字符串拼接，将会很慢。我们可以通过Array的<code>join()</code>方法进行字符串拼接。不过并不是所有浏览器都是这样，现在很多浏览器使用<code>+=</code>比join()方法还要快</p>

<h2 id="web-worker">使用web worker</h2>
<p>web worker是HTML5提出的一项新技术，通过多线程的方式为JavaScript提供并行计算的能力，通过message的方式进行相互之间的信息传递，我还没有仔细研究过</p>

<h2 id="javascript">JavaScript文件的优化</h2>
<p>###使用CDN
在编写JavaScript代码中，我们经常会使用库（jQuery等等），这些JS库通常不会对其进行更改，我们可以将这些库文件放在CDN（内容分发网络上），这样能大大减少响应时间</p>

<h3 id="javascript-1">压缩与合并JavaScript文件</h3>
<p>在网络中传输JS文件，文件越长，需要的时间越多。所以在上线前，通常都会对JS文件进行压缩，去掉其中的注释、回车、不必要的空格等多余内容，如果通过uglify的算法，还可以缩减变量名和函数名，从而将JS代码压缩，节约传输时的带宽。另外经常也会将JavaScript代码合并，使所有代码在一个文件之中，这样就能够减少HTTP的请求次数。合并的原理和sprite技术相同</p>

<h3 id="application-cache">使用Application Cache缓存</h3>
<p>这个在之前的文章<a href="http://skyinlayer.com/blog/2014/02/20/application-cache/">前端性能优化（Application Cache篇）</a>中已有描述，就不赘述了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/25/performance-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（DOM操作篇） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/25/performance-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="dom">缓存DOM对象</h2>
<p>JavaScript的DOM操作可以说是JavaScript最重要的功能，我们经常要根据用户的操作来动态的增加和删除元素，或是通过AJAX返回的数据动态生成元素。比如我们获得了一个很多元素的数组<code>data[]</code>，需要将其每个值生成一个li元素插入到一个id为container的ul元素中，最简单（最慢）的方式是：</p>

<p><code>javascript
var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    document.getElementById("container").appendChild(liNode);
}
</code></p>

<p>这里每一次循环都会去查找id为container的元素，效率自然非常低，所以我们需要将元素在循环前查询完毕，在循环中仅仅是引用就行了，修改代码为：</p>

<p><code>javascript
var ulNode = document.getElementById("container");
var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    ulNode.appendChild(liNode);
}
</code></p>

<p>缓存DOM对象的方式也经常被用在元素的查找中，查找元素应该是DOM操作中最频繁的操作了，其效率优化也是大头。在一般情况下，我们会根据需要，将一些频繁被查找的元素缓存起来，在查找它或查找它的子孙元素时，以它为起点进行查找，就能提高查找效率了。</p>

<h2 id="section">在内存中操作元素</h2>
<p>由于DOM操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。DOM操作本身提供一个创建内存节点片段的功能:<code>document.createDocumentFragment()</code>，我们可以将其运用于上述代码中：
<code>javascript
var ulNode = document.getElementById("container");
var liNode, i, m;
var fragment = document.createDocumentFragment();
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);
</code>
这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点</p>

<h2 id="dom-1">一次性DOM节点生成</h2>
<p>在这里我们每次都需要生成节点（<code>document.createElement("li")</code>），然后将其加入到内存片段中，我们可以通过<code>innerHTML</code>属性来一次性生成节点，具体的思路就是使用字符串拼接的方式，先生成相应的HTML字符串，最后一次性写入到ul的innerHTML中。修改代码为：
<code>javascript
var ulNode = document.getElementById("container");
var fragmentHtml = "", i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += "&lt;li&gt;" + data[i] + "&lt;/li&gt;";
}
ulNode.innerHTML = fragmentHtml;
</code>
这样效率也会有提升，不过手动拼写字符串是相当麻烦的一件事</p>

<h2 id="section-1">通过类修改样式</h2>
<p>有时候我们需要通过JavaScript给元素增加样式，比如如下代码：
<code>javascript
element.style.fontWeight = 'bold';
element.style.backgroundImage = 'url(back.gif)';
element.style.backgroundColor = 'white';
element.style.color = 'white';
//...
</code>
这样效率很低，每次修改style属性后都会触发元素的重绘，如果修改了的属性涉及大小和位置，将会导致回流。所以我们应当尽量避免多次为一个元素设置style属性，应当通过给其添加新的CSS类，来修改其CSS
<code>css
.element {
    background-image: url(back.gif);
    background-color: #fff;
    color: #fff;
    font-weight: 'bold';
    /*...*/
}
</code></p>

<p><code>javascript
element.className += " element";
</code></p>

<h2 id="section-2">通过事件代理批量操作事件</h2>
<p>还是之前那个ul和添加li，如果我们需要给每个li都绑定一个click事件，就可能写出类似如下代码：
<code>javascript
var ulNode = document.getElementById("container");
var fragment = document.createDocumentFragment();
var liNode, i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    liNode.addEventListener("click", liFnCb, false);
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);
</code>
这里每个li元素都需要执行一次<code>addEventListener()</code>方法，如果li元素数量一多，就会降低效率。所以我们可以通过事件代理的方式，将事件绑定在ul上，然后通过<code>event.target</code>来确定被点击的元素是否是li元素，同时我们也可以使用<code>innerHTML</code>属性一次性创建节点了，修改代码为：
<code>javascript
var ulNode = document.getElementById("container");
var fragmentHtml = "", i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += "&lt;li&gt;" + data[i] + "&lt;/li&gt;";
}
ulNode.innerHTML = fragmentHtml;
ulNode.addEventListener("click", function(evt){
    if(evt.target.tagName.toLowerCase() === 'li') {
        liFnCb.call(evt.target, evt);
    }
}, false);
</code>
这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/25/performance-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（DOM操作篇） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/25/performance-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="dom">缓存DOM对象</h2>
<p>JavaScript的DOM操作可以说是JavaScript最重要的功能，我们经常要根据用户的操作来动态的增加和删除元素，或是通过AJAX返回的数据动态生成元素。比如我们获得了一个很多元素的数组<code>data[]</code>，需要将其每个值生成一个li元素插入到一个id为container的ul元素中，最简单（最慢）的方式是：</p>

<p><code>javascript
var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    document.getElementById("container").appendChild(liNode);
}
</code></p>

<p>这里每一次循环都会去查找id为container的元素，效率自然非常低，所以我们需要将元素在循环前查询完毕，在循环中仅仅是引用就行了，修改代码为：</p>

<p><code>javascript
var ulNode = document.getElementById("container");
var liNode, i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    ulNode.appendChild(liNode);
}
</code></p>

<p>缓存DOM对象的方式也经常被用在元素的查找中，查找元素应该是DOM操作中最频繁的操作了，其效率优化也是大头。在一般情况下，我们会根据需要，将一些频繁被查找的元素缓存起来，在查找它或查找它的子孙元素时，以它为起点进行查找，就能提高查找效率了。</p>

<h2 id="section">在内存中操作元素</h2>
<p>由于DOM操作会导致浏览器的回流，回流需要花费大量的时间进行样式计算和节点重绘与渲染，所以应当尽量减少回流次数。一种可靠的方法就是加入元素时不要修改页面上已经存在的元素，而是在内存中的节点进行大量的操作，最后再一并将修改运用到页面上。DOM操作本身提供一个创建内存节点片段的功能:<code>document.createDocumentFragment()</code>，我们可以将其运用于上述代码中：
<code>javascript
var ulNode = document.getElementById("container");
var liNode, i, m;
var fragment = document.createDocumentFragment();
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);
</code>
这样就只会触发一次回流，效率会得到很大的提升。如果需要对一个元素进行复杂的操作（删减、添加子节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个（<code>cloneNode()</code>），在内存中进行操作后再替换原来的节点</p>

<h2 id="dom-1">一次性DOM节点生成</h2>
<p>在这里我们每次都需要生成节点（<code>document.createElement("li")</code>），然后将其加入到内存片段中，我们可以通过<code>innerHTML</code>属性来一次性生成节点，具体的思路就是使用字符串拼接的方式，先生成相应的HTML字符串，最后一次性写入到ul的innerHTML中。修改代码为：
<code>javascript
var ulNode = document.getElementById("container");
var fragmentHtml = "", i, m;
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += "&lt;li&gt;" + data[i] + "&lt;/li&gt;";
}
ulNode.innerHTML = fragmentHtml;
</code>
这样效率也会有提升，不过手动拼写字符串是相当麻烦的一件事</p>

<h2 id="section-1">通过类修改样式</h2>
<p>有时候我们需要通过JavaScript给元素增加样式，比如如下代码：
<code>javascript
element.style.fontWeight = 'bold';
element.style.backgroundImage = 'url(back.gif)';
element.style.backgroundColor = 'white';
element.style.color = 'white';
//...
</code>
这样效率很低，每次修改style属性后都会触发元素的重绘，如果修改了的属性涉及大小和位置，将会导致回流。所以我们应当尽量避免多次为一个元素设置style属性，应当通过给其添加新的CSS类，来修改其CSS
<code>css
.element {
    background-image: url(back.gif);
    background-color: #fff;
    color: #fff;
    font-weight: 'bold';
    /*...*/
}
</code></p>

<p><code>javascript
element.className += " element";
</code></p>

<h2 id="section-2">通过事件代理批量操作事件</h2>
<p>还是之前那个ul和添加li，如果我们需要给每个li都绑定一个click事件，就可能写出类似如下代码：
<code>javascript
var ulNode = document.getElementById("container");
var fragment = document.createDocumentFragment();
var liNode, i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    liNode = document.createElement("li");
    liNode.innerText = data[i];
    liNode.addEventListener("click", liFnCb, false);
    fragment.appendChild(liNode);
}
ulNode.appendChild(fragment);
</code>
这里每个li元素都需要执行一次<code>addEventListener()</code>方法，如果li元素数量一多，就会降低效率。所以我们可以通过事件代理的方式，将事件绑定在ul上，然后通过<code>event.target</code>来确定被点击的元素是否是li元素，同时我们也可以使用<code>innerHTML</code>属性一次性创建节点了，修改代码为：
<code>javascript
var ulNode = document.getElementById("container");
var fragmentHtml = "", i, m;
var liFnCb = function(evt){
    //do something
};
for (i = 0, m = data.length; i &lt; m; i++) {
    fragmentHtml += "&lt;li&gt;" + data[i] + "&lt;/li&gt;";
}
ulNode.innerHTML = fragmentHtml;
ulNode.addEventListener("click", function(evt){
    if(evt.target.tagName.toLowerCase() === 'li') {
        liFnCb.call(evt.target, evt);
    }
}, false);
</code>
这样事件绑定的代码就只要执行一次，可以监听所有li元素的事件了。当然如果需要移除事件回调函数，我们也不需要循环遍历所有的li元素，只需要移除ul元素上的事件处理就行了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/25/performance-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（26-35） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/24/js-interview-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第二十六题</h2>
<p>简述一下什么是JSONP？它与AJAX有什么不同？</p>

<h3 id="jsonp">JSONP是什么</h3>
<p>JSONP看似和JSON很像，但实际上完全不同，JSON是一种数据交换格式，而JSONP则是一种非官方跨域数据交互协议。由于在页面中，Ajax直接请求存在跨域无权限访问的问题，但使用拥有<code>src</code>属性的标签（<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;iframe&gt;</code>）能不受跨域影响，所以一种比较普遍的方式就是通过<code>&lt;script&gt;</code>标签包裹可执行的JavaScript代码，代码内部包含请求所需要的数据和请求响应后需要被触发的回调函数。为了便于客户端使用数据，逐渐就形成了JSONP。它的一个要点就是允许用户传递一个回调函数的参数给服务端，然后服务端将JSON数据包裹在这个回调函数中，这样客户端就可以随意定制自己的函数来自动处理返回的数据了</p>

<h3 id="jsonp-1">简单的JSONP实现</h3>
<p>一个简单的实现：
```javascript
function getComments(data){
    console.log(data);
}</p>

<p>function getJSON(url){
    var script = document.createElement(‘script’);
    script.setAttribute(‘src’, url);
    document.head.appendChild(script);
}</p>

<p>getJSON(“http://api.duoshuo.com/threads/counts.jsonp?short_name=skyinlayer&amp;threads=/blog/2014/03/20/js-interview-2&amp;callback=getComments”);
<code>
这里通过JSONP去获取我在多说中的一篇文章下的所有评论，并通过`getComments()`方法显示出来，由于JSONP返回的数据一定是一段可执行的JavaScript代码，所以通过将其包裹在`&lt;script&gt;`标签中，在获取后执行。可以看一下获取到的实际内容：
</code>javascript
getComments({“response”:{“\/blog\/2014\/03\/20\/js-interview-2”:{“thread_id”:”1158950126861942862”,”channel_key”:null,”thread_key”:”\/blog\/2014\/03\/20\/js-interview-2”,”comments”:0,”reposts”:0,”likes”:0,”weibo_reposts”:0,”qqt_reposts”:0}},”options”:{“comments_zero”:”暂无评论”,”comments_one”:”1”,”comments_multiple”:”{num}”},”code”:0});
<code>
不是很好看，格式化一下：
</code>javascript
getComments({
    “response”: {
        “\/blog\/2014\/03\/20\/js-interview-2”: {
            “thread_id”: “1158950126861942862”,
            “channel_key”: null,
            “thread_key”: “\/blog\/2014\/03\/20\/js-interview-2”,
            “comments”: 0,
            “reposts”: 0,
            “likes”: 0,
            “weibo_reposts”: 0,
            “qqt_reposts”: 0
        }
    },
    “options”: {
        “comments_zero”: “暂无评论”,
        “comments_one”: “1”,
        “comments_multiple”: “{num}”
    },
    “code”: 0
});
```
这样就一目了然了，其实JSONP返回的就是一个函数调用，具体调用的函数名称就是我们传递给服务器的callback方法，由于我们自己定义了处理函数，只需要将数据作为参数，调用这个函数就行了</p>

<h3 id="jqueryjsonp">jQuery中的JSONP</h3>
<p>jQuery中可以使用<code>.getJSON()</code>方法来使用JSONP，如果在url中出现了类似<code>callback=?</code>字段，jQuery将会使用JSONP的方式进行处理</p>

<p>jQuery还提供了<code>.ajax</code>方法，将其<code>dataType</code>设置成<code>jsonp</code>就能按照JSONP方式获取数据，但实际上JSONP和ajax是两码事，jQuery只是为了方便使用将其包裹在一起，这也是很多人（包括我）误以为JSONP就是Ajax的原因</p>

<p>jQuery的JSONP实现机制一样，不过它做了一层封装，生成了一个随机的函数名进行JSONP请求，生成的JSONP回调函数名称大致如下<code>jQuery200001010612421669066_1395458842940</code>,它内部会定义一个同名函数，在其内部调用我们传给jQuery的回调函数</p>

<h2 id="section-1">第二十七题</h2>
<p>JavaScript中的null、undefined、undeclared的区别</p>

<p>解答：首先需要明确的是，<code>null</code>、<code>undefined</code>是JavaScript中的两个值类型，而<code>undeclared</code>则是语法错误，表明变量未定义。<code>typeof null</code>的值是<code>'object'</code>，这也就说明了null的意思是变量是一个不存在的对象（但它还是对象），而undefined则代表着变量已经声明，但未赋值</p>

<h2 id="section-2">第二十八题</h2>
<p>实现一个如下的数组复制方法：<code>[1,2,3,4,5].duplicator()</code>，返回结果<code>[1,2,3,4,5,1,2,3,4,5]</code></p>

<p>解答：
这题看似很简单，但是数组内部的元素并没有确定，所以完全可能是对象甚至是数组，所以这题实际上是考的深度复制，相当复杂：
```javascript
Object.prototype.deepClone = function() {
    var result = Object.prototype.toString.call(this) === ‘[object Array]’ ? [] : {},
        hasOwnProperty = Object.prototype.hasOwnProperty,
        deepClone = Object.prototype.deepClone,
        item,
        tmp;
    for (item in this) {
        tmp = this[item];
        if(typeof item === ‘object’){
            result[item] = tmp.deepClone();
        } else {
            result[item] = tmp;
        }
    }
    return result;
};</p>

<p>Array.prototype.duplicator = function(){
    return this.concat(this.deepClone());
};</p>

<p>var arr = [1,2,3,4,5];
console.log(arr.duplicator());
```</p>

<h2 id="section-3">第二十九题</h2>
<p>谈谈你对Web标准的理解</p>

<p>参考资料： <a href="http://www.alibuybuy.com/posts/55190.html">浅谈web标准、可用性、可访问性</a></p>

<h3 id="web">什么是Web标准</h3>
<p>Web标准不是一个标准，而是一系列标准的集合。网页主要由三部分组成：结构、表现和行为。对应的标准也分为三个方面：结构化标准语言（XHTML、XML），表现标准语言（CSS），行为标准主要包括对象模型（W3C DOM）、ECMAScript等</p>

<h3 id="web-1">为什么要遵循Web标准</h3>
<p>遵循Web标准有如下优点：
1. 代码的效率：在HTML文件中使用最精简的代码，而把样式也页面布局信息包含进CSS文件中。放在服务器上的文件会变小，下载文件需要时间短。同时CSS文件支持缓存，加载速度更快
2. 易于维护：页面的样式和布局信息保存在单独的CSS文件中，可在多个页面中引入相同的CSS文件达到网站的一致性，同时需要修改时也仅仅需要修改单独的CSS文件中内容，更加易于维护
3. 可访问性：对于那些视力受损（盲人、色盲、色弱等等）的用户，通过屏幕阅读器使用键盘命令将网页的内容读给他们听。以语义化的HTML（结构和表现相分离的HTML）编写的网页文件，就可以让此类用户更容易导航，且网页文件中的总要信息也更有可能被这些用户找到
4. 设备兼容性：纯HTML，无附加样式信息，可以针对具有不同特点的设备而被重新格式胡，只需要引入另外一套样式表即可。同时CSS本身也可以让你为不同的呈现方式和媒体类型规定不同而样式表
5. 网络爬虫/搜索引擎：搜索引擎使用“爬虫”，解析网页。语义化的HTML能更加快速的被解析，从而知道哪些才是重要的内容，会极大的影响网页在搜索结果中排名</p>

<h2 id="section-4">第三十题</h2>
<p>简述XMLHttpRequest对象，并说明其如何使用</p>

<h3 id="xmlhttprequst">什么是XMLHttpRequst对象</h3>
<p>XMLHttpRequest对象是Ajax的核心，用于在后台与服务器中交换数据，使用它能够：
1. 在不重新加载页面的情况下更新网页
2. 在页面已加载后从服务器请求数据
3. 在页面已加载后从服务器接收数据
4. 在后台服务器发送数据</p>

<p>需要注意的是所有现代浏览器都支持XMLHttpRequest，但它并不再W3C标准的定义之中…</p>

<h3 id="section-5">如何使用</h3>
<p><code>javascript
//创建一个XMLHttpRequest对象
var xhr = new XMLHttpRequest();
//定义请求方法
var type = "GET";
//定义获取数据的URL
var url = "/someAction"
//定义异步执行还是同步执行
var aysnc = true;
//定义需要发送的数据
var data = JSON.stringify({
    param : "someProperty"
});
//确定XMLHttpRequest状态变换时的回调函数
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
        //loaded
        if(xhr.status === 200){
            //200 成功
        } else {
            //失败
        }
    }
};
//确定XMLHttpRequest执行的参数
xhr.open(type, url, async);
//发送请求
xhr.send(data);
</code></p>

<h2 id="section-6">第三十一题</h2>
<p>简述网页的可用性、可访问性</p>

<h3 id="section-7">什么是可用性？</h3>
<p>可用性（Usability）指的是产品对用户来说有效、易学、高效、好记、少错和令人满意程度，是交互式产品额重要质量指标，是产品竞争力的核心</p>

<h3 id="section-8">什么是可访问性？</h3>
<p>可访问性（Acessibility）指的是：Web内容对于残障用户的可阅读和可理解性。同时提升可访问性也可以让普通用户更容易理解Web内容</p>

<h2 id="section-9">第三十二题</h2>
<p>DOM操作，如何添加、移除、移动、复制、创建和查找节点</p>

<p>创建节点：
1. createDocumentFragment()
2. createElement()
3. createTextNode()
4. cloneNode() （可传入bool型参数表明是否复制所有子节点）</p>

<p>添加：
1. appendChild()</p>

<p>移除：
1. removeChild()</p>

<p>替换：
1. replaceChild()</p>

<p>插入：
1. insertBefore()将新元素做为父元素的最后一个子元素进行添加</p>

<p>查找：
1. getElementsByTagName()：通过标签查找，返回一个类似数组的Object对象
2. getElementsByName(): 通过Name属性查找，返回一个类似数组的Object对象
3. getElementById()：通过元素id查找，返回一个DOM对象，否则返回null</p>

<p>修改：
1. innerHTML改变节点内部结构
2. style.property改变样式</p>

<p>遍历：
1. childNodes 获取所有子元素的列表</p>

<p>属性
1. getAttribute()
2. setAttribute()</p>

<h2 id="section-10">第三十三题</h2>
<p>简介HMTL5中的语义元素</p>

<h3 id="section-11">语义化元素的优点</h3>
<ol>
  <li>使网页结构更清晰</li>
  <li>使代码可读性增强，便于修改和维护</li>
  <li>可访问性</li>
  <li>搜索引擎优化
###article
代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。article通常有自己的标题（一般放在一个header元素里面），有时候还会有自己的脚注（放在其footer元素中）
###section
用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。如果一个容器只是为了被定义样式或通过脚本定义行为时，建议使用div。需要给section增加一个标题，不建议给没有标题的内容区块使用section元素</li>
</ol>

<p>不要将secion和article混淆使用，article元素可以看成一种特殊种类的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而artcle强调独立性，具体来说，如果一块内容相对来说比较独立、完整的时候，应该使用article，如果想将一块内容分成几段，应该使用section
###nav
一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。一般只将主要的、基本的链接组元素放进nav元素即可
###aside
用来表示当前页面或文章的附属信息部分，它可以包含当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。它主要由两种用法
1. 被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的参考资料、名词解释等等
2. 在article元素之外使用，作为页面或站点全局的附属信息部分</p>

<h3 id="time">time与微格式</h3>
<p>微格式，是一个利用HTML的class属性来网页添加附加信息的方法</p>

<p>time用来无歧义地、明确地对机器的日期和时间进行编码，并且让人易读的方式来展现他，它有一个pubdate可选属性（boolean值），用于表示这个time元素代表了文章（存在于article元素中时）或整个网页的发布日期</p>

<h3 id="header">header</h3>
<p>一种具有引导和导航作用的结构元素，通常用来防止整个页面或页面内的一个内容区块的标题，但也可以包含其他内容。一个网页并未限制header元素的个数，可以拥有多个，可以为每个内容区块（article、section）增加一个header元素。HTML5中，一个header元素至少要包含一个heading元素（h1~h6），也可以包括一个hgroup元素，最新的W3C HTML5标准，它还可以包括nav元素</p>

<h3 id="hgroup">hgroup</h3>
<p>将标题及其子标题进行分组的元素，通常会将h1~h6元素进行分组</p>

<h3 id="footer">footer</h3>
<p>作为其上层父级内容区块或是一个根区块的脚注，通常包括其相关区块的脚注信息。页面中也未限制footer元素的个数，也可以为article元素或section元素添加footer元素
###address
用来呈现联系信息，包括文档作者或文档维护者的名字、他们的网站链接、电子邮箱、真实地址、电话号码等</p>

<h3 id="section-12">兼容性</h3>
<p>也可以通过js插件的形式为不支持HTML5语义化元素的浏览器添加HTML5元素支持，一般是使用<code>html5shiv</code>
<code>html
&lt;!--[if lt IE 9]&gt;
&lt;script src="dist/html5shiv.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code>
##第三十四题
什么是事件的冒泡？如何阻止冒泡？如何阻止事件的默认行为？什么是事件代理？</p>

<h3 id="section-13">事件的冒泡</h3>
<p>在某个元素上触发某类事件，这个事件会向元素的父级元素传播，由里到外，直至它被处理或者它到达了元素层次的最顶层</p>

<p>另外关于事件的几个需要注意的地方：
1. 事件冒泡只是事件处理方式的一种，一共有两种事件处理的方式 1) 从里到外的冒泡型事件  2) 从外到里的捕获型事件
2. 不是所有时间都能冒泡，有很多事件不冒泡：<code>blur</code>、<code>focus</code>、<code>load</code>、<code>unload</code>
3. 阻止冒泡不能阻止对象的默认行为</p>

<h3 id="section-14">阻止冒泡</h3>
<p>可以使用<code>event.stopPropagation()</code>来阻止冒泡</p>

<p>比如如下HTML结构：
<code>html
&lt;div id="parent"&gt;
    &lt;p&gt;这是父元素&lt;/p&gt;
    &lt;div id="child"&gt;这是子元素&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>为其添加事件处理器：
<code>javascript
var parent = document.getElementById("parent");
var child = document.getElementById("child");
var clickHandler = function(evt){
    console.log(this.id + " is clicked");
};
//采用冒泡方式处理事件，如果要采用捕获方式处理，将第三个参数改为true
parent.addEventListener("click", clickHandler, false);
child.addEventListener("click", clickHandler, false);
</code></p>

<p>点击子元素后可以看到console框中出现如下结果</p>

<p><img src="http://lingyu.wang/img/fe_interview/6.png" alt="console中显示parent元素和child元素都被点击了" /></p>

<p>修改处理函数，添加<code>stopPropagaton()</code>方法：
<code>javascript
var clickHandler = function(evt){
    console.log(this.id + " is clicked");
    evt.stopPropagation();
};
</code></p>

<p>再次点击子元素，console中将是如下结果</p>

<p><img src="http://lingyu.wang/img/fe_interview/7.png" alt="console中仅显示child元素都被点击了" /></p>

<h3 id="section-15">阻止事件的默认行为</h3>
<p>在平常我们经常会遇到一个表单中有个提交按钮（type为submit），用于提交表单，但是我们不希望它直接提交，而是希望将其元素值提取之后进行ajax交互，于是就需要屏蔽提交按钮默认行为</p>

<p>我们可以使用<code>event.preventDefault()</code>来阻止元素事件的默认行为</p>

<h3 id="section-16">事件代理</h3>
<p>如果我们有一个ul元素，其中有100个li元素，每个点击都会触发一个相同的点击事件，那么我们可能需要为这100个li元素各绑定一个回调函数，费时费力费内存。由于事件的冒泡机制，我们可以通过事件代理的方式，只在ul元素上绑定一个click事件，然后确定其event.target对象是否是li元素就行了,如下例所示：</p>

<p>有一个ul元素，其中5个li元素：
<code>html
&lt;ul id="ul"&gt;
   &lt;li value='1'&gt;1&lt;/li&gt;
   &lt;li value='2'&gt;2&lt;/li&gt;
   &lt;li value='3'&gt;3&lt;/li&gt;
   &lt;li value='4'&gt;4&lt;/li&gt;
   &lt;li value='5'&gt;5&lt;/li&gt;
&lt;/ul&gt;
</code></p>

<p>为ul元素绑定一个click事件回调函数来处理所有li元素的click事件</p>

<p><code>javascript
var ul = document.getElementById("ul");
ul.addEventListener("click", function(evt){
    if(evt.target.tagName === 'LI'){
        console.log("li " + evt.target.getAttribute("value") + " is clicked");
    }
}, false);
</code></p>

<p>点击各个li查看效果：</p>

<p><img src="http://lingyu.wang/img/fe_interview/8.png" alt="各个li元素被点击时都会触发事件并显示哪个li元素被点击" /></p>

<p>这样我们就可以通过为ul增加一个事件代理来处理所有li元素的点击事件了。同理，我们可以使用事件代理让一个元素下的不同子元素共享一个事件处理逻辑</p>

<h2 id="section-17">第三十五题</h2>
<p>简述伪类和伪元素有什么异同，并写出几个常见的伪类和伪元素</p>

<p>相当多的人将伪类和伪元素相混淆</p>

<h3 id="section-18">相同点</h3>
<p>他们的共同点在于，他们都属于CSS选择器的范畴，CSS引入伪类和伪元素的概念是为了实现基于文档树之外的信息的格式化造成伪类和伪元素混淆的最基本原因，就是他们俩可以使用相同的语法进行添加：</p>

<p><code>css
.someclass:before {}
.someclass:hover {}
</code></p>

<h3 id="section-19">不同点</h3>
<ol>
  <li>伪类时根据元素所具有的不同状态来添加相应的样式，而伪元素则是对元素中特定的内容添加相应的样式</li>
  <li>伪元素和伪类使用语法可以不同，伪元素可以使用<code>::before</code>这样的双冒号来使用（当然使用单冒号也可以），而伪类不行</li>
  <li>伪元素和伪类进行选择器优先级计算时不同，伪元素与标签选择器的优先级为0001，而伪类的优先级与类选择器的优先级一样为0010</li>
</ol>

<h3 id="section-20">一些例子</h3>
<p><code>before</code>,<code>after</code>,<code>first-line</code>,<code>first-letter</code>都是伪元素，而像<code>link</code>,<code>visited</code>,<code>hover</code>,<code>active</code>,<code>first-child</code>,<code>lang</code>,<code>focus</code>等都是伪类</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/24/js-interview-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（26-35） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/24/js-interview-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第二十六题</h2>
<p>简述一下什么是JSONP？它与AJAX有什么不同？</p>

<h3 id="jsonp">JSONP是什么</h3>
<p>JSONP看似和JSON很像，但实际上完全不同，JSON是一种数据交换格式，而JSONP则是一种非官方跨域数据交互协议。由于在页面中，Ajax直接请求存在跨域无权限访问的问题，但使用拥有<code>src</code>属性的标签（<code>&lt;script&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;iframe&gt;</code>）能不受跨域影响，所以一种比较普遍的方式就是通过<code>&lt;script&gt;</code>标签包裹可执行的JavaScript代码，代码内部包含请求所需要的数据和请求响应后需要被触发的回调函数。为了便于客户端使用数据，逐渐就形成了JSONP。它的一个要点就是允许用户传递一个回调函数的参数给服务端，然后服务端将JSON数据包裹在这个回调函数中，这样客户端就可以随意定制自己的函数来自动处理返回的数据了</p>

<h3 id="jsonp-1">简单的JSONP实现</h3>
<p>一个简单的实现：
```javascript
function getComments(data){
    console.log(data);
}</p>

<p>function getJSON(url){
    var script = document.createElement(‘script’);
    script.setAttribute(‘src’, url);
    document.head.appendChild(script);
}</p>

<p>getJSON(“http://api.duoshuo.com/threads/counts.jsonp?short_name=skyinlayer&amp;threads=/blog/2014/03/20/js-interview-2&amp;callback=getComments”);
<code>
这里通过JSONP去获取我在多说中的一篇文章下的所有评论，并通过`getComments()`方法显示出来，由于JSONP返回的数据一定是一段可执行的JavaScript代码，所以通过将其包裹在`&lt;script&gt;`标签中，在获取后执行。可以看一下获取到的实际内容：
</code>javascript
getComments({“response”:{“\/blog\/2014\/03\/20\/js-interview-2”:{“thread_id”:”1158950126861942862”,”channel_key”:null,”thread_key”:”\/blog\/2014\/03\/20\/js-interview-2”,”comments”:0,”reposts”:0,”likes”:0,”weibo_reposts”:0,”qqt_reposts”:0}},”options”:{“comments_zero”:”暂无评论”,”comments_one”:”1”,”comments_multiple”:”{num}”},”code”:0});
<code>
不是很好看，格式化一下：
</code>javascript
getComments({
    “response”: {
        “\/blog\/2014\/03\/20\/js-interview-2”: {
            “thread_id”: “1158950126861942862”,
            “channel_key”: null,
            “thread_key”: “\/blog\/2014\/03\/20\/js-interview-2”,
            “comments”: 0,
            “reposts”: 0,
            “likes”: 0,
            “weibo_reposts”: 0,
            “qqt_reposts”: 0
        }
    },
    “options”: {
        “comments_zero”: “暂无评论”,
        “comments_one”: “1”,
        “comments_multiple”: “{num}”
    },
    “code”: 0
});
```
这样就一目了然了，其实JSONP返回的就是一个函数调用，具体调用的函数名称就是我们传递给服务器的callback方法，由于我们自己定义了处理函数，只需要将数据作为参数，调用这个函数就行了</p>

<h3 id="jqueryjsonp">jQuery中的JSONP</h3>
<p>jQuery中可以使用<code>.getJSON()</code>方法来使用JSONP，如果在url中出现了类似<code>callback=?</code>字段，jQuery将会使用JSONP的方式进行处理</p>

<p>jQuery还提供了<code>.ajax</code>方法，将其<code>dataType</code>设置成<code>jsonp</code>就能按照JSONP方式获取数据，但实际上JSONP和ajax是两码事，jQuery只是为了方便使用将其包裹在一起，这也是很多人（包括我）误以为JSONP就是Ajax的原因</p>

<p>jQuery的JSONP实现机制一样，不过它做了一层封装，生成了一个随机的函数名进行JSONP请求，生成的JSONP回调函数名称大致如下<code>jQuery200001010612421669066_1395458842940</code>,它内部会定义一个同名函数，在其内部调用我们传给jQuery的回调函数</p>

<h2 id="section-1">第二十七题</h2>
<p>JavaScript中的null、undefined、undeclared的区别</p>

<p>解答：首先需要明确的是，<code>null</code>、<code>undefined</code>是JavaScript中的两个值类型，而<code>undeclared</code>则是语法错误，表明变量未定义。<code>typeof null</code>的值是<code>'object'</code>，这也就说明了null的意思是变量是一个不存在的对象（但它还是对象），而undefined则代表着变量已经声明，但未赋值</p>

<h2 id="section-2">第二十八题</h2>
<p>实现一个如下的数组复制方法：<code>[1,2,3,4,5].duplicator()</code>，返回结果<code>[1,2,3,4,5,1,2,3,4,5]</code></p>

<p>解答：
这题看似很简单，但是数组内部的元素并没有确定，所以完全可能是对象甚至是数组，所以这题实际上是考的深度复制，相当复杂：
```javascript
Object.prototype.deepClone = function() {
    var result = Object.prototype.toString.call(this) === ‘[object Array]’ ? [] : {},
        hasOwnProperty = Object.prototype.hasOwnProperty,
        deepClone = Object.prototype.deepClone,
        item,
        tmp;
    for (item in this) {
        tmp = this[item];
        if(typeof item === ‘object’){
            result[item] = tmp.deepClone();
        } else {
            result[item] = tmp;
        }
    }
    return result;
};</p>

<p>Array.prototype.duplicator = function(){
    return this.concat(this.deepClone());
};</p>

<p>var arr = [1,2,3,4,5];
console.log(arr.duplicator());
```</p>

<h2 id="section-3">第二十九题</h2>
<p>谈谈你对Web标准的理解</p>

<p>参考资料： <a href="http://www.alibuybuy.com/posts/55190.html">浅谈web标准、可用性、可访问性</a></p>

<h3 id="web">什么是Web标准</h3>
<p>Web标准不是一个标准，而是一系列标准的集合。网页主要由三部分组成：结构、表现和行为。对应的标准也分为三个方面：结构化标准语言（XHTML、XML），表现标准语言（CSS），行为标准主要包括对象模型（W3C DOM）、ECMAScript等</p>

<h3 id="web-1">为什么要遵循Web标准</h3>
<p>遵循Web标准有如下优点：
1. 代码的效率：在HTML文件中使用最精简的代码，而把样式也页面布局信息包含进CSS文件中。放在服务器上的文件会变小，下载文件需要时间短。同时CSS文件支持缓存，加载速度更快
2. 易于维护：页面的样式和布局信息保存在单独的CSS文件中，可在多个页面中引入相同的CSS文件达到网站的一致性，同时需要修改时也仅仅需要修改单独的CSS文件中内容，更加易于维护
3. 可访问性：对于那些视力受损（盲人、色盲、色弱等等）的用户，通过屏幕阅读器使用键盘命令将网页的内容读给他们听。以语义化的HTML（结构和表现相分离的HTML）编写的网页文件，就可以让此类用户更容易导航，且网页文件中的总要信息也更有可能被这些用户找到
4. 设备兼容性：纯HTML，无附加样式信息，可以针对具有不同特点的设备而被重新格式胡，只需要引入另外一套样式表即可。同时CSS本身也可以让你为不同的呈现方式和媒体类型规定不同而样式表
5. 网络爬虫/搜索引擎：搜索引擎使用“爬虫”，解析网页。语义化的HTML能更加快速的被解析，从而知道哪些才是重要的内容，会极大的影响网页在搜索结果中排名</p>

<h2 id="section-4">第三十题</h2>
<p>简述XMLHttpRequest对象，并说明其如何使用</p>

<h3 id="xmlhttprequst">什么是XMLHttpRequst对象</h3>
<p>XMLHttpRequest对象是Ajax的核心，用于在后台与服务器中交换数据，使用它能够：
1. 在不重新加载页面的情况下更新网页
2. 在页面已加载后从服务器请求数据
3. 在页面已加载后从服务器接收数据
4. 在后台服务器发送数据</p>

<p>需要注意的是所有现代浏览器都支持XMLHttpRequest，但它并不再W3C标准的定义之中…</p>

<h3 id="section-5">如何使用</h3>
<p><code>javascript
//创建一个XMLHttpRequest对象
var xhr = new XMLHttpRequest();
//定义请求方法
var type = "GET";
//定义获取数据的URL
var url = "/someAction"
//定义异步执行还是同步执行
var aysnc = true;
//定义需要发送的数据
var data = JSON.stringify({
    param : "someProperty"
});
//确定XMLHttpRequest状态变换时的回调函数
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){
        //loaded
        if(xhr.status === 200){
            //200 成功
        } else {
            //失败
        }
    }
};
//确定XMLHttpRequest执行的参数
xhr.open(type, url, async);
//发送请求
xhr.send(data);
</code></p>

<h2 id="section-6">第三十一题</h2>
<p>简述网页的可用性、可访问性</p>

<h3 id="section-7">什么是可用性？</h3>
<p>可用性（Usability）指的是产品对用户来说有效、易学、高效、好记、少错和令人满意程度，是交互式产品额重要质量指标，是产品竞争力的核心</p>

<h3 id="section-8">什么是可访问性？</h3>
<p>可访问性（Acessibility）指的是：Web内容对于残障用户的可阅读和可理解性。同时提升可访问性也可以让普通用户更容易理解Web内容</p>

<h2 id="section-9">第三十二题</h2>
<p>DOM操作，如何添加、移除、移动、复制、创建和查找节点</p>

<p>创建节点：
1. createDocumentFragment()
2. createElement()
3. createTextNode()
4. cloneNode() （可传入bool型参数表明是否复制所有子节点）</p>

<p>添加：
1. appendChild()</p>

<p>移除：
1. removeChild()</p>

<p>替换：
1. replaceChild()</p>

<p>插入：
1. insertBefore()将新元素做为父元素的最后一个子元素进行添加</p>

<p>查找：
1. getElementsByTagName()：通过标签查找，返回一个类似数组的Object对象
2. getElementsByName(): 通过Name属性查找，返回一个类似数组的Object对象
3. getElementById()：通过元素id查找，返回一个DOM对象，否则返回null</p>

<p>修改：
1. innerHTML改变节点内部结构
2. style.property改变样式</p>

<p>遍历：
1. childNodes 获取所有子元素的列表</p>

<p>属性
1. getAttribute()
2. setAttribute()</p>

<h2 id="section-10">第三十三题</h2>
<p>简介HMTL5中的语义元素</p>

<h3 id="section-11">语义化元素的优点</h3>
<ol>
  <li>使网页结构更清晰</li>
  <li>使代码可读性增强，便于修改和维护</li>
  <li>可访问性</li>
  <li>搜索引擎优化
###article
代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。article通常有自己的标题（一般放在一个header元素里面），有时候还会有自己的脚注（放在其footer元素中）
###section
用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。如果一个容器只是为了被定义样式或通过脚本定义行为时，建议使用div。需要给section增加一个标题，不建议给没有标题的内容区块使用section元素</li>
</ol>

<p>不要将secion和article混淆使用，article元素可以看成一种特殊种类的section元素，它比section元素更强调独立性。即section元素强调分段或分块，而artcle强调独立性，具体来说，如果一块内容相对来说比较独立、完整的时候，应该使用article，如果想将一块内容分成几段，应该使用section
###nav
一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。一般只将主要的、基本的链接组元素放进nav元素即可
###aside
用来表示当前页面或文章的附属信息部分，它可以包含当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有别于主要内容的部分。它主要由两种用法
1. 被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的参考资料、名词解释等等
2. 在article元素之外使用，作为页面或站点全局的附属信息部分</p>

<h3 id="time">time与微格式</h3>
<p>微格式，是一个利用HTML的class属性来网页添加附加信息的方法</p>

<p>time用来无歧义地、明确地对机器的日期和时间进行编码，并且让人易读的方式来展现他，它有一个pubdate可选属性（boolean值），用于表示这个time元素代表了文章（存在于article元素中时）或整个网页的发布日期</p>

<h3 id="header">header</h3>
<p>一种具有引导和导航作用的结构元素，通常用来防止整个页面或页面内的一个内容区块的标题，但也可以包含其他内容。一个网页并未限制header元素的个数，可以拥有多个，可以为每个内容区块（article、section）增加一个header元素。HTML5中，一个header元素至少要包含一个heading元素（h1~h6），也可以包括一个hgroup元素，最新的W3C HTML5标准，它还可以包括nav元素</p>

<h3 id="hgroup">hgroup</h3>
<p>将标题及其子标题进行分组的元素，通常会将h1~h6元素进行分组</p>

<h3 id="footer">footer</h3>
<p>作为其上层父级内容区块或是一个根区块的脚注，通常包括其相关区块的脚注信息。页面中也未限制footer元素的个数，也可以为article元素或section元素添加footer元素
###address
用来呈现联系信息，包括文档作者或文档维护者的名字、他们的网站链接、电子邮箱、真实地址、电话号码等</p>

<h3 id="section-12">兼容性</h3>
<p>也可以通过js插件的形式为不支持HTML5语义化元素的浏览器添加HTML5元素支持，一般是使用<code>html5shiv</code>
<code>html
&lt;!--[if lt IE 9]&gt;
&lt;script src="dist/html5shiv.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code>
##第三十四题
什么是事件的冒泡？如何阻止冒泡？如何阻止事件的默认行为？什么是事件代理？</p>

<h3 id="section-13">事件的冒泡</h3>
<p>在某个元素上触发某类事件，这个事件会向元素的父级元素传播，由里到外，直至它被处理或者它到达了元素层次的最顶层</p>

<p>另外关于事件的几个需要注意的地方：
1. 事件冒泡只是事件处理方式的一种，一共有两种事件处理的方式 1) 从里到外的冒泡型事件  2) 从外到里的捕获型事件
2. 不是所有时间都能冒泡，有很多事件不冒泡：<code>blur</code>、<code>focus</code>、<code>load</code>、<code>unload</code>
3. 阻止冒泡不能阻止对象的默认行为</p>

<h3 id="section-14">阻止冒泡</h3>
<p>可以使用<code>event.stopPropagation()</code>来阻止冒泡</p>

<p>比如如下HTML结构：
<code>html
&lt;div id="parent"&gt;
    &lt;p&gt;这是父元素&lt;/p&gt;
    &lt;div id="child"&gt;这是子元素&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>为其添加事件处理器：
<code>javascript
var parent = document.getElementById("parent");
var child = document.getElementById("child");
var clickHandler = function(evt){
    console.log(this.id + " is clicked");
};
//采用冒泡方式处理事件，如果要采用捕获方式处理，将第三个参数改为true
parent.addEventListener("click", clickHandler, false);
child.addEventListener("click", clickHandler, false);
</code></p>

<p>点击子元素后可以看到console框中出现如下结果</p>

<p><img src="http://lingyu.wang/img/fe_interview/6.png" alt="console中显示parent元素和child元素都被点击了" /></p>

<p>修改处理函数，添加<code>stopPropagaton()</code>方法：
<code>javascript
var clickHandler = function(evt){
    console.log(this.id + " is clicked");
    evt.stopPropagation();
};
</code></p>

<p>再次点击子元素，console中将是如下结果</p>

<p><img src="http://lingyu.wang/img/fe_interview/7.png" alt="console中仅显示child元素都被点击了" /></p>

<h3 id="section-15">阻止事件的默认行为</h3>
<p>在平常我们经常会遇到一个表单中有个提交按钮（type为submit），用于提交表单，但是我们不希望它直接提交，而是希望将其元素值提取之后进行ajax交互，于是就需要屏蔽提交按钮默认行为</p>

<p>我们可以使用<code>event.preventDefault()</code>来阻止元素事件的默认行为</p>

<h3 id="section-16">事件代理</h3>
<p>如果我们有一个ul元素，其中有100个li元素，每个点击都会触发一个相同的点击事件，那么我们可能需要为这100个li元素各绑定一个回调函数，费时费力费内存。由于事件的冒泡机制，我们可以通过事件代理的方式，只在ul元素上绑定一个click事件，然后确定其event.target对象是否是li元素就行了,如下例所示：</p>

<p>有一个ul元素，其中5个li元素：
<code>html
&lt;ul id="ul"&gt;
   &lt;li value='1'&gt;1&lt;/li&gt;
   &lt;li value='2'&gt;2&lt;/li&gt;
   &lt;li value='3'&gt;3&lt;/li&gt;
   &lt;li value='4'&gt;4&lt;/li&gt;
   &lt;li value='5'&gt;5&lt;/li&gt;
&lt;/ul&gt;
</code></p>

<p>为ul元素绑定一个click事件回调函数来处理所有li元素的click事件</p>

<p><code>javascript
var ul = document.getElementById("ul");
ul.addEventListener("click", function(evt){
    if(evt.target.tagName === 'LI'){
        console.log("li " + evt.target.getAttribute("value") + " is clicked");
    }
}, false);
</code></p>

<p>点击各个li查看效果：</p>

<p><img src="http://lingyu.wang/img/fe_interview/8.png" alt="各个li元素被点击时都会触发事件并显示哪个li元素被点击" /></p>

<p>这样我们就可以通过为ul增加一个事件代理来处理所有li元素的点击事件了。同理，我们可以使用事件代理让一个元素下的不同子元素共享一个事件处理逻辑</p>

<h2 id="section-17">第三十五题</h2>
<p>简述伪类和伪元素有什么异同，并写出几个常见的伪类和伪元素</p>

<p>相当多的人将伪类和伪元素相混淆</p>

<h3 id="section-18">相同点</h3>
<p>他们的共同点在于，他们都属于CSS选择器的范畴，CSS引入伪类和伪元素的概念是为了实现基于文档树之外的信息的格式化造成伪类和伪元素混淆的最基本原因，就是他们俩可以使用相同的语法进行添加：</p>

<p><code>css
.someclass:before {}
.someclass:hover {}
</code></p>

<h3 id="section-19">不同点</h3>
<ol>
  <li>伪类时根据元素所具有的不同状态来添加相应的样式，而伪元素则是对元素中特定的内容添加相应的样式</li>
  <li>伪元素和伪类使用语法可以不同，伪元素可以使用<code>::before</code>这样的双冒号来使用（当然使用单冒号也可以），而伪类不行</li>
  <li>伪元素和伪类进行选择器优先级计算时不同，伪元素与标签选择器的优先级为0001，而伪类的优先级与类选择器的优先级一样为0010</li>
</ol>

<h3 id="section-20">一些例子</h3>
<p><code>before</code>,<code>after</code>,<code>first-line</code>,<code>first-letter</code>都是伪元素，而像<code>link</code>,<code>visited</code>,<code>hover</code>,<code>active</code>,<code>first-child</code>,<code>lang</code>,<code>focus</code>等都是伪类</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/24/js-interview-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（15-25） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/20/js-interview-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第十五题</h2>
<p>绘制一个如图红色十字架，方块长150px，宽50px：</p>

<p><img src="http://lingyu.wang/img/fe_interview/4.png" alt="一个长为150px大小的红十字架" /></p>

<p>要求：
1. 使用2个div完成
2. 使用3个div完成
3. 使用5个div完成</p>

<h3 id="div">两个div实现：</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-1">三个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-2">5个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-3">（附送）一个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/3/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-1">第十六题</h2>
<p>请将优化如下CSS属性：
###border
<code>css
border-width: 1px;
border-color: #000;
border-style: solid;
</code>
###background
<code>css
background-position:0 0;
background-repeat:no-repeat;
background-attachment:fixed;
background-color:#f00;
background-image:url(background.gif);
</code>
###font
<code>css
font-style:italic;
font-family:"Lucida Grande",sans-serif;
font-size:1em;
font-weight:bold;
font-variant:small-caps;
line-height:140%;
</code>
###list-style
<code>css
list-style-position:inside;
list-style-type:square;
list-style-image:url(image.gif);
</code>
###color
<code>css
color:#336699;
color:#ffcc00;
</code>
###答案
首先看border的格式：
<code>css
border：[ border-width ] || [ border-style ] || [ border-color ]
</code>
所以答案应该是：
<code>css
border: 1px solid #000;
</code></p>

<hr />

<p>然后看看background：
```css
background：[ <bg-layer>, ]* <final-bg-layer> </final-bg-layer></bg-layer></p>

<bg-layer> = [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}

<final-bg-layer> = [ background-color ] || [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}
```
我去，这么长...可以看到如果是多重背景，除了最后一组规则以外，其他的都没有背景色，其他属性的排列顺序是：
1. background-image
2. background-position/background-size
3. background-repeat
4. background-attachment
5. background-origin background-clip

这样，可以得到答案为
```css
background: #f00 url(background.gif) 0 0 no-repeat fixed;
```

---

然后看看font：
```css
font：[ [ <font-style> || <font-variant> || <font-weight> ]? <font-size> [ / <line-height> ]? <font-family> ] | caption | icon | menu | message-box | small-caption | status-bar
```
可以看到其排列顺序：
1. font-style:
2. font-variant
3. font-weight
4. font-size/line-height
5. font-family
6. ...

所以可以得到的答案为：
```css
font: italic bold small-caps 1em/140% "Lucida Grande",sans-serif;
```

---

看看list-style：
```css
list-style：[ list-style-image ] || [ list-style-position ] || [ list-style-type ]
```
这个简单很多，而且没有什么特殊规则，所以答案是：
```css
list-style: url(image.gif) inside square;
```

---

最后看看color，color只有当使用hex表示且形式是`#aabbcc`时可以简写，所以答案是：
```css
color:#369;
color:#fc0;
```

##第十七题
如何设置CSS强制不换行/不截断单词换行/截断单词换行?


首先明确几个相关属性：
1. word-break: 设置或检索对象内文本的字内换行行为
2. word-wrap：设置或检索当内容超过指定容器边界时是否断行
3. white-space：设置或检索对象内空格的处理方式

###word-break
设置或检索对象内文本的字内换行行为
1. normal：依照亚洲语言和非亚洲语言规则，允许在字内换行
2. keep-all：与所有非亚洲语言的normal相同，对于中文、韩文、日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 
3. break-all：与亚洲语言的normal相同，允许非亚洲语言在任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。 

chrome、opera不支持keep-all

###word-wrap
设置或检索当内容超过指定容器边界时是否断行
1. normal：允许内容顶开或溢出指定的容器边界
2. break-word：内容将在边界内换行，如果需要，单词内部允许断行

###white-space
设置或检索对象内空格的处理方式
1. normal：默认处理方式
2. 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行。可查阅pre对象 
3. 强制在同一行内显示所有文本，合并文本间的多余空白，直到文本结束或者遭遇br对象。 
4. 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。 
5. 保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。 

###强制不换行
```css
.no-wrap {
    white-space: nowrap;
}
```
###不截断单词换行
```css
.wrap {
    white-space: normal;
    word-wrap: break-word;
    word-break: normal;
}
```
###强制英文单词断行
```css
.wrap-break-word {
    white-space: normal;
    word-wrap: break-wrod;
    word-break: break-all;
}
```

##第十八题
如果需要给`<a>`设置伪类，应该按照何种顺序进行设置？

解答：如《CSS禅意花园》中的爱恨原则，使用`LoVe/HAte`方式来记忆，设置的顺序为：
1. L——link: 适用于未被访问的链接
2. V——visited：适用于已经访问过的链接
3. H——hover：适用于光标（鼠标指针）指向一个元素，但还未激活它时
4. A——active：适用于一个元素被用户激活时

如果还需要加入focus，规则则变为`LVHFA`

##第十九题
媒体查询中的`only`属性是干什么的？

解答：`only`用来将样式应用于某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。其实`only`属性很多时候是用来对支持`Media Type`但不支持`Media Query`的设备隐藏样式表的。

其主要有：
1. 若设备支持媒体查询（Media Query），正常调用样式，`only`就当不存在
2. 若设备不支持媒体查询（Media Query），但支持媒体类型（Media Type），样式将不会被调用
3. 如果媒体查询和媒体类型都不支持，样式自然不会被调用

##第二十题
HTML中的文档类型是什么？尽可能多的写出文档类型

解答：Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。
```html
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
```

##第二十一题
`data-`属性是干什么的？

解答：HTML5中可以使用`data-`来为元素添加自定义的合法属性，然后我们可以通过dom节点进行取值,比如如下节点：
```html
&lt;div id="some-dom" data-first="asdfasdf" data-second=123 data-third=true&gt;
```
然后我们可以通过DOM的`dataset`属性取到它们：
```javascript
&gt; var div = document.getElementById("some-dom");
&gt; var divDataSet = div.dataset;
&gt; console.log(divDataSet);
DOMStringMap {first: "asdfasdf", second: "123", third: "true"} 
```
需要注意一点事，所有的值都是字符串类型

当然如果我们使用`getAttribute()`方法也是同样可行的：
```javascript
&gt; div.getAttribute("data-first");
"asdfasdf"
```

在获得了dataset对象之后，我们可以利用这个对象进行CRUD操作：
```javascript
//修改属性值
&gt; divDataSet.second = 999;
&gt; div.outerHTML
'<div id="some-dom" data-first="asdfasdf" data-second="999" data-third="true"></div>'
//增加新属性
&gt; divDataSet.newProperty = "skyinlayer";
&gt; div.outerHTML
'<div id="some-dom" data-first="asdfasdf" data-second="999" data-third="true" data-new-property="skyinlayer"></div>'
//删除属性
&gt; delete divDataSet.first
&gt; div.outerHTML
'<div id="some-dom" data-second="999" data-third="true" data-new-property="skyinlayer"></div>'
```

##第二十二题
简述一下cookie，sessionStorage，localStorage的区别

###cookie
标准的客户端浏览器状态保存方式，cookie每次发送请求的时候都会被带回到服务器，从而保证了服务器可以知道浏览器当前的状态，但同时也意味着其容量不能太大，最多不能超过4k

###sessionStorage
HTML5提供的两种客户端存储数据的新方法（localStorage、sessionStorage）之一，是针对一个session的数据进行存储，有时间限制。sessionStorage数据的存储金特定于某个绘画中，也就是说数据只会保存到浏览器关闭，但浏览器如果是刷新或重新打开页面，数据还是存在的。每在新标签或者新窗口开启一个新页面，都会初始化一个新的会话。Chrome、Safari、Android版的Webkit对其限制是2.5MB，IE8+和Opera限制是5MB

###localStroage
HTML5提供了两种客户端存储数据的新方法的另一种，它不是针对session的数据进行存储，而是用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。它的存储空间比cookie要大得多，大多数桌面浏览器会设置每个来源5MB的限制，Chrome和Safari和Android版的Wekit限制则是2.5MB

##第二十三题
优化以下CSS：
```css
.style {
    margin-top: 4px;
    margin-right: 12px;
    padding: 10px 0px 10px 0px;
    background-color: #ff9800;
    background-image: url(/img/logo.png);
    background-size: 240px 80px;
    border-width: 2px;
    border-style: dashed;
    border-color: #ff8800;
}
```

答案： 
```css
.style {
    margin: 4px 12px 0 0;
    padding: 10px 0;
    background: #ff9800 url(/img/logo.png) 240px 80px;
    border: 2px dashed #f80;
}
```

##第二十四题
请列举出CSS中用于隐藏元素的两个属性？两者的差异？还有什么其他方式吗？

这题很有意思，之前曾经在禅意花园上看到过类似的隐藏元素方案

首先两个属性，不用说分别是`display: none`和`visibility: hidden`,区别就是前者不会在文档流中占据位置，而后者会，如下例所示

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/b5qPx/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

至于还有什么其他方式，禅意花园上的一种方式就是，将元素的`width`、`height`属性设置成0（块状元素），这样自然就隐藏了

还有一些比较YD的方法，比如说将其移位到屏幕外
```css
.hide {
    /*这样不会占据空间*/
    position: absolute;
    top: -9999em;
}
.hide {
    /*占据空间*/
    position: relative;
    top: -9999em;
}
.hide {
    /*占据空间，且可以点击*/
    opacity: 0;
}
```
等等

另外在设置了`display: none`和`visibility: hidden`的时候，将图片放在背景中将不会加载图片，而放在`<img />`标签中将会加载图片：

![图片加载规则](http://lingyu.wang/img/fe_interview/5.png)

##第二十五题
有两个盒子A、B，B在A盒子中，俩盒子的CSS如下：
```css
#A {
    position: relative;
    width: 500px;
    height: 500px;
    background: green;
}

#B {
    position: absolute;
    max-width: 300px;
    max-height: 300px;
    background-color: blue;
}
```
请实现B在A中的水平方向和垂直方向居中

解答：这题想简单了以为直接设置负数的`margin-top`和`margin-left`就行了，现在发现不是这么回事，因为它给的是`max-width`和`max-height`，并不能确定元素当前的大小是多少，而且B元素是绝对定位，所以用内联元素的垂直居中方式也不可能，`margin: auto`也不行...所以这里的解法应该是通过JavaScript算出当前元素的大小，然后设定相应的负数`margin`

思路确定后就是要获取元素的`width`和`height`属性，如果有jQuery的话直接`$().width()`或`$().height()`就行了，但是一般情况下笔试都是写原生的JavaScript，所以需要通过原生的方式计算出元素的宽度和高度

也许会想到使用`dom.style.height`和`dom.style.width`来获取高度和宽度，但是这样只适合获取内联样式，并不适合获取计算后的样式，所以我们需要通过其他的方法：
```javascript

var B = document.getElementById("B");
var A = document.getElementById("A");
var bSize = getComputedSize(B);
B.style.marginTop = "-" + bSize.height/2 + "px";
B.style.marginLeft = "-" + bSize.width/2 + "px";
B.style.left = "50%";
B.style.top = "50%";

function getComputedSize(dom){
    var size = {},
        tmp;
    if(dom.currentStyle) {
        //IE提供currentStyle查询
        size.height = dom.currentStyle.height;
        size.width = dom.currentStyle.width;
    } else {
        //其他浏览器使用window.getComputedStyle方法
        tmp = window.getComputedStyle(dom, null);
        size.height = tmp.height;
        size.width = tmp.width;
    }
    //删除末尾的px并转换成数字
    size.height = Number(size.height.replace("px", ""));
    size.width = Number(size.width.replace("px", ""));
    return size;
}
```
这样就可以了

</a></font-family></line-height></font-size></font-weight></font-variant></font-style></final-bg-layer></bg-layer>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/20/js-interview-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（15-25） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/20/js-interview-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第十五题</h2>
<p>绘制一个如图红色十字架，方块长150px，宽50px：</p>

<p><img src="http://lingyu.wang/img/fe_interview/4.png" alt="一个长为150px大小的红十字架" /></p>

<p>要求：
1. 使用2个div完成
2. 使用3个div完成
3. 使用5个div完成</p>

<h3 id="div">两个div实现：</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-1">三个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-2">5个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="div-3">（附送）一个div实现</h3>
<iframe width="100%" height="500" src="http://jsfiddle.net/skyinlayer/Nak3p/3/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-1">第十六题</h2>
<p>请将优化如下CSS属性：
###border
<code>css
border-width: 1px;
border-color: #000;
border-style: solid;
</code>
###background
<code>css
background-position:0 0;
background-repeat:no-repeat;
background-attachment:fixed;
background-color:#f00;
background-image:url(background.gif);
</code>
###font
<code>css
font-style:italic;
font-family:"Lucida Grande",sans-serif;
font-size:1em;
font-weight:bold;
font-variant:small-caps;
line-height:140%;
</code>
###list-style
<code>css
list-style-position:inside;
list-style-type:square;
list-style-image:url(image.gif);
</code>
###color
<code>css
color:#336699;
color:#ffcc00;
</code>
###答案
首先看border的格式：
<code>css
border：[ border-width ] || [ border-style ] || [ border-color ]
</code>
所以答案应该是：
<code>css
border: 1px solid #000;
</code></p>

<hr />

<p>然后看看background：
```css
background：[ <bg-layer>, ]* <final-bg-layer> </final-bg-layer></bg-layer></p>

<bg-layer> = [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}

<final-bg-layer> = [ background-color ] || [ background-image ] || [ background-position ] [ / background-size ]? || [ background-repeat ] || [ background-attachment ] || [ [ background-origin ] || [ background-clip ] ]{1,2}
```
我去，这么长...可以看到如果是多重背景，除了最后一组规则以外，其他的都没有背景色，其他属性的排列顺序是：
1. background-image
2. background-position/background-size
3. background-repeat
4. background-attachment
5. background-origin background-clip

这样，可以得到答案为
```css
background: #f00 url(background.gif) 0 0 no-repeat fixed;
```

---

然后看看font：
```css
font：[ [ <font-style> || <font-variant> || <font-weight> ]? <font-size> [ / <line-height> ]? <font-family> ] | caption | icon | menu | message-box | small-caption | status-bar
```
可以看到其排列顺序：
1. font-style:
2. font-variant
3. font-weight
4. font-size/line-height
5. font-family
6. ...

所以可以得到的答案为：
```css
font: italic bold small-caps 1em/140% "Lucida Grande",sans-serif;
```

---

看看list-style：
```css
list-style：[ list-style-image ] || [ list-style-position ] || [ list-style-type ]
```
这个简单很多，而且没有什么特殊规则，所以答案是：
```css
list-style: url(image.gif) inside square;
```

---

最后看看color，color只有当使用hex表示且形式是`#aabbcc`时可以简写，所以答案是：
```css
color:#369;
color:#fc0;
```

##第十七题
如何设置CSS强制不换行/不截断单词换行/截断单词换行?


首先明确几个相关属性：
1. word-break: 设置或检索对象内文本的字内换行行为
2. word-wrap：设置或检索当内容超过指定容器边界时是否断行
3. white-space：设置或检索对象内空格的处理方式

###word-break
设置或检索对象内文本的字内换行行为
1. normal：依照亚洲语言和非亚洲语言规则，允许在字内换行
2. keep-all：与所有非亚洲语言的normal相同，对于中文、韩文、日文，不允许字断开。适合包含少量亚洲文本的非亚洲文本。 
3. break-all：与亚洲语言的normal相同，允许非亚洲语言在任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。 

chrome、opera不支持keep-all

###word-wrap
设置或检索当内容超过指定容器边界时是否断行
1. normal：允许内容顶开或溢出指定的容器边界
2. break-word：内容将在边界内换行，如果需要，单词内部允许断行

###white-space
设置或检索对象内空格的处理方式
1. normal：默认处理方式
2. 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行。可查阅pre对象 
3. 强制在同一行内显示所有文本，合并文本间的多余空白，直到文本结束或者遭遇br对象。 
4. 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。 
5. 保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。 

###强制不换行
```css
.no-wrap {
    white-space: nowrap;
}
```
###不截断单词换行
```css
.wrap {
    white-space: normal;
    word-wrap: break-word;
    word-break: normal;
}
```
###强制英文单词断行
```css
.wrap-break-word {
    white-space: normal;
    word-wrap: break-wrod;
    word-break: break-all;
}
```

##第十八题
如果需要给`<a>`设置伪类，应该按照何种顺序进行设置？

解答：如《CSS禅意花园》中的爱恨原则，使用`LoVe/HAte`方式来记忆，设置的顺序为：
1. L——link: 适用于未被访问的链接
2. V——visited：适用于已经访问过的链接
3. H——hover：适用于光标（鼠标指针）指向一个元素，但还未激活它时
4. A——active：适用于一个元素被用户激活时

如果还需要加入focus，规则则变为`LVHFA`

##第十九题
媒体查询中的`only`属性是干什么的？

解答：`only`用来将样式应用于某种特定的媒体类型，可以用来排除不支持媒体查询的浏览器。其实`only`属性很多时候是用来对支持`Media Type`但不支持`Media Query`的设备隐藏样式表的。

其主要有：
1. 若设备支持媒体查询（Media Query），正常调用样式，`only`就当不存在
2. 若设备不支持媒体查询（Media Query），但支持媒体类型（Media Type），样式将不会被调用
3. 如果媒体查询和媒体类型都不支持，样式自然不会被调用

##第二十题
HTML中的文档类型是什么？尽可能多的写出文档类型

解答：Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。
```html
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
```

##第二十一题
`data-`属性是干什么的？

解答：HTML5中可以使用`data-`来为元素添加自定义的合法属性，然后我们可以通过dom节点进行取值,比如如下节点：
```html
&lt;div id="some-dom" data-first="asdfasdf" data-second=123 data-third=true&gt;
```
然后我们可以通过DOM的`dataset`属性取到它们：
```javascript
&gt; var div = document.getElementById("some-dom");
&gt; var divDataSet = div.dataset;
&gt; console.log(divDataSet);
DOMStringMap {first: "asdfasdf", second: "123", third: "true"} 
```
需要注意一点事，所有的值都是字符串类型

当然如果我们使用`getAttribute()`方法也是同样可行的：
```javascript
&gt; div.getAttribute("data-first");
"asdfasdf"
```

在获得了dataset对象之后，我们可以利用这个对象进行CRUD操作：
```javascript
//修改属性值
&gt; divDataSet.second = 999;
&gt; div.outerHTML
'<div id="some-dom" data-first="asdfasdf" data-second="999" data-third="true"></div>'
//增加新属性
&gt; divDataSet.newProperty = "skyinlayer";
&gt; div.outerHTML
'<div id="some-dom" data-first="asdfasdf" data-second="999" data-third="true" data-new-property="skyinlayer"></div>'
//删除属性
&gt; delete divDataSet.first
&gt; div.outerHTML
'<div id="some-dom" data-second="999" data-third="true" data-new-property="skyinlayer"></div>'
```

##第二十二题
简述一下cookie，sessionStorage，localStorage的区别

###cookie
标准的客户端浏览器状态保存方式，cookie每次发送请求的时候都会被带回到服务器，从而保证了服务器可以知道浏览器当前的状态，但同时也意味着其容量不能太大，最多不能超过4k

###sessionStorage
HTML5提供的两种客户端存储数据的新方法（localStorage、sessionStorage）之一，是针对一个session的数据进行存储，有时间限制。sessionStorage数据的存储金特定于某个绘画中，也就是说数据只会保存到浏览器关闭，但浏览器如果是刷新或重新打开页面，数据还是存在的。每在新标签或者新窗口开启一个新页面，都会初始化一个新的会话。Chrome、Safari、Android版的Webkit对其限制是2.5MB，IE8+和Opera限制是5MB

###localStroage
HTML5提供了两种客户端存储数据的新方法的另一种，它不是针对session的数据进行存储，而是用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期。它的存储空间比cookie要大得多，大多数桌面浏览器会设置每个来源5MB的限制，Chrome和Safari和Android版的Wekit限制则是2.5MB

##第二十三题
优化以下CSS：
```css
.style {
    margin-top: 4px;
    margin-right: 12px;
    padding: 10px 0px 10px 0px;
    background-color: #ff9800;
    background-image: url(/img/logo.png);
    background-size: 240px 80px;
    border-width: 2px;
    border-style: dashed;
    border-color: #ff8800;
}
```

答案： 
```css
.style {
    margin: 4px 12px 0 0;
    padding: 10px 0;
    background: #ff9800 url(/img/logo.png) 240px 80px;
    border: 2px dashed #f80;
}
```

##第二十四题
请列举出CSS中用于隐藏元素的两个属性？两者的差异？还有什么其他方式吗？

这题很有意思，之前曾经在禅意花园上看到过类似的隐藏元素方案

首先两个属性，不用说分别是`display: none`和`visibility: hidden`,区别就是前者不会在文档流中占据位置，而后者会，如下例所示

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/b5qPx/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

至于还有什么其他方式，禅意花园上的一种方式就是，将元素的`width`、`height`属性设置成0（块状元素），这样自然就隐藏了

还有一些比较YD的方法，比如说将其移位到屏幕外
```css
.hide {
    /*这样不会占据空间*/
    position: absolute;
    top: -9999em;
}
.hide {
    /*占据空间*/
    position: relative;
    top: -9999em;
}
.hide {
    /*占据空间，且可以点击*/
    opacity: 0;
}
```
等等

另外在设置了`display: none`和`visibility: hidden`的时候，将图片放在背景中将不会加载图片，而放在`<img />`标签中将会加载图片：

![图片加载规则](http://lingyu.wang/img/fe_interview/5.png)

##第二十五题
有两个盒子A、B，B在A盒子中，俩盒子的CSS如下：
```css
#A {
    position: relative;
    width: 500px;
    height: 500px;
    background: green;
}

#B {
    position: absolute;
    max-width: 300px;
    max-height: 300px;
    background-color: blue;
}
```
请实现B在A中的水平方向和垂直方向居中

解答：这题想简单了以为直接设置负数的`margin-top`和`margin-left`就行了，现在发现不是这么回事，因为它给的是`max-width`和`max-height`，并不能确定元素当前的大小是多少，而且B元素是绝对定位，所以用内联元素的垂直居中方式也不可能，`margin: auto`也不行...所以这里的解法应该是通过JavaScript算出当前元素的大小，然后设定相应的负数`margin`

思路确定后就是要获取元素的`width`和`height`属性，如果有jQuery的话直接`$().width()`或`$().height()`就行了，但是一般情况下笔试都是写原生的JavaScript，所以需要通过原生的方式计算出元素的宽度和高度

也许会想到使用`dom.style.height`和`dom.style.width`来获取高度和宽度，但是这样只适合获取内联样式，并不适合获取计算后的样式，所以我们需要通过其他的方法：
```javascript

var B = document.getElementById("B");
var A = document.getElementById("A");
var bSize = getComputedSize(B);
B.style.marginTop = "-" + bSize.height/2 + "px";
B.style.marginLeft = "-" + bSize.width/2 + "px";
B.style.left = "50%";
B.style.top = "50%";

function getComputedSize(dom){
    var size = {},
        tmp;
    if(dom.currentStyle) {
        //IE提供currentStyle查询
        size.height = dom.currentStyle.height;
        size.width = dom.currentStyle.width;
    } else {
        //其他浏览器使用window.getComputedStyle方法
        tmp = window.getComputedStyle(dom, null);
        size.height = tmp.height;
        size.width = tmp.width;
    }
    //删除末尾的px并转换成数字
    size.height = Number(size.height.replace("px", ""));
    size.width = Number(size.width.replace("px", ""));
    return size;
}
```
这样就可以了

</a></font-family></line-height></font-size></font-weight></font-variant></font-style></final-bg-layer></bg-layer>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/20/js-interview-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（1-14） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/20/js-interview-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第一题</h2>
<p>下列关于浏览器对象的说法错误的是：
* A：location对象相当于IE浏览器中的地址栏，包含关于当前URL地址的信息
* B: history对象记录了用户在一个李蓝旗中已经访问过的URLS
* C: location对象是window对象的子对象
* D：location对象是history对象的父对象</p>

<p>这题考查的是location对象和history对象，之前并没有怎么接触过。</p>

<p>答案是D</p>

<h3 id="location">location对象</h3>
<p>location对象里面存放了当前URL的一些信息：</p>

<p><img src="http://lingyu.wang/img/fe_interview/1.png" alt="localtion对象存放的信息" /></p>

<p>location对象同时window对象和window.document对象的子对象：
<code>javascript
&gt; window.location === window.document.location
true
</code></p>

<p>我们可以通过修改其href实现跳转</p>

<h3 id="history">history对象</h3>
<p>history对象是window对象的子对象，里面记录了访问历史：</p>

<p><img src="http://lingyu.wang/img/fe_interview/2.png" alt="history对象存放的信息" /></p>

<p>history与location对象不同的是，其不存在于window.document对象之中
<code>javascript
&gt; window.document.history
undefined
</code></p>

<p>history对象有三个比较常用的跳转方法：
* back()：移动到当前页面的在历史记录中的上一个页面
* forward()：移动到当前页面在历史记录中的下一个页面
* go(n)：接收一个参数n如果参数为正整数或0，移动到当前页面后的第n个页面（0的效果为刷新），如果为负数，移动到当前页面前的第n个页面，超出范围的话将被忽略</p>

<h2 id="section-1">第二题</h2>
<p>析如下JavaScript代码，请问依次打印什么：
<code>javascript
console.log(Function instanceof Object);
console.log(Object instanceof Function);
console.log([].constructor === Array.prototype.constructor);
console.log(new Object(1).constructor === new Number(2).constructor);
</code></p>

<p>这题考察了Function、Object以及constructor</p>

<p>首先我们要确定instanceof方法，如A instanceof B，A必须是一个合法的对象，B是一个合法的JavaScript函数。如果函数B在对象A的原型链中被发现，那么instanceof操作符将返回true，否则返回false</p>

<p>第一行<code>console.log(Function instanceof Object);</code>：</p>

<p>由于Function.prototype是一个对象，它的构造函数是Object，所以从原型链上来说，所有的函数顺着原型链查找，最后都会到达Object的构造原型的Object.prototype对象，所以答案为true。</p>

<p>由此我们可以得出另外一个结论，所有的函数instanceof Object的结果，都是true
<code>javascript
&gt; (function(){}) instanceof Object
true
</code></p>

<p>第二行<code>console.log(Object instanceof Function);</code>：</p>

<p>因为在JavaScript中所有的构造函数（Object、Function、Array）都是函数，而所有函数都是其构造函数（Function）的实例，所以答案也是true</p>

<p>第三行<code>console.log(arr.constructor === Array.prototype.constructor);</code>：</p>

<p>首先我们需要知道constructor的概念，constructor属性始终指向创建当前对象的构造函数。所以很容易得到如下结果:
<code>javascript
&gt; [].constructor === Array
true
</code>
而每个函数都有一个默认的属性prototype，这个prototype的constructor默认指向这个函数：
<code>javascript
&gt; var SomeType = function(){};
&gt; SomeType.prototype.constructor === SomeType
true
</code>
由此可以得知：
<code>javascript
&gt; [].constructor === Array
true
&gt; Array === Array.prototype.constructor
true
&gt; [].constructor === Array.prototype.constructor
true
</code></p>

<p>当然我们哈有另外一个比较简单的思路，其实Array.prototype这个对象比较特殊，它是集上是个数组:
<code>javascript
&gt; Array.prototype
[]
</code>
这样就相当于比较<code>[].constructor === [].constructor</code>了，结果自然是true</p>

<p>第四行<code>console.log(new Object(1).constructor === new Number(2).constructor);</code>：</p>

<p>说实话我被这个坑了，以为是false，后来发现<code>new Object()</code>方法如果传入一个基础类型或基础类型对象，会自动构造成基础类型对象：</p>

<p><code>javascript
&gt; new Object(123) instanceof Number
true
&gt; new Object("asdf") instanceof String
true
&gt; new Object(false) instanceof Boolean
true
&gt; typeof new Object(123)
"object"
</code></p>

<p>这样就很好理解了，<code>new Object()</code>如果传入一个数字，将会调用new Number()，其他类似。所以这里答案是true</p>

<h2 id="section-2">第三题</h2>
<p>下列JavaScript运行完成后，x的值是多少：
<code>javascript
var somevar;
var x = somevar === undefined;
</code></p>

<p>这题错了，囧</p>

<p>以往一直使用<code>typeof somevar === 'undefined'</code>来检测undefined，这下被坑了</p>

<p>undefined可能出现在如下两种情况之中：
1. 变量未定义
2. 定义了变量但未赋值</p>

<p>使用<code>typeof somevar === 'undefined'</code>进行判断：
<code>javascript
&gt; typeof somevar === 'undefined'
true
&gt; var someothervar;
&gt; typeof someothervar === 'undefined'
true
</code>
由此可见，这种方法在两种情况下都适用</p>

<p>使用<code>somevar === undefined</code>进行判断：
<code>javascript
&gt; somevar === undefined
ReferenceError: somevar is not defined
&gt; var someothervar;
&gt; someothervar === undefined
true
</code>
我勒个去…也就是说，这种检测方式仅仅适用于第二种情况，所以这题答案是true</p>

<h2 id="section-3">第四题</h2>
<p><code>javascript
var obj = {
    toString: function() {
        return "obj作用域内";
    },
    func: function() {
        alert(this);
        var innerfunc = function() {
            alert(this);
        };
        innerfunc.call(this);
    }
};
obj.func.call(window);
</code>
弹出来的第二个对话框内容是什么</p>

<p>考this的题，没跑了</p>

<p>首先看<code>obj.func.call(window)</code>，这句使用了call方法指定this，没啥说的，this肯定指向window，所以第一个对话框的内容肯定是<code>[object window]</code>，但是它问第二个对话框，好吧，继续</p>

<p>进入到func内部，其又用call来调用，传入的还是this，也就是window对象，所以第二个对话框也是window</p>

<h2 id="section-4">第五题</h2>
<p>考虑如下代码：
<code>javascript
var message = "Hello world!";
var t1 = message.substring(1, 4);
var t2 = message.substr(1,4);
</code>
t1，t2的值各是多少？</p>

<p>通过这道题我才知道原来还有substr这么个玩意…</p>

<p>首先来看substring方法，其接受两个参数，left和right，分别代表截取的起始点和终点，这是一个左闭右开的区间，right位置的字符不会被截取，所以这里会截取的是message[1], message[2], message[3]三个字符为’ell’</p>

<p>接下来看substr方法，其亦接受两个参数，left和count，分别代表截取的起始点和截取字符的个数…所以会截取message[1], message[2], message[3], message[4]四个字符，也就是’ello’…</p>

<h2 id="section-5">第六题</h2>
<p><code>javascript
if (a in window) {
    var a = 1;
}
console.log(a);
</code></p>

<p>看了那么多关于变量声明提升的概念，这题竟然错了，呵呵</p>

<p>这题就是考的变量的提升：提升后的代码如下：
<code>javascript
var a;
if (a in window) {
    a = 1;
}
console.log(a);
</code>
这样就很明显了，答案是1…</p>

<h2 id="section-6">第七题</h2>
<p>```javascript
var x = 10;
var foo = {
    x: 20,
    bar: function() {
        var x = 30;
        return this.x;
    }
};</p>

<p>alert(foo.bar());
alert((foo.bar)());
alert((foo.bar = foo.bar)());
alert((foo.bar, foo.bar)());
```
弹出的内容依次是？</p>

<p>这题也是考的不同调用方法中的this，本来挺有自信的，但发现和想的不太一样</p>

<p>第一行<code>foo.bar()</code>比较明显，对象的方法调用，this指向拥有该方法的独享，所以输出值为20</p>

<p>第二行<code>(foo.bar)()</code>和我想的不太一样，我以为这会是函数调用，结果不是，其也是对象方法调用，this值指向foo对象，所以答案是20</p>

<p>第三行<code>(foo.bar = foo.bar)()</code>有一个赋值语句，JavaScript的复制语句返回的是被赋予的值，这是函数调用，所以this指向全局对象window，答案是10</p>

<p>第四行<code>(foo.bar, foo.bar)()</code>，逗号表达式，也是函数调用，都好表达式的值默认是最后的那个值，答案是10</p>

<h2 id="section-7">第八题</h2>
<p>在javascript中要改变页面文档的背景色，需要修改document对象的（）属性。</p>

<p>我凑，才知道document还有这么个神奇的属性可以改变背景颜色，而不是通过改变CSS的方式，答案是<code>bgColor</code>属性，修改完后，body会多一个<code>bgcolor</code>属性，而body的css也会加上一条<code>background-color</code>规则</p>

<h2 id="section-8">第九题</h2>
<p>在通过元素的style属性修改CSS时，有横线的属性（如background-color）应该如何表示？</p>

<p>答案：将横线去掉，横线后的首字母大写，如backgroundColor</p>

<h2 id="section-9">第十题</h2>
<p>JavaScript有哪些数据类型？</p>

<p>答案：一共六种，number、boolean、string、object、null、undefined</p>

<h2 id="section-10">第十一题</h2>
<p>img标签的alt和title分别是什么意思</p>

<p>答案: title用于给与一些提示性文字鼠标悬停可以看到title的信息。而alt则是在图片无法显示是的替换文字</p>

<h2 id="section-11">第十二题</h2>
<p>实现一个两列，左边宽度自适应，右边宽度固定200px的布局</p>

<p>答案：
```html
&lt;!doctype html&gt;
&lt;html lang="en"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <style>
        .g-sd {
            float:right;
            width: 200px;
            height: 400px;
            background-color: #f0f0f0;
        }
        .g-mn {
            zoom: 1;
            overflow: hidden;
            height: 700px;
            background: #f0ffff;
        }
    </style>
</head>
<body>
    <div class="g-sd"></div>
    <div class="g-mn"></div>
</body>
<p>&lt;/html&gt;
```</p>

<h2 id="section-12">第十三题</h2>
<p>如何对JavaScript对象进行深拷贝？</p>

<p>```javascript
Object.prototype.deepClone = function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        toString = Object.prototype.toString,
        deepClone = Object.prototype.deepClone,
        result,
        iter,
        cur,
        m;</p>

<pre><code>if (toString.call(this) === '[object Array]') {
    result = [];
} else {
    result = {};
}
for (iter in this) {
    cur = this[iter];
    if (hasOwnProperty.call(this, iter)) {
        if (typeof cur === 'object') {
            result[iter] = deepClone.call(cur);;
        } else {
            result[iter] = cur;
        }
    }
}
return result; }; ``` 测试用例： ```javascript var someObj = {
num: 123,
str: "someString",
bool: true,
func: function(){},
obj: {
    arr: [1,2,{
        num: 1
    }]
},
arr: [1,2,"string"] }; console.log(someObj.deepClone()); ``` 结果图：
</code></pre>

<p><img src="http://lingyu.wang/img/fe_interview/3.png" alt="深度复制成功" /></p>

<h2 id="section-13">第十四题</h2>
<p>动态打印时间，格式为yyyy-MM-dd hh:mm:ss?
```javascript
Date.prototype.format = function(format) {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        timeObj = {
            “YYYY”: this.getFullYear(),
            “YY”: this.getFullYear().toString().slice(2),
            “MM”: this.getMonth() + 1,
            “DD”: this.getDate(),
            “hh”: this.getHours(),
            “mm”: this.getMinutes(),
            “ss”: this.getSeconds()
        },
        item,
        value;
    for (item in timeObj){
        value = timeObj[item];
        if(hasOwnProperty.call(timeObj, item)){
            format = format.replace(item, value &lt; 10 ? “0” + value : value);
        }
    }
    return format;
};</p>

<p>setInterval(function(){
    console.log(new Date().format(“YYYY-MM-DD hh:mm:ss”));
},1000);
```</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/20/js-interview-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端面试题（1-14） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/20/js-interview-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">第一题</h2>
<p>下列关于浏览器对象的说法错误的是：
* A：location对象相当于IE浏览器中的地址栏，包含关于当前URL地址的信息
* B: history对象记录了用户在一个李蓝旗中已经访问过的URLS
* C: location对象是window对象的子对象
* D：location对象是history对象的父对象</p>

<p>这题考查的是location对象和history对象，之前并没有怎么接触过。</p>

<p>答案是D</p>

<h3 id="location">location对象</h3>
<p>location对象里面存放了当前URL的一些信息：</p>

<p><img src="http://lingyu.wang/img/fe_interview/1.png" alt="localtion对象存放的信息" /></p>

<p>location对象同时window对象和window.document对象的子对象：
<code>javascript
&gt; window.location === window.document.location
true
</code></p>

<p>我们可以通过修改其href实现跳转</p>

<h3 id="history">history对象</h3>
<p>history对象是window对象的子对象，里面记录了访问历史：</p>

<p><img src="http://lingyu.wang/img/fe_interview/2.png" alt="history对象存放的信息" /></p>

<p>history与location对象不同的是，其不存在于window.document对象之中
<code>javascript
&gt; window.document.history
undefined
</code></p>

<p>history对象有三个比较常用的跳转方法：
* back()：移动到当前页面的在历史记录中的上一个页面
* forward()：移动到当前页面在历史记录中的下一个页面
* go(n)：接收一个参数n如果参数为正整数或0，移动到当前页面后的第n个页面（0的效果为刷新），如果为负数，移动到当前页面前的第n个页面，超出范围的话将被忽略</p>

<h2 id="section-1">第二题</h2>
<p>析如下JavaScript代码，请问依次打印什么：
<code>javascript
console.log(Function instanceof Object);
console.log(Object instanceof Function);
console.log([].constructor === Array.prototype.constructor);
console.log(new Object(1).constructor === new Number(2).constructor);
</code></p>

<p>这题考察了Function、Object以及constructor</p>

<p>首先我们要确定instanceof方法，如A instanceof B，A必须是一个合法的对象，B是一个合法的JavaScript函数。如果函数B在对象A的原型链中被发现，那么instanceof操作符将返回true，否则返回false</p>

<p>第一行<code>console.log(Function instanceof Object);</code>：</p>

<p>由于Function.prototype是一个对象，它的构造函数是Object，所以从原型链上来说，所有的函数顺着原型链查找，最后都会到达Object的构造原型的Object.prototype对象，所以答案为true。</p>

<p>由此我们可以得出另外一个结论，所有的函数instanceof Object的结果，都是true
<code>javascript
&gt; (function(){}) instanceof Object
true
</code></p>

<p>第二行<code>console.log(Object instanceof Function);</code>：</p>

<p>因为在JavaScript中所有的构造函数（Object、Function、Array）都是函数，而所有函数都是其构造函数（Function）的实例，所以答案也是true</p>

<p>第三行<code>console.log(arr.constructor === Array.prototype.constructor);</code>：</p>

<p>首先我们需要知道constructor的概念，constructor属性始终指向创建当前对象的构造函数。所以很容易得到如下结果:
<code>javascript
&gt; [].constructor === Array
true
</code>
而每个函数都有一个默认的属性prototype，这个prototype的constructor默认指向这个函数：
<code>javascript
&gt; var SomeType = function(){};
&gt; SomeType.prototype.constructor === SomeType
true
</code>
由此可以得知：
<code>javascript
&gt; [].constructor === Array
true
&gt; Array === Array.prototype.constructor
true
&gt; [].constructor === Array.prototype.constructor
true
</code></p>

<p>当然我们哈有另外一个比较简单的思路，其实Array.prototype这个对象比较特殊，它是集上是个数组:
<code>javascript
&gt; Array.prototype
[]
</code>
这样就相当于比较<code>[].constructor === [].constructor</code>了，结果自然是true</p>

<p>第四行<code>console.log(new Object(1).constructor === new Number(2).constructor);</code>：</p>

<p>说实话我被这个坑了，以为是false，后来发现<code>new Object()</code>方法如果传入一个基础类型或基础类型对象，会自动构造成基础类型对象：</p>

<p><code>javascript
&gt; new Object(123) instanceof Number
true
&gt; new Object("asdf") instanceof String
true
&gt; new Object(false) instanceof Boolean
true
&gt; typeof new Object(123)
"object"
</code></p>

<p>这样就很好理解了，<code>new Object()</code>如果传入一个数字，将会调用new Number()，其他类似。所以这里答案是true</p>

<h2 id="section-2">第三题</h2>
<p>下列JavaScript运行完成后，x的值是多少：
<code>javascript
var somevar;
var x = somevar === undefined;
</code></p>

<p>这题错了，囧</p>

<p>以往一直使用<code>typeof somevar === 'undefined'</code>来检测undefined，这下被坑了</p>

<p>undefined可能出现在如下两种情况之中：
1. 变量未定义
2. 定义了变量但未赋值</p>

<p>使用<code>typeof somevar === 'undefined'</code>进行判断：
<code>javascript
&gt; typeof somevar === 'undefined'
true
&gt; var someothervar;
&gt; typeof someothervar === 'undefined'
true
</code>
由此可见，这种方法在两种情况下都适用</p>

<p>使用<code>somevar === undefined</code>进行判断：
<code>javascript
&gt; somevar === undefined
ReferenceError: somevar is not defined
&gt; var someothervar;
&gt; someothervar === undefined
true
</code>
我勒个去…也就是说，这种检测方式仅仅适用于第二种情况，所以这题答案是true</p>

<h2 id="section-3">第四题</h2>
<p><code>javascript
var obj = {
    toString: function() {
        return "obj作用域内";
    },
    func: function() {
        alert(this);
        var innerfunc = function() {
            alert(this);
        };
        innerfunc.call(this);
    }
};
obj.func.call(window);
</code>
弹出来的第二个对话框内容是什么</p>

<p>考this的题，没跑了</p>

<p>首先看<code>obj.func.call(window)</code>，这句使用了call方法指定this，没啥说的，this肯定指向window，所以第一个对话框的内容肯定是<code>[object window]</code>，但是它问第二个对话框，好吧，继续</p>

<p>进入到func内部，其又用call来调用，传入的还是this，也就是window对象，所以第二个对话框也是window</p>

<h2 id="section-4">第五题</h2>
<p>考虑如下代码：
<code>javascript
var message = "Hello world!";
var t1 = message.substring(1, 4);
var t2 = message.substr(1,4);
</code>
t1，t2的值各是多少？</p>

<p>通过这道题我才知道原来还有substr这么个玩意…</p>

<p>首先来看substring方法，其接受两个参数，left和right，分别代表截取的起始点和终点，这是一个左闭右开的区间，right位置的字符不会被截取，所以这里会截取的是message[1], message[2], message[3]三个字符为’ell’</p>

<p>接下来看substr方法，其亦接受两个参数，left和count，分别代表截取的起始点和截取字符的个数…所以会截取message[1], message[2], message[3], message[4]四个字符，也就是’ello’…</p>

<h2 id="section-5">第六题</h2>
<p><code>javascript
if (a in window) {
    var a = 1;
}
console.log(a);
</code></p>

<p>看了那么多关于变量声明提升的概念，这题竟然错了，呵呵</p>

<p>这题就是考的变量的提升：提升后的代码如下：
<code>javascript
var a;
if (a in window) {
    a = 1;
}
console.log(a);
</code>
这样就很明显了，答案是1…</p>

<h2 id="section-6">第七题</h2>
<p>```javascript
var x = 10;
var foo = {
    x: 20,
    bar: function() {
        var x = 30;
        return this.x;
    }
};</p>

<p>alert(foo.bar());
alert((foo.bar)());
alert((foo.bar = foo.bar)());
alert((foo.bar, foo.bar)());
```
弹出的内容依次是？</p>

<p>这题也是考的不同调用方法中的this，本来挺有自信的，但发现和想的不太一样</p>

<p>第一行<code>foo.bar()</code>比较明显，对象的方法调用，this指向拥有该方法的独享，所以输出值为20</p>

<p>第二行<code>(foo.bar)()</code>和我想的不太一样，我以为这会是函数调用，结果不是，其也是对象方法调用，this值指向foo对象，所以答案是20</p>

<p>第三行<code>(foo.bar = foo.bar)()</code>有一个赋值语句，JavaScript的复制语句返回的是被赋予的值，这是函数调用，所以this指向全局对象window，答案是10</p>

<p>第四行<code>(foo.bar, foo.bar)()</code>，逗号表达式，也是函数调用，都好表达式的值默认是最后的那个值，答案是10</p>

<h2 id="section-7">第八题</h2>
<p>在javascript中要改变页面文档的背景色，需要修改document对象的（）属性。</p>

<p>我凑，才知道document还有这么个神奇的属性可以改变背景颜色，而不是通过改变CSS的方式，答案是<code>bgColor</code>属性，修改完后，body会多一个<code>bgcolor</code>属性，而body的css也会加上一条<code>background-color</code>规则</p>

<h2 id="section-8">第九题</h2>
<p>在通过元素的style属性修改CSS时，有横线的属性（如background-color）应该如何表示？</p>

<p>答案：将横线去掉，横线后的首字母大写，如backgroundColor</p>

<h2 id="section-9">第十题</h2>
<p>JavaScript有哪些数据类型？</p>

<p>答案：一共六种，number、boolean、string、object、null、undefined</p>

<h2 id="section-10">第十一题</h2>
<p>img标签的alt和title分别是什么意思</p>

<p>答案: title用于给与一些提示性文字鼠标悬停可以看到title的信息。而alt则是在图片无法显示是的替换文字</p>

<h2 id="section-11">第十二题</h2>
<p>实现一个两列，左边宽度自适应，右边宽度固定200px的布局</p>

<p>答案：
```html
&lt;!doctype html&gt;
&lt;html lang="en"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
    <style>
        .g-sd {
            float:right;
            width: 200px;
            height: 400px;
            background-color: #f0f0f0;
        }
        .g-mn {
            zoom: 1;
            overflow: hidden;
            height: 700px;
            background: #f0ffff;
        }
    </style>
</head>
<body>
    <div class="g-sd"></div>
    <div class="g-mn"></div>
</body>
<p>&lt;/html&gt;
```</p>

<h2 id="section-12">第十三题</h2>
<p>如何对JavaScript对象进行深拷贝？</p>

<p>```javascript
Object.prototype.deepClone = function() {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        toString = Object.prototype.toString,
        deepClone = Object.prototype.deepClone,
        result,
        iter,
        cur,
        m;</p>

<pre><code>if (toString.call(this) === '[object Array]') {
    result = [];
} else {
    result = {};
}
for (iter in this) {
    cur = this[iter];
    if (hasOwnProperty.call(this, iter)) {
        if (typeof cur === 'object') {
            result[iter] = deepClone.call(cur);;
        } else {
            result[iter] = cur;
        }
    }
}
return result; }; ``` 测试用例： ```javascript var someObj = {
num: 123,
str: "someString",
bool: true,
func: function(){},
obj: {
    arr: [1,2,{
        num: 1
    }]
},
arr: [1,2,"string"] }; console.log(someObj.deepClone()); ``` 结果图：
</code></pre>

<p><img src="http://lingyu.wang/img/fe_interview/3.png" alt="深度复制成功" /></p>

<h2 id="section-13">第十四题</h2>
<p>动态打印时间，格式为yyyy-MM-dd hh:mm:ss?
```javascript
Date.prototype.format = function(format) {
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        timeObj = {
            “YYYY”: this.getFullYear(),
            “YY”: this.getFullYear().toString().slice(2),
            “MM”: this.getMonth() + 1,
            “DD”: this.getDate(),
            “hh”: this.getHours(),
            “mm”: this.getMinutes(),
            “ss”: this.getSeconds()
        },
        item,
        value;
    for (item in timeObj){
        value = timeObj[item];
        if(hasOwnProperty.call(timeObj, item)){
            format = format.replace(item, value &lt; 10 ? “0” + value : value);
        }
    }
    return format;
};</p>

<p>setInterval(function(){
    console.log(new Date().format(“YYYY-MM-DD hh:mm:ss”));
},1000);
```</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/20/js-interview-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 浅谈V8引擎中的垃圾回收机制 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/19/v8-gc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>这篇文章的所有内容均来自 朴灵的《深入浅出Node.js》及<a href="http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">A tour of V8:Garbage Collection</a>，后者还有中文翻译版<a href="http://newhtml.net/v8-garbage-collection/">V8 之旅： 垃圾回收器</a>，我在这里只是做了个记录和结合</p>

<h2 id="section">垃圾回收器</h2>
<p>###JavaScript的垃圾回收器
JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理</p>

<h3 id="node">Node的内存管理问题</h3>
<p>在浏览器中，V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）</p>

<h2 id="v8">V8的内存限制</h2>
<p>###存在限制
Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用</p>

<h3 id="section-1">为何限制</h3>
<p>V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响</p>

<h3 id="section-2">突破限制</h3>
<p>当然这个限制是可以打开的，类似于JVM，我们通过在启动node时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变</p>

<h2 id="v8-1">V8的堆构成</h2>
<p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：
*　新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁
*　老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里
*　老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针
*　大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象
*　代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区
*　Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</p>

<p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收</p>

<h2 id="v8-2">V8的垃圾回收机制</h2>
<p>###如何判断回收内容
如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。我们可以这样假定，一个对象为活对象当且仅当它被一个根对象或另一个活对象指向。根对象永远是活对象，它是被浏览器或V8所引用的对象。被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对象。全局对象（Node中为global，浏览器中为window）自然是根对象。浏览器中的DOM元素也属于根对象</p>

<h3 id="section-3">如何识别指针和数据</h3>
<p>垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写</p>

<p>目前主要有三种方法来识别指针：
1. 保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会背误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。
2. 编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言
3. 标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</p>

<h3 id="v8-3">V8的回收策略</h3>
<p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p>

<h3 id="v8-4">V8的分代内存</h3>
<p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p>

<h2 id="section-4">新生代</h2>
<p>###新生代的特点
大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p>

<h3 id="section-5">新生代的垃圾回收算法</h3>
<p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p>

<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p>

<p>具体的执行过程大致是这样：</p>

<p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了</p>

<p>举个栗子(以及凑篇幅)，如果有类似如下的引用情况：
```
          +—– A对象
          |
根对象—-+—– B对象 —— E对象
          |
          +—– C对象 —-+—- F对象 
                           |
                           +—- G对象 —– H对象</p>

<pre><code>D对象 ``` 在执行Scavenge之前，From区长这幅模样 ``` +---+---+---+---+---+---+---+---+--------+ | A | B | C | D | E | F | G | H |        | +---+---+---+---+---+---+---+---+--------+ ```
</code></pre>

<p>那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：
<code>
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
 ↑
scanPtr  
</code></p>

<p>接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样
<code>
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
     ↑
  scanPtr  
</code></p>

<p>接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：
<code>
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
     ↑
  scanPtr  
</code></p>

<p>B对象里所有指针都已被复制完，所以移动scanPtr：
<code>
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
         ↑
      scanPtr  
</code></p>

<p>接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：
<code>
                allocationPtr
                     ↓ 
+---+---+---+---+---+--------------------+
| A | B | C | E | F |                    |
+---+---+---+---+---+--------------------+
         ↑
      scanPtr  
</code></p>

<p>然后复制G对象到To区
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
         ↑
      scanPtr  
</code></p>

<p>这样C对象内部的指针已经复制完成了，移动scanPtr：
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
             ↑
          scanPtr  
</code></p>

<p>逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
                     ↑
                  scanPtr  
</code></p>

<p>扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：
<code>
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                     ↑
                  scanPtr  
</code>
完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：
<code>
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                             ↑
                           scanPtr  
</code>
此时scanPtr和allocationPtr重合，说明复制结束</p>

<p>可以对比一下From区和To区在复制完成后的结果：
<code>
//From区
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
//To区
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
</code>
D对象没有被复制，它将被作为垃圾进行回收</p>

<h3 id="section-6">写屏障</h3>
<p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p>

<h3 id="section-7">对象的晋升</h3>
<p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：
1. 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中
2. 对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</p>

<h2 id="section-8">老生代</h2>
<p>###老生代的特点
老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>

<h3 id="section-9">老生代的垃圾回收算法</h3>
<p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>

<h3 id="mark-sweep">Mark-Sweep（标记清除）</h3>
<p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段总，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p>

<p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p>

<h3 id="mark-compact">Mark-Compact（标记整理）</h3>
<p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>

<h3 id="section-10">算法思路</h3>
<p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p>

<p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：
* 如果一个对象为白对象，它还没未被垃圾回收器发现
* 如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理
* 如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了</p>

<p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象，将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p>

<p>清除和紧缩阶段都是以内存页为单位回收内存</p>

<p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p>

<p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p>

<h3 id="section-11">结合使用标记清除和标记整理</h3>
<p>V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>

<h2 id="v8-5">V8的优化</h2>
<p>###Incremental Marking（增量标记）
由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右</p>

<h3 id="section-12">惰性清理</h3>
<p>由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页</p>

<h3 id="section-13">其他</h3>
<p>V8后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/19/v8-gc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 浅谈V8引擎中的垃圾回收机制 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/19/v8-gc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>这篇文章的所有内容均来自 朴灵的《深入浅出Node.js》及<a href="http://www.jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">A tour of V8:Garbage Collection</a>，后者还有中文翻译版<a href="http://newhtml.net/v8-garbage-collection/">V8 之旅： 垃圾回收器</a>，我在这里只是做了个记录和结合</p>

<h2 id="section">垃圾回收器</h2>
<p>###JavaScript的垃圾回收器
JavaScript使用垃圾回收机制来自动管理内存。垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄露问题。但使用了垃圾回收即意味着程序员将无法掌控内存。ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进行垃圾回收，更无法干预内存管理</p>

<h3 id="node">Node的内存管理问题</h3>
<p>在浏览器中，V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。如果不幸发生内存泄露等问题，仅仅会影响到一个终端用户。且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需要管理内存）。但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）</p>

<h2 id="v8">V8的内存限制</h2>
<p>###存在限制
Node与其他语言不同的一个地方，就是其限制了JavaScript所能使用的内存（64位为1.4GB，32位为0.7GB），这也就意味着将无法直接操作一些大内存对象。这很令人匪夷所思，因为很少有其他语言会限制内存的使用</p>

<h3 id="section-1">为何限制</h3>
<p>V8之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，而深层次的原因则是由于V8的垃圾回收机制的限制。由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的一样，V8在执行垃圾回收时会阻塞JavaScript应用逻辑，直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。这样浏览器将在1s内失去对用户的响应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响</p>

<h3 id="section-2">突破限制</h3>
<p>当然这个限制是可以打开的，类似于JVM，我们通过在启动node时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变</p>

<h2 id="v8-1">V8的堆构成</h2>
<p>V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：
*　新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁
*　老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里
*　老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针
*　大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象
*　代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区
*　Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单</p>

<p>每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，其他区的内存页都是1MB大小，而且按照1MB对齐。内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。另外每个内存页还有一个单独分配在另外内存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收</p>

<h2 id="v8-2">V8的垃圾回收机制</h2>
<p>###如何判断回收内容
如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。我们可以这样假定，一个对象为活对象当且仅当它被一个根对象或另一个活对象指向。根对象永远是活对象，它是被浏览器或V8所引用的对象。被局部变量所指向的对象也属于根对象，因为它们所在的作用域对象被视为根对象。全局对象（Node中为global，浏览器中为window）自然是根对象。浏览器中的DOM元素也属于根对象</p>

<h3 id="section-3">如何识别指针和数据</h3>
<p>垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写</p>

<p>目前主要有三种方法来识别指针：
1. 保守法：将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。于是某些实际是数字的假指针，会背误认为指向活跃对象，导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。
2. 编译器提示法：如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言
3. 标记指针法：这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。这种方法需要编译器支持，但实现简单，而且性能不错。V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01</p>

<h3 id="v8-3">V8的回收策略</h3>
<p>自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。所以V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。分别对新生代和老生代使用不同的垃圾回收算法来提升垃圾回收的效率。对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）</p>

<h3 id="v8-4">V8的分代内存</h3>
<p>默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。具体的计算公式是<code>4*reserved_semispace_space_ + max_old_generation_size_</code>，新生代由两块<code>reserved_semispace_space_</code>组成，每块16MB（64位）或8MB（32位）</p>

<h2 id="section-4">新生代</h2>
<p>###新生代的特点
大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）</p>

<h3 id="section-5">新生代的垃圾回收算法</h3>
<p>新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。</p>

<p>Cheney算法算法是一种采用复制的方式实现的垃圾回收算法。它将内存一分为二，每一部分空间称为semispace。在这两个semispace中，一个处于使用状态，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间，当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收算法时，会检查From空间中的存活对象，这些存活对象将会被复制到To空间中（复制完成后会进行紧缩），而非活跃对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。也就是说，在垃圾回收的过程中，就是通过将存活对象在两个semispace之间进行复制。可以很容易看出来，使用Cheney算法时，总有一半的内存是空的。但是由于新生代很小，所以浪费的内存空间并不大。而且由于新生代中的对象绝大部分都是非活跃对象，需要复制的活跃对象比例很小，所以其时间效率十分理想。复制的过程采用的是BFS（广度优先遍历）的思想，从根对象出发，广度优先遍历所有能到达的对象</p>

<p>具体的执行过程大致是这样：</p>

<p>首先将From空间中所有能从根对象到达的对象复制到To区，然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将扫描的活跃对象和即将为新对象分配内存的地方，开始循环。循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。如果指向老生代我们就不必考虑它了。如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr所指向的位置。复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。如果一个对象内部的所有指针都被处理完，scanPtr就会向前移动，进入下一个循环。若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From区剩下的都可以被视为垃圾，可以进行清理了</p>

<p>举个栗子(以及凑篇幅)，如果有类似如下的引用情况：
```
          +—– A对象
          |
根对象—-+—– B对象 —— E对象
          |
          +—– C对象 —-+—- F对象 
                           |
                           +—- G对象 —– H对象</p>

<pre><code>D对象 ``` 在执行Scavenge之前，From区长这幅模样 ``` +---+---+---+---+---+---+---+---+--------+ | A | B | C | D | E | F | G | H |        | +---+---+---+---+---+---+---+---+--------+ ```
</code></pre>

<p>那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：
<code>
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
 ↑
scanPtr  
</code></p>

<p>接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样
<code>
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
     ↑
  scanPtr  
</code></p>

<p>接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：
<code>
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
     ↑
  scanPtr  
</code></p>

<p>B对象里所有指针都已被复制完，所以移动scanPtr：
<code>
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
         ↑
      scanPtr  
</code></p>

<p>接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：
<code>
                allocationPtr
                     ↓ 
+---+---+---+---+---+--------------------+
| A | B | C | E | F |                    |
+---+---+---+---+---+--------------------+
         ↑
      scanPtr  
</code></p>

<p>然后复制G对象到To区
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
         ↑
      scanPtr  
</code></p>

<p>这样C对象内部的指针已经复制完成了，移动scanPtr：
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
             ↑
          scanPtr  
</code></p>

<p>逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：
<code>
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
                     ↑
                  scanPtr  
</code></p>

<p>扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：
<code>
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                     ↑
                  scanPtr  
</code>
完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：
<code>
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                             ↑
                           scanPtr  
</code>
此时scanPtr和allocationPtr重合，说明复制结束</p>

<p>可以对比一下From区和To区在复制完成后的结果：
<code>
//From区
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
//To区
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
</code>
D对象没有被复制，它将被作为垃圾进行回收</p>

<h3 id="section-6">写屏障</h3>
<p>如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，我们如何判断这个新生代的对象是否存活？为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。每当有老生代对象指向新生代对象的时候，我们就记录下来</p>

<h3 id="section-7">对象的晋升</h3>
<p>当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：
1. 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中
2. 对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代</p>

<h2 id="section-8">老生代</h2>
<p>###老生代的特点
老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多</p>

<h3 id="section-9">老生代的垃圾回收算法</h3>
<p>老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，浪费一半空间不说，复制如此大块的内存消耗时间将会相当长。所以Scavenge算法显然不适合。V8在老生代中的垃圾回收策略采用Mark-Sweep和Mark-Compact相结合</p>

<h3 id="mark-sweep">Mark-Sweep（标记清除）</h3>
<p>标记清除分为标记和清除两个阶段。在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。在清除阶段总，只清除没有被标记的对象。由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高</p>

<p>标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。</p>

<h3 id="mark-compact">Mark-Compact（标记整理）</h3>
<p>标记整理正是为了解决标记清除所带来的内存碎片的问题。标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。在整理的过程中，将活着的对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片</p>

<h3 id="section-10">算法思路</h3>
<p>标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段</p>

<p>在标记阶段，所有堆上的活跃对象都会被标记。每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。这个位图需要占据一定的空间（32位下为3.1%，64位为1.6%）。另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：
* 如果一个对象为白对象，它还没未被垃圾回收器发现
* 如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理
* 如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了</p>

<p>如果将对中的对象看做由指针做边的有向图，标记算法的核心就是深度优先搜索。在初始时，位图为空，所有的对象也都是白对象。从根对象到达的对象会背染色为灰色，放入一个单独的双端队列中。标记阶段的每次循环，垃圾回收器都会从双端队列中取出一个对象并将其转变为黑对象，并将其邻接的对象转变为灰，然后把其邻接对象放入双端队列。如果双端队列为空或所有对象都变成黑对象，则结束。特别大的对象，可能会在处理时进行分片，防止双端队列溢出。如果双端队列溢出，则对象仍然会成为灰对象，但不会被放入队列中，这将导致其邻接对象无法被转变为灰对象。所以在双端队列为空时，需要扫描所有对象，如果仍有灰对象，将它们重新放入队列中进行处理。标记结束后，所有的对象都应该非黑即白，白对象将成为垃圾，等待释放</p>

<p>清除和紧缩阶段都是以内存页为单位回收内存</p>

<p>清除时垃圾回收器会扫描连续存放的死对象，将其变成空闲空间，并保存到一个空闲空间的链表中。这个链表常被scavenge算法用于分配被晋升对象的内存，但也被紧缩算法用于移动对象</p>

<p>紧缩算法会尝试将碎片页整合到一起来释放内存。由于页上的对象会被移动到新的页上，需要重新分配一些页。大致过程是，对目标碎片页中的每个活跃对象，在空闲内存链表中分配一块内存页，将该对象复制过去，并在碎片页中的该对象上写上新的内存地址。随后在迁出过程中，对象的旧地址将会被记录下来，在迁出结束后，V8会遍历所有它所记录的旧对象的地址，将其更新为新地址。由于标记过程中也记录了不同页之间的指针，这些指针在此时也会进行更新。如果一个页非常活跃，如其中有过多需要记录的指针，那么地址记录会跳过它，等到下一轮垃圾回收进行处理</p>

<h3 id="section-11">结合使用标记清除和标记整理</h3>
<p>V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理</p>

<h2 id="v8-5">V8的优化</h2>
<p>###Incremental Marking（增量标记）
由于全停顿会造成了浏览器一段时间无响应，所以V8使用了一种增量标记的方式，将完整的标记拆分成很多部分，每做完一部分就停下来，让JS的应用逻辑执行一会，这样垃圾回收与应用逻辑交替完成。经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原来的1/6左右</p>

<h3 id="section-12">惰性清理</h3>
<p>由于标记完成后，所有的对象都已经被标记，不是死对象就是活对象，堆上多少空间格局已经确定。我们可以不必着急释放那些死对象所占用的空间，而延迟清理过程的执行。垃圾回收器可以根据需要逐一清理死对象所占用的内存页</p>

<h3 id="section-13">其他</h3>
<p>V8后续还引入了增量式整理（incremental compaction），以及并行标记和并行清理，通过并行利用多核CPU来提升垃圾回收的性能</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/19/v8-gc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——信令篇 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/18/webRTC-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 18 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>这篇文章讲述了WebRTC中所涉及的信令交换以及聊天室中的信令交换，主要内容来自<a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a>，我在这里提取出的一些信息，并添加了自己在开发时的一些想法</p>

<h2 id="webrtc">WebRTC的服务器</h2>
<p>WebRTC提供了浏览器到浏览器（点对点）之间的通信，但并不意味着WebRTC不需要服务器。暂且不说基于服务器的一些扩展业务，WebRTC至少有两件事必须要用到服务器：
1. 浏览器之间交换建立通信的元数据（信令）必须通过服务器
2. 为了穿越NAT和防火墙</p>

<h2 id="section-1">为什么需要信令？</h2>
<p>我们需要通过一系列的信令来建立浏览器之间的通信。而具体需要通过信令交换哪些内容呢？这里大概列了一下：
1. 用来控制通信开启或者关闭的连接控制消息
2. 发生错误时用来彼此告知的消息
3. 媒体流元数据，比如像解码器、解码器的配置、带宽、媒体类型等等
4. 用来建立安全连接的关键数据
5. 外界所看到的的网络上的数据，比如IP地址、端口等</p>

<p>在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。</p>

<h2 id="webrtc-1">为什么WebRTC不去实现信令交换？</h2>
<p>不去由WebRTC实现信令交换的原因很简单：WebRTC标准的制定者们希望能够最大限度地兼容已有的成熟技术。具体的连接建立方式由一种叫JSEP（JavaScript Session Establishment Protocol）的协议来规定，使用JSEP有两个好处：
1. 在JSEP中，需要交换的关键信息是多媒体会话描述（multimedia session description）。由于开发者在其所开发的应用程序中信令所使用的协议不同（SIP或是XMPP或是开发者自己定义的协议），WebRTC建立呼叫的思想建立在媒体流控制层面上，从而与上层信令传输相分离，防止相互之间的信令污染。只要上层信令为其提供了多媒体会话描述符这样的关键信息就可以建立连接，不管开发者用何种方式来传递。
2. JSEP的架构同时也避免了在浏览器上保存连接的状态，防止其像一个状态机一样工作。由于页面经常被频繁的刷新，如果连接的状态保存在浏览器中，每次刷新都会丢失。使用JSEP能使得状态被保存在服务器上</p>

<p><img src="http://lingyu.wang/img/WebRTC/2.png" alt="JSEP的架构图" /></p>

<h2 id="session-description-protocol">会话描述协议（Session Description Protocol）</h2>
<p>JSEP将客户端之间传递的信令分为两种:offer信令和answer信令。他们主要内容的格式都遵循会话描述协议（Session Description Protocal，简称SDP）。一个SDP的信令的内容大致上如下：
<code>
v=0
o=- 7806956 075423448571 2 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE audio video data
a=msid-semantic: WMS 5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
m=audio 1 RTP/SAVPF 111 103 104 0 8 106 105 13 126
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=recvonly
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:103 ISAC/16000
a=rtpmap:104 ISAC/32000
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:106 CN/32000
a=rtpmap:105 CN/16000
a=rtpmap:13 CN/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
m=video 1 RTP/SAVPF 100 116 117
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:3162115896 cname:/nERF7Ern+udqf++
a=ssrc:3162115896 msid:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g 221b204e-c9a0-4b01-b361-e17e9bf8f639
a=ssrc:3162115896 mslabel:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
a=ssrc:3162115896 label:221b204e-c9a0-4b01-b361-e17e9bf8f639
m=application 1 DTLS/SCTP 5000
c=IN IP40.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:data
a=sctpmap:5000 webrtc-datachannel 1024
</code>
这些都什么玩意？说实话我不知道，我这里放这么一大段出来，只是为了让文章内容显得很多…如果想深入了解的话，可以参考<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a>自行进行解析</p>

<p>其实可以将其简化一下，它就是一个在点对点连接中描述自己的字符串，我们可以将其封装在JSON中进行传输，在PeerConnection建立后将其通过服务器中转后，将自己的SDP描述符和对方的SDP描述符交给PeerConnection就行了</p>

<h2 id="rtcpeerconnection">信令与RTCPeerConnection建立</h2>
<p>在前一篇文章中介绍过，WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，在建立RTCPeerConnection实例之后，想要使用其建立一个点对点的信道，我们需要做两件事：
1. 确定本机上的媒体流的特性，比如分辨率、编解码能力啥的（SDP描述符）
2. 连接两端的主机的网络地址（ICE Candidate）</p>

<p>需要注意的是，由于连接两端的主机都可能在内网或是在防火墙之后，我们需要一种对所有联网的计算机都通用的定位方式。这其中就涉及NAT/防火墙穿越技术，以及WebRTC用来达到这个目的所ICE框架。这一部分在上一篇文章中有介绍，这里不再赘述。</p>

<h3 id="offeranswersdp">通过offer和answer交换SDP描述符</h3>
<p>大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况，RTCPeerConnection简称PC）：
1. 甲和乙各自建立一个PC实例
2. 甲通过PC所提供的<code>createOffer()</code>方法建立一个包含甲的SDP描述符的offer信令
3. 甲通过PC所提供的<code>setLocalDescription()</code>方法，将甲的SDP描述符交给甲的PC实例
4. 甲将offer信令通过服务器发送给乙
5. 乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的<code>setRemoteDescription()</code>方法交给乙的PC实例
6. 乙通过PC所提供的<code>createAnswer()</code>方法建立一个包含乙的SDP描述符answer信令
7. 乙通过PC所提供的<code>setLocalDescription()</code>方法，将乙的SDP描述符交给乙的PC实例
8. 乙将answer信令通过服务器发送给甲
9. 甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用<code>setRemoteDescripttion()</code>方法交给甲自己的PC实例</p>

<p>通过在这一系列的信令交换之后，甲和乙所创建的PC实例都包含甲和乙的SDP描述符了，完成了两件事的第一件。我们还需要完成第二件事——获取连接两端主机的网络地址</p>

<h3 id="icenat">通过ICE框架建立NAT/防火墙穿越的连接</h3>
<p>这个网络地址应该是能从外界直接访问，WebRTC使用ICE框架来获得这个地址。RTCPeerConnection在创立的时候可以将ICE服务器的地址传递进去，如：
<code>javascript
var iceServer = {
    "iceServers": [{
        "url": "stun:stun.l.google.com:19302"
    }]
};
var pc = new RTCPeerConnection(iceServer);
</code>
当然这个地址也需要交换，还是以甲乙两位为例，交换的流程如下（RTCPeerConnection简称PC）：
1. 甲、乙各创建配置了ICE服务器的PC实例，并为其添加<code>onicecandidate</code>事件回调
2. 当网络候选可用时，将会调用<code>onicecandidate</code>函数
3. 在回调函数内部，甲或乙将网络候选的消息封装在ICE Candidate信令中，通过服务器中转，传递给对方
4. 甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时，将其解析并获得网络候选，将其通过PC实例的<code>addIceCandidate()</code>方法加入到PC实例中</p>

<p>这样连接就创立完成了，可以向RTCPeerConnection中通过<code>addStream()</code>加入流来传输媒体流数据。将流加入到RTCPeerConnection实例中后，对方就可以通过<code>onaddstream</code>所绑定的回调函数监听到了。调用<code>addStream()</code>可以在连接完成之前，在连接建立之后，对方一样能监听到媒体流</p>

<h2 id="section-2">聊天室中的信令</h2>
<p>上面是两个用户之间的信令交换流程，但我们需要建立一个多用户在线视频聊天的聊天室。所以需要进行一些扩展，来达到这个要求
###用户操作
首先需要确定一个用户在聊天室中的操作大致流程：
1. 打开页面连接到服务器上
2. 进入聊天室
3. 与其他所有已在聊天室的用户建立点对点的连接，并输出在页面上
4. 若有聊天室内的其他用户离开，应得到通知，关闭与其的连接并移除其在页面中的输出
5. 若又有其他用户加入，应得到通知，建立于新加入用户的连接，并输出在页面上
6. 离开页面，关闭所有连接</p>

<p>从上面可以看出来，除了点对点连接的建立，还需要服务器至少做如下几件事：
1. 新用户加入房间时，发送新用户的信息给房间内的其他用户
2. 新用户加入房间时，发送房间内的其他用户信息给新加入房间的用户
3. 用户离开房间时，发送离开用户的信息给房间内的其他用户</p>

<h3 id="section-3">实现思路</h3>
<p>以使用WebSocket为例，上面用户操作的流程可以进行以下修改：
1. 浏览器与服务器建立WebSocket连接
2. 发送一个加入聊天室的信令（join），信令中需要包含用户所进入的聊天室名称
3. 服务器根据用户所加入的房间，发送一个其他用户信令（peers），信令中包含聊天室中其他用户的信息，浏览器根据信息来逐个构建与其他用户的点对点连接
4. 若有用户离开，服务器发送一个用户离开信令（remove_peer），信令中包含离开的用户的信息，浏览器根据信息关闭与离开用户的信息，并作相应的清除操作
5. 若有新用户加入，服务器发送一个用户加入信令（new_peer），信令中包含新加入的用户的信息，浏览器根据信息来建立与这个新用户的点对点连接
6. 用户离开页面，关闭WebSocket连接</p>

<h3 id="section-4">服务器实现</h3>
<p>由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了WebSocket的连接：
```javascript
var server = new WebSocketServer();
var sockets = [];</p>

<p>server.on(‘connection’, function(socket){
    socket.on(‘close’, function(){
        var i = sockets.indexOf(socket);
        sockets.splice(i, 1);
        //关闭连接后的其他操作
    });
    sockets.push(socket);
    //连接建立后的其他操作
});
```</p>

<p>由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。</p>

<p>同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）:</p>

<p>于是乎代码大致就变成这样：
```javascript
var server = new WebSocketServer();
var sockets = [];
var rooms = {};</p>

<p>/*
join信令所接收的格式
{
    “eventName”: “join”,
    “data”: {
        “room”: “roomName”
    }
}
*/
var joinRoom = function(data, socket) {
    var room = data.room || “__default”;
    var curRoomSockets; //当前房间的socket列表
    var socketIds = []; //房间其他用户的id</p>

<pre><code>curRoomSockets = rooms[room] = rooms[room] || [];

//给所有房间内的其他人发送新用户的id
for (var i = curRoomSockets.length; i--;) {
    socketIds.push(curRoomSockets[i].id);
    curRoomSockets[i].send(JSON.stringify({
        "eventName": "new_peer",
        "data": {
            "socketId": socket.id
        }
    }));
}

//将新用户的连接加入到房间的连接列表中
curRoomSockets.push(socket);
socket.room = room;

//给新用户发送其他用户的信息，及服务器给新用户自己赋予的id
socket.send(JSON.stringify({
    "eventName": "peers",
    "data": {
        "socketIds": socketIds,
        "you": socket.id
    }
})); };
</code></pre>

<p>server.on(‘connection’, function(socket) {
    //为socket构建一个特有的id，用来作为区分用户的标记
    socket.id = getRandomString();
    //用户关闭连接后，应做的处理
    socket.on(‘close’, function() {
        var i = sockets.indexOf(socket);
        var room = socket.room;
        var curRoomSockets = rooms[room];
        sockets.splice(i, 1);
        //通知房间内其他用户
        if (curRoomSockets) {
            for (i = curRoomSockets.length; i–;) {
                curRoomSockets[i].send(JSON.stringify({
                    “eventName”: “remove_peer”,
                    “data”: {
                        “socketId”: socket.id
                    }
                }));
            }
        }
        //从room中删除socket
        if (room) {
            i = this.rooms[room].indexOf(socket);
            this.rooms[room].splice(i, 1);
            if (this.rooms[room].length === 0) {
                delete this.rooms[room];
            }
        }
        //关闭连接后的其他操作
    });
    //根据前台页面传递过来的信令进行解析，确定应该如何处理
    socket.on(‘message’, function(data) {
        var json = JSON.parse(data);
        if (json.eventName) {
            if (json.eventName === “join”) {
                joinRoom(data, socket);
            }
        }
    });
    //将连接保存
    sockets.push(socket);
    //连接建立后的其他操作
});
```</p>

<p>最后再加上点对点的信令转发就行了，一份完整的代码可参照我写的<a href="https://github.com/LingyuCoder/SkyRTC/blob/master/SkyRTC.js">SkyRTC项目源码</a></p>

<h2 id="section-5">参考资料</h2>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></p>

<p><a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/18/webRTC-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——信令篇 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/18/webRTC-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 18 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>这篇文章讲述了WebRTC中所涉及的信令交换以及聊天室中的信令交换，主要内容来自<a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a>，我在这里提取出的一些信息，并添加了自己在开发时的一些想法</p>

<h2 id="webrtc">WebRTC的服务器</h2>
<p>WebRTC提供了浏览器到浏览器（点对点）之间的通信，但并不意味着WebRTC不需要服务器。暂且不说基于服务器的一些扩展业务，WebRTC至少有两件事必须要用到服务器：
1. 浏览器之间交换建立通信的元数据（信令）必须通过服务器
2. 为了穿越NAT和防火墙</p>

<h2 id="section-1">为什么需要信令？</h2>
<p>我们需要通过一系列的信令来建立浏览器之间的通信。而具体需要通过信令交换哪些内容呢？这里大概列了一下：
1. 用来控制通信开启或者关闭的连接控制消息
2. 发生错误时用来彼此告知的消息
3. 媒体流元数据，比如像解码器、解码器的配置、带宽、媒体类型等等
4. 用来建立安全连接的关键数据
5. 外界所看到的的网络上的数据，比如IP地址、端口等</p>

<p>在建立连接之前，浏览器之间显然没有办法传递数据。所以我们需要通过服务器的中转，在浏览器之间传递这些数据，然后建立浏览器之间的点对点连接。但是WebRTC API中并没有实现这些。</p>

<h2 id="webrtc-1">为什么WebRTC不去实现信令交换？</h2>
<p>不去由WebRTC实现信令交换的原因很简单：WebRTC标准的制定者们希望能够最大限度地兼容已有的成熟技术。具体的连接建立方式由一种叫JSEP（JavaScript Session Establishment Protocol）的协议来规定，使用JSEP有两个好处：
1. 在JSEP中，需要交换的关键信息是多媒体会话描述（multimedia session description）。由于开发者在其所开发的应用程序中信令所使用的协议不同（SIP或是XMPP或是开发者自己定义的协议），WebRTC建立呼叫的思想建立在媒体流控制层面上，从而与上层信令传输相分离，防止相互之间的信令污染。只要上层信令为其提供了多媒体会话描述符这样的关键信息就可以建立连接，不管开发者用何种方式来传递。
2. JSEP的架构同时也避免了在浏览器上保存连接的状态，防止其像一个状态机一样工作。由于页面经常被频繁的刷新，如果连接的状态保存在浏览器中，每次刷新都会丢失。使用JSEP能使得状态被保存在服务器上</p>

<p><img src="http://lingyu.wang/img/WebRTC/2.png" alt="JSEP的架构图" /></p>

<h2 id="session-description-protocol">会话描述协议（Session Description Protocol）</h2>
<p>JSEP将客户端之间传递的信令分为两种:offer信令和answer信令。他们主要内容的格式都遵循会话描述协议（Session Description Protocal，简称SDP）。一个SDP的信令的内容大致上如下：
<code>
v=0
o=- 7806956 075423448571 2 IN IP4 127.0.0.1
s=-
t=0 0
a=group:BUNDLE audio video data
a=msid-semantic: WMS 5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
m=audio 1 RTP/SAVPF 111 103 104 0 8 106 105 13 126
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:audio
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=recvonly
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:111 opus/48000/2
a=fmtp:111 minptime=10
a=rtpmap:103 ISAC/16000
a=rtpmap:104 ISAC/32000
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:106 CN/32000
a=rtpmap:105 CN/16000
a=rtpmap:13 CN/8000
a=rtpmap:126 telephone-event/8000
a=maxptime:60
m=video 1 RTP/SAVPF 100 116 117
c=IN IP4 0.0.0.0
a=rtcp:1 IN IP4 0.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:video
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=sendrecv
a=rtcp-mux
a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:qzcKu22ar1+lYah6o8ggzGcQ5obCttoOO2IzXwFV
a=rtpmap:100 VP8/90000
a=rtcp-fb:100 ccm fir
a=rtcp-fb:100 nack
a=rtcp-fb:100 goog-remb
a=rtpmap:116 red/90000
a=rtpmap:117 ulpfec/90000
a=ssrc:3162115896 cname:/nERF7Ern+udqf++
a=ssrc:3162115896 msid:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g 221b204e-c9a0-4b01-b361-e17e9bf8f639
a=ssrc:3162115896 mslabel:5UhOcZZB1uXtVbYAU5thB0SpkXbzk9FHo30g
a=ssrc:3162115896 label:221b204e-c9a0-4b01-b361-e17e9bf8f639
m=application 1 DTLS/SCTP 5000
c=IN IP40.0.0.0
a=ice-ufrag:grnpQ0BSTSnBLroq
a=ice-pwd:N5i4DZKMM2L7FEYnhO8V7Kg5
a=ice-options:google-ice
a=fingerprint:sha-256 01:A3:18:0E:36:5E:EF:24:18:8C:8B:0C:9E:B0:84:F6:34:E9:42:E3:0F:43:64:ED:EC:46:2C:3C:23:E3:78:7B
a=setup:actpass
a=mid:data
a=sctpmap:5000 webrtc-datachannel 1024
</code>
这些都什么玩意？说实话我不知道，我这里放这么一大段出来，只是为了让文章内容显得很多…如果想深入了解的话，可以参考<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a>自行进行解析</p>

<p>其实可以将其简化一下，它就是一个在点对点连接中描述自己的字符串，我们可以将其封装在JSON中进行传输，在PeerConnection建立后将其通过服务器中转后，将自己的SDP描述符和对方的SDP描述符交给PeerConnection就行了</p>

<h2 id="rtcpeerconnection">信令与RTCPeerConnection建立</h2>
<p>在前一篇文章中介绍过，WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，在建立RTCPeerConnection实例之后，想要使用其建立一个点对点的信道，我们需要做两件事：
1. 确定本机上的媒体流的特性，比如分辨率、编解码能力啥的（SDP描述符）
2. 连接两端的主机的网络地址（ICE Candidate）</p>

<p>需要注意的是，由于连接两端的主机都可能在内网或是在防火墙之后，我们需要一种对所有联网的计算机都通用的定位方式。这其中就涉及NAT/防火墙穿越技术，以及WebRTC用来达到这个目的所ICE框架。这一部分在上一篇文章中有介绍，这里不再赘述。</p>

<h3 id="offeranswersdp">通过offer和answer交换SDP描述符</h3>
<p>大致上在两个用户（甲和乙）之间建立点对点连接流程应该是这个样子（这里不考虑错误的情况，RTCPeerConnection简称PC）：
1. 甲和乙各自建立一个PC实例
2. 甲通过PC所提供的<code>createOffer()</code>方法建立一个包含甲的SDP描述符的offer信令
3. 甲通过PC所提供的<code>setLocalDescription()</code>方法，将甲的SDP描述符交给甲的PC实例
4. 甲将offer信令通过服务器发送给乙
5. 乙将甲的offer信令中所包含的的SDP描述符提取出来，通过PC所提供的<code>setRemoteDescription()</code>方法交给乙的PC实例
6. 乙通过PC所提供的<code>createAnswer()</code>方法建立一个包含乙的SDP描述符answer信令
7. 乙通过PC所提供的<code>setLocalDescription()</code>方法，将乙的SDP描述符交给乙的PC实例
8. 乙将answer信令通过服务器发送给甲
9. 甲接收到乙的answer信令后，将其中乙的SDP描述符提取出来，调用<code>setRemoteDescripttion()</code>方法交给甲自己的PC实例</p>

<p>通过在这一系列的信令交换之后，甲和乙所创建的PC实例都包含甲和乙的SDP描述符了，完成了两件事的第一件。我们还需要完成第二件事——获取连接两端主机的网络地址</p>

<h3 id="icenat">通过ICE框架建立NAT/防火墙穿越的连接</h3>
<p>这个网络地址应该是能从外界直接访问，WebRTC使用ICE框架来获得这个地址。RTCPeerConnection在创立的时候可以将ICE服务器的地址传递进去，如：
<code>javascript
var iceServer = {
    "iceServers": [{
        "url": "stun:stun.l.google.com:19302"
    }]
};
var pc = new RTCPeerConnection(iceServer);
</code>
当然这个地址也需要交换，还是以甲乙两位为例，交换的流程如下（RTCPeerConnection简称PC）：
1. 甲、乙各创建配置了ICE服务器的PC实例，并为其添加<code>onicecandidate</code>事件回调
2. 当网络候选可用时，将会调用<code>onicecandidate</code>函数
3. 在回调函数内部，甲或乙将网络候选的消息封装在ICE Candidate信令中，通过服务器中转，传递给对方
4. 甲或乙接收到对方通过服务器中转所发送过来ICE Candidate信令时，将其解析并获得网络候选，将其通过PC实例的<code>addIceCandidate()</code>方法加入到PC实例中</p>

<p>这样连接就创立完成了，可以向RTCPeerConnection中通过<code>addStream()</code>加入流来传输媒体流数据。将流加入到RTCPeerConnection实例中后，对方就可以通过<code>onaddstream</code>所绑定的回调函数监听到了。调用<code>addStream()</code>可以在连接完成之前，在连接建立之后，对方一样能监听到媒体流</p>

<h2 id="section-2">聊天室中的信令</h2>
<p>上面是两个用户之间的信令交换流程，但我们需要建立一个多用户在线视频聊天的聊天室。所以需要进行一些扩展，来达到这个要求
###用户操作
首先需要确定一个用户在聊天室中的操作大致流程：
1. 打开页面连接到服务器上
2. 进入聊天室
3. 与其他所有已在聊天室的用户建立点对点的连接，并输出在页面上
4. 若有聊天室内的其他用户离开，应得到通知，关闭与其的连接并移除其在页面中的输出
5. 若又有其他用户加入，应得到通知，建立于新加入用户的连接，并输出在页面上
6. 离开页面，关闭所有连接</p>

<p>从上面可以看出来，除了点对点连接的建立，还需要服务器至少做如下几件事：
1. 新用户加入房间时，发送新用户的信息给房间内的其他用户
2. 新用户加入房间时，发送房间内的其他用户信息给新加入房间的用户
3. 用户离开房间时，发送离开用户的信息给房间内的其他用户</p>

<h3 id="section-3">实现思路</h3>
<p>以使用WebSocket为例，上面用户操作的流程可以进行以下修改：
1. 浏览器与服务器建立WebSocket连接
2. 发送一个加入聊天室的信令（join），信令中需要包含用户所进入的聊天室名称
3. 服务器根据用户所加入的房间，发送一个其他用户信令（peers），信令中包含聊天室中其他用户的信息，浏览器根据信息来逐个构建与其他用户的点对点连接
4. 若有用户离开，服务器发送一个用户离开信令（remove_peer），信令中包含离开的用户的信息，浏览器根据信息关闭与离开用户的信息，并作相应的清除操作
5. 若有新用户加入，服务器发送一个用户加入信令（new_peer），信令中包含新加入的用户的信息，浏览器根据信息来建立与这个新用户的点对点连接
6. 用户离开页面，关闭WebSocket连接</p>

<h3 id="section-4">服务器实现</h3>
<p>由于用户可以只是建立连接，可能还没有进入具体房间，所以首先我们需要一个容器来保存所有用户的连接，同时监听用户是否与服务器建立了WebSocket的连接：
```javascript
var server = new WebSocketServer();
var sockets = [];</p>

<p>server.on(‘connection’, function(socket){
    socket.on(‘close’, function(){
        var i = sockets.indexOf(socket);
        sockets.splice(i, 1);
        //关闭连接后的其他操作
    });
    sockets.push(socket);
    //连接建立后的其他操作
});
```</p>

<p>由于有房间的划分，所以我们需要在服务器上建立一个容器，用来保存房间内的用户信息。显然对象较为合适，键为房间名称，值为用户信息列表。</p>

<p>同时我们需要监听上面所说的用户加入房间的信令（join），新用户加入之后需要向新用户发送房间内其他用户信息（peers）和向房间内其他用户发送新用户信息（new_peer），以及用户离开时向其他用户发送离开用户的信息（remove_peer）:</p>

<p>于是乎代码大致就变成这样：
```javascript
var server = new WebSocketServer();
var sockets = [];
var rooms = {};</p>

<p>/*
join信令所接收的格式
{
    “eventName”: “join”,
    “data”: {
        “room”: “roomName”
    }
}
*/
var joinRoom = function(data, socket) {
    var room = data.room || “__default”;
    var curRoomSockets; //当前房间的socket列表
    var socketIds = []; //房间其他用户的id</p>

<pre><code>curRoomSockets = rooms[room] = rooms[room] || [];

//给所有房间内的其他人发送新用户的id
for (var i = curRoomSockets.length; i--;) {
    socketIds.push(curRoomSockets[i].id);
    curRoomSockets[i].send(JSON.stringify({
        "eventName": "new_peer",
        "data": {
            "socketId": socket.id
        }
    }));
}

//将新用户的连接加入到房间的连接列表中
curRoomSockets.push(socket);
socket.room = room;

//给新用户发送其他用户的信息，及服务器给新用户自己赋予的id
socket.send(JSON.stringify({
    "eventName": "peers",
    "data": {
        "socketIds": socketIds,
        "you": socket.id
    }
})); };
</code></pre>

<p>server.on(‘connection’, function(socket) {
    //为socket构建一个特有的id，用来作为区分用户的标记
    socket.id = getRandomString();
    //用户关闭连接后，应做的处理
    socket.on(‘close’, function() {
        var i = sockets.indexOf(socket);
        var room = socket.room;
        var curRoomSockets = rooms[room];
        sockets.splice(i, 1);
        //通知房间内其他用户
        if (curRoomSockets) {
            for (i = curRoomSockets.length; i–;) {
                curRoomSockets[i].send(JSON.stringify({
                    “eventName”: “remove_peer”,
                    “data”: {
                        “socketId”: socket.id
                    }
                }));
            }
        }
        //从room中删除socket
        if (room) {
            i = this.rooms[room].indexOf(socket);
            this.rooms[room].splice(i, 1);
            if (this.rooms[room].length === 0) {
                delete this.rooms[room];
            }
        }
        //关闭连接后的其他操作
    });
    //根据前台页面传递过来的信令进行解析，确定应该如何处理
    socket.on(‘message’, function(data) {
        var json = JSON.parse(data);
        if (json.eventName) {
            if (json.eventName === “join”) {
                joinRoom(data, socket);
            }
        }
    });
    //将连接保存
    sockets.push(socket);
    //连接建立后的其他操作
});
```</p>

<p>最后再加上点对点的信令转发就行了，一份完整的代码可参照我写的<a href="https://github.com/LingyuCoder/SkyRTC/blob/master/SkyRTC.js">SkyRTC项目源码</a></p>

<h2 id="section-5">参考资料</h2>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">WebRTC in the real world: STUN, TURN and signaling</a></p>

<p><a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1">SDP for the WebRTC draft-nandakumar-rtcweb-sdp-04</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/18/webRTC-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC文档（服务器部分） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/17/SkyRTC-doc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC">我在Github上的SkyRTC项目</a></p>

<h2 id="section">简介</h2>
<p>一个Node.js编写的WebRTC服务器端库，为服务器端库，需要配合客户端库<a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtcskyrtc-client">SkyRTC前端库SkyRTC-client</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a></p>

<h2 id="section-1">简单示例</h2>
<p>###NPM安装
执行如下命令从npm进行安装：
<code>
$ npm install skyrtc
</code>
###监听服务器
<code>javascript
var express = require('express');
var app = express();
var server = require('http').createServer(app);
var SkyRTC = require('skyrtc').listen(server);
var port = process.env.PORT || 3000;
server.listen(port);
</code></p>

<h3 id="webrtc">监听WebRTC事件</h3>
<p>SkyRTC继承自EventEmitter, 可以通过如下语法监听事件：
<code>javascript
SkyRTC.rtc.on('eventName', function(params) {
  //...
});
</code></p>

<h2 id="section-2">内置事件</h2>
<ul>
  <li>new_connect</li>
  <li>new_peer</li>
  <li>remove_peer</li>
  <li>socket_message</li>
  <li>ice_candidate</li>
  <li>offer</li>
  <li>answer</li>
</ul>

<h3 id="newconnect">new_connect</h3>
<p>新用户与服务器建立WebSocket连接时触发</p>

<p>参数：</p>

<ul>
  <li>socket——新建立的WebSocket连接实例</li>
</ul>

<h3 id="newpeer">new_peer</h3>
<p>用户加入房间后触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>room——房间名称</li>
</ul>

<h3 id="removepeer">remove_peer</h3>
<p>用户关闭连接后触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
</ul>

<h3 id="socketmessage">socket_message</h3>
<p>客户端向服务器端发送消息，且非自定义事件格式时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>msg——发送的消息内容</li>
</ul>

<h3 id="icecandidate">ice_candidate</h3>
<p>接收到ice candidate信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>candidate——ice candidate信令数据</li>
</ul>

<h3 id="offer">offer</h3>
<p>接收到offer信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>offer——offer信令数据</li>
</ul>

<h3 id="answer">answer</h3>
<p>接收到answer信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>answer——answer信令数据</li>
</ul>

<h2 id="section-3">接口</h2>
<ul>
  <li>getRooms</li>
  <li>broadcastInRoom</li>
  <li>broadcast</li>
  <li>getSocket</li>
  <li>on</li>
</ul>

<h3 id="getrooms">getRooms</h3>
<p>用户获取当前服务器上所有房间信息</p>

<p>参数：</p>

<p>无</p>

<p>返回值：</p>

<ul>
  <li>rooms——所有房间名称的数组</li>
</ul>

<h3 id="getsocket">getSocket</h3>
<p>通过socket的id获得socket实例</p>

<p>参数：</p>

<ul>
  <li>id——socket的id</li>
</ul>

<p>返回值：</p>

<ul>
  <li>socket——WebSocket实例</li>
</ul>

<h3 id="broadcastinroom">broadcastInRoom</h3>
<p>在房间中广播消息</p>

<p>参数：</p>

<ul>
  <li>room——被广播消息的房间名称</li>
  <li>data——消息的具体内容</li>
  <li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="broadcast">broadcast</h3>
<p>向服务器上的所有用户广播消息</p>

<p>参数：</p>

<ul>
  <li>data——消息的具体内容</li>
  <li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="on">on</h3>
<p>向服务器上的事件绑定处理器</p>

<p>参数：</p>

<ul>
  <li>eventName——被绑定的事件名称</li>
  <li>callback——被绑定的事件触发时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h2 id="section-4">自定义事件</h2>
<p>在SkyRTC中可以自定义事件，在前端页面使用WebSocket发送信息时，以如下JSON格式发送信息：
<code>javascript
{
    "eventName": "yourOwnEventName",
    "data": {
        //自定义事件数据
    }
}
</code></p>

<p>在后台通过监听同名事件来进行处理：
<code>javascript
SkyRTC.rtc.on("yourOwnEventName", function(data){
    //data将是前台所传输的数据
});
</code></p>

<p>自定义事件请不要与上述SkyRTC原生事件重名</p>

<h2 id="section-5">项目完整实例</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/17/SkyRTC-doc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC文档（服务器部分） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/17/SkyRTC-doc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC">我在Github上的SkyRTC项目</a></p>

<h2 id="section">简介</h2>
<p>一个Node.js编写的WebRTC服务器端库，为服务器端库，需要配合客户端库<a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtcskyrtc-client">SkyRTC前端库SkyRTC-client</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client</a></p>

<h2 id="section-1">简单示例</h2>
<p>###NPM安装
执行如下命令从npm进行安装：
<code>
$ npm install skyrtc
</code>
###监听服务器
<code>javascript
var express = require('express');
var app = express();
var server = require('http').createServer(app);
var SkyRTC = require('skyrtc').listen(server);
var port = process.env.PORT || 3000;
server.listen(port);
</code></p>

<h3 id="webrtc">监听WebRTC事件</h3>
<p>SkyRTC继承自EventEmitter, 可以通过如下语法监听事件：
<code>javascript
SkyRTC.rtc.on('eventName', function(params) {
  //...
});
</code></p>

<h2 id="section-2">内置事件</h2>
<ul>
  <li>new_connect</li>
  <li>new_peer</li>
  <li>remove_peer</li>
  <li>socket_message</li>
  <li>ice_candidate</li>
  <li>offer</li>
  <li>answer</li>
</ul>

<h3 id="newconnect">new_connect</h3>
<p>新用户与服务器建立WebSocket连接时触发</p>

<p>参数：</p>

<ul>
  <li>socket——新建立的WebSocket连接实例</li>
</ul>

<h3 id="newpeer">new_peer</h3>
<p>用户加入房间后触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>room——房间名称</li>
</ul>

<h3 id="removepeer">remove_peer</h3>
<p>用户关闭连接后触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
</ul>

<h3 id="socketmessage">socket_message</h3>
<p>客户端向服务器端发送消息，且非自定义事件格式时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>msg——发送的消息内容</li>
</ul>

<h3 id="icecandidate">ice_candidate</h3>
<p>接收到ice candidate信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>candidate——ice candidate信令数据</li>
</ul>

<h3 id="offer">offer</h3>
<p>接收到offer信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>offer——offer信令数据</li>
</ul>

<h3 id="answer">answer</h3>
<p>接收到answer信令时触发</p>

<p>参数：</p>

<ul>
  <li>socket——用户使用的WebSocket连接实例</li>
  <li>answer——answer信令数据</li>
</ul>

<h2 id="section-3">接口</h2>
<ul>
  <li>getRooms</li>
  <li>broadcastInRoom</li>
  <li>broadcast</li>
  <li>getSocket</li>
  <li>on</li>
</ul>

<h3 id="getrooms">getRooms</h3>
<p>用户获取当前服务器上所有房间信息</p>

<p>参数：</p>

<p>无</p>

<p>返回值：</p>

<ul>
  <li>rooms——所有房间名称的数组</li>
</ul>

<h3 id="getsocket">getSocket</h3>
<p>通过socket的id获得socket实例</p>

<p>参数：</p>

<ul>
  <li>id——socket的id</li>
</ul>

<p>返回值：</p>

<ul>
  <li>socket——WebSocket实例</li>
</ul>

<h3 id="broadcastinroom">broadcastInRoom</h3>
<p>在房间中广播消息</p>

<p>参数：</p>

<ul>
  <li>room——被广播消息的房间名称</li>
  <li>data——消息的具体内容</li>
  <li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="broadcast">broadcast</h3>
<p>向服务器上的所有用户广播消息</p>

<p>参数：</p>

<ul>
  <li>data——消息的具体内容</li>
  <li>errorCb——广播失败时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h3 id="on">on</h3>
<p>向服务器上的事件绑定处理器</p>

<p>参数：</p>

<ul>
  <li>eventName——被绑定的事件名称</li>
  <li>callback——被绑定的事件触发时的回调函数</li>
</ul>

<p>返回值：</p>

<p>无</p>

<h2 id="section-4">自定义事件</h2>
<p>在SkyRTC中可以自定义事件，在前端页面使用WebSocket发送信息时，以如下JSON格式发送信息：
<code>javascript
{
    "eventName": "yourOwnEventName",
    "data": {
        //自定义事件数据
    }
}
</code></p>

<p>在后台通过监听同名事件来进行处理：
<code>javascript
SkyRTC.rtc.on("yourOwnEventName", function(data){
    //data将是前台所传输的数据
});
</code></p>

<p>自定义事件请不要与上述SkyRTC原生事件重名</p>

<h2 id="section-5">项目完整实例</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/17/SkyRTC-doc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC实例 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/17/SkyRTC-demo.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体见<a href="https://github.com/LingyuCoder/SkyRTC-demo">我在Github上的SkyRTC-demo</a></p>

<h2 id="section">简介</h2>
<p>这是一个使用SkyRTC和SkyRTC-client搭建浏览器中音频、视频、文字聊天室的Demo</p>

<h2 id="section-1">安装和使用</h2>
<ol>
  <li>安装Node.js及npm环境</li>
  <li>下载源码到本地，并解压缩</li>
  <li>移动到解压后的目录下</li>
  <li>使用命令<code>npm install</code>安装所需要的库</li>
  <li>运行命令<code>node server.js</code>，建议配合<code>forever</code></li>
  <li>访问<code>localhost:3000#roomName</code>查看效果，其中<code>roomName</code>为进入的房间名，不同房间的用户无法互相通信</li>
</ol>

<h2 id="section-2">功能说明</h2>
<p>支持划分房间的在线音频、视频、文字聊天，提供房间内文件共享功能</p>

<h2 id="skyrtc">SkyRTC项目链接</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC项目</a></p>

<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client项目</a></p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/17/SkyRTC-demo.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC实例 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/17/SkyRTC-demo.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体见<a href="https://github.com/LingyuCoder/SkyRTC-demo">我在Github上的SkyRTC-demo</a></p>

<h2 id="section">简介</h2>
<p>这是一个使用SkyRTC和SkyRTC-client搭建浏览器中音频、视频、文字聊天室的Demo</p>

<h2 id="section-1">安装和使用</h2>
<ol>
  <li>安装Node.js及npm环境</li>
  <li>下载源码到本地，并解压缩</li>
  <li>移动到解压后的目录下</li>
  <li>使用命令<code>npm install</code>安装所需要的库</li>
  <li>运行命令<code>node server.js</code>，建议配合<code>forever</code></li>
  <li>访问<code>localhost:3000#roomName</code>查看效果，其中<code>roomName</code>为进入的房间名，不同房间的用户无法互相通信</li>
</ol>

<h2 id="section-2">功能说明</h2>
<p>支持划分房间的在线音频、视频、文字聊天，提供房间内文件共享功能</p>

<h2 id="skyrtc">SkyRTC项目链接</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC项目</a></p>

<p><a href="https://github.com/LingyuCoder/SkyRTC-client">SkyRTC-client项目</a></p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/17/SkyRTC-demo.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC-client文档(客户端部分) ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/17/SkyRTC-client-doc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC-client">我在Github上的SkyRTC-client项目</a></p>

<h2 id="section">简介</h2>
<p>一个Node.js编写的WebRTC浏览器端库，为客户端库，需要配合服务器端库<a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtc">SkyRTC客户端库</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a></p>

<p>可使用npm进行安装：
<code>
$ npm install skyrtc
</code></p>

<h2 id="skyrtc-1">SkyRTC实例</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>是一个基于SkyRTC搭建的多房间的在线音频、视频、文字聊天室，并能够共享文件</p>

<h2 id="skyrtc-client">SkyRTC-client的使用</h2>
<p>通过在HTML中引入JavaScript文件的方式引入：
<code>html
&lt;script type="text/javascript" src="/SkyRTC-client.js"&gt;&lt;/script&gt;
</code></p>

<p>可通过如下方式监听SkyRTC-client的事件：
<code>javascript
SkyRTC.on('someEvent', function(params) {
    //...
});
</code></p>

<p>连接后台WebSocket服务器：
<code>javascript
SkyRTC.connect("ws:" + window.location.href.substring(window.location.protocol.length).split('#')[0], window.location.hash.slice(1));
</code></p>

<h2 id="section-1">方法</h2>
<ul>
  <li>connect</li>
  <li>on</li>
  <li>sendFile</li>
  <li>shareFile</li>
  <li>sendMessage</li>
  <li>broadcast</li>
  <li>sendFileAccept</li>
  <li>sendFileRefuse</li>
  <li>createStream</li>
  <li>attachStream</li>
</ul>

<h3 id="connect">connect</h3>
<p>连接WebSocket后台服务器，建立信令交互的信道，并加入到一个房间之中</p>

<p>参数：</p>

<ul>
  <li>server——服务器地址</li>
  <li>room——房间名称</li>
</ul>

<p>返回值：
无</p>

<h3 id="on">on</h3>
<p>向SkyRTC-client相关事件绑定回调函数</p>

<p>参数：</p>

<ul>
  <li>eventName——事件名称</li>
  <li>callback——事件触发时的回调函数</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfile">sendFile</h3>
<p>向所在房间中的某个特定用户请求发送文件</p>

<p>参数：</p>

<ul>
  <li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>
  <li>socketId——接收文件的用户的id</li>
</ul>

<h3 id="sharefile">shareFile</h3>
<p>向所在房间中的所有其他用户请求发送文件</p>

<p>参数：</p>

<ul>
  <li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendmessage">sendMessage</h3>
<p>向所在房间内的某个特定用户发送消息</p>

<p>参数：</p>

<ul>
  <li>message——需要被发送的消息内容</li>
  <li>socketId——接收消息用户的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="broadcast">broadcast</h3>
<p>向所在房间中的所有其他用户发送文字消息</p>

<p>参数：</p>

<ul>
  <li>msg——需要被发送的消息字符串</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfileaccept">sendFileAccept</h3>
<p>接收到文件发送请求后，同意接收文件</p>

<p>参数：</p>

<ul>
  <li>sendId——发送文件的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfilerefuse">sendFileRefuse</h3>
<p>接收到文件发送请求后，拒绝接收文件</p>

<p>参数：</p>

<ul>
  <li>sendId——发送文件的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="createstream">createStream</h3>
<p>创建本地视频流</p>

<p>参数：</p>

<ul>
  <li>constraints——创建的视频流的约束对象</li>
</ul>

<p>返回值：
无</p>

<h3 id="attachstream">attachStream</h3>
<p>接收到远程视频流后，将视频流绑定到video标签上</p>

<p>参数：</p>

<ul>
  <li>stream——远程视频流对象</li>
  <li>domId——需要被绑定的video标签的id</li>
</ul>

<p>返回值：
无</p>

<h2 id="section-2">原生事件</h2>
<p>###连接建立
* connected
* socket_opened
* socket_error
* socket_closed
* socket_receive_message</p>

<h3 id="section-3">信令交换</h3>
<ul>
  <li>get_peers</li>
  <li>get_ice_candidate</li>
  <li>get_offer</li>
  <li>get_answer</li>
  <li>new_peer</li>
  <li>remove_peer</li>
</ul>

<h3 id="section-4">建立流</h3>
<ul>
  <li>stream_created</li>
  <li>stream_created_error</li>
</ul>

<h3 id="peerconnection">PeerConnection相关事件</h3>
<ul>
  <li>pc_get_ice_candidate</li>
  <li>pc_opened</li>
  <li>pc_add_stream</li>
  <li>pc_add_data_channel</li>
</ul>

<h3 id="datachannel">DataChannel相关事件</h3>
<ul>
  <li>data_channel_create_error</li>
  <li>data_channel_opened</li>
  <li>data_channel_closed</li>
  <li>data_channel_message</li>
  <li>data_channel_error</li>
</ul>

<h3 id="section-5">文件发送相关</h3>
<ul>
  <li>send_file_error</li>
  <li>send_file</li>
  <li>send_file_refused</li>
  <li>send_file_accepted</li>
  <li>send_file_chunk</li>
  <li>sended_file</li>
  <li>receive_file_chunk</li>
  <li>receive_file</li>
  <li>receive_file_ask</li>
  <li>receive_file_error</li>
</ul>

<h2 id="section-6">连接建立事件详解</h2>
<p>###connected
在于后台服务器成功创立WebSocket连接后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketopened">socket_opened</h3>
<p>WebSocket连接开启后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketerror">socket_error</h3>
<p>WebSocket连接发生错误后触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketclosed">socket_closed</h3>
<p>WebSocket连接关闭后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketreceivemessage">socket_receive_message</h3>
<p>WebSocket连接接收到非自定义事件格式的信息时触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
  <li>jsonMsg——JSON格式的message</li>
</ul>

<h2 id="section-7">信令交换事件详解</h2>
<p>###get_peers
在获取当前房间所有用户的id后调用</p>

<p>参数：</p>

<ul>
  <li>socketIds——房间内其他用户的id字符串列表</li>
</ul>

<h3 id="geticecandidate">get_ice_candidate</h3>
<p>在获得了ICE Candidate信令后调用</p>

<p>参数：</p>

<ul>
  <li>candidate——ICE Candidate信令数据</li>
</ul>

<h3 id="getoffer">get_offer</h3>
<p>在获得offer信令后调用</p>

<p>参数：</p>

<ul>
  <li>offer——offer信令数据
###get_answer
在获得answer信令后调用</li>
</ul>

<p>参数：</p>

<ul>
  <li>answer——answer信令数据</li>
</ul>

<h3 id="newpeer">new_peer</h3>
<p>在有新用户加入后调用</p>

<p>参数：</p>

<ul>
  <li>socketId：新用户的id</li>
</ul>

<h3 id="removepeer">remove_peer</h3>
<p>有用户断开连接后调用</p>

<p>参数：</p>

<ul>
  <li>socketId：断开连接的用户的socket id</li>
</ul>

<h2 id="section-8">建立流</h2>
<p>###stream_created
成功建立本地视频流时触发</p>

<p>参数：</p>

<ul>
  <li>stream——本地视频流对象</li>
</ul>

<h3 id="streamcreatederror">stream_created_error</h3>
<p>建立本地视频流失败时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
</ul>

<h2 id="peerconnection-1">PeerConnection相关事件</h2>
<p>###pc_opened
PeerConnection成功开启后触发</p>

<p>参数：</p>

<ul>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——成功开启的PeerConnection实例</li>
</ul>

<h3 id="pcgeticecandidate">pc_get_ice_candidate</h3>
<p>获得从ICE Candidate消息时触发</p>

<p>参数：</p>

<ul>
  <li>candidate——ICE Candidate信令内容</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——获得信令PeerConnection实例</li>
</ul>

<h3 id="pcaddstream">pc_add_stream</h3>
<p>通过PeerConnection上接收到视频流后触发</p>

<p>参数：</p>

<ul>
  <li>stream——添加的流对象</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——增加流的PeerConnection实例</li>
</ul>

<h3 id="pcadddatachannel">pc_add_data_channel</h3>
<p>通过PeerConnection上接收到data channel后触发</p>

<p>参数：</p>

<ul>
  <li>channel——添加的data channel</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——增加data channel的PeerConnection实例</li>
</ul>

<h2 id="datachannel-1">DataChannel相关事件</h2>
<p>###data_channel_create_error
data channel创建失败时触发</p>

<p>参数：</p>

<ul>
  <li>socketId——data channel所连接用户的id</li>
  <li>error——错误对象</li>
</ul>

<h3 id="datachannelopened">data_channel_opened</h3>
<p>data channel成功开启后触发</p>

<p>参数：</p>

<ul>
  <li>channel——开启的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="datachannelclosed">data_channel_closed</h3>
<p>data channel关闭后触发</p>

<p>参数：</p>

<ul>
  <li>channel——被关闭的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="datachannelmessage">data_channel_message</h3>
<p>data channel上接收到数据且非文件信令类型时触发</p>

<p>参数：</p>

<ul>
  <li>channel——接收到数据的data channel实例</li>
  <li>socketId——data channel所属用户的id</li>
  <li>message——json格式的接收到的具体数据信息</li>
</ul>

<h3 id="datachannelerror">data_channel_error</h3>
<p>data channel发生错误时触发</p>

<p>参数：</p>

<ul>
  <li>channel——发生错误的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
  <li>error——错误对象</li>
</ul>

<h2 id="section-9">文件发送相关</h2>
<p>###send_file
读取需要发送的文件完毕，并请求对方接收时触发</p>

<p>参数：</p>

<ul>
  <li>sendId：发送的文件id</li>
  <li>socketId：接收者的id</li>
  <li>file：被发送的文件对象</li>
</ul>

<h3 id="sendfileerror">send_file_error</h3>
<p>发送方发送文件失败时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>socketId——接收者的id</li>
  <li>sendId——发送失败的文件的id，为空则表示获取文件失败</li>
  <li>file——发送失败的文件对象，为空则表示获取文件失败</li>
</ul>

<h3 id="sendfilerefused">send_file_refused</h3>
<p>对方拒绝接收文件时触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被拒绝接收的文件id</li>
  <li>socketId——接收者的id</li>
  <li>file——被拒绝接收的文件</li>
</ul>

<h3 id="sendfileaccepted">send_file_accepted</h3>
<p>对方同意接收文件时触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被同意接收的文件id</li>
  <li>socketId——接收者的id</li>
  <li>file——被同意接收的文件</li>
</ul>

<h3 id="sendfilechunk">send_file_chunk</h3>
<p>文件碎片发送后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——文件碎片所属文件的id</li>
  <li>socketId——接收者的id</li>
  <li>percent——已发送的百分比</li>
  <li>file——被发送的文件对象</li>
</ul>

<h3 id="sendedfile">sended_file</h3>
<p>文件发送完成后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被发送的文件Id</li>
  <li>socketId——接收者的id</li>
  <li>file——被发送的文件对象
###receive_file_chunk
接收到文件碎片时触发</li>
</ul>

<p>参数：</p>

<ul>
  <li>sendId——接收的文件的Id</li>
  <li>socketId——发送者的id</li>
  <li>fileName——文件的名称</li>
  <li>percent——文件接收到的百分比</li>
</ul>

<h3 id="receivefile">receive_file</h3>
<p>接收完整个文件后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——接收的文件的Id</li>
  <li>socketId——发送者的id</li>
  <li>name——接收到的文件的名称</li>
</ul>

<h3 id="receivefileask">receive_file_ask</h3>
<p>接收到文件发送请求后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被请求接收的文件的id</li>
  <li>socketId——发送者的id</li>
  <li>fileName——被请求接收的文件的名称</li>
  <li>fileSize——被请求接收的文件的大小</li>
</ul>

<h3 id="receivefileerror">receive_file_error</h3>
<p>接收文件错误时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>sendId——接收文件的id</li>
  <li>socketId——发送者的id</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/17/SkyRTC-client-doc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 开源WebRTC库——SkyRTC-client文档(客户端部分) ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/17/SkyRTC-client-doc.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 17 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>忙了几天终于把SkyRTC库上传到NPM上了，并写了一份详细的使用文档，标明了基本的使用方法和类，修正了几个小bug，更多的bug还需要更多的测试，把文档发一下，具体项目见<a href="https://github.com/LingyuCoder/SkyRTC-client">我在Github上的SkyRTC-client项目</a></p>

<h2 id="section">简介</h2>
<p>一个Node.js编写的WebRTC浏览器端库，为客户端库，需要配合服务器端库<a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a>共同使用，用于搭建基于WebRTC和WebSocket技术的在线音频、视频聊天室</p>

<h2 id="skyrtc">SkyRTC客户端库</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC">SkyRTC</a></p>

<p>可使用npm进行安装：
<code>
$ npm install skyrtc
</code></p>

<h2 id="skyrtc-1">SkyRTC实例</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>是一个基于SkyRTC搭建的多房间的在线音频、视频、文字聊天室，并能够共享文件</p>

<h2 id="skyrtc-client">SkyRTC-client的使用</h2>
<p>通过在HTML中引入JavaScript文件的方式引入：
<code>html
&lt;script type="text/javascript" src="/SkyRTC-client.js"&gt;&lt;/script&gt;
</code></p>

<p>可通过如下方式监听SkyRTC-client的事件：
<code>javascript
SkyRTC.on('someEvent', function(params) {
    //...
});
</code></p>

<p>连接后台WebSocket服务器：
<code>javascript
SkyRTC.connect("ws:" + window.location.href.substring(window.location.protocol.length).split('#')[0], window.location.hash.slice(1));
</code></p>

<h2 id="section-1">方法</h2>
<ul>
  <li>connect</li>
  <li>on</li>
  <li>sendFile</li>
  <li>shareFile</li>
  <li>sendMessage</li>
  <li>broadcast</li>
  <li>sendFileAccept</li>
  <li>sendFileRefuse</li>
  <li>createStream</li>
  <li>attachStream</li>
</ul>

<h3 id="connect">connect</h3>
<p>连接WebSocket后台服务器，建立信令交互的信道，并加入到一个房间之中</p>

<p>参数：</p>

<ul>
  <li>server——服务器地址</li>
  <li>room——房间名称</li>
</ul>

<p>返回值：
无</p>

<h3 id="on">on</h3>
<p>向SkyRTC-client相关事件绑定回调函数</p>

<p>参数：</p>

<ul>
  <li>eventName——事件名称</li>
  <li>callback——事件触发时的回调函数</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfile">sendFile</h3>
<p>向所在房间中的某个特定用户请求发送文件</p>

<p>参数：</p>

<ul>
  <li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>
  <li>socketId——接收文件的用户的id</li>
</ul>

<h3 id="sharefile">shareFile</h3>
<p>向所在房间中的所有其他用户请求发送文件</p>

<p>参数：</p>

<ul>
  <li>dom——包含需要被发送的文件的input[type=’file’]的id或者dom对象</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendmessage">sendMessage</h3>
<p>向所在房间内的某个特定用户发送消息</p>

<p>参数：</p>

<ul>
  <li>message——需要被发送的消息内容</li>
  <li>socketId——接收消息用户的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="broadcast">broadcast</h3>
<p>向所在房间中的所有其他用户发送文字消息</p>

<p>参数：</p>

<ul>
  <li>msg——需要被发送的消息字符串</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfileaccept">sendFileAccept</h3>
<p>接收到文件发送请求后，同意接收文件</p>

<p>参数：</p>

<ul>
  <li>sendId——发送文件的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="sendfilerefuse">sendFileRefuse</h3>
<p>接收到文件发送请求后，拒绝接收文件</p>

<p>参数：</p>

<ul>
  <li>sendId——发送文件的id</li>
</ul>

<p>返回值：
无</p>

<h3 id="createstream">createStream</h3>
<p>创建本地视频流</p>

<p>参数：</p>

<ul>
  <li>constraints——创建的视频流的约束对象</li>
</ul>

<p>返回值：
无</p>

<h3 id="attachstream">attachStream</h3>
<p>接收到远程视频流后，将视频流绑定到video标签上</p>

<p>参数：</p>

<ul>
  <li>stream——远程视频流对象</li>
  <li>domId——需要被绑定的video标签的id</li>
</ul>

<p>返回值：
无</p>

<h2 id="section-2">原生事件</h2>
<p>###连接建立
* connected
* socket_opened
* socket_error
* socket_closed
* socket_receive_message</p>

<h3 id="section-3">信令交换</h3>
<ul>
  <li>get_peers</li>
  <li>get_ice_candidate</li>
  <li>get_offer</li>
  <li>get_answer</li>
  <li>new_peer</li>
  <li>remove_peer</li>
</ul>

<h3 id="section-4">建立流</h3>
<ul>
  <li>stream_created</li>
  <li>stream_created_error</li>
</ul>

<h3 id="peerconnection">PeerConnection相关事件</h3>
<ul>
  <li>pc_get_ice_candidate</li>
  <li>pc_opened</li>
  <li>pc_add_stream</li>
  <li>pc_add_data_channel</li>
</ul>

<h3 id="datachannel">DataChannel相关事件</h3>
<ul>
  <li>data_channel_create_error</li>
  <li>data_channel_opened</li>
  <li>data_channel_closed</li>
  <li>data_channel_message</li>
  <li>data_channel_error</li>
</ul>

<h3 id="section-5">文件发送相关</h3>
<ul>
  <li>send_file_error</li>
  <li>send_file</li>
  <li>send_file_refused</li>
  <li>send_file_accepted</li>
  <li>send_file_chunk</li>
  <li>sended_file</li>
  <li>receive_file_chunk</li>
  <li>receive_file</li>
  <li>receive_file_ask</li>
  <li>receive_file_error</li>
</ul>

<h2 id="section-6">连接建立事件详解</h2>
<p>###connected
在于后台服务器成功创立WebSocket连接后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketopened">socket_opened</h3>
<p>WebSocket连接开启后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketerror">socket_error</h3>
<p>WebSocket连接发生错误后触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketclosed">socket_closed</h3>
<p>WebSocket连接关闭后触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
</ul>

<h3 id="socketreceivemessage">socket_receive_message</h3>
<p>WebSocket连接接收到非自定义事件格式的信息时触发</p>

<p>参数：</p>

<ul>
  <li>socket——与后台连接的WebSocket实例</li>
  <li>jsonMsg——JSON格式的message</li>
</ul>

<h2 id="section-7">信令交换事件详解</h2>
<p>###get_peers
在获取当前房间所有用户的id后调用</p>

<p>参数：</p>

<ul>
  <li>socketIds——房间内其他用户的id字符串列表</li>
</ul>

<h3 id="geticecandidate">get_ice_candidate</h3>
<p>在获得了ICE Candidate信令后调用</p>

<p>参数：</p>

<ul>
  <li>candidate——ICE Candidate信令数据</li>
</ul>

<h3 id="getoffer">get_offer</h3>
<p>在获得offer信令后调用</p>

<p>参数：</p>

<ul>
  <li>offer——offer信令数据
###get_answer
在获得answer信令后调用</li>
</ul>

<p>参数：</p>

<ul>
  <li>answer——answer信令数据</li>
</ul>

<h3 id="newpeer">new_peer</h3>
<p>在有新用户加入后调用</p>

<p>参数：</p>

<ul>
  <li>socketId：新用户的id</li>
</ul>

<h3 id="removepeer">remove_peer</h3>
<p>有用户断开连接后调用</p>

<p>参数：</p>

<ul>
  <li>socketId：断开连接的用户的socket id</li>
</ul>

<h2 id="section-8">建立流</h2>
<p>###stream_created
成功建立本地视频流时触发</p>

<p>参数：</p>

<ul>
  <li>stream——本地视频流对象</li>
</ul>

<h3 id="streamcreatederror">stream_created_error</h3>
<p>建立本地视频流失败时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
</ul>

<h2 id="peerconnection-1">PeerConnection相关事件</h2>
<p>###pc_opened
PeerConnection成功开启后触发</p>

<p>参数：</p>

<ul>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——成功开启的PeerConnection实例</li>
</ul>

<h3 id="pcgeticecandidate">pc_get_ice_candidate</h3>
<p>获得从ICE Candidate消息时触发</p>

<p>参数：</p>

<ul>
  <li>candidate——ICE Candidate信令内容</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——获得信令PeerConnection实例</li>
</ul>

<h3 id="pcaddstream">pc_add_stream</h3>
<p>通过PeerConnection上接收到视频流后触发</p>

<p>参数：</p>

<ul>
  <li>stream——添加的流对象</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——增加流的PeerConnection实例</li>
</ul>

<h3 id="pcadddatachannel">pc_add_data_channel</h3>
<p>通过PeerConnection上接收到data channel后触发</p>

<p>参数：</p>

<ul>
  <li>channel——添加的data channel</li>
  <li>socketId——PeerConnection所连接用户的id</li>
  <li>pc——增加data channel的PeerConnection实例</li>
</ul>

<h2 id="datachannel-1">DataChannel相关事件</h2>
<p>###data_channel_create_error
data channel创建失败时触发</p>

<p>参数：</p>

<ul>
  <li>socketId——data channel所连接用户的id</li>
  <li>error——错误对象</li>
</ul>

<h3 id="datachannelopened">data_channel_opened</h3>
<p>data channel成功开启后触发</p>

<p>参数：</p>

<ul>
  <li>channel——开启的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="datachannelclosed">data_channel_closed</h3>
<p>data channel关闭后触发</p>

<p>参数：</p>

<ul>
  <li>channel——被关闭的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
</ul>

<h3 id="datachannelmessage">data_channel_message</h3>
<p>data channel上接收到数据且非文件信令类型时触发</p>

<p>参数：</p>

<ul>
  <li>channel——接收到数据的data channel实例</li>
  <li>socketId——data channel所属用户的id</li>
  <li>message——json格式的接收到的具体数据信息</li>
</ul>

<h3 id="datachannelerror">data_channel_error</h3>
<p>data channel发生错误时触发</p>

<p>参数：</p>

<ul>
  <li>channel——发生错误的data channel实例</li>
  <li>socketId——data channel所连接用户的id</li>
  <li>error——错误对象</li>
</ul>

<h2 id="section-9">文件发送相关</h2>
<p>###send_file
读取需要发送的文件完毕，并请求对方接收时触发</p>

<p>参数：</p>

<ul>
  <li>sendId：发送的文件id</li>
  <li>socketId：接收者的id</li>
  <li>file：被发送的文件对象</li>
</ul>

<h3 id="sendfileerror">send_file_error</h3>
<p>发送方发送文件失败时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>socketId——接收者的id</li>
  <li>sendId——发送失败的文件的id，为空则表示获取文件失败</li>
  <li>file——发送失败的文件对象，为空则表示获取文件失败</li>
</ul>

<h3 id="sendfilerefused">send_file_refused</h3>
<p>对方拒绝接收文件时触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被拒绝接收的文件id</li>
  <li>socketId——接收者的id</li>
  <li>file——被拒绝接收的文件</li>
</ul>

<h3 id="sendfileaccepted">send_file_accepted</h3>
<p>对方同意接收文件时触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被同意接收的文件id</li>
  <li>socketId——接收者的id</li>
  <li>file——被同意接收的文件</li>
</ul>

<h3 id="sendfilechunk">send_file_chunk</h3>
<p>文件碎片发送后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——文件碎片所属文件的id</li>
  <li>socketId——接收者的id</li>
  <li>percent——已发送的百分比</li>
  <li>file——被发送的文件对象</li>
</ul>

<h3 id="sendedfile">sended_file</h3>
<p>文件发送完成后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被发送的文件Id</li>
  <li>socketId——接收者的id</li>
  <li>file——被发送的文件对象
###receive_file_chunk
接收到文件碎片时触发</li>
</ul>

<p>参数：</p>

<ul>
  <li>sendId——接收的文件的Id</li>
  <li>socketId——发送者的id</li>
  <li>fileName——文件的名称</li>
  <li>percent——文件接收到的百分比</li>
</ul>

<h3 id="receivefile">receive_file</h3>
<p>接收完整个文件后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——接收的文件的Id</li>
  <li>socketId——发送者的id</li>
  <li>name——接收到的文件的名称</li>
</ul>

<h3 id="receivefileask">receive_file_ask</h3>
<p>接收到文件发送请求后触发</p>

<p>参数：</p>

<ul>
  <li>sendId——被请求接收的文件的id</li>
  <li>socketId——发送者的id</li>
  <li>fileName——被请求接收的文件的名称</li>
  <li>fileSize——被请求接收的文件的大小</li>
</ul>

<h3 id="receivefileerror">receive_file_error</h3>
<p>接收文件错误时触发</p>

<p>参数：</p>

<ul>
  <li>error——错误对象</li>
  <li>sendId——接收文件的id</li>
  <li>socketId——发送者的id</li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/17/SkyRTC-client-doc.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——入门篇 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/15/webRTC-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="webrtc">什么是WebRTC？</h2>
<p>众所周知，浏览器本身不支持相互之间直接建立信道进行通信，都是通过服务器进行中转。比如现在有两个客户端，甲和乙，他们俩想要通信，首先需要甲和服务器、乙和服务器之间建立信道。甲给乙发送消息时，甲先将消息发送到服务器上，服务器对甲的消息进行中转，发送到乙处，反过来也是一样。这样甲与乙之间的一次消息要通过两段信道，通信的效率同时受制于这两段信道的带宽。同时这样的信道并不适合数据流的传输，如何建立浏览器之间的点对点传输，一直困扰着开发者。WebRTC应运而生</p>

<p>WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口。说的简单明了一点就是让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频</p>

<h2 id="webrtc-1">WebRTC已经在我们的浏览器中</h2>
<p>这么好的功能，各大浏览器厂商自然不会置之不理。现在WebRTC已经可以在较新版的Chrome、Opera和Firefox中使用了，著名的浏览器兼容性查询网站caniuse上给出了一份详尽的浏览器兼容情况</p>

<p><img src="http://lingyu.wang/img/WebRTC/1.png" alt="WebRTC浏览器兼容性from caniuse.com" /></p>

<p>另外根据36Kr前段时间的新闻<a href="http://www.36kr.com/p/205614.html">Google推出支持WebRTC及Web Audio的Android 版Chrome 29@36kr</a>和<a href="http://www.36kr.com/p/210209.html">Android版Opera开始支持WebRTC，允许用户在没有任何插件的情况下实现语音和视频聊天</a>，Android也开始支持WebRTC</p>

<h2 id="section">三个接口</h2>
<p>WebRTC实现了三个API，分别是:
* MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流
* RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件
* RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据</p>

<p>这里大致上介绍一下这三个API</p>

<h2 id="mediastreamgetusermedia">MediaStream（getUserMedia）</h2>
<p>MediaStream API为WebRTC提供了从设备的摄像头、话筒获取视频、音频流数据的功能
###W3C标准
<a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C标准传送门</a>
###如何调用
同门可以通过调用navigator.getUserMedia()，这个方法接受三个参数：
1. 一个约束对象（constraints object），这个后面会单独讲
2. 一个调用成功的回调函数，如果调用成功，传递给它一个流对象
3. 一个调用失败的回调函数，如果调用失败，传递给它一个错误对象</p>

<h3 id="section-1">浏览器兼容性</h3>
<p>由于浏览器实现不同，他们经常会在实现标准版本之前，在方法前面加上前缀，所以一个兼容版本就像这样
<code>javacript
var getUserMedia = (navigator.getUserMedia || 
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);
</code></p>

<h3 id="section-2">一个超级简单的例子</h3>
<p>这里写一个超级简单的例子，用来展现getUserMedia的效果：
```html
&lt;!doctype html&gt;
&lt;html lang="zh-CN"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>GetUserMedia实例</title>
</head>
<body>
    <video id="video" autoplay=""></video>
</body>
<script type="text/javascript">
    var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

    getUserMedia.call(navigator, {
        video: true,
        audio: true
    }, function(localMediaStream) {
        var video = document.getElementById('video');
        video.src = window.URL.createObjectURL(localMediaStream);
        video.onloadedmetadata = function(e) {
            console.log("Label: " + localMediaStream.label);
            console.log("AudioTracks" , localMediaStream.getAudioTracks());
            console.log("VideoTracks" , localMediaStream.getVideoTracks());
        };
    }, function(e) {
        console.log('Reeeejected!', e);
    });
</script>

<p>&lt;/html&gt;
```
将这段内容保存在一个HTML文件中，放在服务器上。用较新版本的Opera、Firefox、Chrome打开，在浏览器弹出询问是否允许访问摄像头和话筒，选同意，浏览器上就会出现摄像头所拍摄到的画面了</p>

<p>注意，HTML文件要放在服务器上，否则会得到一个NavigatorUserMediaError的错误，显示PermissionDeniedError，最简单方法就是cd到HTML文件所在目录下，然后<code>python -m SimpleHTTPServer</code>（装了python的话），然后在浏览器中输入<code>http://localhost:8000/{文件名称}.html</code></p>

<p>这里使用<code>getUserMedia</code>获得流之后，需要将其输出，一般是绑定到<code>video</code>标签上输出，需要使用<code>window.URL.createObjectURL(localMediaStream)</code>来创造能在<code>video</code>中使用<code>src</code>属性播放的Blob URL，注意在<code>video</code>上加入<code>autoplay</code>属性，否则只能捕获到一张图片</p>

<p>流创建完毕后可以通过<code>label</code>属性来获得其唯一的标识，还可以通过<code>getAudioTracks()</code>和<code>getVideoTracks()</code>方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组）</p>

<h3 id="constraints">约束对象（Constraints）</h3>
<p>约束对象可以被设置在<code>getUserMedia()</code>和RTCPeerConnection的<code>addStream</code>方法中，这个约束对象是WebRTC用来指定接受什么样的流的，其中可以定义如下属性：
* video: 是否接受视频流
* audio：是否接受音频流
* MinWidth: 视频流的最小宽度
* MaxWidth：视频流的最大宽度
* MinHeight：视频流的最小高度
* MaxHiehgt：视频流的最大高度
* MinAspectRatio：视频流的最小宽高比
* MaxAspectRatio：视频流的最大宽高比
* MinFramerate：视频流的最小帧速率
* MaxFramerate：视频流的最大帧速率</p>

<p>详情见<a href="http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00">Resolution Constraints in Web Real Time Communications draft-alvestrand-constraints-resolution-00</a></p>

<h2 id="rtcpeerconnection">RTCPeerConnection</h2>
<p>WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，这个流数据通道是点对点的，不需要经过服务器进行中转。但是这并不意味着我们能抛弃服务器，我们仍然需要它来为我们传递信令（signaling）来建立这个信道。WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分</p>

<h3 id="section-3">信令</h3>
<p>既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道，比如我写的<a href="https://github.com/LingyuCoder/SkyRTC-demo">demo</a>，就是用的node的ws模块，在WebSocket上传递信令</p>

<p>需要信令来交换的信息有三种：
* session的信息：用来初始化通信还有报错
* 网络配置：比如IP地址和端口啥的
* 媒体适配：发送方和接收方的浏览器能够接受什么样的编码器和分辨率</p>

<p>这些信息的交换应该在点对点的流传输之前就全部完成，一个大致的架构图如下：</p>

<p><img src="http://lingyu.wang/img/WebRTC/2.png" alt="JSEP架构" /></p>

<h3 id="section-4">通过服务器建立信道</h3>
<p>这里再次重申，就算WebRTC提供浏览器之间的点对点信道进行数据传输，但是建立这个信道，必须有服务器的参与。WebRTC需要服务器对其进行四方面的功能支持：
1. 用户发现以及通信
2. 信令传输
3. NAT/防火墙穿越
4. 如果点对点通信建立失败，可以作为中转服务器</p>

<h3 id="nat">NAT/防火墙穿越技术</h3>
<p>建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越</p>

<p>ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。</p>

<p>我们可以使用Google的STUN服务器：<code>stun:stun.l.google.com:19302</code>，于是乎，一个整合了ICE框架的架构应该长这个样子</p>

<p><img src="http://lingyu.wang/img/WebRTC/3.png" alt="整合了ICE框架的WebRTC应用架构" /></p>

<h3 id="section-5">浏览器兼容</h3>
<p>还是前缀不同的问题，采用和上面类似的方法：
<code>javascript
var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);
</code></p>

<h3 id="section-6">创建和使用</h3>
<p>```javascript
//使用Google的stun服务器
var iceServer = {
    “iceServers”: [{
        “url”: “stun:stun.l.google.com:19302”
    }]
};
//兼容浏览器的getUserMedia写法
var getUserMedia = (navigator.getUserMedia ||
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);
//兼容浏览器的PeerConnection写法
var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);
//与后台服务器的WebSocket连接
var socket = __createWebSocketChannel();
//创建PeerConnection实例
var pc = new PeerConnection(iceServer);
//发送ICE候选到其他客户端
pc.onicecandidate = function(event){
    socket.send(JSON.stringify({
        “event”: “__ice_candidate”,
        “data”: {
            “candidate”: event.candidate
        }
    }));
};
//如果检测到媒体流连接到本地，将其绑定到一个video标签上输出
pc.onaddstream = function(event){
    someVideoElement.src = URL.createObjectURL(event.stream);
};
//获取本地的媒体流，并绑定到一个video标签上输出，并且发送这个媒体流给其他客户端
getUserMedia.call(navigator, {
    “audio”: true,
    “video”: true
}, function(stream){
    //发送offer和answer的函数，发送本地session描述
    var sendOfferFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                “event”: “__offer”,
                “data”: {
                    “sdp”: desc
                }
            }));
        },
        sendAnswerFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                “event”: “__answer”,
                “data”: {
                    “sdp”: desc
                }
            }));
        };
    //绑定本地媒体流到video标签用于输出
    myselfVideoElement.src = URL.createObjectURL(stream);
    //向PeerConnection中加入需要发送的流
    pc.addStream(stream);
    //如果是发送方则发送一个offer信令，否则发送一个answer信令
    if(isCaller){
        pc.createOffer(sendOfferFn);
    } else {
        pc.createAnswer(sendAnswerFn);
    }
}, function(error){
    //处理媒体流创建失败错误
});
//处理到来的信令
socket.onmessage = function(event){
    var json = JSON.parse(event.data);
    //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
    if( json.event === “__ice_candidate” ){
        pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
    } else {
         pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));
    }
};</p>

<p>```</p>

<h3 id="section-7">实例</h3>
<p>由于涉及较为复杂灵活的信令传输，故这里不做简短的实例，可以直接移步到最后</p>

<h2 id="rtcdatachannel">RTCDataChannel</h2>
<p>既然能建立点对点的信道来传递实时的视频、音频数据流，为什么不能用这个信道传一点其他数据呢？RTCDataChannel API就是用来干这个的，基于它我们可以在浏览器之间传输任意数据。DataChannel是建立在PeerConnection上的，不能单独使用
###使用DataChannel
我们可以使用<code>channel = pc.createDataCHannel("someLabel");</code>来在PeerConnection的实例上创建Data Channel，并给与它一个标签</p>

<p>DataChannel使用方式几乎和WebSocket一样，有几个事件：
* onopen
* onclose
* onmessage
* onerror</p>

<p>同时它有几个状态，可以通过<code>readyState</code>获取：
* connecting: 浏览器之间正在试图建立channel
* open：建立成功，可以使用<code>send</code>方法发送数据了
* closing：浏览器正在关闭channel
* closed：channel已经被关闭了</p>

<p>两个暴露的方法:
* close(): 用于关闭channel
* send()：用于通过channel向对方发送数据</p>

<h3 id="data-channel">通过Data Channel发送文件大致思路</h3>
<p>JavaScript已经提供了File API从<code>input[type='file']</code>的元素中提取文件，并通过FileReader来将文件的转换成DataURL，这也意味着我们可以将DataURL分成多个碎片来通过Channel来进行文件传输</p>

<h2 id="demo">一个综合的Demo</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>，这是我写的一个Demo。建立一个视频聊天室，并能够广播文件，当然也支持单对单文件传输，写得还很粗糙，后期会继续完善</p>

<h3 id="section-8">使用方式</h3>
<ol>
  <li>下载解压并cd到目录下</li>
  <li>运行<code>npm install</code>安装依赖的库（express, ws, node-uuid）</li>
  <li>运行<code>node server.js</code>，访问<code>localhost:3000</code>，允许摄像头访问</li>
  <li>打开另一台电脑，在浏览器（Chrome和Opera，还未兼容Firefox）打开<code>{server所在IP}:3000</code>，允许摄像头和话筒访问</li>
  <li>广播文件：在左下角选定一个文件，点击“发送文件”按钮</li>
  <li>广播信息：左下角input框输入信息，点击发送</li>
  <li>可能会出错，注意F12对话框，一般F5能解决</li>
</ol>

<h3 id="section-9">功能</h3>
<p>视频音频聊天（连接了摄像头和话筒，至少要有摄像头），广播文件（可单独传播，提供API，广播就是基于单独传播实现的，可同时传播多个，小文件还好说，大文件坐等内存吃光），广播聊天信息</p>

<h2 id="section-10">参考资料</h2>
<ul>
  <li><a href="http://www.webrtc.org/">WebRTC官方网站</a></li>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C-GetUserMedia</a></li>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">W3C-WebRTC</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/getusermedia/intro/">Capturing Audio &amp; Video in HTML5@html5rocks</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started with WebRTC@html5rocks</a></li>
  <li><a href="http://caniuse.com">caniuse</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E5%BC%8F%E9%80%A3%E6%8E%A5%E5%BB%BA%E7%AB%8B">ICE交互式连接建立</a></li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/15/webRTC-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用WebRTC搭建前端视频聊天室——入门篇 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/15/webRTC-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="webrtc">什么是WebRTC？</h2>
<p>众所周知，浏览器本身不支持相互之间直接建立信道进行通信，都是通过服务器进行中转。比如现在有两个客户端，甲和乙，他们俩想要通信，首先需要甲和服务器、乙和服务器之间建立信道。甲给乙发送消息时，甲先将消息发送到服务器上，服务器对甲的消息进行中转，发送到乙处，反过来也是一样。这样甲与乙之间的一次消息要通过两段信道，通信的效率同时受制于这两段信道的带宽。同时这样的信道并不适合数据流的传输，如何建立浏览器之间的点对点传输，一直困扰着开发者。WebRTC应运而生</p>

<p>WebRTC是一个开源项目，旨在使得浏览器能为实时通信（RTC）提供简单的JavaScript接口。说的简单明了一点就是让浏览器提供JS的即时通信接口。这个接口所创立的信道并不是像WebSocket一样，打通一个浏览器与WebSocket服务器之间的通信，而是通过一系列的信令，建立一个浏览器与浏览器之间（peer-to-peer）的信道，这个信道可以发送任何数据，而不需要经过服务器。并且WebRTC通过实现MediaStream，通过浏览器调用设备的摄像头、话筒，使得浏览器之间可以传递音频和视频</p>

<h2 id="webrtc-1">WebRTC已经在我们的浏览器中</h2>
<p>这么好的功能，各大浏览器厂商自然不会置之不理。现在WebRTC已经可以在较新版的Chrome、Opera和Firefox中使用了，著名的浏览器兼容性查询网站caniuse上给出了一份详尽的浏览器兼容情况</p>

<p><img src="http://lingyu.wang/img/WebRTC/1.png" alt="WebRTC浏览器兼容性from caniuse.com" /></p>

<p>另外根据36Kr前段时间的新闻<a href="http://www.36kr.com/p/205614.html">Google推出支持WebRTC及Web Audio的Android 版Chrome 29@36kr</a>和<a href="http://www.36kr.com/p/210209.html">Android版Opera开始支持WebRTC，允许用户在没有任何插件的情况下实现语音和视频聊天</a>，Android也开始支持WebRTC</p>

<h2 id="section">三个接口</h2>
<p>WebRTC实现了三个API，分别是:
* MediaStream：通过MediaStream的API能够通过设备的摄像头及话筒获得视频、音频的同步流
* RTCPeerConnection：RTCPeerConnection是WebRTC用于构建点对点之间稳定、高效的流传输的组件
* RTCDataChannel：RTCDataChannel使得浏览器之间（点对点）建立一个高吞吐量、低延时的信道，用于传输任意数据</p>

<p>这里大致上介绍一下这三个API</p>

<h2 id="mediastreamgetusermedia">MediaStream（getUserMedia）</h2>
<p>MediaStream API为WebRTC提供了从设备的摄像头、话筒获取视频、音频流数据的功能
###W3C标准
<a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C标准传送门</a>
###如何调用
同门可以通过调用navigator.getUserMedia()，这个方法接受三个参数：
1. 一个约束对象（constraints object），这个后面会单独讲
2. 一个调用成功的回调函数，如果调用成功，传递给它一个流对象
3. 一个调用失败的回调函数，如果调用失败，传递给它一个错误对象</p>

<h3 id="section-1">浏览器兼容性</h3>
<p>由于浏览器实现不同，他们经常会在实现标准版本之前，在方法前面加上前缀，所以一个兼容版本就像这样
<code>javacript
var getUserMedia = (navigator.getUserMedia || 
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);
</code></p>

<h3 id="section-2">一个超级简单的例子</h3>
<p>这里写一个超级简单的例子，用来展现getUserMedia的效果：
```html
&lt;!doctype html&gt;
&lt;html lang="zh-CN"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>GetUserMedia实例</title>
</head>
<body>
    <video id="video" autoplay=""></video>
</body>
<script type="text/javascript">
    var getUserMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

    getUserMedia.call(navigator, {
        video: true,
        audio: true
    }, function(localMediaStream) {
        var video = document.getElementById('video');
        video.src = window.URL.createObjectURL(localMediaStream);
        video.onloadedmetadata = function(e) {
            console.log("Label: " + localMediaStream.label);
            console.log("AudioTracks" , localMediaStream.getAudioTracks());
            console.log("VideoTracks" , localMediaStream.getVideoTracks());
        };
    }, function(e) {
        console.log('Reeeejected!', e);
    });
</script>

<p>&lt;/html&gt;
```
将这段内容保存在一个HTML文件中，放在服务器上。用较新版本的Opera、Firefox、Chrome打开，在浏览器弹出询问是否允许访问摄像头和话筒，选同意，浏览器上就会出现摄像头所拍摄到的画面了</p>

<p>注意，HTML文件要放在服务器上，否则会得到一个NavigatorUserMediaError的错误，显示PermissionDeniedError，最简单方法就是cd到HTML文件所在目录下，然后<code>python -m SimpleHTTPServer</code>（装了python的话），然后在浏览器中输入<code>http://localhost:8000/{文件名称}.html</code></p>

<p>这里使用<code>getUserMedia</code>获得流之后，需要将其输出，一般是绑定到<code>video</code>标签上输出，需要使用<code>window.URL.createObjectURL(localMediaStream)</code>来创造能在<code>video</code>中使用<code>src</code>属性播放的Blob URL，注意在<code>video</code>上加入<code>autoplay</code>属性，否则只能捕获到一张图片</p>

<p>流创建完毕后可以通过<code>label</code>属性来获得其唯一的标识，还可以通过<code>getAudioTracks()</code>和<code>getVideoTracks()</code>方法来获得流的追踪对象数组（如果没有开启某种流，它的追踪对象数组将是一个空数组）</p>

<h3 id="constraints">约束对象（Constraints）</h3>
<p>约束对象可以被设置在<code>getUserMedia()</code>和RTCPeerConnection的<code>addStream</code>方法中，这个约束对象是WebRTC用来指定接受什么样的流的，其中可以定义如下属性：
* video: 是否接受视频流
* audio：是否接受音频流
* MinWidth: 视频流的最小宽度
* MaxWidth：视频流的最大宽度
* MinHeight：视频流的最小高度
* MaxHiehgt：视频流的最大高度
* MinAspectRatio：视频流的最小宽高比
* MaxAspectRatio：视频流的最大宽高比
* MinFramerate：视频流的最小帧速率
* MaxFramerate：视频流的最大帧速率</p>

<p>详情见<a href="http://tools.ietf.org/html/draft-alvestrand-constraints-resolution-00">Resolution Constraints in Web Real Time Communications draft-alvestrand-constraints-resolution-00</a></p>

<h2 id="rtcpeerconnection">RTCPeerConnection</h2>
<p>WebRTC使用RTCPeerConnection来在浏览器之间传递流数据，这个流数据通道是点对点的，不需要经过服务器进行中转。但是这并不意味着我们能抛弃服务器，我们仍然需要它来为我们传递信令（signaling）来建立这个信道。WebRTC没有定义用于建立信道的信令的协议：信令并不是RTCPeerConnection API的一部分</p>

<h3 id="section-3">信令</h3>
<p>既然没有定义具体的信令的协议，我们就可以选择任意方式（AJAX、WebSocket），采用任意的协议（SIP、XMPP）来传递信令，建立信道，比如我写的<a href="https://github.com/LingyuCoder/SkyRTC-demo">demo</a>，就是用的node的ws模块，在WebSocket上传递信令</p>

<p>需要信令来交换的信息有三种：
* session的信息：用来初始化通信还有报错
* 网络配置：比如IP地址和端口啥的
* 媒体适配：发送方和接收方的浏览器能够接受什么样的编码器和分辨率</p>

<p>这些信息的交换应该在点对点的流传输之前就全部完成，一个大致的架构图如下：</p>

<p><img src="http://lingyu.wang/img/WebRTC/2.png" alt="JSEP架构" /></p>

<h3 id="section-4">通过服务器建立信道</h3>
<p>这里再次重申，就算WebRTC提供浏览器之间的点对点信道进行数据传输，但是建立这个信道，必须有服务器的参与。WebRTC需要服务器对其进行四方面的功能支持：
1. 用户发现以及通信
2. 信令传输
3. NAT/防火墙穿越
4. 如果点对点通信建立失败，可以作为中转服务器</p>

<h3 id="nat">NAT/防火墙穿越技术</h3>
<p>建立点对点信道的一个常见问题，就是NAT穿越技术。在处于使用了NAT设备的私有TCP/IP网络中的主机之间需要建立连接时需要使用NAT穿越技术。以往在VoIP领域经常会遇到这个问题。目前已经有很多NAT穿越技术，但没有一项是完美的，因为NAT的行为是非标准化的。这些技术中大多使用了一个公共服务器，这个服务使用了一个从全球任何地方都能访问得到的IP地址。在RTCPeeConnection中，使用ICE框架来保证RTCPeerConnection能实现NAT穿越</p>

<p>ICE，全名叫交互式连接建立（Interactive Connectivity Establishment）,一种综合性的NAT穿越技术，它是一种框架，可以整合各种NAT穿越技术如STUN、TURN（Traversal Using Relay NAT 中继NAT实现的穿透）。ICE会先使用STUN，尝试建立一个基于UDP的连接，如果失败了，就会去TCP（先尝试HTTP，然后尝试HTTPS），如果依旧失败ICE就会使用一个中继的TURN服务器。</p>

<p>我们可以使用Google的STUN服务器：<code>stun:stun.l.google.com:19302</code>，于是乎，一个整合了ICE框架的架构应该长这个样子</p>

<p><img src="http://lingyu.wang/img/WebRTC/3.png" alt="整合了ICE框架的WebRTC应用架构" /></p>

<h3 id="section-5">浏览器兼容</h3>
<p>还是前缀不同的问题，采用和上面类似的方法：
<code>javascript
var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);
</code></p>

<h3 id="section-6">创建和使用</h3>
<p>```javascript
//使用Google的stun服务器
var iceServer = {
    “iceServers”: [{
        “url”: “stun:stun.l.google.com:19302”
    }]
};
//兼容浏览器的getUserMedia写法
var getUserMedia = (navigator.getUserMedia ||
                    navigator.webkitGetUserMedia || 
                    navigator.mozGetUserMedia || 
                    navigator.msGetUserMedia);
//兼容浏览器的PeerConnection写法
var PeerConnection = (window.PeerConnection ||
                    window.webkitPeerConnection00 || 
                    window.webkitRTCPeerConnection || 
                    window.mozRTCPeerConnection);
//与后台服务器的WebSocket连接
var socket = __createWebSocketChannel();
//创建PeerConnection实例
var pc = new PeerConnection(iceServer);
//发送ICE候选到其他客户端
pc.onicecandidate = function(event){
    socket.send(JSON.stringify({
        “event”: “__ice_candidate”,
        “data”: {
            “candidate”: event.candidate
        }
    }));
};
//如果检测到媒体流连接到本地，将其绑定到一个video标签上输出
pc.onaddstream = function(event){
    someVideoElement.src = URL.createObjectURL(event.stream);
};
//获取本地的媒体流，并绑定到一个video标签上输出，并且发送这个媒体流给其他客户端
getUserMedia.call(navigator, {
    “audio”: true,
    “video”: true
}, function(stream){
    //发送offer和answer的函数，发送本地session描述
    var sendOfferFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                “event”: “__offer”,
                “data”: {
                    “sdp”: desc
                }
            }));
        },
        sendAnswerFn = function(desc){
            pc.setLocalDescription(desc);
            socket.send(JSON.stringify({ 
                “event”: “__answer”,
                “data”: {
                    “sdp”: desc
                }
            }));
        };
    //绑定本地媒体流到video标签用于输出
    myselfVideoElement.src = URL.createObjectURL(stream);
    //向PeerConnection中加入需要发送的流
    pc.addStream(stream);
    //如果是发送方则发送一个offer信令，否则发送一个answer信令
    if(isCaller){
        pc.createOffer(sendOfferFn);
    } else {
        pc.createAnswer(sendAnswerFn);
    }
}, function(error){
    //处理媒体流创建失败错误
});
//处理到来的信令
socket.onmessage = function(event){
    var json = JSON.parse(event.data);
    //如果是一个ICE的候选，则将其加入到PeerConnection中，否则设定对方的session描述为传递过来的描述
    if( json.event === “__ice_candidate” ){
        pc.addIceCandidate(new RTCIceCandidate(json.data.candidate));
    } else {
         pc.setRemoteDescription(new RTCSessionDescription(json.data.sdp));
    }
};</p>

<p>```</p>

<h3 id="section-7">实例</h3>
<p>由于涉及较为复杂灵活的信令传输，故这里不做简短的实例，可以直接移步到最后</p>

<h2 id="rtcdatachannel">RTCDataChannel</h2>
<p>既然能建立点对点的信道来传递实时的视频、音频数据流，为什么不能用这个信道传一点其他数据呢？RTCDataChannel API就是用来干这个的，基于它我们可以在浏览器之间传输任意数据。DataChannel是建立在PeerConnection上的，不能单独使用
###使用DataChannel
我们可以使用<code>channel = pc.createDataCHannel("someLabel");</code>来在PeerConnection的实例上创建Data Channel，并给与它一个标签</p>

<p>DataChannel使用方式几乎和WebSocket一样，有几个事件：
* onopen
* onclose
* onmessage
* onerror</p>

<p>同时它有几个状态，可以通过<code>readyState</code>获取：
* connecting: 浏览器之间正在试图建立channel
* open：建立成功，可以使用<code>send</code>方法发送数据了
* closing：浏览器正在关闭channel
* closed：channel已经被关闭了</p>

<p>两个暴露的方法:
* close(): 用于关闭channel
* send()：用于通过channel向对方发送数据</p>

<h3 id="data-channel">通过Data Channel发送文件大致思路</h3>
<p>JavaScript已经提供了File API从<code>input[type='file']</code>的元素中提取文件，并通过FileReader来将文件的转换成DataURL，这也意味着我们可以将DataURL分成多个碎片来通过Channel来进行文件传输</p>

<h2 id="demo">一个综合的Demo</h2>
<p><a href="https://github.com/LingyuCoder/SkyRTC-demo">SkyRTC-demo</a>，这是我写的一个Demo。建立一个视频聊天室，并能够广播文件，当然也支持单对单文件传输，写得还很粗糙，后期会继续完善</p>

<h3 id="section-8">使用方式</h3>
<ol>
  <li>下载解压并cd到目录下</li>
  <li>运行<code>npm install</code>安装依赖的库（express, ws, node-uuid）</li>
  <li>运行<code>node server.js</code>，访问<code>localhost:3000</code>，允许摄像头访问</li>
  <li>打开另一台电脑，在浏览器（Chrome和Opera，还未兼容Firefox）打开<code>{server所在IP}:3000</code>，允许摄像头和话筒访问</li>
  <li>广播文件：在左下角选定一个文件，点击“发送文件”按钮</li>
  <li>广播信息：左下角input框输入信息，点击发送</li>
  <li>可能会出错，注意F12对话框，一般F5能解决</li>
</ol>

<h3 id="section-9">功能</h3>
<p>视频音频聊天（连接了摄像头和话筒，至少要有摄像头），广播文件（可单独传播，提供API，广播就是基于单独传播实现的，可同时传播多个，小文件还好说，大文件坐等内存吃光），广播聊天信息</p>

<h2 id="section-10">参考资料</h2>
<ul>
  <li><a href="http://www.webrtc.org/">WebRTC官方网站</a></li>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/getusermedia.html">W3C-GetUserMedia</a></li>
  <li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">W3C-WebRTC</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/getusermedia/intro/">Capturing Audio &amp; Video in HTML5@html5rocks</a></li>
  <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/">Getting Started with WebRTC@html5rocks</a></li>
  <li><a href="http://caniuse.com">caniuse</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E5%BC%8F%E9%80%A3%E6%8E%A5%E5%BB%BA%E7%AB%8B">ICE交互式连接建立</a></li>
</ul>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/15/webRTC-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——大的方面和外界影响 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/12/dont-make-me-think-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">可用性是礼貌</h2>
<p>###好感度存储器
可以想象，我们每次进入一个网站，都从一个好感存储器开始，在网站上遇到的每个问题都会降低好感存储器的高度。这个存储器容量是有限的，如果对用户的态度恶劣，把它消耗殆尽，用户就很可能离开网站。这样的好感存储器，有以下几点值得注意：
1. 因个人的特质不同而不同，有的人有耐心，有的人脾气不好
2. 根据情况而定，赶时间或者刚刚在一个另一个网站上得到糟糕的体验，那么进入网站是，好感程度已经很低了
3. 可以重新填满它，即使犯了一些错误，降低了好感，可以通过一些其他事来弥补
4. 有是有一个错误就能清空它</p>

<h3 id="section-1">降低好感的几种方式</h3>
<ol>
  <li>隐藏用户想要的信息</li>
  <li>没有按照网站的设计行事而惩罚用户，比如表单验证错误后需要重新输入</li>
  <li>询问不必要的信息，用户很介意个人信息</li>
  <li>敷衍用户、欺骗用户，不需要虚伪的真诚、假意的关心</li>
  <li>为用户设置障碍，不得不等待一个介绍或必须看一些图片，都是为用户设置障碍</li>
  <li>网站看上去不专业，网站看上去凌乱，用户会失去好感</li>
</ol>

<h3 id="section-2">提高好感的几种方式</h3>
<ol>
  <li>知道人们在你的网站上想做什么，并让他们明白简易</li>
  <li>告诉用户他们想知道的</li>
  <li>尽量减少步骤</li>
  <li>花点心思</li>
  <li>知道用户肯能有哪些疑问，并给与解答</li>
  <li>提供协助，例如打印友好页面</li>
  <li>容易从错误中回复</li>
  <li>如果不确定，记得道歉</li>
</ol>

<h2 id="section-3">可访问性</h2>
<p>可访问性是可用性的一部分，除非确定了哪些残障人士都不是目标用户，否则如果网站的可访问性不足，就不能说它是可用的</p>

<h3 id="section-4">开发人员和设计人员所听到的</h3>
<p>大多数公司里，负责实现可访问性的人是实际上建造网站的人：开发人员和设计师</p>

<p>有很多不太可能让开发人员和设计师相信他们应该支持可访问性的理由，尤其是两点：
1. 他们的世界里主要是健全人，很难让他们相信有相当比例的人会贞德在访问网络时需要帮助
2. 他们怀疑更好的访问性能否能让所有人收益</p>

<p>事实上，支持可访问性的重要理由就是：支持可访问性才是正确的做法</p>

<h3 id="section-5">开发人员和设计师们害怕的</h3>
<p>对于可访问性了解更多时，会让他们觉得害怕，因为：
1. 这意味着更大的工作量，特别是对于开发人员而言，实现可访问性就像往他们已经不可能完成的项目计划中再添加一项复杂的新任务，同时还伴随着很多费时费力的报告、评审、特别会议等等
2. 设计折衷，设计师们担心对于网站的大部分目标用户而言，自己不得不让网站的手机变得不那么吸引人</p>

<h3 id="section-6">解决方案</h3>
<p>我们可以用一个Bobby那样的检查器来保证网站符合WCAG的标准</p>

<h3 id="section-7">能正确实施的五件事</h3>
<ol>
  <li>改正让所有人改到混淆的可用性问题，让网站对我们其他的人更好用，会让残障人士也更好用</li>
  <li>读一篇文章， 网站可访问性及可用指南：屏幕阅读器用户观察。绝大多数盲人用户和正常用户一样没耐心，他们希望尽快得到自己需要的信息</li>
  <li>看一本书，阅读一本关于Web可访问性的书籍</li>
  <li>使用级联样式表，它有以下几个好处
    <ol>
      <li>灵活性</li>
      <li>浏览器之间的一致性</li>
      <li>序列化内容</li>
      <li>允许重新定义文字大小</li>
    </ol>
  </li>
  <li>在HTML代码中做一些具体的变更
    <ol>
      <li>为每张图片增加alt文本</li>
      <li>让表单配合屏幕阅读器</li>
      <li>在每页的最前面添加一个“跳转到主要内容”的链接</li>
      <li>让所有内容都可以通过键盘访问</li>
      <li>没有充分的理由，不要使用JavaScript</li>
      <li>使用客户端的影像地图</li>
    </ol>
  </li>
</ol>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/12/dont-make-me-think-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——大的方面和外界影响 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/12/dont-make-me-think-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">可用性是礼貌</h2>
<p>###好感度存储器
可以想象，我们每次进入一个网站，都从一个好感存储器开始，在网站上遇到的每个问题都会降低好感存储器的高度。这个存储器容量是有限的，如果对用户的态度恶劣，把它消耗殆尽，用户就很可能离开网站。这样的好感存储器，有以下几点值得注意：
1. 因个人的特质不同而不同，有的人有耐心，有的人脾气不好
2. 根据情况而定，赶时间或者刚刚在一个另一个网站上得到糟糕的体验，那么进入网站是，好感程度已经很低了
3. 可以重新填满它，即使犯了一些错误，降低了好感，可以通过一些其他事来弥补
4. 有是有一个错误就能清空它</p>

<h3 id="section-1">降低好感的几种方式</h3>
<ol>
  <li>隐藏用户想要的信息</li>
  <li>没有按照网站的设计行事而惩罚用户，比如表单验证错误后需要重新输入</li>
  <li>询问不必要的信息，用户很介意个人信息</li>
  <li>敷衍用户、欺骗用户，不需要虚伪的真诚、假意的关心</li>
  <li>为用户设置障碍，不得不等待一个介绍或必须看一些图片，都是为用户设置障碍</li>
  <li>网站看上去不专业，网站看上去凌乱，用户会失去好感</li>
</ol>

<h3 id="section-2">提高好感的几种方式</h3>
<ol>
  <li>知道人们在你的网站上想做什么，并让他们明白简易</li>
  <li>告诉用户他们想知道的</li>
  <li>尽量减少步骤</li>
  <li>花点心思</li>
  <li>知道用户肯能有哪些疑问，并给与解答</li>
  <li>提供协助，例如打印友好页面</li>
  <li>容易从错误中回复</li>
  <li>如果不确定，记得道歉</li>
</ol>

<h2 id="section-3">可访问性</h2>
<p>可访问性是可用性的一部分，除非确定了哪些残障人士都不是目标用户，否则如果网站的可访问性不足，就不能说它是可用的</p>

<h3 id="section-4">开发人员和设计人员所听到的</h3>
<p>大多数公司里，负责实现可访问性的人是实际上建造网站的人：开发人员和设计师</p>

<p>有很多不太可能让开发人员和设计师相信他们应该支持可访问性的理由，尤其是两点：
1. 他们的世界里主要是健全人，很难让他们相信有相当比例的人会贞德在访问网络时需要帮助
2. 他们怀疑更好的访问性能否能让所有人收益</p>

<p>事实上，支持可访问性的重要理由就是：支持可访问性才是正确的做法</p>

<h3 id="section-5">开发人员和设计师们害怕的</h3>
<p>对于可访问性了解更多时，会让他们觉得害怕，因为：
1. 这意味着更大的工作量，特别是对于开发人员而言，实现可访问性就像往他们已经不可能完成的项目计划中再添加一项复杂的新任务，同时还伴随着很多费时费力的报告、评审、特别会议等等
2. 设计折衷，设计师们担心对于网站的大部分目标用户而言，自己不得不让网站的手机变得不那么吸引人</p>

<h3 id="section-6">解决方案</h3>
<p>我们可以用一个Bobby那样的检查器来保证网站符合WCAG的标准</p>

<h3 id="section-7">能正确实施的五件事</h3>
<ol>
  <li>改正让所有人改到混淆的可用性问题，让网站对我们其他的人更好用，会让残障人士也更好用</li>
  <li>读一篇文章， 网站可访问性及可用指南：屏幕阅读器用户观察。绝大多数盲人用户和正常用户一样没耐心，他们希望尽快得到自己需要的信息</li>
  <li>看一本书，阅读一本关于Web可访问性的书籍</li>
  <li>使用级联样式表，它有以下几个好处
    <ol>
      <li>灵活性</li>
      <li>浏览器之间的一致性</li>
      <li>序列化内容</li>
      <li>允许重新定义文字大小</li>
    </ol>
  </li>
  <li>在HTML代码中做一些具体的变更
    <ol>
      <li>为每张图片增加alt文本</li>
      <li>让表单配合屏幕阅读器</li>
      <li>在每页的最前面添加一个“跳转到主要内容”的链接</li>
      <li>让所有内容都可以通过键盘访问</li>
      <li>没有充分的理由，不要使用JavaScript</li>
      <li>使用客户端的影像地图</li>
    </ol>
  </li>
</ol>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/12/dont-make-me-think-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——确定你没有做错的几件事 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/12/dont-make-me-think-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="web">为什么Web设计团队通论可用性是在浪费时间，如何避免这种情况</h2>
<p>###每个人都有自己的喜好
每个人，无论是真正的用户还是建造网站的人，自己也是Web用户，和其他所有的Web用户一样，会对网站上自己喜欢什么、不喜欢什么有着强烈的感觉。同时我们通常会认为大部分Web用户和我们一样</p>

<h3 id="section">不同的职位，不同的目标</h3>
<p>每个职位都有自己对网站的期望，以设计师和开发人员为例，设计师通常认为，大多数人喜欢视觉上看起来有趣的网站，因为设计师们喜欢这样的网站。而另一方面，开发人员认为人们喜欢功能又多又酷的网站，因为开发人员喜欢这样的网站</p>

<h3 id="section-1">没有人能代表普通用户</h3>
<p>“大部分Web用户和我们一样”这种信仰足以让通常的Web设计会议陷入僵局，在这个信仰背后还隐藏着一个更深的信仰–相信大部分Web用户是弹性的，可以随意变化。但事实上，所有Web用户多事独一无二的，所有的Web使用都是不一样的。试图用一些简单的喜好来形容用户毫无意义。好的设计自然会把这种复杂性考虑进去。</p>

<p>什么是好的设计呢？事实上对于大部分设计问题来说，没有简单的“正确”答案。良好的、一体化的设计能满足需要，也就是说，经过仔细考虑、实现和测试的设计就是好的</p>

<h3 id="section-2">如何解决</h3>
<p>只有一种方式来解决，就是测试。必须使用团队的集体技巧、经验、创造力和判断力来创建一些版本，然后仔细观察人们对它的看法和使用的方法</p>

<h2 id="section-3">如何测试一个网站？</h2>
<p>设计网站时，市场部门的人往往觉得自己没有什么影响力，尽管他们在研究网站的目标用户和目标用户需求方面花费的时间最多，但是设计师和开发人员往往是最有权力决定网站最后是什么样子的人</p>

<h3 id="section-4">焦点小组测试</h3>
<p>在一次焦点小组研究中，一小组人（5-8人）围坐在桌子边，对展示给他们的想法和设计做出反应。主要价值来自参与成员彼此的反应。这是快速得到用户意见和感觉的一种不错的方法</p>

<p>焦点小组在抽象的确定目标用户想要什么、需要什么、喜欢什么的时候会很有用。同时也可以测试出网站的理念是否有意义，价值主张是否吸引人。同时在测试网站功能命名、发现用户对竞争对手看法等方面，也是很好的办法</p>

<h3 id="section-5">可用性测试</h3>
<p>在一次可用性测试中，一次一个用户展示一些内容（不管是网站、还是网站原型、还是单个页面的草图），要求用户说出：
1. 这是什么
2. 试着用它来完成一项典型的任务</p>

<h3 id="section-6">选用哪种测试？</h3>
<p>焦点小组测试不适合用来了解网站的运行情况，以及怎样改进网站</p>

<h3 id="section-7">关于测试的几个事实</h3>
<ol>
  <li>如果想建立一个优秀的网站，一定要测试</li>
  <li>测试一个用户比不错测试好一倍</li>
  <li>在项目中，早点测试已为用户好过最后测试50位用户，早做测试才能用上测试所得。事实上，一旦网站投入使用，要改变它就不是那么容易了，很多用户拒绝做出任何变化，即便很小的变更也会给他们带来深远的影响</li>
  <li>人们对招募用户代表的重要性估计过高</li>
  <li>测试的关键不是要证明什么或者反驳什么，而是了解自己的判断力。测试能做的就是给你提供有价值的参考，加上你的经验、专业判断和尝试能够更容易做出自信的选择</li>
  <li>测试是一个迭代过程</li>
  <li>没有什么比现场用户的反应更重要</li>
</ol>

<p>如果想知道软件、网站是否容易使用，那么在一些人视图使用的时候观察他们，记下他们在哪里遇到问题，然后修改这些问题，再度测试</p>

<h3 id="section-8">每组的测试人数（3-4个）</h3>
<p>每轮测试的理想用户数量是3-4个，前三个用户很可能会遇到几乎所有最明显的问题，并且最重要的是多做几轮测试，而不是谢谢爱每轮测试里面发现的所有问题，3-4名测试用户有助于保证很快进入下一轮测试</p>

<h3 id="section-9">宽松招募，曲线上升</h3>
<p>在决定要进行测试后，团队通常会花很多时间来招募他们认为能准确反应他们目标群体的测试用户。然而，对于可用性测试的最大秘密就是，测试对象是谁并不重要，对于大部分网站而言，用只需要懂得上网基本知识的用户就可以了。推荐的方式：利用你能够找到的任何人（满足最低要求），然后曲线上升。理由如下：
* 实际上，我们都是初学者
* 设计出的网站只有你的目标群体能使用，这不是一个好主意
* 专家通常不会介意对初学者来说很清楚的界面</p>

<p>当然也有一些例外情况发生，比如：
* 网站几乎只由某一类用户使用，而且招募这一类测试用户并不困难，那么就去招募
* 目标用户群体可以分成几个明显的阵营，而且这些阵营有着完全不同的兴趣和需要，那么至少要从每个阵营里选择用户进行一次测试
* 使用网站需要专门的领域知识，那么至少才一个回合的测试中招募具有该领域知识的用户</p>

<p>在进行测试人员找牧时，需要做到如下几点：
* 提供合理的奖励
* 邀请要简单
* 避免对网站（或网站背后的组织结构）进行预先讨论
* 别不好意思请朋友和邻居帮忙</p>

<h3 id="section-10">什么时候测试</h3>
<p>在Web开发的各个阶段尽早进行测试，甚至在开始设计之前，应该测试一下同类的网站，对于同类网站可以进行两种测试：
1. “理解”测试：让测试用户看到网站，然后看他们是否能理解这个网站，理解网站的目标、价值主张、组织方法、运行方法
2. 关键任务测试，让用户完成一些任务，然后观察他们是怎么做的</p>

<h3 id="section-11">立刻回顾测试结果</h3>
<p>测试完后的会议上，应该做两件事：
1. 给问题分类：回顾大家看到的问题，决定哪些问题需要修正
2. 解决问题：找出修正这些问题的方法</p>

<h3 id="section-12">常见问题</h3>
<p>测试过程中，最有可能遇到几个问题：
1. 用户不清楚概念，他们不理解，他们看着网站或者页面，要么不知道他们说的是什么，要么他们以为自己知道，但是理解有误
2. 他们找不到自己要找的字眼，这通常意味着 1) 用来组织内容的分类不符合用户的习惯  2) 分类符合他们的习惯,但没有使用他们期望的名字
3. 内容太多了，我们需要 1)减少页面上的整体干扰 2)把他们需要看到的内容设置的更加醒目</p>

<h3 id="section-13">一些问题分类指南</h3>
<ol>
  <li>在任何测试中，都有可能遇到这样的情况，用户暂时出现错误，然后又在没有任何帮助的情况下回到原来的轨道。这中情况可以忽略，无须在意</li>
  <li>抵制添加的冲动，在测试看到人们没有理解某些内容时，大部分人会选择增加一些注释或指导说明。但正确的解决方案往往是去除某个（一些）让人混淆的东西，而不是增加另一些干扰</li>
  <li>不要太看重人们对新功能的要求</li>
  <li>每轮测试中，主要目标是寻找重要而不费力的收获，一般有两种，1)当大家看到第一个用户试着勉强应付的时候，问题和结局方法都很明显的情况 2)需要实现两种变更，几乎毫不费力的或者需要费一点力气，但效果很明显的</li>
</ol>

<h3 id="section-14">别过火</h3>
<p>测试真正的挑战不是修正所发现的问题，而是修正问题的时候，不破坏已经正常运行的部分</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/12/dont-make-me-think-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——确定你没有做错的几件事 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/12/dont-make-me-think-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="web">为什么Web设计团队通论可用性是在浪费时间，如何避免这种情况</h2>
<p>###每个人都有自己的喜好
每个人，无论是真正的用户还是建造网站的人，自己也是Web用户，和其他所有的Web用户一样，会对网站上自己喜欢什么、不喜欢什么有着强烈的感觉。同时我们通常会认为大部分Web用户和我们一样</p>

<h3 id="section">不同的职位，不同的目标</h3>
<p>每个职位都有自己对网站的期望，以设计师和开发人员为例，设计师通常认为，大多数人喜欢视觉上看起来有趣的网站，因为设计师们喜欢这样的网站。而另一方面，开发人员认为人们喜欢功能又多又酷的网站，因为开发人员喜欢这样的网站</p>

<h3 id="section-1">没有人能代表普通用户</h3>
<p>“大部分Web用户和我们一样”这种信仰足以让通常的Web设计会议陷入僵局，在这个信仰背后还隐藏着一个更深的信仰–相信大部分Web用户是弹性的，可以随意变化。但事实上，所有Web用户多事独一无二的，所有的Web使用都是不一样的。试图用一些简单的喜好来形容用户毫无意义。好的设计自然会把这种复杂性考虑进去。</p>

<p>什么是好的设计呢？事实上对于大部分设计问题来说，没有简单的“正确”答案。良好的、一体化的设计能满足需要，也就是说，经过仔细考虑、实现和测试的设计就是好的</p>

<h3 id="section-2">如何解决</h3>
<p>只有一种方式来解决，就是测试。必须使用团队的集体技巧、经验、创造力和判断力来创建一些版本，然后仔细观察人们对它的看法和使用的方法</p>

<h2 id="section-3">如何测试一个网站？</h2>
<p>设计网站时，市场部门的人往往觉得自己没有什么影响力，尽管他们在研究网站的目标用户和目标用户需求方面花费的时间最多，但是设计师和开发人员往往是最有权力决定网站最后是什么样子的人</p>

<h3 id="section-4">焦点小组测试</h3>
<p>在一次焦点小组研究中，一小组人（5-8人）围坐在桌子边，对展示给他们的想法和设计做出反应。主要价值来自参与成员彼此的反应。这是快速得到用户意见和感觉的一种不错的方法</p>

<p>焦点小组在抽象的确定目标用户想要什么、需要什么、喜欢什么的时候会很有用。同时也可以测试出网站的理念是否有意义，价值主张是否吸引人。同时在测试网站功能命名、发现用户对竞争对手看法等方面，也是很好的办法</p>

<h3 id="section-5">可用性测试</h3>
<p>在一次可用性测试中，一次一个用户展示一些内容（不管是网站、还是网站原型、还是单个页面的草图），要求用户说出：
1. 这是什么
2. 试着用它来完成一项典型的任务</p>

<h3 id="section-6">选用哪种测试？</h3>
<p>焦点小组测试不适合用来了解网站的运行情况，以及怎样改进网站</p>

<h3 id="section-7">关于测试的几个事实</h3>
<ol>
  <li>如果想建立一个优秀的网站，一定要测试</li>
  <li>测试一个用户比不错测试好一倍</li>
  <li>在项目中，早点测试已为用户好过最后测试50位用户，早做测试才能用上测试所得。事实上，一旦网站投入使用，要改变它就不是那么容易了，很多用户拒绝做出任何变化，即便很小的变更也会给他们带来深远的影响</li>
  <li>人们对招募用户代表的重要性估计过高</li>
  <li>测试的关键不是要证明什么或者反驳什么，而是了解自己的判断力。测试能做的就是给你提供有价值的参考，加上你的经验、专业判断和尝试能够更容易做出自信的选择</li>
  <li>测试是一个迭代过程</li>
  <li>没有什么比现场用户的反应更重要</li>
</ol>

<p>如果想知道软件、网站是否容易使用，那么在一些人视图使用的时候观察他们，记下他们在哪里遇到问题，然后修改这些问题，再度测试</p>

<h3 id="section-8">每组的测试人数（3-4个）</h3>
<p>每轮测试的理想用户数量是3-4个，前三个用户很可能会遇到几乎所有最明显的问题，并且最重要的是多做几轮测试，而不是谢谢爱每轮测试里面发现的所有问题，3-4名测试用户有助于保证很快进入下一轮测试</p>

<h3 id="section-9">宽松招募，曲线上升</h3>
<p>在决定要进行测试后，团队通常会花很多时间来招募他们认为能准确反应他们目标群体的测试用户。然而，对于可用性测试的最大秘密就是，测试对象是谁并不重要，对于大部分网站而言，用只需要懂得上网基本知识的用户就可以了。推荐的方式：利用你能够找到的任何人（满足最低要求），然后曲线上升。理由如下：
* 实际上，我们都是初学者
* 设计出的网站只有你的目标群体能使用，这不是一个好主意
* 专家通常不会介意对初学者来说很清楚的界面</p>

<p>当然也有一些例外情况发生，比如：
* 网站几乎只由某一类用户使用，而且招募这一类测试用户并不困难，那么就去招募
* 目标用户群体可以分成几个明显的阵营，而且这些阵营有着完全不同的兴趣和需要，那么至少要从每个阵营里选择用户进行一次测试
* 使用网站需要专门的领域知识，那么至少才一个回合的测试中招募具有该领域知识的用户</p>

<p>在进行测试人员找牧时，需要做到如下几点：
* 提供合理的奖励
* 邀请要简单
* 避免对网站（或网站背后的组织结构）进行预先讨论
* 别不好意思请朋友和邻居帮忙</p>

<h3 id="section-10">什么时候测试</h3>
<p>在Web开发的各个阶段尽早进行测试，甚至在开始设计之前，应该测试一下同类的网站，对于同类网站可以进行两种测试：
1. “理解”测试：让测试用户看到网站，然后看他们是否能理解这个网站，理解网站的目标、价值主张、组织方法、运行方法
2. 关键任务测试，让用户完成一些任务，然后观察他们是怎么做的</p>

<h3 id="section-11">立刻回顾测试结果</h3>
<p>测试完后的会议上，应该做两件事：
1. 给问题分类：回顾大家看到的问题，决定哪些问题需要修正
2. 解决问题：找出修正这些问题的方法</p>

<h3 id="section-12">常见问题</h3>
<p>测试过程中，最有可能遇到几个问题：
1. 用户不清楚概念，他们不理解，他们看着网站或者页面，要么不知道他们说的是什么，要么他们以为自己知道，但是理解有误
2. 他们找不到自己要找的字眼，这通常意味着 1) 用来组织内容的分类不符合用户的习惯  2) 分类符合他们的习惯,但没有使用他们期望的名字
3. 内容太多了，我们需要 1)减少页面上的整体干扰 2)把他们需要看到的内容设置的更加醒目</p>

<h3 id="section-13">一些问题分类指南</h3>
<ol>
  <li>在任何测试中，都有可能遇到这样的情况，用户暂时出现错误，然后又在没有任何帮助的情况下回到原来的轨道。这中情况可以忽略，无须在意</li>
  <li>抵制添加的冲动，在测试看到人们没有理解某些内容时，大部分人会选择增加一些注释或指导说明。但正确的解决方案往往是去除某个（一些）让人混淆的东西，而不是增加另一些干扰</li>
  <li>不要太看重人们对新功能的要求</li>
  <li>每轮测试中，主要目标是寻找重要而不费力的收获，一般有两种，1)当大家看到第一个用户试着勉强应付的时候，问题和结局方法都很明显的情况 2)需要实现两种变更，几乎毫不费力的或者需要费一点力气，但效果很明显的</li>
</ol>

<h3 id="section-14">别过火</h3>
<p>测试真正的挑战不是修正所发现的问题，而是修正问题的时候，不破坏已经正常运行的部分</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/12/dont-make-me-think-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——必须正确处理的几个方面 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/12/dont-make-me-think-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">设计导航</h2>
<p>如果网站上找不到方向，人们不会使用你的网站。作为一个用户，如果到了一个网站，没有找到需要的内容，或者不知道网站怎么组织的，可能还会回来</p>

<h3 id="section-1">网站导航</h3>
<p>用户通常是为了寻找某个目标而来。他们会进行思考，是先询问（搜索），还是先浏览。通常用户决定是先搜索还是先浏览取决于他们的打算、匆忙程度，以及网站是否具有良好的导航机制。如果选择浏览，他们将通过标志的引导在层次结构中穿行。最后他们如果没有找到想要的东西，会离开。</p>

<h3 id="section-2">无法承受的浏览之轻</h3>
<p>网络上查找东西和真实世界有很多相似之处，但也有很多不同，比如：
* 用户无法感觉到网站本身的大小
* 用户不会有方向的感觉
* 用户感觉不到位置</p>

<p>在真实世界中，查找过一次的货物，会和容易去。而在Web上，通过点击链接向前移动。想要再次访问网站上的某个内容，需要记住它在概念层次上的位置，然后重新顺着以往的链接过去。使用Web导航，就是为了让用户得知他们当前的位置，导航通过具体化网站的层次结构，来补偿确实的现实空间感</p>

<h3 id="section-3">被忽视了的导航用途</h3>
<p>导航有两个显而易见的用途： 帮助我们找到想要的东西和告诉我们现在身在何处，其实导航的所有用途有：
* 给了哦我们一些固定的感觉
* 告诉我们当前的位置
* 告诉我们如何使用网站
* 给了我们对网站建造者的信心</p>

<h3 id="web">Web导航习惯用法</h3>
<p>设计得当的持久导航需要表达的意思：导航部分在这里，其中一些可能会根据您所处的位置有所变化，但它总是在这里</p>

<p>持久导航包括5个元素，这5个元素是用户一直需要的：
1. 站点ID
2. 回到主页的方式
3. 搜索的方式
4. 实用工具
5. 栏目</p>

<h3 id="section-4">我说的是每一页</h3>
<p>对于每个地方都一样的规则，有两个例外：
* 主页，主页承担着一些不同的任务，有时候在主页内不必使用持久导航
* 表单，在需要填写表单的页面，持久导航可能会造成不必要的干扰</p>

<p>对于这些页面，只需要站点ID，一个回到主页的链接，有助于谈些表单的实用工具这样最小规模的持久导航就可以了</p>

<h3 id="section-5">知道我们还在网站里</h3>
<p>在网站里，我们移动方式是瞬移，我们需要在每个页面上见到网站的名称以保证我们还在网站中。站点的ID代表整个网站，所以站点的ID应该在页面可视层次的首要位置。通常可以让它成为本页最显眼的内容，或者让它涵盖页面所有元素。另外站点ID应该一眼看起来就像一个站点ID</p>

<h3 id="section-6">栏目</h3>
<p>也称主导航条，到达站点主要栏目的链接，层次结构的最顶层。有时会包含二级导航</p>

<h3 id="section-7">实用工具</h3>
<p>帮助用户使用站点，或提供网站发布者信息，例如帮助，联系我们等等，对于不同类型的万展，实用工具有所不同。通常，持久导航上只能放置4-5个实用工具</p>

<h3 id="section-8">返回主页</h3>
<p>最重要的元素之一，新兴的用法就是让站点ID同时也作为一个让用户回到主页的按钮，或者用下列两种方式：
* 在栏目中或实用工具中包含一个回到主页的链接
* 在主页之外的站点ID上加上一个Home，让大家知道可以点击它</p>

<h3 id="section-9">提供搜索</h3>
<p>除非站点规模很小而且组织得很好，否则每个页面都应该有一个搜索框或一个到搜索页面的链接。除非网站真的不太需要搜索，否则它应该是一个搜索框</p>

<p>搜索框需要注意：
* 花哨的用词，用搜索就好，不要用查找，快速查找之类的词
* 指示说明：告诉用户搜索框的使用方式
* 选项，如果有存在任何混淆的搜索范围，需要将他们写出来。在提供时，需要谨慎思考</p>

<h3 id="section-10">多级导航</h3>
<p>Web设计中普遍存在一个问题，没有对低层次的导航给与足够的重视，在很多网站，一旦到了第二个层次一下，导航会变得支离破碎，因为：
* 导航本身难以设计，页面空间有限
* 设计师即使在设计前两个层次时也感觉到时间不够
* 因为低级层次导航看起来不那么重要</p>

<p>事实上用户在底层页面上花呃时间通常和花在顶层页面上的时间是相同的的</p>

<h3 id="section-11">页面名称</h3>
<p>页面名称就像路牌一样：
*　每个页面都需要一个名称
*　页面名称应该出现在合适的位置上
*　名称要引人注目
*　名称要和点击并来到这个页面的链接一致</p>

<h3 id="section-12">你在这里</h3>
<p>提供你在这里指示器来告诉用户当前所在的位置，这个指示器需要突出，否则就是去了视觉线索的价值，而变成一种噪声。同时不能太过模糊</p>

<h3 id="section-13">面包屑</h3>
<p>面包屑也告诉用户当前的位置，同时告诉了从主页到当前位置的路径，这是一种很重要的导航方式，能提供回退到任意层次，回到主页，提供当前位置等多个功能，有一些最佳实践：
* 把他们放在页面最顶端，避免它和导航相混淆
* 使用”&gt;”进行层级分割
* 使用小字体：它只是补充机制
* 使用文字“你在这里”
* 最后一个元素加粗，最后一个元素时当前页面的名称，加粗可以得到应有的突出
* 没有把他们用作页面的名称</p>

<h3 id="section-14">标签页</h3>
<p>标签页是大型网站的上佳选择：
* 标签页不言而喻，每个人都知道标签页是干什么的
* 标签页很难错过，用户都会留意到
* 他们很灵活
* 他们暗示了一个物理的空间</p>

<p>标签页需要注意的三个要点：
1. 正确绘制，激活的标签页位于其他标签页之前
2. 不是标签页功能的普通按钮，不要按照标签页的方式绘制
3. 颜色编码，为每个栏目使用一种不同的颜色，吧这个颜色用在页面其他导航元素上，让他们浑然一体
4. 当进入页面时，有一个标签页已经选中</p>

<h3 id="section-15">测试</h3>
<p>执行过程：
1. 任意选择一个网页，打印下来
2. 拿到一手开外，或者斜过一个角度，让你不能仔细观察
3. 尽快找到下面清单中的项目并画上圆圈（站点ID、页内导航、页面名称、你在这里指示器、栏目和下一级栏目、搜索）</p>

<h2 id="section-16">设计主页</h2>
<p>###主页的任务
主页要完成的任务：
1. 站点的标识和使命，告诉这是个什么网站，用来做什么的
2. 站点层次，给出网站提供的服务的概貌，包括内容、功能、服务如何组织，可以交由持久导航处理
3. 搜索，突出明显的搜索框
4. 导读，用一些“里面有精彩内容”来吸引用户，内容推荐部分应该突出最新、最好、最流行的内容片断，功能推荐部分邀请我去访问网站更多栏目或使用一些个性化功能
5. 内容更新，主页的内容应经常更新
6. 友情链接
7. 快捷方式，最常访问的内容片断值得将链接放在首页上
8. 注册，如果网站提供注册，应为型用户和老用户登录提供了明显的链接，并用某种方式告诉他们知道自己是否已经登录
9. 让我们看到正在寻找的东西
10. 还有没有寻找的，主页应该让用户看到一些很精彩的，也许会感兴趣的内容
11. 告诉用户从哪里开始
12. 建立可信度和信任感</p>

<h3 id="section-17">主页的问题</h3>
<ul>
  <li>需要推荐的内容很容易过多</li>
  <li>主页十分重要，每个人都想对她发表看法</li>
  <li>主页要呈现在每个访问者面前，适合所有人</li>
</ul>

<h3 id="section-18">主页要传达整体形象</h3>
<p>一个主页应回答头脑里的四个问题：
1. 这是什么网站
2. 我能在这里做什么
3. 网站上有些什么
4. 为什么我在这里，而不在别的地方</p>

<h3 id="section-19">如何传达</h3>
<p>在主页上有两个重要位置，我们希望能从这两个地方找到清除的陈述：
1. 口号，最有价值的位置之一就是靠近站点ID的地方
2. 欢迎广告，在主页的首要位置显示，网站的简要描述</p>

<p>传达信息的知道原则：
* 需要多大空间就是用多大空间
* 不要使用过多的空间
* 不要把使命陈述当做欢迎公告
* 最重要的事件进行测试</p>

<h3 id="section-20">没有什么比得上一个好口号</h3>
<p>口号是一条精炼的短句，总结了这个企业是干什么的，为什么好。在网站中，口号可能出现在站点ID的下方、上方或旁边。选择口号时需要注意几点：
* 口号要清楚，言之有物，不能含糊不清
* 长度适中
* 表述出网站的特点和显而易见的好处，不能听起来太笼统
* 有个性、生动、有时还很俏皮</p>

<p>有些网站可以不需要口号，但他们也可以从口号中获益，例如
* 家喻户晓的网站
* 品牌在网站建立之前就很有名的网站</p>

<h3 id="section-21">从哪里开始</h3>
<p>用户进入一个新网站，快速扫描主页后，应该能明白：
* 如果我想搜索，从哪儿开始
* 如果想扫描，从哪儿开始
* 想扫描该网站最精彩的内容，从哪儿开始</p>

<p>让每个起点看起来像起点。要清除的给他们加上文字描述</p>

<h3 id="section-22">主页导航可以不一样</h3>
<p>主页独特的职责，不必使用持久导航，常见的差别包括：
* 栏目描述，可以为栏目名称加上一个描述性短语
* 不同的方向，和其他页面布局不同
* 用于识别的空间更多</p>

<p>主页导航和持久导航也应当保持一定程度上的一致性</p>

<h3 id="section-23">下拉框的问题</h3>
<p>由于主页位置有限，经常会有使用下拉框的情况用来节约空间，但有几个问题：
* 必须会造出下拉框，必须点击下拉框，才能看到下拉列表
* 他们难以扫描
* 不好控制，列表显示和收缩很快，影响查看效果</p>

<p>如果用户不知道自己再找什么名称时，下拉框的效率很低</p>

<h3 id="section-24">推荐的问题</h3>
<p>在主页上进行推荐因为其效果好，任何项目在主页上有一个醒目的链接，肯定会得到更多的访问量，但是在主页上增加更多的项目所得到的和所付出的不一致。任何共享的资源都会因为过度使用而遭到破坏。</p>

<h3 id="section-25">测试</h3>
<p>看到一个主页，快速扫描，然后回答两个问题：
1. 这个网站是做什么的
2. 从哪里开始</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/12/dont-make-me-think-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——必须正确处理的几个方面 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/12/dont-make-me-think-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">设计导航</h2>
<p>如果网站上找不到方向，人们不会使用你的网站。作为一个用户，如果到了一个网站，没有找到需要的内容，或者不知道网站怎么组织的，可能还会回来</p>

<h3 id="section-1">网站导航</h3>
<p>用户通常是为了寻找某个目标而来。他们会进行思考，是先询问（搜索），还是先浏览。通常用户决定是先搜索还是先浏览取决于他们的打算、匆忙程度，以及网站是否具有良好的导航机制。如果选择浏览，他们将通过标志的引导在层次结构中穿行。最后他们如果没有找到想要的东西，会离开。</p>

<h3 id="section-2">无法承受的浏览之轻</h3>
<p>网络上查找东西和真实世界有很多相似之处，但也有很多不同，比如：
* 用户无法感觉到网站本身的大小
* 用户不会有方向的感觉
* 用户感觉不到位置</p>

<p>在真实世界中，查找过一次的货物，会和容易去。而在Web上，通过点击链接向前移动。想要再次访问网站上的某个内容，需要记住它在概念层次上的位置，然后重新顺着以往的链接过去。使用Web导航，就是为了让用户得知他们当前的位置，导航通过具体化网站的层次结构，来补偿确实的现实空间感</p>

<h3 id="section-3">被忽视了的导航用途</h3>
<p>导航有两个显而易见的用途： 帮助我们找到想要的东西和告诉我们现在身在何处，其实导航的所有用途有：
* 给了哦我们一些固定的感觉
* 告诉我们当前的位置
* 告诉我们如何使用网站
* 给了我们对网站建造者的信心</p>

<h3 id="web">Web导航习惯用法</h3>
<p>设计得当的持久导航需要表达的意思：导航部分在这里，其中一些可能会根据您所处的位置有所变化，但它总是在这里</p>

<p>持久导航包括5个元素，这5个元素是用户一直需要的：
1. 站点ID
2. 回到主页的方式
3. 搜索的方式
4. 实用工具
5. 栏目</p>

<h3 id="section-4">我说的是每一页</h3>
<p>对于每个地方都一样的规则，有两个例外：
* 主页，主页承担着一些不同的任务，有时候在主页内不必使用持久导航
* 表单，在需要填写表单的页面，持久导航可能会造成不必要的干扰</p>

<p>对于这些页面，只需要站点ID，一个回到主页的链接，有助于谈些表单的实用工具这样最小规模的持久导航就可以了</p>

<h3 id="section-5">知道我们还在网站里</h3>
<p>在网站里，我们移动方式是瞬移，我们需要在每个页面上见到网站的名称以保证我们还在网站中。站点的ID代表整个网站，所以站点的ID应该在页面可视层次的首要位置。通常可以让它成为本页最显眼的内容，或者让它涵盖页面所有元素。另外站点ID应该一眼看起来就像一个站点ID</p>

<h3 id="section-6">栏目</h3>
<p>也称主导航条，到达站点主要栏目的链接，层次结构的最顶层。有时会包含二级导航</p>

<h3 id="section-7">实用工具</h3>
<p>帮助用户使用站点，或提供网站发布者信息，例如帮助，联系我们等等，对于不同类型的万展，实用工具有所不同。通常，持久导航上只能放置4-5个实用工具</p>

<h3 id="section-8">返回主页</h3>
<p>最重要的元素之一，新兴的用法就是让站点ID同时也作为一个让用户回到主页的按钮，或者用下列两种方式：
* 在栏目中或实用工具中包含一个回到主页的链接
* 在主页之外的站点ID上加上一个Home，让大家知道可以点击它</p>

<h3 id="section-9">提供搜索</h3>
<p>除非站点规模很小而且组织得很好，否则每个页面都应该有一个搜索框或一个到搜索页面的链接。除非网站真的不太需要搜索，否则它应该是一个搜索框</p>

<p>搜索框需要注意：
* 花哨的用词，用搜索就好，不要用查找，快速查找之类的词
* 指示说明：告诉用户搜索框的使用方式
* 选项，如果有存在任何混淆的搜索范围，需要将他们写出来。在提供时，需要谨慎思考</p>

<h3 id="section-10">多级导航</h3>
<p>Web设计中普遍存在一个问题，没有对低层次的导航给与足够的重视，在很多网站，一旦到了第二个层次一下，导航会变得支离破碎，因为：
* 导航本身难以设计，页面空间有限
* 设计师即使在设计前两个层次时也感觉到时间不够
* 因为低级层次导航看起来不那么重要</p>

<p>事实上用户在底层页面上花呃时间通常和花在顶层页面上的时间是相同的的</p>

<h3 id="section-11">页面名称</h3>
<p>页面名称就像路牌一样：
*　每个页面都需要一个名称
*　页面名称应该出现在合适的位置上
*　名称要引人注目
*　名称要和点击并来到这个页面的链接一致</p>

<h3 id="section-12">你在这里</h3>
<p>提供你在这里指示器来告诉用户当前所在的位置，这个指示器需要突出，否则就是去了视觉线索的价值，而变成一种噪声。同时不能太过模糊</p>

<h3 id="section-13">面包屑</h3>
<p>面包屑也告诉用户当前的位置，同时告诉了从主页到当前位置的路径，这是一种很重要的导航方式，能提供回退到任意层次，回到主页，提供当前位置等多个功能，有一些最佳实践：
* 把他们放在页面最顶端，避免它和导航相混淆
* 使用”&gt;”进行层级分割
* 使用小字体：它只是补充机制
* 使用文字“你在这里”
* 最后一个元素加粗，最后一个元素时当前页面的名称，加粗可以得到应有的突出
* 没有把他们用作页面的名称</p>

<h3 id="section-14">标签页</h3>
<p>标签页是大型网站的上佳选择：
* 标签页不言而喻，每个人都知道标签页是干什么的
* 标签页很难错过，用户都会留意到
* 他们很灵活
* 他们暗示了一个物理的空间</p>

<p>标签页需要注意的三个要点：
1. 正确绘制，激活的标签页位于其他标签页之前
2. 不是标签页功能的普通按钮，不要按照标签页的方式绘制
3. 颜色编码，为每个栏目使用一种不同的颜色，吧这个颜色用在页面其他导航元素上，让他们浑然一体
4. 当进入页面时，有一个标签页已经选中</p>

<h3 id="section-15">测试</h3>
<p>执行过程：
1. 任意选择一个网页，打印下来
2. 拿到一手开外，或者斜过一个角度，让你不能仔细观察
3. 尽快找到下面清单中的项目并画上圆圈（站点ID、页内导航、页面名称、你在这里指示器、栏目和下一级栏目、搜索）</p>

<h2 id="section-16">设计主页</h2>
<p>###主页的任务
主页要完成的任务：
1. 站点的标识和使命，告诉这是个什么网站，用来做什么的
2. 站点层次，给出网站提供的服务的概貌，包括内容、功能、服务如何组织，可以交由持久导航处理
3. 搜索，突出明显的搜索框
4. 导读，用一些“里面有精彩内容”来吸引用户，内容推荐部分应该突出最新、最好、最流行的内容片断，功能推荐部分邀请我去访问网站更多栏目或使用一些个性化功能
5. 内容更新，主页的内容应经常更新
6. 友情链接
7. 快捷方式，最常访问的内容片断值得将链接放在首页上
8. 注册，如果网站提供注册，应为型用户和老用户登录提供了明显的链接，并用某种方式告诉他们知道自己是否已经登录
9. 让我们看到正在寻找的东西
10. 还有没有寻找的，主页应该让用户看到一些很精彩的，也许会感兴趣的内容
11. 告诉用户从哪里开始
12. 建立可信度和信任感</p>

<h3 id="section-17">主页的问题</h3>
<ul>
  <li>需要推荐的内容很容易过多</li>
  <li>主页十分重要，每个人都想对她发表看法</li>
  <li>主页要呈现在每个访问者面前，适合所有人</li>
</ul>

<h3 id="section-18">主页要传达整体形象</h3>
<p>一个主页应回答头脑里的四个问题：
1. 这是什么网站
2. 我能在这里做什么
3. 网站上有些什么
4. 为什么我在这里，而不在别的地方</p>

<h3 id="section-19">如何传达</h3>
<p>在主页上有两个重要位置，我们希望能从这两个地方找到清除的陈述：
1. 口号，最有价值的位置之一就是靠近站点ID的地方
2. 欢迎广告，在主页的首要位置显示，网站的简要描述</p>

<p>传达信息的知道原则：
* 需要多大空间就是用多大空间
* 不要使用过多的空间
* 不要把使命陈述当做欢迎公告
* 最重要的事件进行测试</p>

<h3 id="section-20">没有什么比得上一个好口号</h3>
<p>口号是一条精炼的短句，总结了这个企业是干什么的，为什么好。在网站中，口号可能出现在站点ID的下方、上方或旁边。选择口号时需要注意几点：
* 口号要清楚，言之有物，不能含糊不清
* 长度适中
* 表述出网站的特点和显而易见的好处，不能听起来太笼统
* 有个性、生动、有时还很俏皮</p>

<p>有些网站可以不需要口号，但他们也可以从口号中获益，例如
* 家喻户晓的网站
* 品牌在网站建立之前就很有名的网站</p>

<h3 id="section-21">从哪里开始</h3>
<p>用户进入一个新网站，快速扫描主页后，应该能明白：
* 如果我想搜索，从哪儿开始
* 如果想扫描，从哪儿开始
* 想扫描该网站最精彩的内容，从哪儿开始</p>

<p>让每个起点看起来像起点。要清除的给他们加上文字描述</p>

<h3 id="section-22">主页导航可以不一样</h3>
<p>主页独特的职责，不必使用持久导航，常见的差别包括：
* 栏目描述，可以为栏目名称加上一个描述性短语
* 不同的方向，和其他页面布局不同
* 用于识别的空间更多</p>

<p>主页导航和持久导航也应当保持一定程度上的一致性</p>

<h3 id="section-23">下拉框的问题</h3>
<p>由于主页位置有限，经常会有使用下拉框的情况用来节约空间，但有几个问题：
* 必须会造出下拉框，必须点击下拉框，才能看到下拉列表
* 他们难以扫描
* 不好控制，列表显示和收缩很快，影响查看效果</p>

<p>如果用户不知道自己再找什么名称时，下拉框的效率很低</p>

<h3 id="section-24">推荐的问题</h3>
<p>在主页上进行推荐因为其效果好，任何项目在主页上有一个醒目的链接，肯定会得到更多的访问量，但是在主页上增加更多的项目所得到的和所付出的不一致。任何共享的资源都会因为过度使用而遭到破坏。</p>

<h3 id="section-25">测试</h3>
<p>看到一个主页，快速扫描，然后回答两个问题：
1. 这个网站是做什么的
2. 从哪里开始</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/12/dont-make-me-think-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——指导原则 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/12/dont-make-me-think-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="dont-make-me-think">Don`t make me think</h2>
<p>###不言而喻、一目了然
设计这应该尽量做到，当用户看到一个页面时，应该是不言而喻，一目了然，自我解释的。用户应该能明白它是什么、如何使用，而不需要花精力去思考。网页上每项内容都有可能迫使我们停下来思考，比如自以为很酷或自以为很聪明的名字、具体公司相关的名字，还有看起来不太明显的连接和按钮等等。在确定这些名字和按钮时，我们应该更倾向于显而易见，而不是需要额外的思考
###用户的思考
在用户访问网站时，经常会陷入下列思考中：
* 我在什么位置
* 我该从哪儿开始
* 他们把XX放在哪儿了
* 这个页面上最重要的是什么
* 为什么叫这个名字
* 等等</p>

<h3 id="section">网页设计的目标</h3>
<p>网页最好是能达到一个目标，就是让普通用户只要看到它一眼，就知道是什么内容，如何使用它。因为大多数人会花比我们预计少的多的时间来浏览器网页</p>

<h2 id="web">我们实际上是如何使用Web的</h2>
<p>绝大部分用户，在大部分时间里，都只是在每个页面上行瞥一眼，扫过一些文字，点击第一个令他们感兴趣的或者大概符合他们寻找目标的链接。通常情况下，页面上有很多东西用户都不会去看，甚至当做从来没存在过。</p>

<h3 id="section-1">不去阅读，而是扫描</h3>
<p>用户浏览页面，不会去阅读，而是扫描，因为：
1. 用户总是处于忙碌之中，他们使用Web是想节约时间，所以他们没有时间来阅读哪些不必要的内容
2. 用户知道自己不需要阅读所有信息，他们只会对其中一小部分感兴趣，而他们也只会寻找这一部分并阅读它，扫描就是用户找到这一小部分内容的方式
3. 在日常生活中，我们一直在扫描报纸、杂志、书籍，所以我们善于扫描</p>

<h3 id="section-2">不是最佳，而是满意</h3>
<p>用户不会做最佳的选择，而是满意即可。事实上，大多数时间用户都不会选择最佳选项，而是选择第一个合理的选项。因为:
1. 用户很忙，寻找最佳策略很难，需要很长时间，只是寻找满意策略效率要高得多
2. 如果猜错了，不会有什么严重后果。网站上一次错误的选择，换来的不过是几次后退按钮罢了
3. 对选择进行权衡并不会改善我们的机会
4. 猜测更有意思，猜测不会像仔细衡量那么累，如果猜对了，速度会更快</p>

<h3 id="section-3">不问原理，只要能用</h3>
<p>用户不会追根究底，而是勉强应付。在很大程度上，人们在使用一些东西时，不会去理解他们的运作原理，甚至对他们的运作原理完全是错误的理解。在网页上也是一样，很多人完全不是以设计师设想的方式使用网络和软件，但是他们用得很好。因为：
* 事物背后的工作机制往往对用户来说不中用，只要能正常使用它就行了
* 如果发现某个事物能用，用户就会一直用它，无论它有多难用，除非偶然发现一种更好地方法。用户不太会自己去找一种更好的方法</p>

<p>所以，如果用户能很快的明白这个页面，那么：
* 他们更容易找到自己所需要的东西
* 他们更容易理解网站提供哪些服务
* 你更可能引导他们去你所希望他们看到的地方
* 他们会觉得，在你的网站上，他们更能把握全局，这会让他们成为老用户</p>

<h2 id="section-4">为扫描设计，不为阅读设计</h2>
<p>###视觉层次
让页面在瞬间明白易懂的一个好办法是确保页面上所有内容的外观–所有的可视线索–清除，而且能偶准确的表达页面上内容之间的关系，也就是有清楚的视觉层次</p>

<p>视觉层次清楚的特点有：
* 越重要的部分越突出
* 逻辑上相关的部分在视觉上也应当相关
* 逻辑上包含的部分，在视觉上应该进行嵌套</p>

<p>用户每天都会对视觉层次进行分解，好的视觉层次通过预先处理页面，用一种我们能快速理解的方式对页面的内容进行组织并却分优先级，减少用户的对页面的思考，加快浏览页面找到所需内容的时间。如果页面没有清楚的视觉层次，用户将会被迫降低扫描页面的速度，寻找关键的文字和短语，然后拼凑出我们感觉重要的内容和内容的组织方式，加大了用户的思考内容</p>

<h3 id="section-5">习惯用法</h3>
<p>由于文化的关系，用户从小会养成一种习惯用法，比如很大的短语它通常是标题，一张照片下面的文字要么是对照片的说明，要么是照片的拍摄者署名，等等。这些习惯用法根植在用户的脑海中，通过常年累月积累而来</p>

<p>关于Web上的习惯用法，有两点很重要：
1. 这些习惯用法非常有用，我们需要知道，习惯用法之所以会成为习惯，就是因为他们有用
2. 设计师通常不愿意利用他们，设计师总是希望能做出一些崭新的，与众不同的设计，而不是使用那些原有的东西</p>

<p>如果不打算使用一种已有的习惯用法，那也必须使用一种清楚地，能带来很大价值的习惯用法。所以，在清楚自己有个更好地想法时进行创新，否则尽量使用习惯用法</p>

<h3 id="section-6">划分页面</h3>
<p>把页面划分成明确定义的区域很重要，因为这可以让用户很快的决定关注页面的哪些区域，或者放心的跳过哪些区域</p>

<h3 id="section-7">明显标识可以点击的地方</h3>
<p>人们在网页上所做的大多数申请就是找到下一个地方点击，那么明确地标注哪些地方可以点击，哪些地方不能点击，这很重要
###降低视觉噪声
让页面不易理解的一个最大原因，就是视觉噪声，它分为两种：
* 眼花缭乱
* 背景噪声</p>

<p>在设计页面的时候，可以先假定所有内容都是视觉噪声，除非得到证明它们不是</p>

<h2 id="section-8">为什么用户喜欢无需思考的选择</h2>
<p>一些站点规定，到达网页的任何页面需要点击的次数永远不能超过指定的次数（3、4、5）。但真正的问题不是到达目标之前要的点击次数（当然这里也要有个限度），而是每次点击需要多少思考。用户不介意有多少次点击，只要每次点击都毫不费力，并且能让用户坚信自己的选择正确。“三次无需思考、明确无误的点击相当于一次需要思考的点击”</p>

<h2 id="section-9">省略不必要的文字</h2>
<p>###页面到处是多余
有力的文字都很简练。句子里不应该有多余的文字，段落里不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。网页上大部分文字斗不过实在占地方，因为没有人打算读他们。去掉没有人看的文字，有三个好处：
1. 可以降低页面的噪声
2. 让有用的内容更加突出
3. 让页面更简短，用户一眼能看到更多的信息，而不用滚动屏幕</p>

<h3 id="section-10">去掉欢迎词</h3>
<p>欢迎词是一段引导性的文字，可能是欢迎我们来到这个站点，告诉这个网站有多棒，或者告诉我们在刚进入这个版面将会看到什么内容。很多欢迎词没有包括有用的信息，而是在一个劲的说自己有多好，而不是描述什么东西能让用户感觉更好。欢迎词就像闲聊，内容无所谓，主要是一种社交手段，但大部分Web用户没有时间闲聊，他们喜欢直截了当，所以尽量减少欢迎词，能减多少减多少</p>

<h3 id="section-11">去掉指示说明</h3>
<p>多余文字的另一个主要来源就是指示说明，关于指示说明，没有人会细读他们，如果只是说明非常长，用户发现他们所需信息的机会就越小。我们应当让每项内容不言而喻来消除指示说明</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/12/dont-make-me-think-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《Don`t make me think》读书笔记——指导原则 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/12/dont-make-me-think-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 12 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="dont-make-me-think">Don`t make me think</h2>
<p>###不言而喻、一目了然
设计这应该尽量做到，当用户看到一个页面时，应该是不言而喻，一目了然，自我解释的。用户应该能明白它是什么、如何使用，而不需要花精力去思考。网页上每项内容都有可能迫使我们停下来思考，比如自以为很酷或自以为很聪明的名字、具体公司相关的名字，还有看起来不太明显的连接和按钮等等。在确定这些名字和按钮时，我们应该更倾向于显而易见，而不是需要额外的思考
###用户的思考
在用户访问网站时，经常会陷入下列思考中：
* 我在什么位置
* 我该从哪儿开始
* 他们把XX放在哪儿了
* 这个页面上最重要的是什么
* 为什么叫这个名字
* 等等</p>

<h3 id="section">网页设计的目标</h3>
<p>网页最好是能达到一个目标，就是让普通用户只要看到它一眼，就知道是什么内容，如何使用它。因为大多数人会花比我们预计少的多的时间来浏览器网页</p>

<h2 id="web">我们实际上是如何使用Web的</h2>
<p>绝大部分用户，在大部分时间里，都只是在每个页面上行瞥一眼，扫过一些文字，点击第一个令他们感兴趣的或者大概符合他们寻找目标的链接。通常情况下，页面上有很多东西用户都不会去看，甚至当做从来没存在过。</p>

<h3 id="section-1">不去阅读，而是扫描</h3>
<p>用户浏览页面，不会去阅读，而是扫描，因为：
1. 用户总是处于忙碌之中，他们使用Web是想节约时间，所以他们没有时间来阅读哪些不必要的内容
2. 用户知道自己不需要阅读所有信息，他们只会对其中一小部分感兴趣，而他们也只会寻找这一部分并阅读它，扫描就是用户找到这一小部分内容的方式
3. 在日常生活中，我们一直在扫描报纸、杂志、书籍，所以我们善于扫描</p>

<h3 id="section-2">不是最佳，而是满意</h3>
<p>用户不会做最佳的选择，而是满意即可。事实上，大多数时间用户都不会选择最佳选项，而是选择第一个合理的选项。因为:
1. 用户很忙，寻找最佳策略很难，需要很长时间，只是寻找满意策略效率要高得多
2. 如果猜错了，不会有什么严重后果。网站上一次错误的选择，换来的不过是几次后退按钮罢了
3. 对选择进行权衡并不会改善我们的机会
4. 猜测更有意思，猜测不会像仔细衡量那么累，如果猜对了，速度会更快</p>

<h3 id="section-3">不问原理，只要能用</h3>
<p>用户不会追根究底，而是勉强应付。在很大程度上，人们在使用一些东西时，不会去理解他们的运作原理，甚至对他们的运作原理完全是错误的理解。在网页上也是一样，很多人完全不是以设计师设想的方式使用网络和软件，但是他们用得很好。因为：
* 事物背后的工作机制往往对用户来说不中用，只要能正常使用它就行了
* 如果发现某个事物能用，用户就会一直用它，无论它有多难用，除非偶然发现一种更好地方法。用户不太会自己去找一种更好的方法</p>

<p>所以，如果用户能很快的明白这个页面，那么：
* 他们更容易找到自己所需要的东西
* 他们更容易理解网站提供哪些服务
* 你更可能引导他们去你所希望他们看到的地方
* 他们会觉得，在你的网站上，他们更能把握全局，这会让他们成为老用户</p>

<h2 id="section-4">为扫描设计，不为阅读设计</h2>
<p>###视觉层次
让页面在瞬间明白易懂的一个好办法是确保页面上所有内容的外观–所有的可视线索–清除，而且能偶准确的表达页面上内容之间的关系，也就是有清楚的视觉层次</p>

<p>视觉层次清楚的特点有：
* 越重要的部分越突出
* 逻辑上相关的部分在视觉上也应当相关
* 逻辑上包含的部分，在视觉上应该进行嵌套</p>

<p>用户每天都会对视觉层次进行分解，好的视觉层次通过预先处理页面，用一种我们能快速理解的方式对页面的内容进行组织并却分优先级，减少用户的对页面的思考，加快浏览页面找到所需内容的时间。如果页面没有清楚的视觉层次，用户将会被迫降低扫描页面的速度，寻找关键的文字和短语，然后拼凑出我们感觉重要的内容和内容的组织方式，加大了用户的思考内容</p>

<h3 id="section-5">习惯用法</h3>
<p>由于文化的关系，用户从小会养成一种习惯用法，比如很大的短语它通常是标题，一张照片下面的文字要么是对照片的说明，要么是照片的拍摄者署名，等等。这些习惯用法根植在用户的脑海中，通过常年累月积累而来</p>

<p>关于Web上的习惯用法，有两点很重要：
1. 这些习惯用法非常有用，我们需要知道，习惯用法之所以会成为习惯，就是因为他们有用
2. 设计师通常不愿意利用他们，设计师总是希望能做出一些崭新的，与众不同的设计，而不是使用那些原有的东西</p>

<p>如果不打算使用一种已有的习惯用法，那也必须使用一种清楚地，能带来很大价值的习惯用法。所以，在清楚自己有个更好地想法时进行创新，否则尽量使用习惯用法</p>

<h3 id="section-6">划分页面</h3>
<p>把页面划分成明确定义的区域很重要，因为这可以让用户很快的决定关注页面的哪些区域，或者放心的跳过哪些区域</p>

<h3 id="section-7">明显标识可以点击的地方</h3>
<p>人们在网页上所做的大多数申请就是找到下一个地方点击，那么明确地标注哪些地方可以点击，哪些地方不能点击，这很重要
###降低视觉噪声
让页面不易理解的一个最大原因，就是视觉噪声，它分为两种：
* 眼花缭乱
* 背景噪声</p>

<p>在设计页面的时候，可以先假定所有内容都是视觉噪声，除非得到证明它们不是</p>

<h2 id="section-8">为什么用户喜欢无需思考的选择</h2>
<p>一些站点规定，到达网页的任何页面需要点击的次数永远不能超过指定的次数（3、4、5）。但真正的问题不是到达目标之前要的点击次数（当然这里也要有个限度），而是每次点击需要多少思考。用户不介意有多少次点击，只要每次点击都毫不费力，并且能让用户坚信自己的选择正确。“三次无需思考、明确无误的点击相当于一次需要思考的点击”</p>

<h2 id="section-9">省略不必要的文字</h2>
<p>###页面到处是多余
有力的文字都很简练。句子里不应该有多余的文字，段落里不应该有多余的句子。同样，画上不应该有多余的线条，机器上不应该有多余的零件。网页上大部分文字斗不过实在占地方，因为没有人打算读他们。去掉没有人看的文字，有三个好处：
1. 可以降低页面的噪声
2. 让有用的内容更加突出
3. 让页面更简短，用户一眼能看到更多的信息，而不用滚动屏幕</p>

<h3 id="section-10">去掉欢迎词</h3>
<p>欢迎词是一段引导性的文字，可能是欢迎我们来到这个站点，告诉这个网站有多棒，或者告诉我们在刚进入这个版面将会看到什么内容。很多欢迎词没有包括有用的信息，而是在一个劲的说自己有多好，而不是描述什么东西能让用户感觉更好。欢迎词就像闲聊，内容无所谓，主要是一种社交手段，但大部分Web用户没有时间闲聊，他们喜欢直截了当，所以尽量减少欢迎词，能减多少减多少</p>

<h3 id="section-11">去掉指示说明</h3>
<p>多余文字的另一个主要来源就是指示说明，关于指示说明，没有人会细读他们，如果只是说明非常长，用户发现他们所需信息的机会就越小。我们应当让每项内容不言而喻来消除指示说明</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/12/dont-make-me-think-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——最佳实践 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/09/csszengarden-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">若是不确信的话，就去验证</h3>
<p>在调试之前可以简单地验证一下代码，格式不正确的XHTML或CSS将会导致很多布局问题。W3C提供了XHTML和CSS的验证工具，链接<a href="http://validator.w3.org">XHTML</a>和<a href="http://jigsaw.w3.org/css-validator/">CSS</a></p>

<h3 id="css">创建并测试CSS时优先在最高级、最先进的浏览器中进行，然后考虑其他浏览器</h3>
<p>首先基于先进浏览器编写，然后再为那些非标准浏览器调整的话，代码将从一个开始就非常标准，调整的过程也将会非常容易。
###若用浮动实现布局，请确保正确地清除了浮动</p>

<h3 id="section-1">为元素应用内边距或边框来避免外边距重叠</h3>
<p>现在可以通过触发BFC来防止外边距重叠</p>

<h3 id="section-2">避免同时为元素制定明确的内边距/边框值与宽度/高度值</h3>
<p>兼容性问题</p>

<h3 id="ie6">避免IE6的“无样式瞬间现象”</h3>
<p>若在IE6中用<code>@import</code>引入外部样式就会出现闪烁的情况，可以通过link元素，或是在页面中添加script元素来避免这个问题</p>

<h3 id="min-widthmin-height">不要依靠min-width或min-height属性</h3>
<p>兼容性问题</p>

<h3 id="section-3">尝试减少百分比值</h3>
<p>适当减少百分比，让其相加稍小于100%</p>

<h3 id="section-4">确保要实现的效果确实存在</h3>
<p>不同的效果在不同的浏览器中兼容性不一样，需要进行更多的测试</p>

<h3 id="lovehate">牢记“LoVe/HAte”（爱恨）连接规则</h3>
<p>在为连接元素指定伪类时，注意以下顺序：<code>link</code>、<code>visited</code>、<code>hover</code>和<code>active</code>，任何其他的声明顺序都可能会导致问题。若还要考虑<code>:focus</code>伪类，则规则修改为LVHFA</p>

<h3 id="troubled">牢记“TRouBLED”（麻烦的）边框简写顺序</h3>
<p><code>boder</code>、<code>margin</code>、<code>padding</code>的顺序都是按照时钟的顺序，<code>top</code>，<code>right</code>，<code>bottom</code>，<code>left</code>。</p>

<h3 id="section-5">为非零值表明单位</h3>
<p>除了line-height以外，我们需要为非零的值标上单位</p>

<h3 id="section-6">测试不同的字体大小</h3>
<p>高级浏览器会允许用户调整字体大小，所以需要调整字体大小来进行更多的测试</p>

<h3 id="htmlcss">HTML和CSS中统一大小写</h3>

<h3 id="section-7">测试时使用嵌入样式，发布时再改为外部输入</h3>
<p>在测试时将样式嵌入到HTML代码中，可避免许多因浏览器缓存导致的不正常现象。对于较老的浏览器，这一点很重要。但是在发布前，记得将他们改为<code>@import</code>或<code>&lt;link&gt;</code>引入</p>

<h3 id="section-8">用明显的边框辅助调试布局</h3>
<p>通过类似<code>div {border: 1px solid #f00}</code>之类的全局规则可以帮助检查很多细微的布局差错</p>

<h3 id="section-9">指定图片路径是不要使用单引号</h3>
<p>设置背景图片时不需要使用引号。如果使用单引号，苹果机上的IE无法正确加载图像，所以要么使用双引号，要么不用引号</p>

<h3 id="anchor">若使用了锚点（anchor），那么在为超链接应用样式要格外小心</h3>

<h3 id="section-10">不要未雨绸缪的链接至作为“占位符”的空样式表</h3>
<p>这样会加长页面的加载时间</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/09/csszengarden-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——最佳实践 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/09/csszengarden-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">若是不确信的话，就去验证</h3>
<p>在调试之前可以简单地验证一下代码，格式不正确的XHTML或CSS将会导致很多布局问题。W3C提供了XHTML和CSS的验证工具，链接<a href="http://validator.w3.org">XHTML</a>和<a href="http://jigsaw.w3.org/css-validator/">CSS</a></p>

<h3 id="css">创建并测试CSS时优先在最高级、最先进的浏览器中进行，然后考虑其他浏览器</h3>
<p>首先基于先进浏览器编写，然后再为那些非标准浏览器调整的话，代码将从一个开始就非常标准，调整的过程也将会非常容易。
###若用浮动实现布局，请确保正确地清除了浮动</p>

<h3 id="section-1">为元素应用内边距或边框来避免外边距重叠</h3>
<p>现在可以通过触发BFC来防止外边距重叠</p>

<h3 id="section-2">避免同时为元素制定明确的内边距/边框值与宽度/高度值</h3>
<p>兼容性问题</p>

<h3 id="ie6">避免IE6的“无样式瞬间现象”</h3>
<p>若在IE6中用<code>@import</code>引入外部样式就会出现闪烁的情况，可以通过link元素，或是在页面中添加script元素来避免这个问题</p>

<h3 id="min-widthmin-height">不要依靠min-width或min-height属性</h3>
<p>兼容性问题</p>

<h3 id="section-3">尝试减少百分比值</h3>
<p>适当减少百分比，让其相加稍小于100%</p>

<h3 id="section-4">确保要实现的效果确实存在</h3>
<p>不同的效果在不同的浏览器中兼容性不一样，需要进行更多的测试</p>

<h3 id="lovehate">牢记“LoVe/HAte”（爱恨）连接规则</h3>
<p>在为连接元素指定伪类时，注意以下顺序：<code>link</code>、<code>visited</code>、<code>hover</code>和<code>active</code>，任何其他的声明顺序都可能会导致问题。若还要考虑<code>:focus</code>伪类，则规则修改为LVHFA</p>

<h3 id="troubled">牢记“TRouBLED”（麻烦的）边框简写顺序</h3>
<p><code>boder</code>、<code>margin</code>、<code>padding</code>的顺序都是按照时钟的顺序，<code>top</code>，<code>right</code>，<code>bottom</code>，<code>left</code>。</p>

<h3 id="section-5">为非零值表明单位</h3>
<p>除了line-height以外，我们需要为非零的值标上单位</p>

<h3 id="section-6">测试不同的字体大小</h3>
<p>高级浏览器会允许用户调整字体大小，所以需要调整字体大小来进行更多的测试</p>

<h3 id="htmlcss">HTML和CSS中统一大小写</h3>

<h3 id="section-7">测试时使用嵌入样式，发布时再改为外部输入</h3>
<p>在测试时将样式嵌入到HTML代码中，可避免许多因浏览器缓存导致的不正常现象。对于较老的浏览器，这一点很重要。但是在发布前，记得将他们改为<code>@import</code>或<code>&lt;link&gt;</code>引入</p>

<h3 id="section-8">用明显的边框辅助调试布局</h3>
<p>通过类似<code>div {border: 1px solid #f00}</code>之类的全局规则可以帮助检查很多细微的布局差错</p>

<h3 id="section-9">指定图片路径是不要使用单引号</h3>
<p>设置背景图片时不需要使用引号。如果使用单引号，苹果机上的IE无法正确加载图像，所以要么使用双引号，要么不用引号</p>

<h3 id="anchor">若使用了锚点（anchor），那么在为超链接应用样式要格外小心</h3>

<h3 id="section-10">不要未雨绸缪的链接至作为“占位符”的空样式表</h3>
<p>这样会加长页面的加载时间</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/09/csszengarden-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 去哪儿笔试题之我答 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/08/qunar-interview.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>题目来自： <a href="http://www.itmian4.com/forum.php?mod=forumdisplay&amp;fid=44">IT面试论坛</a></p>

<p>之前想报去哪儿的实习，去参加参加笔试，结果因为填报的时间太晚了，没去成。今天全国统一笔试放出来了笔试题，说实话让我现场写基本上都写不出来…深刻感到了自己实力的不足，在这里借助浏览器内部的调试工具试着写了写，把握一下细节，也算是一种积累了</p>

<h2 id="section">第一题</h2>
<p>###题目
输入一个有序数组和一个数，若在数组中返回索引，若不在返回应该插入的索引</p>

<h3 id="section-1">想法</h3>
<p>没啥好想的，经典二分题</p>

<h3 id="section-2">实现</h3>
<p>因为好久没摸java了，所以写了个JavaScript版本的：
<code>javascript
var getPosInArray = function(arr, ele) {
    if (Object.prototype.toString.apply(arr) !== '[object Array]') {
        throw Error("The first param must be an array!!!");
    }
    if (typeof ele !== "number") {
        throw Error("The second param must be a number!!!");
    }
    var left = 0,
        right = arr.length - 1,
        middle;
    for (; left &lt;= right;) {
        middle = left + Math.floor((right - left) / 2);
        if (arr[middle] === ele) {
            return middle;
        } else if (arr[middle] &gt; ele) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return left;
};
</code>
java的也是类似的</p>

<h2 id="section-3">第二题</h2>
<p>###题目
给定一个随机数组，数组可能包含数组（也就是说数组元素可能为数组）。要求用js实现一个函数，返回该数组中所有元素，重复的要求去掉。例如：数组[2,3,[4,6,[3,8]],12,10]，返回结果为：[2,3,4,6,8,12,10]</p>

<h3 id="section-4">想法</h3>
<p>数组中的数组，很容易想到的一种方式就是新建一个结果数组，通过递归遍历将不同的值插入到结果数组中，JavaScript中查询结果数组中是否已有某值的时候可以用<code>arr.indexOf(ele) === -1</code>来确定，同时注意一下类型检测，使用<code>Object.prototype.toString.apply(rawArray) === '[object Array]'</code>来进行数组的检测，用<code>typeof</code>来检测基础类型</p>

<h3 id="section-5">实现</h3>
<p>这道题是前端题，自然是JavaScript：
<code>javascript
var getUniEle = function(rawArr) {
    if (Object.prototype.toString.apply(rawArr) !== '[object Array]') {
        throw Error("The param must be an array!!!");
    }
    var result = [],
        process = function(arr) {
            var i,
                m;
            for (i = 0, m = arr.length; i &lt; m; i++) {
                if (typeof arr[i] === 'number' &amp;&amp; result.indexOf(arr[i]) === -1) {
                    result.push(arr[i]);
                } else if (Object.prototype.toString.apply(arr[i]) === '[object Array]') {
                    processCurArray(arr[i]);
                } else {
                    throw Error("Any element must be an array or a number!!!");
                }
            }
        };
    process(rawArr);
    return result;
};
</code></p>

<h2 id="section-6">第三题</h2>
<p>###题目
这个题和腾讯2014校园招聘前端题目是一样的。
给定一个URL字符串，要求用js实现一个函数，返回该URL的域名、请求路径、参数和hash值、
例如：URL：<code>http://www.qunar.com/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code>
返回结果为：
<code>javascript
{
    host: "www.qunar.com",
    path: "plane/queryPlane.html",
    query: {
        "startTime": "xxxxx",
        "endTime": "xxxxx"
    },
    hash: "tags"
}
</code>
注明：xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</p>

<h3 id="section-7">想法</h3>
<p>解析url这个题目很常见，容易想到通过正则表达式提取，但是我就栽在这种常见的题目上了，正则怎么写都不对，跪了</p>

<p>首先要了解一个常规的url分为哪些内容，一个包含所有内容的url大致上长这样：<code>scheme://host:port/path?query#fragment</code>，其中：
* scheme: 通信协议，如http，https，ftp等
* host：主机（域名或者是IP地址）
* port：端口
* path：请求的路径
* query：请求所发送的数据
* fragment：片段，用于指向网页中的片段</p>

<p>需要知道其中哪些是可能被省略的，最简单的url只有主机，比如skinlayer.com，其他都是可选的。在正则匹配的时候需要使用<code>()?</code>来进行可选时的匹配</p>

<p>比如如下的url就比较完整：<code>http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code></p>

<ul>
  <li>
    <p>将url拆分，首先匹配scheme，scheme前面都是字母，然后是<code>://</code>，所以可以写出这样的正则:<code>(?:(\w+)\:\/\/)?</code>，这里用了非捕获性匹配<code>(?:)</code>，匹配到上面的<code>http://</code>部分，但由于非捕获性分组的存在，仅仅捕获了<code>http</code></p>
  </li>
  <li>
    <p>然后匹配主机部分，主机部分不可省略，同时其可能是字母，数字，小数点，下划线，所以可以写出这样的正则：<code>([\w\d]+(?:\.[\w\d]+)*)</code>，匹配并捕获到上面的<code>www.qunar.com</code>部分</p>
  </li>
  <li>
    <p>然后匹配端口，同样是可选，格式为<code>:dd</code>，所以可以写出正则：<code>(?:\:[\d]+)?</code>，匹配到<code>:8080</code>部分，捕获<code>8080</code></p>
  </li>
  <li>
    <p>然后匹配路径，从之前匹配到之后的?或者#（如果没有query部分，就可能直接碰到#），都是path部分，因此通过排除这两个字符的方式来写正则<code>(?:\/([^?#]+))?</code>，匹配到<code>/plane/queryPlane.html</code>，捕获<code>plane/queryPlane.html</code></p>
  </li>
  <li>
    <p>接着就是query这个大头了，我们先把里面这一部分抠出来，留在以后再进行详细的处理转换为对象，这里可以看到到#之前都是这个部分<code>(?:\?([^#]*))?</code>，匹配到<code>?startTime=xxxx&amp;endTime=xxxxx</code>，捕获<code>startTime=xxxx&amp;endTime=xxxxx</code></p>
  </li>
  <li>
    <p>最后捕获一些fragment就行了，很好弄，#后面所有的字符都是这一部分<code>(?:#(.*))?</code></p>
  </li>
</ul>

<p>最后再加上起始和结束就可以生成完整的正则表达式了：
<code>javascript
var reg = /^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/;
</code>
相当长，说实话，如果让我笔试写肯定跪逼了</p>

<p>然后运用在url字符串上：
<code>javascript
var regResult = url.match(/^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/);
//["http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags", "http", "www.qunar.com", "8080", "plane/queryPlane.html", "startTime=xxxx&amp;endTime=xxxxx", "tags"]
</code>
生成的数组各个元素基本上就是我们要的了，除了query部分，对query部分做一下单独的处理，首先利用正则表达式将所有的键值对字符串取出来放在一个数组中：
<code>javascript
var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);
</code>
这个正则由于可能匹配多次，所以用到了全局匹配</p>

<p>然后将所有的键值对字符串进行分割，分割成键和值插入到结果中就行了，这里分割使用了<code>String.split()</code>方法：
<code>javascript
result.query = {};
if (rawParams) {
    for (var i = rawParams.length; i--;) {
        tmp = rawParams[i].split("=");
        result.query[tmp[0]] = unescape(tmp[1]);
    }
}
</code></p>

<p>需要注意题目上有一句话：<code>xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</code>，所以这里需要使用unescape来进行解码</p>

<p>最后完整的代码如下：
```javascript
var parseUrl = function(url) {
    if (typeof url !== “string”) {
        throw Error(“The param is not a string!!!”);
    }
    if (url === “”){
        throw Error(“The param is an empty string!!!”);
    }
    var regResult = url.match(/^(?:(\w+):\/\/)?([\w\d]+(?:.[\w]+)<em>)(?::(\d+))?(?:\/([^?#]+))?(?:\?([^#]</em>))?(?:#(.*))?$/);
    var result = {
        url: regResult[0],
        scheme: regResult[1],
        host: regResult[2],
        port: regResult[3],
        path: regResult[4],
        query: regResult[5],
        fragment: regResult[6]
    };</p>

<pre><code>if (typeof result.query !== "undefined") {
    var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);
    var tmp;
    result.query = {};
    if (rawParams) {
        for (var i = rawParams.length; i--;) {
            tmp = rawParams[i].split("=");
            result.query[tmp[0]] = unescape(tmp[1]);
        }
    }
}
return result; }; ``` 由于加了非字符串以及空字符串的检测，基本上能解析所有的情况了
</code></pre>

<h2 id="section-8">总结</h2>
<p>这三题都是看似简单（解题思路很容易想到），但实际上实现起来很在乎细节。正则这个东西说实话在纸上写很难保证正确，基本上都是边调试边写，看来要笔试好还有很长的路要走</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/08/qunar-interview.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 去哪儿笔试题之我答 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/08/qunar-interview.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>题目来自： <a href="http://www.itmian4.com/forum.php?mod=forumdisplay&amp;fid=44">IT面试论坛</a></p>

<p>之前想报去哪儿的实习，去参加参加笔试，结果因为填报的时间太晚了，没去成。今天全国统一笔试放出来了笔试题，说实话让我现场写基本上都写不出来…深刻感到了自己实力的不足，在这里借助浏览器内部的调试工具试着写了写，把握一下细节，也算是一种积累了</p>

<h2 id="section">第一题</h2>
<p>###题目
输入一个有序数组和一个数，若在数组中返回索引，若不在返回应该插入的索引</p>

<h3 id="section-1">想法</h3>
<p>没啥好想的，经典二分题</p>

<h3 id="section-2">实现</h3>
<p>因为好久没摸java了，所以写了个JavaScript版本的：
<code>javascript
var getPosInArray = function(arr, ele) {
    if (Object.prototype.toString.apply(arr) !== '[object Array]') {
        throw Error("The first param must be an array!!!");
    }
    if (typeof ele !== "number") {
        throw Error("The second param must be a number!!!");
    }
    var left = 0,
        right = arr.length - 1,
        middle;
    for (; left &lt;= right;) {
        middle = left + Math.floor((right - left) / 2);
        if (arr[middle] === ele) {
            return middle;
        } else if (arr[middle] &gt; ele) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return left;
};
</code>
java的也是类似的</p>

<h2 id="section-3">第二题</h2>
<p>###题目
给定一个随机数组，数组可能包含数组（也就是说数组元素可能为数组）。要求用js实现一个函数，返回该数组中所有元素，重复的要求去掉。例如：数组[2,3,[4,6,[3,8]],12,10]，返回结果为：[2,3,4,6,8,12,10]</p>

<h3 id="section-4">想法</h3>
<p>数组中的数组，很容易想到的一种方式就是新建一个结果数组，通过递归遍历将不同的值插入到结果数组中，JavaScript中查询结果数组中是否已有某值的时候可以用<code>arr.indexOf(ele) === -1</code>来确定，同时注意一下类型检测，使用<code>Object.prototype.toString.apply(rawArray) === '[object Array]'</code>来进行数组的检测，用<code>typeof</code>来检测基础类型</p>

<h3 id="section-5">实现</h3>
<p>这道题是前端题，自然是JavaScript：
<code>javascript
var getUniEle = function(rawArr) {
    if (Object.prototype.toString.apply(rawArr) !== '[object Array]') {
        throw Error("The param must be an array!!!");
    }
    var result = [],
        process = function(arr) {
            var i,
                m;
            for (i = 0, m = arr.length; i &lt; m; i++) {
                if (typeof arr[i] === 'number' &amp;&amp; result.indexOf(arr[i]) === -1) {
                    result.push(arr[i]);
                } else if (Object.prototype.toString.apply(arr[i]) === '[object Array]') {
                    processCurArray(arr[i]);
                } else {
                    throw Error("Any element must be an array or a number!!!");
                }
            }
        };
    process(rawArr);
    return result;
};
</code></p>

<h2 id="section-6">第三题</h2>
<p>###题目
这个题和腾讯2014校园招聘前端题目是一样的。
给定一个URL字符串，要求用js实现一个函数，返回该URL的域名、请求路径、参数和hash值、
例如：URL：<code>http://www.qunar.com/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code>
返回结果为：
<code>javascript
{
    host: "www.qunar.com",
    path: "plane/queryPlane.html",
    query: {
        "startTime": "xxxxx",
        "endTime": "xxxxx"
    },
    hash: "tags"
}
</code>
注明：xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</p>

<h3 id="section-7">想法</h3>
<p>解析url这个题目很常见，容易想到通过正则表达式提取，但是我就栽在这种常见的题目上了，正则怎么写都不对，跪了</p>

<p>首先要了解一个常规的url分为哪些内容，一个包含所有内容的url大致上长这样：<code>scheme://host:port/path?query#fragment</code>，其中：
* scheme: 通信协议，如http，https，ftp等
* host：主机（域名或者是IP地址）
* port：端口
* path：请求的路径
* query：请求所发送的数据
* fragment：片段，用于指向网页中的片段</p>

<p>需要知道其中哪些是可能被省略的，最简单的url只有主机，比如skinlayer.com，其他都是可选的。在正则匹配的时候需要使用<code>()?</code>来进行可选时的匹配</p>

<p>比如如下的url就比较完整：<code>http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags</code></p>

<ul>
  <li>
    <p>将url拆分，首先匹配scheme，scheme前面都是字母，然后是<code>://</code>，所以可以写出这样的正则:<code>(?:(\w+)\:\/\/)?</code>，这里用了非捕获性匹配<code>(?:)</code>，匹配到上面的<code>http://</code>部分，但由于非捕获性分组的存在，仅仅捕获了<code>http</code></p>
  </li>
  <li>
    <p>然后匹配主机部分，主机部分不可省略，同时其可能是字母，数字，小数点，下划线，所以可以写出这样的正则：<code>([\w\d]+(?:\.[\w\d]+)*)</code>，匹配并捕获到上面的<code>www.qunar.com</code>部分</p>
  </li>
  <li>
    <p>然后匹配端口，同样是可选，格式为<code>:dd</code>，所以可以写出正则：<code>(?:\:[\d]+)?</code>，匹配到<code>:8080</code>部分，捕获<code>8080</code></p>
  </li>
  <li>
    <p>然后匹配路径，从之前匹配到之后的?或者#（如果没有query部分，就可能直接碰到#），都是path部分，因此通过排除这两个字符的方式来写正则<code>(?:\/([^?#]+))?</code>，匹配到<code>/plane/queryPlane.html</code>，捕获<code>plane/queryPlane.html</code></p>
  </li>
  <li>
    <p>接着就是query这个大头了，我们先把里面这一部分抠出来，留在以后再进行详细的处理转换为对象，这里可以看到到#之前都是这个部分<code>(?:\?([^#]*))?</code>，匹配到<code>?startTime=xxxx&amp;endTime=xxxxx</code>，捕获<code>startTime=xxxx&amp;endTime=xxxxx</code></p>
  </li>
  <li>
    <p>最后捕获一些fragment就行了，很好弄，#后面所有的字符都是这一部分<code>(?:#(.*))?</code></p>
  </li>
</ul>

<p>最后再加上起始和结束就可以生成完整的正则表达式了：
<code>javascript
var reg = /^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/;
</code>
相当长，说实话，如果让我笔试写肯定跪逼了</p>

<p>然后运用在url字符串上：
<code>javascript
var regResult = url.match(/^(?:(\w+)\:\/\/)?([\w\d]+(?:\.[\w]+)*)(?:\:(\d+))?(?:\/([^?#]+))?(?:\?([^#]*))?(?:#(.*))?$/);
//["http://www.qunar.com:8080/plane/queryPlane.html?startTime=xxxx&amp;endTime=xxxxx#tags", "http", "www.qunar.com", "8080", "plane/queryPlane.html", "startTime=xxxx&amp;endTime=xxxxx", "tags"]
</code>
生成的数组各个元素基本上就是我们要的了，除了query部分，对query部分做一下单独的处理，首先利用正则表达式将所有的键值对字符串取出来放在一个数组中：
<code>javascript
var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);
</code>
这个正则由于可能匹配多次，所以用到了全局匹配</p>

<p>然后将所有的键值对字符串进行分割，分割成键和值插入到结果中就行了，这里分割使用了<code>String.split()</code>方法：
<code>javascript
result.query = {};
if (rawParams) {
    for (var i = rawParams.length; i--;) {
        tmp = rawParams[i].split("=");
        result.query[tmp[0]] = unescape(tmp[1]);
    }
}
</code></p>

<p>需要注意题目上有一句话：<code>xxxx为url编码后的字符串，设计函数是肯定要求把它解码过来！</code>，所以这里需要使用unescape来进行解码</p>

<p>最后完整的代码如下：
```javascript
var parseUrl = function(url) {
    if (typeof url !== “string”) {
        throw Error(“The param is not a string!!!”);
    }
    if (url === “”){
        throw Error(“The param is an empty string!!!”);
    }
    var regResult = url.match(/^(?:(\w+):\/\/)?([\w\d]+(?:.[\w]+)<em>)(?::(\d+))?(?:\/([^?#]+))?(?:\?([^#]</em>))?(?:#(.*))?$/);
    var result = {
        url: regResult[0],
        scheme: regResult[1],
        host: regResult[2],
        port: regResult[3],
        path: regResult[4],
        query: regResult[5],
        fragment: regResult[6]
    };</p>

<pre><code>if (typeof result.query !== "undefined") {
    var rawParams = result.query.match(/([^=&amp;]+)=([^&amp;=]+)/g);
    var tmp;
    result.query = {};
    if (rawParams) {
        for (var i = rawParams.length; i--;) {
            tmp = rawParams[i].split("=");
            result.query[tmp[0]] = unescape(tmp[1]);
        }
    }
}
return result; }; ``` 由于加了非字符串以及空字符串的检测，基本上能解析所有的情况了
</code></pre>

<h2 id="section-8">总结</h2>
<p>这三题都是看似简单（解题思路很容易想到），但实际上实现起来很在乎细节。正则这个东西说实话在纸上写很难保证正确，基本上都是边调试边写，看来要笔试好还有很长的路要走</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/08/qunar-interview.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——文字排布 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/08/csszengarden-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">字体排印学基础知识</h2>
<p>###字体格式
字体格式指的是字样表现出的粗细、宽度和姿态等特征
###字体粗细
字体粗细指文字笔画的宽度</p>

<p>CSS中对应属性为<code>font-wight</code>。有些字体并没有粗细适中的字样，因而他们不能提供和CSS中等同的粗细划分。一般只依赖两种设置： <code>normal</code>和<code>bold</code>
* <code>normal</code>： 常规字体显示，和weight为400等价
* <code>bold</code>： 一般对应于700的weight值，少数字体为600
* 数字：范围100-900
* <code>bolder</code>：比继承的值更粗，如果继承值已经达到最高值900，则不变
* <code>lighter</code>：比继承值更细，如果继承值为100，那么计算所得的值还是100
* <code>inherit</code>：粗细与父元素一致</p>

<h3 id="section-1">字体宽度</h3>
<p>字体宽度指字符的宽度。紧缩字体会显得更为狭窄，而扩张字体则显得宽大</p>

<p>CSS中对应属性是<code>font-stretch</code>,不过这个属性浏览器支持很不好。目前只有ff9+和ie9+支持</p>

<h3 id="section-2">字体姿态</h3>
<p>字体姿态就是字体的倾斜程度</p>

<p>CSS中对应属性为<code>font-style</code>: 
* <code>italic</code>：一种在常规字体基础上做过特殊处理的变体，一般带有手写风格
* <code>oblique</code>：直接由浏览器作倾斜处理后的版本</p>

<h3 id="section-3">字体对比度</h3>
<p>字体对比度指字形中粗的部分与细的部分之间的差异程度。不同字体的对比度相差很大</p>

<p>serif字体即衬线字体，sans-serif字体则为非衬线字体，衬线字体在笔画本来必要的形状之外，在笔画起始端、末端和关键节点处会有多出来的形状用于装饰。而非衬线字体则没有这些装饰，表现较为圆滑。通常做法中，圆滑、缺乏粗细对比的sans serif字体被用作标题用字，而Serif字体常用作正文字体。不过这种传统在当今的Web时代受到很大争议</p>

<h3 id="section-4">字体色深</h3>
<p>字体色深就是指文字的深浅程度。字体色深不完全依赖于字体本身，还有很多其他的影响因素（字距调整、字间距、行间距、字体色相等等）</p>

<hr />
<p>##对比
###色相和对比度的选择
色相和对比度选择关系到设计的一致性，直接影响作品的可读性</p>

<p>传统的文字设计理论认为提高前景和背景的色相对比，会大大提高文本的可读性</p>

<p>低对比度的字体会造成视觉不便人士阅读困难</p>

<h3 id="section-5">字号对比和字体颜色</h3>
<p>使用不同大小的字体可以增加文字区块间的对比</p>

<h3 id="section-6">字号对比和粗细</h3>
<p>可以使用字号和粗细的变化来增加对比度</p>

<hr />
<p>##字体选择
###限制
所有站点文字都依赖与用户本地安装的字体。但是我们几乎无法在Windows、OS X和Unix/Linux中找到共有的字体。</p>

<h3 id="section-7">通用字体族</h3>
<p>serif： 有明显的装饰钩，所以在字母笔画的结尾处大都能看到细小的衬钩</p>

<p>sans serif： 没有装饰钩</p>

<p>monospace：买个字母拥有相同的宽度，这类字体在现实代码时特别有用</p>

<p>cursive： 模仿手写风格，通常用于标题</p>

<p>fantasy： 装饰用字体，多数用于标题，但这个字族拥有太多的字体，无法统一，所以很少有人会在正式的站点设计中使用它们</p>

<h3 id="css">CSS中的字体</h3>
<p>使用<code>font-family</code>来去确定使用的字体族</p>

<p>需要明确一个x-height的概念，x-height定义为去除高出部分和低出部分后的高度，而通常就是小写的x字母的高度。拥有相同x-height的字体往往具有较好的相似性。而x-height也影响到了字体的显示。在CSS中，<code>font-size</code>对所有字体的作用都是相同的，因而如果使用了一中x-height比较大的字体，用户看起来这个字体就会显得比其他字体略小一些</p>

<hr />
<p>##字体大小的变化
###字体大小
由于网页中大号字体的显示效果较差，设计师往往倾向于使用小号的字。而小号的字也意味着同样的空间可以容纳更多的内容。但这让很多读者无法适应</p>

<h3 id="section-8">浏览器控制</h3>
<p>很多浏览器都支持改变字体的大小</p>

<h3 id="section-9">绝对单位和相对单位</h3>
<p>CSS中，绝对单位指可以预先确定单位长度的度量单位。这里包括<code>cm</code>、<code>in</code>、<code>pt</code>等</p>

<p>而相对单位包括<code>%</code>、<code>em</code>、<code>larger</code>和<code>smaller</code>等。这是一种可变的尺寸。如果使用相对单位意味着会有一个默认的基值。</p>

<p>CSS中有一些描述字体大小的关键字，比如<code>xx-small</code>、<code>medium</code>、<code>x-large</code>等，他们是绝对单位，但是实际显示大小却不是那么精确</p>

<h3 id="px">px像素</h3>
<p>根据CSS定义，px实际上是一个相对单位。因为就算相同分辨率的设备屏幕大小也不相同。有的设备屏幕较小，但分辨率高，导致1px很小，几乎无法分辨。在IE中，px被当做绝对单位来处理的。</p>

<p>浏览器的默认字体大小是16px</p>

<h2 id="section-10">合理设置字体大小</h2>
<p>在使用百分比的方式能够避免很多舍入的误差，所以对body元素应用了百分比单位后，我们就可以为其余元素使用em值。同时需要注意的是，不要将文字大小设置在1em以下</p>

<hr />
<p>##文字排布
###视觉行为
在设计网页时，需要遵循人们的阅读方式进行页面布局。排版的主流理论认为人类视觉会自然地偏向页面的左上角，也就是所谓的视觉中心区。之后实现可以流畅的向右移动，或是转向新的一行，这样和逐渐趋近于页面底端。在这个过程中，视线会将页面的地段作为最终的停靠点</p>

<h3 id="section-11">引导视线</h3>
<p>视线被吸引的现象被形象的比喻为“引力”。将重要的站点标志放在视觉中心区，而把文字等其他元素至于页面下部形成停靠点的设计规则非常合理，而视线从右方转向左侧时形成的这点通常也是较易被浏览者关注的地方</p>

<hr />
<p>##避免产生理解上的问题
###标题文字
标题文字用来指明段落的主要内容，关于处理标题，有如下建议：
* 标题中使用的颜色必须是整个设计中较为强势的颜色
* 标题的色彩必须鲜明。在标题中亮色所带来的影响不如暗色。越是接近黑色的标题，越是能对浏览者产生强的冲击力
* 越是重要的标题，越是需要带有强烈冲击力的色彩
* 略为紧缩的字体更能凸现标题。设计师建议使用正常字体70%-90%宽的标题文字
* 字体对比可以帮助增强标题效果
* 标题长度应该有所限制
* 避免在标题中使用句号</p>

<h3 id="section-12">正文字体</h3>
<p>正文字体是页面文字的主体部分，关于正文布局，有如下建议：
* 保持一行在60个字符以内
* 避免每行字数过少
* 较短的段落在快捷的网络时代更适合迅速传达重要信息
* 如果确实需要发布长篇文字，应当尽力让段落保持小巧。并且将长段落分割为节并加以标题，这样才能更好地引导读者
* 不要让段落之间的距离过大
* 避免在正文中使用鲜艳的色彩。唯一的色彩变化应该就在正文的链接上</p>

<h3 id="section-13">重要文字</h3>
<p>重要文字指的是侧栏、引用和说明部分的文字，有如下建议：
* 重要文字的目的是引起读者的注意，可以应用鲜艳的色彩
* 重要文字应当使用短行，且只能有很少的行数
* 重要文字不应当阻断正文，而应当增强正文的效果
* 文字能为插图提供上下文，起到帮助读者阅读的作用</p>

<hr />
<p>##文本样式
有是有需要对单个字符进行调整，CSS有很多属性能够达到类似的效果
###font-varient
这个属性唯一的作用就是将文字用略小的大写字母表示
###text-transform
这个属性提供了更精确的字符大小写控制，有如下值：
* <code>capitalize</code>：每个单词首字母大写
* <code>uppercase</code>：所有字母大写
* <code>lowercase</code>：所有字母小写
* <code>none</code>：正常
###text-decoration
文本装饰，常用的有如下值：
* <code>none</code>： 没有装饰，在没有理由使用其他选项时，none是最好的选择
* <code>underline</code>： 下划线，仅仅在链接中使用下划线
* <code>overline</code>：上划线，仅仅在数学中表示平均值时候用到，其他时候很少会用
* <code>line-through</code>： 贯穿线，仅用于表示已经不再相关、非事实或无效的文字，这些文字可能很快会背其他文字替代，理想的用法是用于那些需要被改写的部分
* <code>blink</code>： 闪烁，已被废弃</p>

<hr />
<p>##间距样式
CSS提供了很多控制间距的属性
###line-height
用于控制行间距，该属性可被设置为绝对数值、相对大小、长度或百分比，还有inherit</p>

<p><code>line-height</code>不需要单位，1.2和1.2em和120%是同义的</p>

<h3 id="letter-spacing">letter-spacing</h3>
<p>可以控制字符间距，可将其设为normal或一个长度值。不应当为大段的文字设置字符间距。最好只在标题和小段文字中使用<code>letter-spacing</code></p>

<h3 id="word-spacing">word-spacing</h3>
<p>用于调整单词的间距，<code>text-align</code>和<code>white-space</code>都会影响到浏览器对<code>word-spacing</code>的处理</p>

<h3 id="text-align">text-align</h3>
<p>用于对齐文字，可选值为<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>。建议使用传统的right-align和left-align方式对齐正文。居中对齐仅仅用于标题、引用等小块文字，不要将其用于大段文字中</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/08/csszengarden-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——文字排布 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/08/csszengarden-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">字体排印学基础知识</h2>
<p>###字体格式
字体格式指的是字样表现出的粗细、宽度和姿态等特征
###字体粗细
字体粗细指文字笔画的宽度</p>

<p>CSS中对应属性为<code>font-wight</code>。有些字体并没有粗细适中的字样，因而他们不能提供和CSS中等同的粗细划分。一般只依赖两种设置： <code>normal</code>和<code>bold</code>
* <code>normal</code>： 常规字体显示，和weight为400等价
* <code>bold</code>： 一般对应于700的weight值，少数字体为600
* 数字：范围100-900
* <code>bolder</code>：比继承的值更粗，如果继承值已经达到最高值900，则不变
* <code>lighter</code>：比继承值更细，如果继承值为100，那么计算所得的值还是100
* <code>inherit</code>：粗细与父元素一致</p>

<h3 id="section-1">字体宽度</h3>
<p>字体宽度指字符的宽度。紧缩字体会显得更为狭窄，而扩张字体则显得宽大</p>

<p>CSS中对应属性是<code>font-stretch</code>,不过这个属性浏览器支持很不好。目前只有ff9+和ie9+支持</p>

<h3 id="section-2">字体姿态</h3>
<p>字体姿态就是字体的倾斜程度</p>

<p>CSS中对应属性为<code>font-style</code>: 
* <code>italic</code>：一种在常规字体基础上做过特殊处理的变体，一般带有手写风格
* <code>oblique</code>：直接由浏览器作倾斜处理后的版本</p>

<h3 id="section-3">字体对比度</h3>
<p>字体对比度指字形中粗的部分与细的部分之间的差异程度。不同字体的对比度相差很大</p>

<p>serif字体即衬线字体，sans-serif字体则为非衬线字体，衬线字体在笔画本来必要的形状之外，在笔画起始端、末端和关键节点处会有多出来的形状用于装饰。而非衬线字体则没有这些装饰，表现较为圆滑。通常做法中，圆滑、缺乏粗细对比的sans serif字体被用作标题用字，而Serif字体常用作正文字体。不过这种传统在当今的Web时代受到很大争议</p>

<h3 id="section-4">字体色深</h3>
<p>字体色深就是指文字的深浅程度。字体色深不完全依赖于字体本身，还有很多其他的影响因素（字距调整、字间距、行间距、字体色相等等）</p>

<hr />
<p>##对比
###色相和对比度的选择
色相和对比度选择关系到设计的一致性，直接影响作品的可读性</p>

<p>传统的文字设计理论认为提高前景和背景的色相对比，会大大提高文本的可读性</p>

<p>低对比度的字体会造成视觉不便人士阅读困难</p>

<h3 id="section-5">字号对比和字体颜色</h3>
<p>使用不同大小的字体可以增加文字区块间的对比</p>

<h3 id="section-6">字号对比和粗细</h3>
<p>可以使用字号和粗细的变化来增加对比度</p>

<hr />
<p>##字体选择
###限制
所有站点文字都依赖与用户本地安装的字体。但是我们几乎无法在Windows、OS X和Unix/Linux中找到共有的字体。</p>

<h3 id="section-7">通用字体族</h3>
<p>serif： 有明显的装饰钩，所以在字母笔画的结尾处大都能看到细小的衬钩</p>

<p>sans serif： 没有装饰钩</p>

<p>monospace：买个字母拥有相同的宽度，这类字体在现实代码时特别有用</p>

<p>cursive： 模仿手写风格，通常用于标题</p>

<p>fantasy： 装饰用字体，多数用于标题，但这个字族拥有太多的字体，无法统一，所以很少有人会在正式的站点设计中使用它们</p>

<h3 id="css">CSS中的字体</h3>
<p>使用<code>font-family</code>来去确定使用的字体族</p>

<p>需要明确一个x-height的概念，x-height定义为去除高出部分和低出部分后的高度，而通常就是小写的x字母的高度。拥有相同x-height的字体往往具有较好的相似性。而x-height也影响到了字体的显示。在CSS中，<code>font-size</code>对所有字体的作用都是相同的，因而如果使用了一中x-height比较大的字体，用户看起来这个字体就会显得比其他字体略小一些</p>

<hr />
<p>##字体大小的变化
###字体大小
由于网页中大号字体的显示效果较差，设计师往往倾向于使用小号的字。而小号的字也意味着同样的空间可以容纳更多的内容。但这让很多读者无法适应</p>

<h3 id="section-8">浏览器控制</h3>
<p>很多浏览器都支持改变字体的大小</p>

<h3 id="section-9">绝对单位和相对单位</h3>
<p>CSS中，绝对单位指可以预先确定单位长度的度量单位。这里包括<code>cm</code>、<code>in</code>、<code>pt</code>等</p>

<p>而相对单位包括<code>%</code>、<code>em</code>、<code>larger</code>和<code>smaller</code>等。这是一种可变的尺寸。如果使用相对单位意味着会有一个默认的基值。</p>

<p>CSS中有一些描述字体大小的关键字，比如<code>xx-small</code>、<code>medium</code>、<code>x-large</code>等，他们是绝对单位，但是实际显示大小却不是那么精确</p>

<h3 id="px">px像素</h3>
<p>根据CSS定义，px实际上是一个相对单位。因为就算相同分辨率的设备屏幕大小也不相同。有的设备屏幕较小，但分辨率高，导致1px很小，几乎无法分辨。在IE中，px被当做绝对单位来处理的。</p>

<p>浏览器的默认字体大小是16px</p>

<h2 id="section-10">合理设置字体大小</h2>
<p>在使用百分比的方式能够避免很多舍入的误差，所以对body元素应用了百分比单位后，我们就可以为其余元素使用em值。同时需要注意的是，不要将文字大小设置在1em以下</p>

<hr />
<p>##文字排布
###视觉行为
在设计网页时，需要遵循人们的阅读方式进行页面布局。排版的主流理论认为人类视觉会自然地偏向页面的左上角，也就是所谓的视觉中心区。之后实现可以流畅的向右移动，或是转向新的一行，这样和逐渐趋近于页面底端。在这个过程中，视线会将页面的地段作为最终的停靠点</p>

<h3 id="section-11">引导视线</h3>
<p>视线被吸引的现象被形象的比喻为“引力”。将重要的站点标志放在视觉中心区，而把文字等其他元素至于页面下部形成停靠点的设计规则非常合理，而视线从右方转向左侧时形成的这点通常也是较易被浏览者关注的地方</p>

<hr />
<p>##避免产生理解上的问题
###标题文字
标题文字用来指明段落的主要内容，关于处理标题，有如下建议：
* 标题中使用的颜色必须是整个设计中较为强势的颜色
* 标题的色彩必须鲜明。在标题中亮色所带来的影响不如暗色。越是接近黑色的标题，越是能对浏览者产生强的冲击力
* 越是重要的标题，越是需要带有强烈冲击力的色彩
* 略为紧缩的字体更能凸现标题。设计师建议使用正常字体70%-90%宽的标题文字
* 字体对比可以帮助增强标题效果
* 标题长度应该有所限制
* 避免在标题中使用句号</p>

<h3 id="section-12">正文字体</h3>
<p>正文字体是页面文字的主体部分，关于正文布局，有如下建议：
* 保持一行在60个字符以内
* 避免每行字数过少
* 较短的段落在快捷的网络时代更适合迅速传达重要信息
* 如果确实需要发布长篇文字，应当尽力让段落保持小巧。并且将长段落分割为节并加以标题，这样才能更好地引导读者
* 不要让段落之间的距离过大
* 避免在正文中使用鲜艳的色彩。唯一的色彩变化应该就在正文的链接上</p>

<h3 id="section-13">重要文字</h3>
<p>重要文字指的是侧栏、引用和说明部分的文字，有如下建议：
* 重要文字的目的是引起读者的注意，可以应用鲜艳的色彩
* 重要文字应当使用短行，且只能有很少的行数
* 重要文字不应当阻断正文，而应当增强正文的效果
* 文字能为插图提供上下文，起到帮助读者阅读的作用</p>

<hr />
<p>##文本样式
有是有需要对单个字符进行调整，CSS有很多属性能够达到类似的效果
###font-varient
这个属性唯一的作用就是将文字用略小的大写字母表示
###text-transform
这个属性提供了更精确的字符大小写控制，有如下值：
* <code>capitalize</code>：每个单词首字母大写
* <code>uppercase</code>：所有字母大写
* <code>lowercase</code>：所有字母小写
* <code>none</code>：正常
###text-decoration
文本装饰，常用的有如下值：
* <code>none</code>： 没有装饰，在没有理由使用其他选项时，none是最好的选择
* <code>underline</code>： 下划线，仅仅在链接中使用下划线
* <code>overline</code>：上划线，仅仅在数学中表示平均值时候用到，其他时候很少会用
* <code>line-through</code>： 贯穿线，仅用于表示已经不再相关、非事实或无效的文字，这些文字可能很快会背其他文字替代，理想的用法是用于那些需要被改写的部分
* <code>blink</code>： 闪烁，已被废弃</p>

<hr />
<p>##间距样式
CSS提供了很多控制间距的属性
###line-height
用于控制行间距，该属性可被设置为绝对数值、相对大小、长度或百分比，还有inherit</p>

<p><code>line-height</code>不需要单位，1.2和1.2em和120%是同义的</p>

<h3 id="letter-spacing">letter-spacing</h3>
<p>可以控制字符间距，可将其设为normal或一个长度值。不应当为大段的文字设置字符间距。最好只在标题和小段文字中使用<code>letter-spacing</code></p>

<h3 id="word-spacing">word-spacing</h3>
<p>用于调整单词的间距，<code>text-align</code>和<code>white-space</code>都会影响到浏览器对<code>word-spacing</code>的处理</p>

<h3 id="text-align">text-align</h3>
<p>用于对齐文字，可选值为<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>。建议使用传统的right-align和left-align方式对齐正文。居中对齐仅仅用于标题、引用等小块文字，不要将其用于大段文字中</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/08/csszengarden-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——图像 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/08/csszengarden-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">优化的重要性</h2>
<p>###客户端
网速的限制导致较大的文件需要更长的等待时间，降低用户体验
###服务端
高流量的站点通常都有很多用户同时访问，每个用户耗费的带宽越多，总的带宽需求就越大</p>

<hr />
<p>##图像格式基础
常用的图像格式有三种，GIF、JPEG和PNG。这三种格式都支持压缩。选择合适的图像文件格式也就是在透明支持、色深和压缩比率三者之间取舍</p>

<h3 id="section-1">图像格式</h3>
<p>每个图片文件格式都有自己的色彩模型、表示形式、压缩方案以及透明度效果支持等特性。需要了解不同图像的优劣之处，根据实际需求做出合理的选择。</p>

<h3 id="section-2">无损压缩和有损压缩</h3>
<p>无损压缩将保留原图像的所有细节，有损压缩会对细节有所取舍，以换取更小的文件。二者都有自己适用的地方</p>

<h3 id="section-3">色深</h3>
<p>色深是指某种给图像格式包含的颜色的多少。用位计量，更高的色申表示能包含更多的颜色种类</p>

<hr />
<p>##GIF
###适用范围
GIF使用一中叫做LZW的无损压缩格式，非常适合带有大块相同颜色区域的图像。单色插图、文本、色块等文件非常适合存为此格式。
###色深和压缩
GIF最多只能支持256种颜色，如果超出范围，颜色信息将会丢失。通过颜色索引来实现无损压缩，若颜色超过256种，会变成有损压缩
###透明度
GIF支持1位的透明度，即某个像素要么完全透明，要么完全不透明，没有任何中间值
###其他
GIF支持基于帧的简单动画以及隔行加载技术，但这两者会增加文件大小</p>

<hr />
<p>##JPEG
###适用范围
适合色彩、细节丰富的图像，比如照片
###色深和压缩
JPEG有24位色深，支持有损压缩且可以设置压缩等级。压缩比很大的JPEG图像将高度失真，并引发一种叫非自然痕迹的小块像素缺陷问题
###透明度
不支持任何形式的透明度
###其他
最新的“渐进JPEG”版本能够和GIF一样实现隔行加载，且已被大多数浏览器所支持</p>

<hr />
<p>##PNG
###适用范围
由于其两种色深模式，理论上可以用于任何图像。但实际上最好还是用GIF和JPEG，前者用于带有大块相同颜色区域的图像，后者用于照片等色彩、细节丰富的图像。但PNG本身的256级透明度使得在无法预知图像在Web页面中所处区域的背景颜色时，PNG将会非常实用
###色深和压缩
提供了两种色深模式，24位和8位。24位色深可以保证完全无损的压缩，8位色深的PNG使用类似GIF的颜色索引，同样设置项，很多时候PNG压缩的文件要比GIF更小
###透明度
支持256级透明度
###其他
老版Windows上的IE浏览器（IE6）无法正确呈现PNG的透明度设置</p>

<hr />
<p>##优化技巧
最好的方式是从较低品质（即较高压缩比）的图像开始，逐步提高品质，直到对图像质量满意为止
###GIF优化
从最低的颜色级别开始（8种），逐步提高颜色数目，直至可以接受，如果256种颜色还是不能满意，那么就需要考虑用JPEG代替GIF了</p>

<p>还有一些设定能偶影响到GIF格式文件的大小，例如抖动技术（在一块相同颜色区域添加另一种像素点， 这个技术可以用于模拟出一些本部在文件颜色索引中的颜色）
###JPEG
优化JPEG相对简单，将原始图像保存为JPEG时，可以从较低的图像品质等级开始，逐步增加，直至可以接受
###PNG
优化8位PNG图像的步骤与优化GIF完全一致。24位PNG图像的优化无需关注，因为其压缩防止固化在文件格式中，无法更改</p>

<hr />
<p>##图像替换技术
很多时候需要隐去原本文字，取而代之是一副图像。
###图像替换的目的
通过CSS将元素中的文本隐藏，然后运用背景显示图像
###图像替换的责任
没有任何提示或帮助，计算机无法认出或读取图像中包含的文字。如果使用<code>display: none</code>，Google能够读取到隐藏的文本，但有些屏幕阅读器不能。这导致视觉不便用户不能够获取图像传递的信息。
###Leahy和Langridge的方案
如下HTML结构：
<code>html
&lt;h1 id="header"&gt;这是一个标题&lt;/h1&gt;
</code></p>

<p>通过添加CSS且不改变HTML文档结构的方式来替换，CSS如下：
<code>css
#header {
    padding: 25px 0 0 0;
    overflow: hidden;
    background-image: url(back.gif) no-repeat;
    height: 0px !important;
    height /**/:25px;
}
</code>
这种方式的原理是，由于background会在padding block中进行显示，所以先将height设为0以隐藏content block，padding设为背景图片的高度，这样background中定义的图片就能在padding中正常显示</p>

<p>这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题，同时需要hack</p>

<h3 id="rundle">Rundle的方案</h3>
<p>使用负数的text-indent属性方法，将文本推到屏幕的左边缘外，CSS如下：
<code>css
#header {
    text-indent: -5000px;
    background: url(back.gif) no-repeat;
    height: 25px;
}
</code>
这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题</p>

<h3 id="levin">Levin的方案</h3>
<p>通过将文本放在span外，并设置span覆盖住文本，HTML如下：
<code>html
&lt;h1 id="header"&gt;这是一个标题&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
</code>
CSS代码如下：
```css
#header {
    position: relative;
    margin: 0px;
    padding: 0px;
    height: 25px;
    width: 300px;
    overflow: hidden;
}</p>

<h1 id="header-span-">header span {</h1>
<pre><code>display: block;
position: absolute;
top: 0;
left: 0;
z-index: 1;
background-image: url(back.gif) no-repeat; } ```
</code></pre>

<p>这样就算禁用了图像，空白部分依旧可访问。但这种情况下无法使用透明图像，同时HTML和CSS代码都很冗长</p>

<hr />
<p>##图像使用技巧
###图像的大小和尺寸
在保证足够质量的前提下，图像文件的大小应该尽可能地降低
###减少图像数量
图像数量的增加，会导致浏览器的请求增加，所以在使用图像时，尽量做到以下几点：
* 尽可能用文本样式替代图像
* 只把刘图像中为实现预期效果所必须的部分
* 使用细条图像填充背景
* 尽可能地重复使用图像
* 合理的选用图像和颜色
* 若能不适用图像，那么就不要使用
* 将图像合并，使用sprite技术</p>

<hr />
<p>##图像细节
###理解细节
设计师的主要职责之一就是仔细观察生活中的细节，以便在作品中充分的重现环境。这就意味着必须全面理解细节，而不仅仅停留在能够看到的水平上
###表现真实感
创建真实感不一定必须用照片
* 要特别注意图形边缘的效果。事实上，边缘来自于线条、光影、正负空间之间的交汇融合，而正是这种融合才让我们体会到线条的感觉
* 注意形状，大多数物体都是由若干种形状组合而来
* 图像的材质能够为物体带来真实感
* 深度可以表现出额外维度的感觉，即使在二维环境中也是如此
* 重力模拟同样重要</p>

<p>在二维设计描述三维物体时，参考如下建议：
* 封闭区域是由颜色和材质组成
* 物体的体积是由长宽高组成
* 体积感是这些视觉元素组合的结果，由此营造出了真实感</p>

<h3 id="section-4">处理层次</h3>
<p>层次表示环境的分层状态
* 层次之间的线条、空间和大小都要有区别
* 层与层之间仍然是一个整体，以某种方式保持着联系
* 层与层之间的过度要自然
* 作品中总是要包含焦点或终点
* 作品中绝对不能缺少重力感</p>

<h3 id="section-5">其他</h3>
<p>在处理环境中非真实存在的元素时，应根据环境对其进行模拟，保持风格高度统一</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/08/csszengarden-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——图像 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/08/csszengarden-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">优化的重要性</h2>
<p>###客户端
网速的限制导致较大的文件需要更长的等待时间，降低用户体验
###服务端
高流量的站点通常都有很多用户同时访问，每个用户耗费的带宽越多，总的带宽需求就越大</p>

<hr />
<p>##图像格式基础
常用的图像格式有三种，GIF、JPEG和PNG。这三种格式都支持压缩。选择合适的图像文件格式也就是在透明支持、色深和压缩比率三者之间取舍</p>

<h3 id="section-1">图像格式</h3>
<p>每个图片文件格式都有自己的色彩模型、表示形式、压缩方案以及透明度效果支持等特性。需要了解不同图像的优劣之处，根据实际需求做出合理的选择。</p>

<h3 id="section-2">无损压缩和有损压缩</h3>
<p>无损压缩将保留原图像的所有细节，有损压缩会对细节有所取舍，以换取更小的文件。二者都有自己适用的地方</p>

<h3 id="section-3">色深</h3>
<p>色深是指某种给图像格式包含的颜色的多少。用位计量，更高的色申表示能包含更多的颜色种类</p>

<hr />
<p>##GIF
###适用范围
GIF使用一中叫做LZW的无损压缩格式，非常适合带有大块相同颜色区域的图像。单色插图、文本、色块等文件非常适合存为此格式。
###色深和压缩
GIF最多只能支持256种颜色，如果超出范围，颜色信息将会丢失。通过颜色索引来实现无损压缩，若颜色超过256种，会变成有损压缩
###透明度
GIF支持1位的透明度，即某个像素要么完全透明，要么完全不透明，没有任何中间值
###其他
GIF支持基于帧的简单动画以及隔行加载技术，但这两者会增加文件大小</p>

<hr />
<p>##JPEG
###适用范围
适合色彩、细节丰富的图像，比如照片
###色深和压缩
JPEG有24位色深，支持有损压缩且可以设置压缩等级。压缩比很大的JPEG图像将高度失真，并引发一种叫非自然痕迹的小块像素缺陷问题
###透明度
不支持任何形式的透明度
###其他
最新的“渐进JPEG”版本能够和GIF一样实现隔行加载，且已被大多数浏览器所支持</p>

<hr />
<p>##PNG
###适用范围
由于其两种色深模式，理论上可以用于任何图像。但实际上最好还是用GIF和JPEG，前者用于带有大块相同颜色区域的图像，后者用于照片等色彩、细节丰富的图像。但PNG本身的256级透明度使得在无法预知图像在Web页面中所处区域的背景颜色时，PNG将会非常实用
###色深和压缩
提供了两种色深模式，24位和8位。24位色深可以保证完全无损的压缩，8位色深的PNG使用类似GIF的颜色索引，同样设置项，很多时候PNG压缩的文件要比GIF更小
###透明度
支持256级透明度
###其他
老版Windows上的IE浏览器（IE6）无法正确呈现PNG的透明度设置</p>

<hr />
<p>##优化技巧
最好的方式是从较低品质（即较高压缩比）的图像开始，逐步提高品质，直到对图像质量满意为止
###GIF优化
从最低的颜色级别开始（8种），逐步提高颜色数目，直至可以接受，如果256种颜色还是不能满意，那么就需要考虑用JPEG代替GIF了</p>

<p>还有一些设定能偶影响到GIF格式文件的大小，例如抖动技术（在一块相同颜色区域添加另一种像素点， 这个技术可以用于模拟出一些本部在文件颜色索引中的颜色）
###JPEG
优化JPEG相对简单，将原始图像保存为JPEG时，可以从较低的图像品质等级开始，逐步增加，直至可以接受
###PNG
优化8位PNG图像的步骤与优化GIF完全一致。24位PNG图像的优化无需关注，因为其压缩防止固化在文件格式中，无法更改</p>

<hr />
<p>##图像替换技术
很多时候需要隐去原本文字，取而代之是一副图像。
###图像替换的目的
通过CSS将元素中的文本隐藏，然后运用背景显示图像
###图像替换的责任
没有任何提示或帮助，计算机无法认出或读取图像中包含的文字。如果使用<code>display: none</code>，Google能够读取到隐藏的文本，但有些屏幕阅读器不能。这导致视觉不便用户不能够获取图像传递的信息。
###Leahy和Langridge的方案
如下HTML结构：
<code>html
&lt;h1 id="header"&gt;这是一个标题&lt;/h1&gt;
</code></p>

<p>通过添加CSS且不改变HTML文档结构的方式来替换，CSS如下：
<code>css
#header {
    padding: 25px 0 0 0;
    overflow: hidden;
    background-image: url(back.gif) no-repeat;
    height: 0px !important;
    height /**/:25px;
}
</code>
这种方式的原理是，由于background会在padding block中进行显示，所以先将height设为0以隐藏content block，padding设为背景图片的高度，这样background中定义的图片就能在padding中正常显示</p>

<p>这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题，同时需要hack</p>

<h3 id="rundle">Rundle的方案</h3>
<p>使用负数的text-indent属性方法，将文本推到屏幕的左边缘外，CSS如下：
<code>css
#header {
    text-indent: -5000px;
    background: url(back.gif) no-repeat;
    height: 25px;
}
</code>
这种方式并没有解决浏览器禁用图像后空白页面的可访问性问题</p>

<h3 id="levin">Levin的方案</h3>
<p>通过将文本放在span外，并设置span覆盖住文本，HTML如下：
<code>html
&lt;h1 id="header"&gt;这是一个标题&lt;span&gt;&lt;/span&gt;&lt;/h1&gt;
</code>
CSS代码如下：
```css
#header {
    position: relative;
    margin: 0px;
    padding: 0px;
    height: 25px;
    width: 300px;
    overflow: hidden;
}</p>

<h1 id="header-span-">header span {</h1>
<pre><code>display: block;
position: absolute;
top: 0;
left: 0;
z-index: 1;
background-image: url(back.gif) no-repeat; } ```
</code></pre>

<p>这样就算禁用了图像，空白部分依旧可访问。但这种情况下无法使用透明图像，同时HTML和CSS代码都很冗长</p>

<hr />
<p>##图像使用技巧
###图像的大小和尺寸
在保证足够质量的前提下，图像文件的大小应该尽可能地降低
###减少图像数量
图像数量的增加，会导致浏览器的请求增加，所以在使用图像时，尽量做到以下几点：
* 尽可能用文本样式替代图像
* 只把刘图像中为实现预期效果所必须的部分
* 使用细条图像填充背景
* 尽可能地重复使用图像
* 合理的选用图像和颜色
* 若能不适用图像，那么就不要使用
* 将图像合并，使用sprite技术</p>

<hr />
<p>##图像细节
###理解细节
设计师的主要职责之一就是仔细观察生活中的细节，以便在作品中充分的重现环境。这就意味着必须全面理解细节，而不仅仅停留在能够看到的水平上
###表现真实感
创建真实感不一定必须用照片
* 要特别注意图形边缘的效果。事实上，边缘来自于线条、光影、正负空间之间的交汇融合，而正是这种融合才让我们体会到线条的感觉
* 注意形状，大多数物体都是由若干种形状组合而来
* 图像的材质能够为物体带来真实感
* 深度可以表现出额外维度的感觉，即使在二维环境中也是如此
* 重力模拟同样重要</p>

<p>在二维设计描述三维物体时，参考如下建议：
* 封闭区域是由颜色和材质组成
* 物体的体积是由长宽高组成
* 体积感是这些视觉元素组合的结果，由此营造出了真实感</p>

<h3 id="section-4">处理层次</h3>
<p>层次表示环境的分层状态
* 层次之间的线条、空间和大小都要有区别
* 层与层之间仍然是一个整体，以某种方式保持着联系
* 层与层之间的过度要自然
* 作品中总是要包含焦点或终点
* 作品中绝对不能缺少重力感</p>

<h3 id="section-5">其他</h3>
<p>在处理环境中非真实存在的元素时，应根据环境对其进行模拟，保持风格高度统一</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/08/csszengarden-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 对比display布局（clearfix） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/07/display.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近在看面试题的时候看到很多次出现display的inline、block、inline-block的区别。在这里做一做实验，可以从margin、padding、border、width、height来区别</p>

<h2 id="display-block">display: block</h2>
<p>###典型元素
如<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>等等</p>

<h3 id="section">缺省宽度</h3>
<p>缺省宽度为其容器的100%</p>

<h3 id="section-1">换行</h3>
<p>前后均会换行</p>

<h3 id="section-2">设定盒子模型属性时</h3>
<p>设定<code>margin</code>、<code>padding</code>、<code>border</code>、<code>width</code>、<code>height</code>后都会根据设定进行相应显示
<code>css
.block {
    display: block;
    margin: 1em;
    padding: 1em;
    border: 1em solid transparent;
    width: 10em;
    height: 10em;
}
</code>
<img src="/img/display/1.png" alt="display: block时的盒子模型" /></p>

<p><img src="/img/display/2.png" alt="display: block时的z真正显示的盒子模型" /></p>

<h2 id="display-inline">display: inline</h2>
<p>###典型元素
如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等等</p>

<h3 id="section-3">缺省宽度</h3>
<p>宽度为内容宽度，且宽度不可变</p>

<h3 id="section-4">换行</h3>
<p>前后均不会换行</p>

<h3 id="section-5">设定盒子模型属性时</h3>
<p>设定<code>width</code>、<code>height</code>均不会起任何作用</p>

<p>设定<code>margin</code>时，仅有左右margin会起作用，上下margin无效</p>

<p>设定<code>padding</code>与<code>border</code>时，上下左右均有效，但不会影响布局（仅仅会拉大background，border显示）
<code>css
.inline {
    display: inline;
    width: 200em;
    height: 200em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}
</code>
<img src="/img/display/3.png" alt="display: inline时真正显示的盒子模型" /></p>

<p><img src="/img/display/4.png" alt="display: inline时的盒子模型" /></p>

<h2 id="display-inline-block">display: inline-block</h2>
<p>###典型元素
无</p>

<h3 id="section-6">缺省宽度</h3>
<p>缺省宽度为内容宽度，可以设置宽度</p>

<h3 id="section-7">换行</h3>
<p>前后均不会换行</p>

<h3 id="section-8">设定盒子模型属性时</h3>
<p>设定<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>时均会撑大元素，并且与<code>display:block</code>时一样显示，但前后不会换行
<code>css
.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}
</code>
<img src="/img/display/5.png" alt="display: inline-block时的实际显示的盒子模型" /></p>

<p><img src="/img/display/6.png" alt="display: inline-block时的盒子模型" /></p>

<h3 id="section-9">其他</h3>
<p>可以通过<code>verticle-align: middle</code>等属性来对文字与设定了<code>display:inline-block</code>来进行布局</p>

<p><code>css
.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
    vertical-align: middle;
}
</code>
<img src="/img/display/7.png" alt="Alt text" /></p>

<h3 id="section-10">浏览器兼容性</h3>
<p>兼容ie8+、ff26+、chrome31+、safari7+、opera19+，详见<a href="http://caniuse.com/#search=inline-block">caniuse.com</a></p>

<p>需要让老版IE兼容，可以通过如下方式：
<code>css
div {
    display: inline-block;/*触发块元素*/
    *display: inline;/*让块元素呈递为内联对象*/
    *zoom: 1;/*为内联对象触发块元素的layout*/
}
</code></p>

<h2 id="section-11">总结</h2>
<p>display的这三个常用属性还是有很多陷阱的，面试也经常会问，在这里做一个对比。其实display还有很多新增的table布局的属性，比如<code>display: table</code>,<code>display: table-cell</code>等等，也可以深入的去试验一下具体的效果。这里把三种对比放在jsfiddle上</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/KC3Xr/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/07/display.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 对比display布局（clearfix） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/07/display.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近在看面试题的时候看到很多次出现display的inline、block、inline-block的区别。在这里做一做实验，可以从margin、padding、border、width、height来区别</p>

<h2 id="display-block">display: block</h2>
<p>###典型元素
如<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;ul&gt;</code>等等</p>

<h3 id="section">缺省宽度</h3>
<p>缺省宽度为其容器的100%</p>

<h3 id="section-1">换行</h3>
<p>前后均会换行</p>

<h3 id="section-2">设定盒子模型属性时</h3>
<p>设定<code>margin</code>、<code>padding</code>、<code>border</code>、<code>width</code>、<code>height</code>后都会根据设定进行相应显示
<code>css
.block {
    display: block;
    margin: 1em;
    padding: 1em;
    border: 1em solid transparent;
    width: 10em;
    height: 10em;
}
</code>
<img src="/img/display/1.png" alt="display: block时的盒子模型" /></p>

<p><img src="/img/display/2.png" alt="display: block时的z真正显示的盒子模型" /></p>

<h2 id="display-inline">display: inline</h2>
<p>###典型元素
如<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等等</p>

<h3 id="section-3">缺省宽度</h3>
<p>宽度为内容宽度，且宽度不可变</p>

<h3 id="section-4">换行</h3>
<p>前后均不会换行</p>

<h3 id="section-5">设定盒子模型属性时</h3>
<p>设定<code>width</code>、<code>height</code>均不会起任何作用</p>

<p>设定<code>margin</code>时，仅有左右margin会起作用，上下margin无效</p>

<p>设定<code>padding</code>与<code>border</code>时，上下左右均有效，但不会影响布局（仅仅会拉大background，border显示）
<code>css
.inline {
    display: inline;
    width: 200em;
    height: 200em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}
</code>
<img src="/img/display/3.png" alt="display: inline时真正显示的盒子模型" /></p>

<p><img src="/img/display/4.png" alt="display: inline时的盒子模型" /></p>

<h2 id="display-inline-block">display: inline-block</h2>
<p>###典型元素
无</p>

<h3 id="section-6">缺省宽度</h3>
<p>缺省宽度为内容宽度，可以设置宽度</p>

<h3 id="section-7">换行</h3>
<p>前后均不会换行</p>

<h3 id="section-8">设定盒子模型属性时</h3>
<p>设定<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>border</code>时均会撑大元素，并且与<code>display:block</code>时一样显示，但前后不会换行
<code>css
.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
}
</code>
<img src="/img/display/5.png" alt="display: inline-block时的实际显示的盒子模型" /></p>

<p><img src="/img/display/6.png" alt="display: inline-block时的盒子模型" /></p>

<h3 id="section-9">其他</h3>
<p>可以通过<code>verticle-align: middle</code>等属性来对文字与设定了<code>display:inline-block</code>来进行布局</p>

<p><code>css
.inline-block {
    display: inline-block;
    width: 15em;
    height: 15em;
    margin: 1em;
    padding: 1em;
    border: 1em solid #FF8686;
    vertical-align: middle;
}
</code>
<img src="/img/display/7.png" alt="Alt text" /></p>

<h3 id="section-10">浏览器兼容性</h3>
<p>兼容ie8+、ff26+、chrome31+、safari7+、opera19+，详见<a href="http://caniuse.com/#search=inline-block">caniuse.com</a></p>

<p>需要让老版IE兼容，可以通过如下方式：
<code>css
div {
    display: inline-block;/*触发块元素*/
    *display: inline;/*让块元素呈递为内联对象*/
    *zoom: 1;/*为内联对象触发块元素的layout*/
}
</code></p>

<h2 id="section-11">总结</h2>
<p>display的这三个常用属性还是有很多陷阱的，面试也经常会问，在这里做一个对比。其实display还有很多新增的table布局的属性，比如<code>display: table</code>,<code>display: table-cell</code>等等，也可以深入的去试验一下具体的效果。这里把三种对比放在jsfiddle上</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/KC3Xr/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/07/display.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——正文布局 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/07/csszengarden-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">布局</h2>
<p>###绝对定位
元素使用绝对定位时，其将脱离原始文档流，不会对其旁边的元素带来任何影响</p>

<h3 id="section-1">浮动</h3>
<p>浮动布局的优势在于：浮动元素仍保留在文档流中其环绕的元素也都清楚它的位置</p>

<hr />
<p>##布局方法
###固定布局和流式布局
固定布局：页面有着固定的宽度，居左、居右对齐，或者居中。页面内容的宽度不会随着浏览器窗口的宽度变化而变化</p>

<p>流式布局：页面宽度用百分比指定，而不是某个固定的宽度。浏览器窗口大小变化时，页面宽度随之变化</p>

<p>流式布局设计避免了另一半页面的空白，显得更为平衡。但使用流式布局，无法精确控制行长、页面布局以及元素位置</p>

<hr />
<p>##水平居中方案
###自动margin水平居中
使用<code>margin: 0 auto</code>，使用时注意指定宽度，兼容ie6+</p>

<h3 id="text-align">使用text-align实现居中</h3>
<p>在body上设置<code>text-align: center</code>，这是一条hack，整整完全遵守标准的浏览器不会改变容器的位置，所以这条行不通</p>

<h3 id="margin">负margin</h3>
<p>先将元素通过如下代码右移屏幕宽度的50%：
<code>css
position: absolute;
left: 50%;
</code>
然后使用负margin左移元素宽度的50%:
<code>css
position: absolute;
left: 50%;
width: 1000px;
margin-left: -500px;
</code>
使用这种方式，需要将内边距、边框计算在容器宽度中</p>

<hr />
<p>##布局的灵感和法则
###用户界面设计
用户界面设计更加关注用户，其最主要的研究目的就是让开发者和工程师能够更好的满足用户的需求
* 了解浏览额面的用户
* 在页面和站点中给用户足够的导向
* 使用被人们熟知的象征符号
* 保证与功能现骨干的特性在页面中足够显眼
* 保证设计元素的一致性
* 了解页面中的关键元素
* 清楚的表达页面内容：通常来讲人类的注意力持续最多9秒钟，这段时间还是不能了解页面的主要内容，用户就会彻底放弃</p>

<h3 id="section-2">可用性</h3>
<p>可用性研究更加关注最终的用户体验，即用户如何与已经开发完成了的程序进行交互</p>

<p>可用性原则：
* 重要信息应放在显眼的位置
* 永远在title中给出页面的简单介绍
* 尽可能地保证页面中的导航链接有着一致的表现，同样也要确保有回到首页的链接
* 在大中型站点来说，最好提供搜索功能。搜索功能的位置要让用户直觉就能够发现
* 用缩进和偏移将栏中内容分开</p>

<hr />
<p>##灵感
建议新手去一些地点进行观察。如壮美、多彩、富有活力的大自然常常是灵感的发源地。另外一个灵感的发源地就是人的性格和外贸。人的外形总会在艺术中占有相当的地位。
###从印刷作品中找到灵感
###打破纵向布局的常规
考虑横向布局，但注意浏览器兼容性和实现</p>

<hr />
<p>##元素的位置以及带来的含义
如果将一张纸分为四个象限，西方文字布局的顺序是从左到右，从上至下。浏览者一般都会无意中按照这个顺序来区分四个象限内容的重要性</p>

<p>所以logo一般放在左上位置</p>

<p>在页面中，无需滚动即可看到的区域都是最重要的部分，将某个元素至于页面的右上角，意味着该元素的重要性略逊于左上角的元素，但仍然远高于页面其他元素</p>

<p>底部两个象限并不是那么重要</p>

<p>页面底部的常见用途就是放置一些非必要的内容，比如没有足够层次性的连接，指向本页或网站其他页面的导航等等。这些内容若是用户没有看到，也没有什么大不了的</p>

<hr />
<p>##网格布局
网格不过是一系列相交线分割出的大小一致且极具逻辑性的方框。若在布局中严格依照网格，元素的比例和间距将变得更为协调统一，虽然这可能让作品过于规整、缺乏创造性</p>

<p>根据需要，可以使用绝对定位（<code>position: absolute</code>）或是相对定位（<code>position: relative</code>）来打破网格的限制</p>

<hr />
<p>##内容溢出
大多数浏览器都支持缩放页面的文本字号，很多视力不佳的人很依赖这个功能。字号会进行放大（150%甚至更大），字号放大后可能会导致文本重叠问题，尤其是类似导航链接之类的小块文字区域容易受影响</p>

<p>最常见的两种内容溢出情况：
1. 绝对定位元素中内容过多
2. 浮动元素尺寸超过其可容纳区域</p>

<h3 id="section-3">浮动导致的内容溢出</h3>
<p>CSS引入浮动的本意是让文本能够环绕在其中内嵌的其他元素周围，而不是为了页面布局</p>

<p>浮动后可以使用清除浮动的的方式来让某一元素不再跟随在另一元素后面。清除浮动的方式有很多，这里就不一一列举了</p>

<h3 id="section-4">绝对定位导致的内容已出</h3>
<p>绝对定位中遇到的最多的问题就是垂直方向溢出。绝对定位元素不像浮动元素那样能够被“清除”</p>

<p>避免方法：
* 使用浮动替代绝对布局
* 在设计中尝试避免
* 通过<code>overflow: auto</code>或者<code>overflow: scroll</code>来让内容超出时出现滚动条
* 使用JavaScript脚本辅助
* 使用em作为长度单位而不是px（仅适用于增大字号导致的内容溢出）</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/07/csszengarden-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——正文布局 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/07/csszengarden-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">布局</h2>
<p>###绝对定位
元素使用绝对定位时，其将脱离原始文档流，不会对其旁边的元素带来任何影响</p>

<h3 id="section-1">浮动</h3>
<p>浮动布局的优势在于：浮动元素仍保留在文档流中其环绕的元素也都清楚它的位置</p>

<hr />
<p>##布局方法
###固定布局和流式布局
固定布局：页面有着固定的宽度，居左、居右对齐，或者居中。页面内容的宽度不会随着浏览器窗口的宽度变化而变化</p>

<p>流式布局：页面宽度用百分比指定，而不是某个固定的宽度。浏览器窗口大小变化时，页面宽度随之变化</p>

<p>流式布局设计避免了另一半页面的空白，显得更为平衡。但使用流式布局，无法精确控制行长、页面布局以及元素位置</p>

<hr />
<p>##水平居中方案
###自动margin水平居中
使用<code>margin: 0 auto</code>，使用时注意指定宽度，兼容ie6+</p>

<h3 id="text-align">使用text-align实现居中</h3>
<p>在body上设置<code>text-align: center</code>，这是一条hack，整整完全遵守标准的浏览器不会改变容器的位置，所以这条行不通</p>

<h3 id="margin">负margin</h3>
<p>先将元素通过如下代码右移屏幕宽度的50%：
<code>css
position: absolute;
left: 50%;
</code>
然后使用负margin左移元素宽度的50%:
<code>css
position: absolute;
left: 50%;
width: 1000px;
margin-left: -500px;
</code>
使用这种方式，需要将内边距、边框计算在容器宽度中</p>

<hr />
<p>##布局的灵感和法则
###用户界面设计
用户界面设计更加关注用户，其最主要的研究目的就是让开发者和工程师能够更好的满足用户的需求
* 了解浏览额面的用户
* 在页面和站点中给用户足够的导向
* 使用被人们熟知的象征符号
* 保证与功能现骨干的特性在页面中足够显眼
* 保证设计元素的一致性
* 了解页面中的关键元素
* 清楚的表达页面内容：通常来讲人类的注意力持续最多9秒钟，这段时间还是不能了解页面的主要内容，用户就会彻底放弃</p>

<h3 id="section-2">可用性</h3>
<p>可用性研究更加关注最终的用户体验，即用户如何与已经开发完成了的程序进行交互</p>

<p>可用性原则：
* 重要信息应放在显眼的位置
* 永远在title中给出页面的简单介绍
* 尽可能地保证页面中的导航链接有着一致的表现，同样也要确保有回到首页的链接
* 在大中型站点来说，最好提供搜索功能。搜索功能的位置要让用户直觉就能够发现
* 用缩进和偏移将栏中内容分开</p>

<hr />
<p>##灵感
建议新手去一些地点进行观察。如壮美、多彩、富有活力的大自然常常是灵感的发源地。另外一个灵感的发源地就是人的性格和外贸。人的外形总会在艺术中占有相当的地位。
###从印刷作品中找到灵感
###打破纵向布局的常规
考虑横向布局，但注意浏览器兼容性和实现</p>

<hr />
<p>##元素的位置以及带来的含义
如果将一张纸分为四个象限，西方文字布局的顺序是从左到右，从上至下。浏览者一般都会无意中按照这个顺序来区分四个象限内容的重要性</p>

<p>所以logo一般放在左上位置</p>

<p>在页面中，无需滚动即可看到的区域都是最重要的部分，将某个元素至于页面的右上角，意味着该元素的重要性略逊于左上角的元素，但仍然远高于页面其他元素</p>

<p>底部两个象限并不是那么重要</p>

<p>页面底部的常见用途就是放置一些非必要的内容，比如没有足够层次性的连接，指向本页或网站其他页面的导航等等。这些内容若是用户没有看到，也没有什么大不了的</p>

<hr />
<p>##网格布局
网格不过是一系列相交线分割出的大小一致且极具逻辑性的方框。若在布局中严格依照网格，元素的比例和间距将变得更为协调统一，虽然这可能让作品过于规整、缺乏创造性</p>

<p>根据需要，可以使用绝对定位（<code>position: absolute</code>）或是相对定位（<code>position: relative</code>）来打破网格的限制</p>

<hr />
<p>##内容溢出
大多数浏览器都支持缩放页面的文本字号，很多视力不佳的人很依赖这个功能。字号会进行放大（150%甚至更大），字号放大后可能会导致文本重叠问题，尤其是类似导航链接之类的小块文字区域容易受影响</p>

<p>最常见的两种内容溢出情况：
1. 绝对定位元素中内容过多
2. 浮动元素尺寸超过其可容纳区域</p>

<h3 id="section-3">浮动导致的内容溢出</h3>
<p>CSS引入浮动的本意是让文本能够环绕在其中内嵌的其他元素周围，而不是为了页面布局</p>

<p>浮动后可以使用清除浮动的的方式来让某一元素不再跟随在另一元素后面。清除浮动的方式有很多，这里就不一一列举了</p>

<h3 id="section-4">绝对定位导致的内容已出</h3>
<p>绝对定位中遇到的最多的问题就是垂直方向溢出。绝对定位元素不像浮动元素那样能够被“清除”</p>

<p>避免方法：
* 使用浮动替代绝对布局
* 在设计中尝试避免
* 通过<code>overflow: auto</code>或者<code>overflow: scroll</code>来让内容超出时出现滚动条
* 使用JavaScript脚本辅助
* 使用em作为长度单位而不是px（仅适用于增大字号导致的内容溢出）</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/07/csszengarden-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——设计 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/06/csszengarden-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">简洁的设计</h2>
<p>###排版样式
正文部分的文字按照比例来讲要远大于菜单部分的文字。合理地使用字号来暗示浏览者哪些区域重要，哪些不重要</p>

<h3 id="section-1">图标</h3>
<p>图标是一类简化的符号，用来表示某件物品或者某类概念，或者用来以抽象的图形化概念替代一段较长的文字描述</p>

<p>图标仅仅起到标号的作用，而不至于喧宾夺主地吸引或让浏览者转移视线</p>

<h3 id="section-2">分界线</h3>
<p>适当的使用线条能够在页面中定义区域的边界，给页面增加额外的维度，但不要过度使用</p>

<h3 id="section-3">外边距</h3>
<p>适当的左右外边距会让作品的正文部分不至于显得太局促。</p>

<p>文本需要一些呼吸的空间</p>

<hr />
<p>##统一和象征手法
###一致性
作品中用到的元素可能各不相同，但作品整体达到统一的已经却是最重要的
###借喻
借喻（用简单的设计元素表示复杂的图像或概念）是一种强大的设计方法，可以为为作品添加一些微妙的气氛并增加作品的深度
##光与影
###确定光源的位置
###保留阴影
* 阴影可以为页面增加丰富的视觉效果
* 投射出的阴影能让浏览者感觉到页面以及页面中的元素存在层次感
* 绘图软件中，阴影很容易实现</p>

<h3 id="section-4">需要注意</h3>
<ul>
  <li>注意阴影的深浅，深色的阴影代表物体与背景较近，而浅色的阴影表示物体与背景较远，更靠近观察者</li>
  <li>注意阴影的长宽，较为细小的阴影让人感觉物体与背景较近，宽大的阴影让物体看起来离背景较远</li>
  <li>确保光源的真实性，阴影的方向要保持统一以体现光源的一致性</li>
</ul>

<hr />
<p>##形状
###圆弧
与女性、阴柔关联，表示温暖、舒适、暧昧、爱情等
###三角形
让人联想到男性、阳刚，表达诸如强壮、攻击以及运动感等含义。</p>

<p>浏览者的目光通常会被吸引至处于支配地位的棱角所指方向。指向上方体现向上的趋势和攻击性，指向下方通常暗示出消极的意味
###方形
暗示力量和根基，看上去足够坚实稳重。给浏览者带来有序、逻辑、严密以及安全的感觉</p>

<hr />
<p>##空间
适当的空间可以将浏览者的目光引导至页面中的关键位置。空间还能够对文本和图像的过密产生一定的缓冲，让眼睛有休息的余地。大大提高内容的可读性，并给读者足够的思考内容的时间
###心理和社会意义
* 间隔空间和经济形势息息相关
* 使用间隔空间并不意味着这个位置什么都没有
* 间隔空间与特定地区的文化也有关系</p>

<h3 id="section-5">正空间和负空间</h3>
<p>正空间是指组成作品的对象所占据的空间，负空间则是指非作品对象部分（即背景）占据的空间。负空间起到定义正空间边界的作用</p>

<hr />
<p>##色彩
###清楚地表达信息
优秀的实际是了解如何恰当地使用色彩来进行交流，表达设计意图，加深浏览者印象。色彩和主题息息相关</p>

<h3 id="section-6">色彩和人类心理</h3>
<ul>
  <li>红色： 力量、活力、爱、激情、进攻、危险</li>
  <li>蓝色： 信任、保守、安全、清洁、悲伤、有序</li>
  <li>绿色： 大自然、健康、嫉妒、复苏</li>
  <li>橙色： 愉快、幸福</li>
  <li>黄色： 乐观、希望、冷静、懦弱</li>
  <li>紫色： 神秘</li>
  <li>褐色： 可靠、舒适、忍耐、大地</li>
  <li>灰色/银色： 智慧、未来、谦虚、悲哀、腐朽、高雅</li>
  <li>黑色： 力量、性、完善、神秘、恐惧、忧愁、死亡</li>
  <li>白色： 纯洁、干净、精确、清白、中性、不毛、死亡</li>
</ul>

<h3 id="section-7">色彩、文化和性别</h3>
<p>文化背景和性别差异都会扩展并复杂化颜色引发的心里联想</p>

<h3 id="css">CSS中的颜色</h3>
<p>系统颜色是在CSS 2.1中引入的一系列关键词，允许设计师是用浏览器计算机上的系统颜色配置如：
<code>css
color: WindowText
</code>
很多人仍然坚持使用“Web安全”的调色板。但目前主流的计算机都能够显示数百万种颜色，所以已经没有必要再受限于这个规定了</p>

<hr />
<p>##图案和材质
图案是指重复填充到指定区域内的某一种（也可能多于一种）小块视觉元素</p>

<p>材质并不一定必须要通过触觉才能感受，视觉也能够体现材质感</p>

<p>图案是体现材质感所必不可少的。通常情况下，图案都能够模拟出材质的效果。很多材质的元素都自然地由图案的自有重复而体现出来。</p>

<hr />
<p>##对比度
对比度差别可以用来区分不同的元素。若对比度太低，则元素会失去彼此的界限并混合在一起，文字也变得难以辨认。若对比度高，则将给浏览者压迫感，同样不会觉得舒适
###高对比度
高对比度让作品显得过于拥挤，有过度设计之嫌。</p>

<p>一般来讲，白底黑字原则在计算机屏幕上同样是达到最佳对比度的不二之选</p>

<p>黑暗房间中一个明亮的LCD屏幕将显得极为刺眼，在这种环境下，阅读任何纯白北京上的文字无疑都是对视力的巨大挑战</p>

<p>若将两种互补色，例如橙色和蓝色、红色和绿色相邻防止，那么将显出明显的边界以及强烈的对比效果。进而引发人不愉快的视觉上的紧张感</p>

<p>在更加暗淡的颜色背景村脱下偏暗的颜色也会变得明亮起来</p>

<h3 id="section-8">低对比度</h3>
<p>若作品的对比度过低，往往会给人带来压抑的感觉</p>

<p>若是降低线条与其背景之间的对比度，则能让其看上去变得更细一些</p>

<p>对比度低时，对于视力不好的浏览者来说，看清屏幕上的文字将会更加困难，从而降低可读性</p>

<h3 id="section-9">视觉障碍</h3>
<p>对于任何依赖颜色传递的信息，我们都应该提供如下方式中的至少一种来告知用户：蓝色且带有下划线的超链接、包含图标或文本的绿色按钮、带有实现边框的红色警告信息</p>

<hr />
<p>##引导视线
一个良好的作品应该能够引导读者的实现，让读者以合理的逻辑顺序逐一阅读内容中的重点，但同时又不会让读者觉察出来</p>

<p>大多数人会在左边或上边寻找导航条，所以把导航条放那吧</p>

<p>在页面中添加足够、适当的旁白能够为读者的眼镜提供一些休息的空间</p>

<hr />
<p>##CSS技巧
###减少使用table布局
* 表格布局会添加大量的标记（没必要的标记）
* 间隔图像（table布局中的常见技巧，通常是1*1大小的透明gif图，用来撑大表格等辅助布局），不必要地增加了页面的文件大小
* 图片通过img加入到页面中，增加了页面文件的大小，导致页面加载时间更长
* 各个页面必须统一的使用table布局，没给个页面都要包含类似的table和img，每次加载需要重绘，代价很大
* 降低可访问性，很多为障碍人士准备的屏幕浏览器无法正确理解table布局的页面</p>

<p>需要留意CSS布局呈现时的FOUC（无样式内容瞬间），通过把CSS放在文档前来解决（不要使用@import）</p>

<h3 id="section-10">图像</h3>
<p>若图像属于“内容”，而不是“样式”的一部分，应该使用img标签，否则应该使用background。通过将内容至于背景图像创建样式，能够：
* 减少页面文件的大小
* CSS会被缓存，大多数样式标记放在CSS中，浏览器不必每次都去服务器端获取页面样式，加快加载速度
* 可访问性增强
* 网站易于管理</p>

<p>使用图片时，使用png可以免去很多不必要的麻烦，它带有256级透明度能够完美的显示阴影效果</p>

<h3 id="section-11">外边距重叠</h3>
<p>外边距重叠是指，若两个上下毗邻且都定义了不为0的外边距值，同时有没有任何内边距、边框等设定，那么两个元素之间的距离将小于二者外边距的和。为元素添加1px的垂直内边距，就不会形成外边距重叠了（BFC也可）</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/06/csszengarden-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 《CSS禅意花园》读书笔记——设计 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/06/csszengarden-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">简洁的设计</h2>
<p>###排版样式
正文部分的文字按照比例来讲要远大于菜单部分的文字。合理地使用字号来暗示浏览者哪些区域重要，哪些不重要</p>

<h3 id="section-1">图标</h3>
<p>图标是一类简化的符号，用来表示某件物品或者某类概念，或者用来以抽象的图形化概念替代一段较长的文字描述</p>

<p>图标仅仅起到标号的作用，而不至于喧宾夺主地吸引或让浏览者转移视线</p>

<h3 id="section-2">分界线</h3>
<p>适当的使用线条能够在页面中定义区域的边界，给页面增加额外的维度，但不要过度使用</p>

<h3 id="section-3">外边距</h3>
<p>适当的左右外边距会让作品的正文部分不至于显得太局促。</p>

<p>文本需要一些呼吸的空间</p>

<hr />
<p>##统一和象征手法
###一致性
作品中用到的元素可能各不相同，但作品整体达到统一的已经却是最重要的
###借喻
借喻（用简单的设计元素表示复杂的图像或概念）是一种强大的设计方法，可以为为作品添加一些微妙的气氛并增加作品的深度
##光与影
###确定光源的位置
###保留阴影
* 阴影可以为页面增加丰富的视觉效果
* 投射出的阴影能让浏览者感觉到页面以及页面中的元素存在层次感
* 绘图软件中，阴影很容易实现</p>

<h3 id="section-4">需要注意</h3>
<ul>
  <li>注意阴影的深浅，深色的阴影代表物体与背景较近，而浅色的阴影表示物体与背景较远，更靠近观察者</li>
  <li>注意阴影的长宽，较为细小的阴影让人感觉物体与背景较近，宽大的阴影让物体看起来离背景较远</li>
  <li>确保光源的真实性，阴影的方向要保持统一以体现光源的一致性</li>
</ul>

<hr />
<p>##形状
###圆弧
与女性、阴柔关联，表示温暖、舒适、暧昧、爱情等
###三角形
让人联想到男性、阳刚，表达诸如强壮、攻击以及运动感等含义。</p>

<p>浏览者的目光通常会被吸引至处于支配地位的棱角所指方向。指向上方体现向上的趋势和攻击性，指向下方通常暗示出消极的意味
###方形
暗示力量和根基，看上去足够坚实稳重。给浏览者带来有序、逻辑、严密以及安全的感觉</p>

<hr />
<p>##空间
适当的空间可以将浏览者的目光引导至页面中的关键位置。空间还能够对文本和图像的过密产生一定的缓冲，让眼睛有休息的余地。大大提高内容的可读性，并给读者足够的思考内容的时间
###心理和社会意义
* 间隔空间和经济形势息息相关
* 使用间隔空间并不意味着这个位置什么都没有
* 间隔空间与特定地区的文化也有关系</p>

<h3 id="section-5">正空间和负空间</h3>
<p>正空间是指组成作品的对象所占据的空间，负空间则是指非作品对象部分（即背景）占据的空间。负空间起到定义正空间边界的作用</p>

<hr />
<p>##色彩
###清楚地表达信息
优秀的实际是了解如何恰当地使用色彩来进行交流，表达设计意图，加深浏览者印象。色彩和主题息息相关</p>

<h3 id="section-6">色彩和人类心理</h3>
<ul>
  <li>红色： 力量、活力、爱、激情、进攻、危险</li>
  <li>蓝色： 信任、保守、安全、清洁、悲伤、有序</li>
  <li>绿色： 大自然、健康、嫉妒、复苏</li>
  <li>橙色： 愉快、幸福</li>
  <li>黄色： 乐观、希望、冷静、懦弱</li>
  <li>紫色： 神秘</li>
  <li>褐色： 可靠、舒适、忍耐、大地</li>
  <li>灰色/银色： 智慧、未来、谦虚、悲哀、腐朽、高雅</li>
  <li>黑色： 力量、性、完善、神秘、恐惧、忧愁、死亡</li>
  <li>白色： 纯洁、干净、精确、清白、中性、不毛、死亡</li>
</ul>

<h3 id="section-7">色彩、文化和性别</h3>
<p>文化背景和性别差异都会扩展并复杂化颜色引发的心里联想</p>

<h3 id="css">CSS中的颜色</h3>
<p>系统颜色是在CSS 2.1中引入的一系列关键词，允许设计师是用浏览器计算机上的系统颜色配置如：
<code>css
color: WindowText
</code>
很多人仍然坚持使用“Web安全”的调色板。但目前主流的计算机都能够显示数百万种颜色，所以已经没有必要再受限于这个规定了</p>

<hr />
<p>##图案和材质
图案是指重复填充到指定区域内的某一种（也可能多于一种）小块视觉元素</p>

<p>材质并不一定必须要通过触觉才能感受，视觉也能够体现材质感</p>

<p>图案是体现材质感所必不可少的。通常情况下，图案都能够模拟出材质的效果。很多材质的元素都自然地由图案的自有重复而体现出来。</p>

<hr />
<p>##对比度
对比度差别可以用来区分不同的元素。若对比度太低，则元素会失去彼此的界限并混合在一起，文字也变得难以辨认。若对比度高，则将给浏览者压迫感，同样不会觉得舒适
###高对比度
高对比度让作品显得过于拥挤，有过度设计之嫌。</p>

<p>一般来讲，白底黑字原则在计算机屏幕上同样是达到最佳对比度的不二之选</p>

<p>黑暗房间中一个明亮的LCD屏幕将显得极为刺眼，在这种环境下，阅读任何纯白北京上的文字无疑都是对视力的巨大挑战</p>

<p>若将两种互补色，例如橙色和蓝色、红色和绿色相邻防止，那么将显出明显的边界以及强烈的对比效果。进而引发人不愉快的视觉上的紧张感</p>

<p>在更加暗淡的颜色背景村脱下偏暗的颜色也会变得明亮起来</p>

<h3 id="section-8">低对比度</h3>
<p>若作品的对比度过低，往往会给人带来压抑的感觉</p>

<p>若是降低线条与其背景之间的对比度，则能让其看上去变得更细一些</p>

<p>对比度低时，对于视力不好的浏览者来说，看清屏幕上的文字将会更加困难，从而降低可读性</p>

<h3 id="section-9">视觉障碍</h3>
<p>对于任何依赖颜色传递的信息，我们都应该提供如下方式中的至少一种来告知用户：蓝色且带有下划线的超链接、包含图标或文本的绿色按钮、带有实现边框的红色警告信息</p>

<hr />
<p>##引导视线
一个良好的作品应该能够引导读者的实现，让读者以合理的逻辑顺序逐一阅读内容中的重点，但同时又不会让读者觉察出来</p>

<p>大多数人会在左边或上边寻找导航条，所以把导航条放那吧</p>

<p>在页面中添加足够、适当的旁白能够为读者的眼镜提供一些休息的空间</p>

<hr />
<p>##CSS技巧
###减少使用table布局
* 表格布局会添加大量的标记（没必要的标记）
* 间隔图像（table布局中的常见技巧，通常是1*1大小的透明gif图，用来撑大表格等辅助布局），不必要地增加了页面的文件大小
* 图片通过img加入到页面中，增加了页面文件的大小，导致页面加载时间更长
* 各个页面必须统一的使用table布局，没给个页面都要包含类似的table和img，每次加载需要重绘，代价很大
* 降低可访问性，很多为障碍人士准备的屏幕浏览器无法正确理解table布局的页面</p>

<p>需要留意CSS布局呈现时的FOUC（无样式内容瞬间），通过把CSS放在文档前来解决（不要使用@import）</p>

<h3 id="section-10">图像</h3>
<p>若图像属于“内容”，而不是“样式”的一部分，应该使用img标签，否则应该使用background。通过将内容至于背景图像创建样式，能够：
* 减少页面文件的大小
* CSS会被缓存，大多数样式标记放在CSS中，浏览器不必每次都去服务器端获取页面样式，加快加载速度
* 可访问性增强
* 网站易于管理</p>

<p>使用图片时，使用png可以免去很多不必要的麻烦，它带有256级透明度能够完美的显示阴影效果</p>

<h3 id="section-11">外边距重叠</h3>
<p>外边距重叠是指，若两个上下毗邻且都定义了不为0的外边距值，同时有没有任何内边距、边框等设定，那么两个元素之间的距离将小于二者外边距的和。为元素添加1px的垂直内边距，就不会形成外边距重叠了（BFC也可）</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/06/csszengarden-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 博客换页面了 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/05/new-page.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>上一篇文章是2月28日，今天这篇3月5日才写。中间隔了这么久，两天一篇的计划又被抛弃了。得加紧赶上了。这段时间还是做了点事的，不过没有记录上。</p>

<h2 id="section">起因</h2>
<p>如果之前看过这个博客的人一定会发现，整个页面焕然一新了。之前用的是html5up-striped的模板。虽然浏览器兼容性很好，但无论是背景纹理的图片大小还是为了那兼容性所使用的响应式库的大小都让这个搭载在github上的博客肝颤（背景纹理两张分别为60k+，skelton的js有41k+还有50k+的CSS以及好几百K的字体…）。加载速度简直让我这种强迫症患者有种砸电脑的感觉。同时使用别人的代码，自己也不好修改，不好扩展，不好发挥。于是乎就决定自己写一个响应式的页面出来。这个页面就出来了。</p>

<h2 id="section-1">参考</h2>
<p>这个页面是参考了<a href="http://www.csszengarden.com/220//">CSS禅意花园的220号作品</a>。不过CSS文件并不是照搬他的，都是自己重写的（压缩后的大小8KB）。不过用了它的两个图片（都很小，2.79K+1.77K）。之前也是使用了禅意花园上的那种“文字配合mask-image”的形式，后来发现除了Chrome都不兼容（我勒个血槽，连FF都不兼容）于是乎就转而去网上寻找纹理。在一个非常不错的纹理网站<a href="http://subtlepatterns.com/">Subtle Patterns</a> 上找到了两个纹理，分别作为博客中的背景以及文章中代码块的背景（一个113B，一个128B，注意是B不是KB），简直爽歪歪。瞬间感觉之前的60K的背景纹理就是渣渣啊。于是乎就剩jQuery比较大了，但是jQuery可以放在CDN上，这里使用的是百度提供的CDN（速度杠杠的，400ms）。如果后续有时间，我会抛弃jQuery，重写博客中的JS部分，这样就更快了（其实压根就没有几行js代码）</p>

<h2 id="section-2">设计</h2>
<p>这个页面的设计也是<a href="http://lingyu.wang#/art/blog/2014/02/14/responsive-web-design/">响应式设计</a>的<a href="http://lingyu.wang#/art/blog/2014/02/25/design-strategies/">移动先行策略</a>的产物。贯彻其从小到大的方针。
###小视口出发
从小型视口出发（这里我定义的小型视口是宽度小于768px的视口，准确来说是48em，font-size为初始的16px，为什么呢，因为我的ipad mini竖屏分辨率是768…）。定义了一套布局，最上面是header，里面有主要导航条，下面是内容，再下面是一些其他链接（以后成为侧边栏），再下面是footer</p>

<p>于是乎格式就变成了html文档大概就会变成这个样子：
```html</p>
<body>
    <div class="wrapper">
        <header class="header">
            <div class="banner"></div>
            <nav></nav>
        
        </header>
        <div class="content">
            <article class="post">
                <header></header>
                <div class="main"></div>
                <a class="to-detail" href="#"></a>
                <div class="tags"></div>
            </article>
        </div>
        <aside class="aside">
            <section class="recent">
                <h3></h3>
                <div class="inner"></div>
            </section>
        </aside>
        <footer class="footer">
        </footer>
    </div>
</body>
<p>```
这里先用了几个语义化元素，header、nav、section、footer、article还有aside。另外我喜欢用一个wrapper包裹所有内容，方便以后有需要的时候布局</p>

<p>其中article的内容从上到下排布就好，所以我这里设定了<code>&lt;a class="to-detail" href="#"&gt;&lt;/a&gt;</code>为<code>display:block</code>，其他在结构上基本上保持了原样</p>

<p>小视口设备上的绝大部分内容都是很直观的显示的，也不用谈太多的布局，把一些基础的展现效果的css加进去就好，主要就是控制h1~h6的文字大小（上下margin），文字颜色，背景颜色等等</p>

<p>大致上达到的效果：</p>

<h3 id="section-3">中视口的扩展</h3>
<p>中视口设备基本上和小视口设备差不多，我这里只不过在aside里面的内容作了一些变化，同时在主页上拉出一个侧边栏用于显示“查看详细”按钮</p>

<p>这样就需要添加一些布局进去了，这里都采用了很简单的布局，基本上就是float+BFC，保证浮动元素与非浮动元素不重叠</p>

<p>于是乎简单的布局代码如下
```css
@media screen and (min-width: 48em) {
    .content .post .to-detail {width: 18%; overflow: hidden}
    .content .post .main {float:left;width: 80%; }
    .content .post .tags {clear:both}</p>

<pre><code>.aside section h3 {float:left; width: 30%;}
.aside section .inner {overflow: hidden;}
.aside section:after {content: ""; display: block; height: 0; visibility: hidden; clear: both; } } ``` 大致上说一下，设定了float的元素一般会与不设定float的元素重叠，但如果不设定float的元素触发了BFC，就不会了，于是乎这里使用```overflow:hidden```触发BFC，同时由于有浮动元素的存在，需要清除浮动，如果后面有元素，在后面元素上加上```clear:both```就可以了。如果后面没有元素，那就在父元素上加入一个```::after```伪元素，里面设定清除浮动，代码如上所示
</code></pre>

<p>这样中视口的布局效果就搞定了，还可以加上一些额外的效果，比如修改一下h1~h6的文字大小和margin，修改一下导航条内元素的间距之类的</p>

<h3 id="section-4">大视口的变革</h3>
<p>中视口和小视口终究还是一栏布局（中视口虽然拉出了一列仅显示“查看详细”按钮，但本质上还是一栏布局）。到了大视口（我这里定义的大视口是大于等于1024px，也就是64em的视口，为什么呢？因为我的ipadmini 横屏是1024px），边栏应该拉出来，放在屏幕的左边，内容在右边，同时footer应该还在最下面</p>

<p>还是用之前类似的方式，核心CSS如下：
<code>css
@media screen and (min-width: 64em) {
    .content {float:right;}
    .aside {overflow: hidden}
    .footer {clear:both}
}
</code>
这样布局修改就完成了，再加上一些CSS3的animation特效，齐活</p>

<h2 id="section-5">总结</h2>
<p>响应式页面设计还是很有意思的，逐步向上扩展，需要很明确的将各个部分划分成一块一块，方便日后响应式布局，新的页面虽然丑了点，但是还能看，有点小清新的感觉（笑），关键是加载的大小降低了很多。至于浏览器的兼容性问题，我只是兼容了比较主流的浏览器，没有兼容ie6-8这些坑货，不过无所谓了，能兼容ie9+，Chrome和Firefox、opera我就满足了，毕竟ie8压根就不支持CSS3的media queries</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/05/new-page.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 博客换页面了 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/05/new-page.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>上一篇文章是2月28日，今天这篇3月5日才写。中间隔了这么久，两天一篇的计划又被抛弃了。得加紧赶上了。这段时间还是做了点事的，不过没有记录上。</p>

<h2 id="section">起因</h2>
<p>如果之前看过这个博客的人一定会发现，整个页面焕然一新了。之前用的是html5up-striped的模板。虽然浏览器兼容性很好，但无论是背景纹理的图片大小还是为了那兼容性所使用的响应式库的大小都让这个搭载在github上的博客肝颤（背景纹理两张分别为60k+，skelton的js有41k+还有50k+的CSS以及好几百K的字体…）。加载速度简直让我这种强迫症患者有种砸电脑的感觉。同时使用别人的代码，自己也不好修改，不好扩展，不好发挥。于是乎就决定自己写一个响应式的页面出来。这个页面就出来了。</p>

<h2 id="section-1">参考</h2>
<p>这个页面是参考了<a href="http://www.csszengarden.com/220//">CSS禅意花园的220号作品</a>。不过CSS文件并不是照搬他的，都是自己重写的（压缩后的大小8KB）。不过用了它的两个图片（都很小，2.79K+1.77K）。之前也是使用了禅意花园上的那种“文字配合mask-image”的形式，后来发现除了Chrome都不兼容（我勒个血槽，连FF都不兼容）于是乎就转而去网上寻找纹理。在一个非常不错的纹理网站<a href="http://subtlepatterns.com/">Subtle Patterns</a> 上找到了两个纹理，分别作为博客中的背景以及文章中代码块的背景（一个113B，一个128B，注意是B不是KB），简直爽歪歪。瞬间感觉之前的60K的背景纹理就是渣渣啊。于是乎就剩jQuery比较大了，但是jQuery可以放在CDN上，这里使用的是百度提供的CDN（速度杠杠的，400ms）。如果后续有时间，我会抛弃jQuery，重写博客中的JS部分，这样就更快了（其实压根就没有几行js代码）</p>

<h2 id="section-2">设计</h2>
<p>这个页面的设计也是<a href="http://lingyu.wang#/art/blog/2014/02/14/responsive-web-design/">响应式设计</a>的<a href="http://lingyu.wang#/art/blog/2014/02/25/design-strategies/">移动先行策略</a>的产物。贯彻其从小到大的方针。
###小视口出发
从小型视口出发（这里我定义的小型视口是宽度小于768px的视口，准确来说是48em，font-size为初始的16px，为什么呢，因为我的ipad mini竖屏分辨率是768…）。定义了一套布局，最上面是header，里面有主要导航条，下面是内容，再下面是一些其他链接（以后成为侧边栏），再下面是footer</p>

<p>于是乎格式就变成了html文档大概就会变成这个样子：
```html</p>
<body>
    <div class="wrapper">
        <header class="header">
            <div class="banner"></div>
            <nav></nav>
        
        </header>
        <div class="content">
            <article class="post">
                <header></header>
                <div class="main"></div>
                <a class="to-detail" href="#"></a>
                <div class="tags"></div>
            </article>
        </div>
        <aside class="aside">
            <section class="recent">
                <h3></h3>
                <div class="inner"></div>
            </section>
        </aside>
        <footer class="footer">
        </footer>
    </div>
</body>
<p>```
这里先用了几个语义化元素，header、nav、section、footer、article还有aside。另外我喜欢用一个wrapper包裹所有内容，方便以后有需要的时候布局</p>

<p>其中article的内容从上到下排布就好，所以我这里设定了<code>&lt;a class="to-detail" href="#"&gt;&lt;/a&gt;</code>为<code>display:block</code>，其他在结构上基本上保持了原样</p>

<p>小视口设备上的绝大部分内容都是很直观的显示的，也不用谈太多的布局，把一些基础的展现效果的css加进去就好，主要就是控制h1~h6的文字大小（上下margin），文字颜色，背景颜色等等</p>

<p>大致上达到的效果：</p>

<h3 id="section-3">中视口的扩展</h3>
<p>中视口设备基本上和小视口设备差不多，我这里只不过在aside里面的内容作了一些变化，同时在主页上拉出一个侧边栏用于显示“查看详细”按钮</p>

<p>这样就需要添加一些布局进去了，这里都采用了很简单的布局，基本上就是float+BFC，保证浮动元素与非浮动元素不重叠</p>

<p>于是乎简单的布局代码如下
```css
@media screen and (min-width: 48em) {
    .content .post .to-detail {width: 18%; overflow: hidden}
    .content .post .main {float:left;width: 80%; }
    .content .post .tags {clear:both}</p>

<pre><code>.aside section h3 {float:left; width: 30%;}
.aside section .inner {overflow: hidden;}
.aside section:after {content: ""; display: block; height: 0; visibility: hidden; clear: both; } } ``` 大致上说一下，设定了float的元素一般会与不设定float的元素重叠，但如果不设定float的元素触发了BFC，就不会了，于是乎这里使用```overflow:hidden```触发BFC，同时由于有浮动元素的存在，需要清除浮动，如果后面有元素，在后面元素上加上```clear:both```就可以了。如果后面没有元素，那就在父元素上加入一个```::after```伪元素，里面设定清除浮动，代码如上所示
</code></pre>

<p>这样中视口的布局效果就搞定了，还可以加上一些额外的效果，比如修改一下h1~h6的文字大小和margin，修改一下导航条内元素的间距之类的</p>

<h3 id="section-4">大视口的变革</h3>
<p>中视口和小视口终究还是一栏布局（中视口虽然拉出了一列仅显示“查看详细”按钮，但本质上还是一栏布局）。到了大视口（我这里定义的大视口是大于等于1024px，也就是64em的视口，为什么呢？因为我的ipadmini 横屏是1024px），边栏应该拉出来，放在屏幕的左边，内容在右边，同时footer应该还在最下面</p>

<p>还是用之前类似的方式，核心CSS如下：
<code>css
@media screen and (min-width: 64em) {
    .content {float:right;}
    .aside {overflow: hidden}
    .footer {clear:both}
}
</code>
这样布局修改就完成了，再加上一些CSS3的animation特效，齐活</p>

<h2 id="section-5">总结</h2>
<p>响应式页面设计还是很有意思的，逐步向上扩展，需要很明确的将各个部分划分成一块一块，方便日后响应式布局，新的页面虽然丑了点，但是还能看，有点小清新的感觉（笑），关键是加载的大小降低了很多。至于浏览器的兼容性问题，我只是兼容了比较主流的浏览器，没有兼容ie6-8这些坑货，不过无所谓了，能兼容ie9+，Chrome和Firefox、opera我就满足了，毕竟ie8压根就不支持CSS3的media queries</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/05/new-page.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 网页布局实例 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/03/05/layouts.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>最近看前端相关面试题，看到很多关于CSS布局的面试题。于是乎自己实现了几个常用的布局，这里记录一下实现。所有的布局均已上传到github，命名为<a href="https://github.com/LingyuCoder/sky_layouts">sky_layouts项目</a></p>

<p>所有的页面都引入了一段CSS reset的代码，用于屏蔽不同浏览器之间的差异
<code>css
/* Style reset 消除浏览器默认样式 */
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,blockquote,th,td,p{margin:0;padding:0}input,button,select,textarea{outline:none}li{list-style:none}img{border:none}textarea{resize:none}body{color:#666;background:#fff;word-break:break-all;word-wrap:break-word;text-align:center}body,input,textarea{font-size:12px;font-family:\5b8b\4f53,Verdana,Arial}a{color:#305999;text-decoration:none;outline:none}a:hover{color:#090}.wrap{width:1000px;margin:0 auto;text-align:left;position:relative}/*clearfix*/.clearfix:after,.wrap:after{content:".";display:block;height:0;clear:both;visibility:hidden}.clearfix,.wrap{*+height:1%}
</code></p>

<p>另外这里所有的header区、footer区的高度都为100px，侧边栏都是300px</p>

<h2 id="section-1">单栏水平居中布局（首尾全屏）</h2>
<p>这种布局很常见，比如新浪微博的布局就是这样，header宽度为全屏，内容区宽度固定</p>

<p>这种布局有三部分构成:
* header区，g-hd
* main区，g-mn
* footer区，g-ft</p>

<h3 id="html">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-mn"&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code></p>

<h3 id="css">CSS样式</h3>
<p><code>css
.g-hd, .g-ft {
    height: 100px;
}
.g-mn {
    max-width: 1000px;
    margin: 0 auto
}
</code>
###说明
这里技巧不多，使用了一个很常见的水平居中样式<code>margin: 0 auto</code>。需要注意的是<code>max-width: 1000px</code>这个属性，这个属性时为了自适应。当浏览器窗口宽度大于1000px时，main区将以1000px的宽度居中显示。如果浏览器窗口宽度小于等于1000px时，页面的宽度将是浏览器窗口宽度
###效果
<a href="http://jsfiddle.net/skyinlayer/24rT2/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-2">浏览器兼容性</h3>
<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="section-3">单栏水平居中布局（全部居中）</h2>
<p>实现思路和上面类似，不过这次把header区，main区，footer区全部放在一个容器中，然后把这个容器设定居中（记得设定max-width）</p>

<h3 id="html-1">HTML结构</h3>
<p><code>html
&lt;div class="g-ctn"&gt;
    &lt;div class="g-hd"&gt;
    &lt;/div&gt;
    &lt;div class="g-mn"&gt;
    &lt;/div&gt;
    &lt;div class="g-ft"&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></p>

<h3 id="css-1">CSS样式</h3>
<p><code>css
.g-ctn { margin: 0 auto; max-width: 1000px;}
.g-hd, .g-ft {height: 100px }
</code></p>

<h3 id="section-4">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/1/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-5">浏览器兼容性</h3>
<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="section-6">全屏两栏自适应布局</h2>
<p>这一类布局分为4个部分：
* header区 g-hd
* footer区 g-ft
* aside区 g-sd
* main区 g-mn</p>

<p>这种布局一般用于应用类的页面，所有区块全部在一个屏幕中固定显示，内容溢出时使用滚动条浏览</p>

<h3 id="html-2">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-sd"&gt;
&lt;/div&gt;
&lt;div class="g-mn"&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {height: 100%; width: 100%; }
.g-hd, .g-ft {position: absolute; width: 100%; height: 100px;  }
.g-hd {top: 0; }
.g-ft {bottom: 0; }
.g-sd, .g-mn {position: absolute; top: 100px; bottom: 100px; overflow: auto; }
.g-sd {width: 300px; }
.g-mn {left: 300px; right: 0px; }
</code>
###说明
这里首先需要注意<code>html, body {height: 100%; width: 100%; }</code>，这一句是常用的将页面的宽度、高度定义为浏览器窗口的大小一致。然后将四个区块全都设置为<code>position: absolute</code>绝对定位，通过设定每个区块相对于根元素的位置，来拉开区块。比如main区，相对上下都有100px的空隙，左侧300px的空隙(这里侧边栏设定为300px)，所以其css样式为<code>.g-mn {position: absolute; top: 100px; bottom: 100px;left: 300px;}</code>其他也是一样的方式。需要注意给侧边栏和内容区增加<code>overflow:auto</code>，这样在其内容溢出时，显示滚动条</p>

<h3 id="section-7">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/2/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-8">浏览器兼容性</h3>
<p>兼容所有ie8+和现代浏览器</p>

<h2 id="section-9">全屏三栏自适应布局</h2>
<p>这一类布局有5个部分：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* 左侧边栏 g-lsd
* 右测边栏 g-rsd</p>

<h3 id="html-3">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-lsd"&gt;&lt;/div&gt;
&lt;div class="g-mn"&gt;&lt;/div&gt;
&lt;div class="g-rsd"&gt;&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {width: 100%; height: 100%; }
.g-hd, .g-ft {height: 100px; width: 100%;}
.g-hd, .g-ft, .g-lsd, .g-rsd, .g-mn {position: absolute;} 
.g-lsd, .g-rsd, .g-mn {top: 100px;bottom: 100px;overflow: auto;}
.g-lsd, .g-rsd {width: 300px;}
.g-mn {right: 300px;left: 300px;}
.g-rsd {right: 0 }
.g-ft {bottom: 0; }
</code>
###说明
和上面全屏两栏自适应布局一样，首先使用<code>html, body {width: 100%; height: 100%; }</code>设定整个页面的大小为浏览器窗口大小，然后通过上例同样的方式将所有元素设定为绝对位置，通过偏移拉长区块。同时左侧边栏、内容区、右侧边栏都需要设定<code>overflow: auto</code>使得内容溢出时显示滚动条</p>

<h3 id="section-10">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/3/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/3/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-11">浏览器兼容性</h3>
<p>兼容所有ie8+和现代浏览器</p>

<h2 id="section-12">两栏自适应布局（左侧固定，右侧自适应）</h2>
<p>这个分四块：
* header区 g-hd
* aside区 g-sd
* main区 g-mn
* footer区 g-ft</p>

<h3 id="html-4">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-sd"&gt;&lt;/div&gt;
&lt;div class="g-mn"&gt;&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code>
###CSS样式
<code>css
.g-hd, .g-ft {height: 100px;}
.g-ft {clear: both;}
.g-sd {float: left; width: 300px; }
.g-mn {*zoom: 1; overflow: hidden; }
</code>
###说明
常见情况，侧边栏宽度固定，右侧内容区自适应布局。这里使BFC，设定aside区为浮动，在main区触发BFC，使得不与aside区重叠。同时由于有浮动出现，所以在footer区加上<code>clear:both</code>来清除浮动。在老式的ie中使用<code>zoom:1</code>来达到BFC的效果
###效果预览
<a href="http://jsfiddle.net/skyinlayer/24rT2/4/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/4/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-13">浏览器兼容</h3>
<p>兼容ie6+及所有现代浏览器</p>

<h2 id="section-14">两栏底部自适应布局</h2>
<p>这个分4个区块：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* aside区 g-sd</p>

<p>这个需求比较有意思，主要是需要footer在内容aside区、main区内容都比较少时（不满一个屏幕），显示在页面底部，而当aisde区、main区内容增多时，footer区显示在这两个区下面（高度较高的元素下面）</p>

<h3 id="html-5">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-ctn"&gt;
    &lt;div class="g-ct"&gt;
        &lt;div class="g-sd"&gt;
        &lt;/div&gt;
        &lt;div class="g-mn"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {width: 100%; height: 100%; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding-top: 100px; padding-bottom: 100px; overflow: hidden; }
        .g-ctn .g-ct .g-sd {float: left; height: 600px; width: 300px; }
        .g-ctn .g-ct .g-mn {height: 600px; overflow: hidden; zoom:1; }
.g-hd {height: 100px; margin-bottom: -100px; }
.g-ft {height:100px; margin-top: -100px; }
</code>
###说明
首先需要设定html的高度为一个页面以方便将一个div（g-ctn）设定为最小大小为浏览器窗口大小。然后针对这个g-ctn，header区（g-hd）和footer区（g-ft），利用负margin来将他们定位到g-ctn里面，这样g-ctn的大小就是整个页面了。然后在g-ctn中顶一个一个div（g-ct），为其设定<code>padding-top</code>和<code>padding-bottom</code>来防止内容区和header区与footer区重叠。然后在这个区块触发BFC，来清除子元素浮动，清除aside区（g-sd）的浮动。在里面放入aside区和main区，将aside区设为<code>float: left</code>，在main区上触发BFC，防止其余aside区重叠。这样布局就完成了
###预览效果
<a href="http://jsfiddle.net/skyinlayer/24rT2/5/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/5/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-15">浏览器兼容性</h3>
<p>兼容ie6+和所有现代浏览器</p>

<h2 id="section-16">三栏底部自适应布局</h2>
<p>这个布局分5块：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* 左边栏区 g-lsd
* 右边栏区 g-rsd</p>

<h3 id="html-6">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-ctn"&gt;
    &lt;div class="g-ct"&gt;
        &lt;div class="g-lsd"&gt;
        &lt;/div&gt;
        &lt;div class="g-rsd"&gt;
        &lt;/div&gt;
        &lt;div class="g-mn"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code></p>

<h3 id="css-2">CSS样式</h3>
<p><code>css
html, body {width: 100%; height: 100%; }
.g-hd {margin-bottom: -100px; height: 100px; }
.g-ft {margin-top: -100px; height: 100px; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding: 100px 0; overflow: hidden; *zoom: 1; }
        .g-ctn .g-ct .g-lsd {width: 300px; float: left; }
        .g-ctn .g-ct .g-rsd {width: 300px; float: right; }
        .g-ctn .g-ct .g-mn {overflow: hidden; *zoom: 1; }
</code></p>

<h3 id="section-17">说明</h3>
<p>和上面底部两栏自适应几乎一样，不过这一次分为左边栏和右边栏，所以需要注意一下，把两个侧边栏写在前面，后面写main区，否则会出现main区直接把右边栏挤开的情况</p>

<h3 id="section-18">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/6/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/6/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-19">总结</h2>
<p>还有很多很多的布局没有实现，有时间实现一些其他的布局，布局前端面试还是问的很多的，手动实现了一下发现，还是需要动手的，否则直接问真心不一定能答上来</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/03/05/layouts.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 网页布局实例 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/03/05/layouts.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Mar 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>最近看前端相关面试题，看到很多关于CSS布局的面试题。于是乎自己实现了几个常用的布局，这里记录一下实现。所有的布局均已上传到github，命名为<a href="https://github.com/LingyuCoder/sky_layouts">sky_layouts项目</a></p>

<p>所有的页面都引入了一段CSS reset的代码，用于屏蔽不同浏览器之间的差异
<code>css
/* Style reset 消除浏览器默认样式 */
body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,blockquote,th,td,p{margin:0;padding:0}input,button,select,textarea{outline:none}li{list-style:none}img{border:none}textarea{resize:none}body{color:#666;background:#fff;word-break:break-all;word-wrap:break-word;text-align:center}body,input,textarea{font-size:12px;font-family:\5b8b\4f53,Verdana,Arial}a{color:#305999;text-decoration:none;outline:none}a:hover{color:#090}.wrap{width:1000px;margin:0 auto;text-align:left;position:relative}/*clearfix*/.clearfix:after,.wrap:after{content:".";display:block;height:0;clear:both;visibility:hidden}.clearfix,.wrap{*+height:1%}
</code></p>

<p>另外这里所有的header区、footer区的高度都为100px，侧边栏都是300px</p>

<h2 id="section-1">单栏水平居中布局（首尾全屏）</h2>
<p>这种布局很常见，比如新浪微博的布局就是这样，header宽度为全屏，内容区宽度固定</p>

<p>这种布局有三部分构成:
* header区，g-hd
* main区，g-mn
* footer区，g-ft</p>

<h3 id="html">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-mn"&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code></p>

<h3 id="css">CSS样式</h3>
<p><code>css
.g-hd, .g-ft {
    height: 100px;
}
.g-mn {
    max-width: 1000px;
    margin: 0 auto
}
</code>
###说明
这里技巧不多，使用了一个很常见的水平居中样式<code>margin: 0 auto</code>。需要注意的是<code>max-width: 1000px</code>这个属性，这个属性时为了自适应。当浏览器窗口宽度大于1000px时，main区将以1000px的宽度居中显示。如果浏览器窗口宽度小于等于1000px时，页面的宽度将是浏览器窗口宽度
###效果
<a href="http://jsfiddle.net/skyinlayer/24rT2/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-2">浏览器兼容性</h3>
<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="section-3">单栏水平居中布局（全部居中）</h2>
<p>实现思路和上面类似，不过这次把header区，main区，footer区全部放在一个容器中，然后把这个容器设定居中（记得设定max-width）</p>

<h3 id="html-1">HTML结构</h3>
<p><code>html
&lt;div class="g-ctn"&gt;
    &lt;div class="g-hd"&gt;
    &lt;/div&gt;
    &lt;div class="g-mn"&gt;
    &lt;/div&gt;
    &lt;div class="g-ft"&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></p>

<h3 id="css-1">CSS样式</h3>
<p><code>css
.g-ctn { margin: 0 auto; max-width: 1000px;}
.g-hd, .g-ft {height: 100px }
</code></p>

<h3 id="section-4">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/1/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/1/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-5">浏览器兼容性</h3>
<p>兼容ie8+和所有现代浏览器，如果设定为固定宽度，则兼容ie6</p>

<h2 id="section-6">全屏两栏自适应布局</h2>
<p>这一类布局分为4个部分：
* header区 g-hd
* footer区 g-ft
* aside区 g-sd
* main区 g-mn</p>

<p>这种布局一般用于应用类的页面，所有区块全部在一个屏幕中固定显示，内容溢出时使用滚动条浏览</p>

<h3 id="html-2">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-sd"&gt;
&lt;/div&gt;
&lt;div class="g-mn"&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {height: 100%; width: 100%; }
.g-hd, .g-ft {position: absolute; width: 100%; height: 100px;  }
.g-hd {top: 0; }
.g-ft {bottom: 0; }
.g-sd, .g-mn {position: absolute; top: 100px; bottom: 100px; overflow: auto; }
.g-sd {width: 300px; }
.g-mn {left: 300px; right: 0px; }
</code>
###说明
这里首先需要注意<code>html, body {height: 100%; width: 100%; }</code>，这一句是常用的将页面的宽度、高度定义为浏览器窗口的大小一致。然后将四个区块全都设置为<code>position: absolute</code>绝对定位，通过设定每个区块相对于根元素的位置，来拉开区块。比如main区，相对上下都有100px的空隙，左侧300px的空隙(这里侧边栏设定为300px)，所以其css样式为<code>.g-mn {position: absolute; top: 100px; bottom: 100px;left: 300px;}</code>其他也是一样的方式。需要注意给侧边栏和内容区增加<code>overflow:auto</code>，这样在其内容溢出时，显示滚动条</p>

<h3 id="section-7">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/2/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/2/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-8">浏览器兼容性</h3>
<p>兼容所有ie8+和现代浏览器</p>

<h2 id="section-9">全屏三栏自适应布局</h2>
<p>这一类布局有5个部分：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* 左侧边栏 g-lsd
* 右测边栏 g-rsd</p>

<h3 id="html-3">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-lsd"&gt;&lt;/div&gt;
&lt;div class="g-mn"&gt;&lt;/div&gt;
&lt;div class="g-rsd"&gt;&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {width: 100%; height: 100%; }
.g-hd, .g-ft {height: 100px; width: 100%;}
.g-hd, .g-ft, .g-lsd, .g-rsd, .g-mn {position: absolute;} 
.g-lsd, .g-rsd, .g-mn {top: 100px;bottom: 100px;overflow: auto;}
.g-lsd, .g-rsd {width: 300px;}
.g-mn {right: 300px;left: 300px;}
.g-rsd {right: 0 }
.g-ft {bottom: 0; }
</code>
###说明
和上面全屏两栏自适应布局一样，首先使用<code>html, body {width: 100%; height: 100%; }</code>设定整个页面的大小为浏览器窗口大小，然后通过上例同样的方式将所有元素设定为绝对位置，通过偏移拉长区块。同时左侧边栏、内容区、右侧边栏都需要设定<code>overflow: auto</code>使得内容溢出时显示滚动条</p>

<h3 id="section-10">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/3/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/3/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-11">浏览器兼容性</h3>
<p>兼容所有ie8+和现代浏览器</p>

<h2 id="section-12">两栏自适应布局（左侧固定，右侧自适应）</h2>
<p>这个分四块：
* header区 g-hd
* aside区 g-sd
* main区 g-mn
* footer区 g-ft</p>

<h3 id="html-4">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-sd"&gt;&lt;/div&gt;
&lt;div class="g-mn"&gt;&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code>
###CSS样式
<code>css
.g-hd, .g-ft {height: 100px;}
.g-ft {clear: both;}
.g-sd {float: left; width: 300px; }
.g-mn {*zoom: 1; overflow: hidden; }
</code>
###说明
常见情况，侧边栏宽度固定，右侧内容区自适应布局。这里使BFC，设定aside区为浮动，在main区触发BFC，使得不与aside区重叠。同时由于有浮动出现，所以在footer区加上<code>clear:both</code>来清除浮动。在老式的ie中使用<code>zoom:1</code>来达到BFC的效果
###效果预览
<a href="http://jsfiddle.net/skyinlayer/24rT2/4/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/4/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-13">浏览器兼容</h3>
<p>兼容ie6+及所有现代浏览器</p>

<h2 id="section-14">两栏底部自适应布局</h2>
<p>这个分4个区块：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* aside区 g-sd</p>

<p>这个需求比较有意思，主要是需要footer在内容aside区、main区内容都比较少时（不满一个屏幕），显示在页面底部，而当aisde区、main区内容增多时，footer区显示在这两个区下面（高度较高的元素下面）</p>

<h3 id="html-5">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;
&lt;/div&gt;
&lt;div class="g-ctn"&gt;
    &lt;div class="g-ct"&gt;
        &lt;div class="g-sd"&gt;
        &lt;/div&gt;
        &lt;div class="g-mn"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;
&lt;/div&gt;
</code>
###CSS样式
<code>css
html, body {width: 100%; height: 100%; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding-top: 100px; padding-bottom: 100px; overflow: hidden; }
        .g-ctn .g-ct .g-sd {float: left; height: 600px; width: 300px; }
        .g-ctn .g-ct .g-mn {height: 600px; overflow: hidden; zoom:1; }
.g-hd {height: 100px; margin-bottom: -100px; }
.g-ft {height:100px; margin-top: -100px; }
</code>
###说明
首先需要设定html的高度为一个页面以方便将一个div（g-ctn）设定为最小大小为浏览器窗口大小。然后针对这个g-ctn，header区（g-hd）和footer区（g-ft），利用负margin来将他们定位到g-ctn里面，这样g-ctn的大小就是整个页面了。然后在g-ctn中顶一个一个div（g-ct），为其设定<code>padding-top</code>和<code>padding-bottom</code>来防止内容区和header区与footer区重叠。然后在这个区块触发BFC，来清除子元素浮动，清除aside区（g-sd）的浮动。在里面放入aside区和main区，将aside区设为<code>float: left</code>，在main区上触发BFC，防止其余aside区重叠。这样布局就完成了
###预览效果
<a href="http://jsfiddle.net/skyinlayer/24rT2/5/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/5/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-15">浏览器兼容性</h3>
<p>兼容ie6+和所有现代浏览器</p>

<h2 id="section-16">三栏底部自适应布局</h2>
<p>这个布局分5块：
* header区 g-hd
* footer区 g-ft
* main区 g-mn
* 左边栏区 g-lsd
* 右边栏区 g-rsd</p>

<h3 id="html-6">HTML结构</h3>
<p><code>html
&lt;div class="g-hd"&gt;&lt;/div&gt;
&lt;div class="g-ctn"&gt;
    &lt;div class="g-ct"&gt;
        &lt;div class="g-lsd"&gt;
        &lt;/div&gt;
        &lt;div class="g-rsd"&gt;
        &lt;/div&gt;
        &lt;div class="g-mn"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;div class="g-ft"&gt;&lt;/div&gt;
</code></p>

<h3 id="css-2">CSS样式</h3>
<p><code>css
html, body {width: 100%; height: 100%; }
.g-hd {margin-bottom: -100px; height: 100px; }
.g-ft {margin-top: -100px; height: 100px; }
.g-ctn {position: relative; min-height: 100%; }
    .g-ctn .g-ct {padding: 100px 0; overflow: hidden; *zoom: 1; }
        .g-ctn .g-ct .g-lsd {width: 300px; float: left; }
        .g-ctn .g-ct .g-rsd {width: 300px; float: right; }
        .g-ctn .g-ct .g-mn {overflow: hidden; *zoom: 1; }
</code></p>

<h3 id="section-17">说明</h3>
<p>和上面底部两栏自适应几乎一样，不过这一次分为左边栏和右边栏，所以需要注意一下，把两个侧边栏写在前面，后面写main区，否则会出现main区直接把右边栏挤开的情况</p>

<h3 id="section-18">预览效果</h3>
<p><a href="http://jsfiddle.net/skyinlayer/24rT2/6/">jsfiddle地址</a></p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/24rT2/6/embedded/result,html,css" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h2 id="section-19">总结</h2>
<p>还有很多很多的布局没有实现，有时间实现一些其他的布局，布局前端面试还是问的很多的，手动实现了一下发现，还是需要动手的，否则直接问真心不一定能答上来</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/03/05/layouts.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 初识Grunt ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/28/grunt.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近总是看到各种推荐使用Grunt的文章，说其对前端项目开发的自动化程度提升到一个新的流程。之前开发也是苦于各种文件的处理，比如之前写less的时候，每次改动都得手动去调用命令编译一次，效率很低。而Grunt正解决了这个问题，于是乎乘着这两天闲下来了，乘机学习了一下Grunt的基础用法</p>

<h2 id="grunt">什么是Grunt？</h2>
<p>Grunt官网首页上，最显眼的一句话就是：“Grunt JavaScript世界的构建工具”，它运行于Node.js平台</p>

<h2 id="grunt-1">为什么要用Grunt？</h2>
<p>面对以下一些常见的前端开发中的问题，Grunt都可以大展拳脚
###文件的压缩与合并
在平常的前端项目开发中，最需要顾忌的就是效率问题。为了提升用户体验，页面的加载不能过长，这也就使得“优化”在前端开发中永远是个说不完道不尽的话题。一些比较常见的优化方式有这么几种：
* JavaScript文件的优化：将多个JS文件合并成一个文件，以减少请求次数。对JavaScript文件采用压缩，消除掉所有缩进和换行，减小文件体积。使用类似uglify的压缩工具压缩JavaScript代码内部变量名称长度，减少文件体积等等
* CSS文件的优化：将多个CSS文件合并成一个文件，并进行压缩。道理同JS文件的合并及压缩
* 图片文件的合并：sprite技术，也是为了减少请求次数
* 等等等等</p>

<p>这些文件的压缩合并都可以交给Grunt进行处理</p>

<h3 id="section">代码提示</h3>
<p>无论CSS、JavaScript、HTML都是在快速发展的，这也导致了API及一些属性功能的变化。同时这些代码不像Java那样有一套完善的编码时错误提示，这也是JSHint，CSSHint等代码提示出现的原因。这些编码提示也可以通过Grunt来进行处理</p>

<h3 id="section-1">预处理</h3>
<p>众所周知，现在出现了很多以提升开发效率为目的的前端语言预处理方案：
* CSS相关：Less和Sass，通过简洁的语法，来提升代码的复用性
* JavaScript相关：CoffeeScript，类似Python的语法，友好而高效
* HTML：一些模板引擎如Jade</p>

<p>这些预处理也可以交给Grunt来进行</p>

<h3 id="section-2">一些额外的处理</h3>
<p>有时候还会需要一些额外的需求，比如添加版本自动更新注释，CSS前缀自动补全等等。这些Grunt也提供了很多插件进行处理，方便快捷</p>

<h2 id="grunt-2">安装Grunt</h2>
<p>###首先你得有一个xxx
想要使用Grunt，首先你得有一个Node.js环境和一个npm。这俩网上教程一大把，安装也很简单，就不说了。这里只提及Grunt如何安装</p>

<p>另外这里介绍的是Grunt 0.4.x，要求Node.js的版本在0.8.0以上，如果已经使用了Grunt 0.3.x版本的，可以先卸载，然后重新安装0.4.x版本</p>

<h3 id="npmgrunt">使用npm安装Grunt命令行</h3>
<p>执行如下代码：
<code>shell
$ npm install -g grunt-cli
</code>
这样就可以在命令行使用<code>grunt</code>命令。需要注意的是，安装了grunt-cli并不等同于安装了Grunt，它只是一个命令行命令，用来调用与gruntfile文件在同一目录下的grunt的，如果没有grunt，将会给一个错误提示并退出。之所以这么设计的主要原因是，这样可以在同一个系统上安装多个版本的grunt了</p>

<h3 id="grunt-3">安装Grunt</h3>
<p>使用过Node.js做过项目的人应该都对<code>package.json</code>这个文件不陌生了。Grunt安装也是通过npm安装，所以只要将其加入到<code>devDependencies</code>中就可以了。一个简单的package.json文件大概长这个样子：
<code>javascript
{
  "name": "your project name",
  "version": "x.x.x",
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-autoprefixer": "~0.4.0",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-contrib-concat": "~0.3.0",
    "grunt-contrib-cssmin": "~0.8.0",
    "load-grunt-tasks": "~0.2.0"
  }
}
</code></p>

<p>在写完类似的<code>package.json</code>（或添加完Grunt依赖后），运行<code>npm install</code>就可以从npm自动安装了，下面几个都是grunt的可选查件，大致上介绍几个可选查件（包括上面出现的和没出现的）:
* grunt-contrib-watch: 自动监听指定文件改变并执行相关任务流的插件
* grunt-contrib-concat: 文本合并插件
* grunt-contrib-cssmin: CSS代码压缩插件
* grunt-autoprefixer: 为CSS属性自动添加前缀，兼容信息来自著名的<a href="http://caniuse.com/">Can I Use</a>网站
* grunt-contrib-jshint：JavaScript代码提示插件
* grunt-contrib-uglify：JavaScript代码压缩插件
* load-grunt-tasks：自动加载Grunt插件的插件（好绕口）
* 还有一大堆请参见<a href="http://gruntjs.com/plugins">Grunt plugins</a>，这个是官网上的，但是我显示不出来,无止境的loading，所以可以去<a href="https://npmjs.org/">npm官网</a>上搜gruntplugin关键字</p>

<p>这些插件的安装也是一样写在devDependencies中，定好需要的版本号后直接使用<code>npm install</code>命令安装可以了。或者也可以反过来，先使用<code>npm install grunt --save-dev</code>安装，然后再将依赖加入到package.json的devDependencies中</p>

<h2 id="grunt-4">配置项目中的Grunt</h2>
<p>Grunt的配置都写在一个名为<code>Gruntfile.js</code>的文件中（当然，在这里面可以通过引入外部文件的方式来加载自己的配置文件），这个文件必须在项目的根目录下，也就是和<code>package.json</code>同一路径下，一个简单的<code>Gruntfile.js</code>文件大概长这个样子：
<code>javascript
module.exports = function(grunt) {
  grunt.initConfig({
    //确定需要加载的package.json文件的路径
    pkg: grunt.file.readJSON('package.json'),
    //定义任务
    concat: {
      dist: {
        src: [
          'src/css/*.css'
        ],
        dest: 'skyinlayer.css'
      }
    }
  });
  //加载插件
  grunt.loadNpmTasks('grunt-contrib-concat');
  //定义默认任务列表
  grunt.registerTask('default', ['concat']);
};
</code>
###引入package.json中的配置
通过<code>pkg</code>引入的<code>package.json</code>文件的JSON数据可以通过<code>&lt;% %&gt;</code>模板字符串来进行引用
###定义任务
定义任务部分则是定义了一个任务所需要的相关配置，比如这里定义了合并文件（concat）任务，相关配置确定了需要被合并的文件为<code>src/css/</code>下的所有后缀为<code>.css</code>的文件，合并完成的文件输出到根目录下的<code>skyinlayer.css</code>文件中。</p>

<p>在定义任务部分可以定义多个任务，比如我写一个纯CSS的项目，也需要经过合并、添加前缀、压缩等任务，，所以可以将其修改为如下：
```javascript
concat: {
  dist: {
    src: [
      ‘src/base.css’,
      ‘src/<em>*/</em>.css’
    ],
    dest: ‘skyinlayer.css’
  }
},</p>

<p>autoprefixer: {
  no_dest: {
    src: ‘skyinlayer.css’
  },
},</p>

<p>cssmin: {
  minify: {
    src: [‘skyinlayer.css’],
    dest: ‘skyinlayer.min.css’,
  },
}
```</p>

<h3 id="section-3">加载插件</h3>
<p>由于Grunt的任务都是通过npm插件的形式被引入的，所以需要进行查件加载，通过如下语句加载：
<code>javascript
grunt.loadNpmTasks('grunt-contrib-concat');
grunt.loadNpmTasks('grunt-autoprefixer');
grunt.loadNpmTasks('grunt-contrib-cssmin');
</code>
这样就加载了三个插件，分别用来指向上面定义的三个任务，值得注意的是可以使用<code>load-grunt-tasks</code>来自动加载所有在<code>package.json</code>中被依赖的grunt插件，其检测的标准是插件名称以<code>grunt-</code>字符串开头。如果使用了<code>load-grunt-tasks</code>，加载就变得很简单了，一句代码搞定：
<code>javascript
require('load-grunt-tasks')(grunt);
</code></p>

<h3 id="section-4">定义默认任务流程</h3>
<p>在定义完任务以及加载完插件之后，我们需要定义任务流程，确定任务执行的顺序。使用如下代码定义任务流程：
<code>javascript
grunt.registerTask('default', ['concat','autoprefixer','cssmin']);
</code>
这样定义完后，每次执行<code>grunt</code>命令，就会制动执行代码合并，添加前缀和CSS代码压缩三项任务了</p>

<h3 id="section-5">监听文件变化</h3>
<p>一般情况下，我们需要多次改动代码来查看效果，有时候改动很小甚至只是一个数字。这样每次改动都需要手动执行grunt命令太麻烦了，<code>grunt-contrib-watch</code>这个插件帮我们解决了这个问题。引入<code>grunt-contrib-watch</code>插件和上面一样（如果使用了<code>load-grunt-tasks</code>，不需要额外的引入过程）。定义watch任务：
<code>javascript
watch: {
  css: {
    files: [
      'src/**/*',
      '!node_modules'
    ],
    tasks: ['concat', 'autoprefixer', 'cssmin'],
  }
}
</code>
其中，files属性可以定义哪些文件需要监听改变，哪些不需要，而tasks则定义了文件改变后需要执行的任务流程。这样定义的话，比如我的<code>src/css/base.css</code>文件进行了变更，在保存的时候，将自动执行代码合并，前缀添加及代码压缩等任务</p>

<h2 id="section-6">总结</h2>
<p>Grunt其实还有很多更加深入的用法，比如读取json问价作为配置文件、根据配置文件动态的进行处理等等（比如<a href="https://github.com/daneden/animate.css">daneden的animate.css项目</a>），这里就只是介绍了一下基础的用法。学好了Grunt，以后也可以出去和别人吹牛逼说自己的项目工作流是自动化的啦（括弧笑）</p>

<h2 id="section-7">更多详细请参考</h2>
<p><a href="http://www.gruntjs.net/">Grunt官网</a></p>

<p><a href="http://www.w3cplus.com/blog/tags/372.html">W3CPlus的Grunt相关文章</a></p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/28/grunt.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 初识Grunt ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/28/grunt.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 28 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近总是看到各种推荐使用Grunt的文章，说其对前端项目开发的自动化程度提升到一个新的流程。之前开发也是苦于各种文件的处理，比如之前写less的时候，每次改动都得手动去调用命令编译一次，效率很低。而Grunt正解决了这个问题，于是乎乘着这两天闲下来了，乘机学习了一下Grunt的基础用法</p>

<h2 id="grunt">什么是Grunt？</h2>
<p>Grunt官网首页上，最显眼的一句话就是：“Grunt JavaScript世界的构建工具”，它运行于Node.js平台</p>

<h2 id="grunt-1">为什么要用Grunt？</h2>
<p>面对以下一些常见的前端开发中的问题，Grunt都可以大展拳脚
###文件的压缩与合并
在平常的前端项目开发中，最需要顾忌的就是效率问题。为了提升用户体验，页面的加载不能过长，这也就使得“优化”在前端开发中永远是个说不完道不尽的话题。一些比较常见的优化方式有这么几种：
* JavaScript文件的优化：将多个JS文件合并成一个文件，以减少请求次数。对JavaScript文件采用压缩，消除掉所有缩进和换行，减小文件体积。使用类似uglify的压缩工具压缩JavaScript代码内部变量名称长度，减少文件体积等等
* CSS文件的优化：将多个CSS文件合并成一个文件，并进行压缩。道理同JS文件的合并及压缩
* 图片文件的合并：sprite技术，也是为了减少请求次数
* 等等等等</p>

<p>这些文件的压缩合并都可以交给Grunt进行处理</p>

<h3 id="section">代码提示</h3>
<p>无论CSS、JavaScript、HTML都是在快速发展的，这也导致了API及一些属性功能的变化。同时这些代码不像Java那样有一套完善的编码时错误提示，这也是JSHint，CSSHint等代码提示出现的原因。这些编码提示也可以通过Grunt来进行处理</p>

<h3 id="section-1">预处理</h3>
<p>众所周知，现在出现了很多以提升开发效率为目的的前端语言预处理方案：
* CSS相关：Less和Sass，通过简洁的语法，来提升代码的复用性
* JavaScript相关：CoffeeScript，类似Python的语法，友好而高效
* HTML：一些模板引擎如Jade</p>

<p>这些预处理也可以交给Grunt来进行</p>

<h3 id="section-2">一些额外的处理</h3>
<p>有时候还会需要一些额外的需求，比如添加版本自动更新注释，CSS前缀自动补全等等。这些Grunt也提供了很多插件进行处理，方便快捷</p>

<h2 id="grunt-2">安装Grunt</h2>
<p>###首先你得有一个xxx
想要使用Grunt，首先你得有一个Node.js环境和一个npm。这俩网上教程一大把，安装也很简单，就不说了。这里只提及Grunt如何安装</p>

<p>另外这里介绍的是Grunt 0.4.x，要求Node.js的版本在0.8.0以上，如果已经使用了Grunt 0.3.x版本的，可以先卸载，然后重新安装0.4.x版本</p>

<h3 id="npmgrunt">使用npm安装Grunt命令行</h3>
<p>执行如下代码：
<code>shell
$ npm install -g grunt-cli
</code>
这样就可以在命令行使用<code>grunt</code>命令。需要注意的是，安装了grunt-cli并不等同于安装了Grunt，它只是一个命令行命令，用来调用与gruntfile文件在同一目录下的grunt的，如果没有grunt，将会给一个错误提示并退出。之所以这么设计的主要原因是，这样可以在同一个系统上安装多个版本的grunt了</p>

<h3 id="grunt-3">安装Grunt</h3>
<p>使用过Node.js做过项目的人应该都对<code>package.json</code>这个文件不陌生了。Grunt安装也是通过npm安装，所以只要将其加入到<code>devDependencies</code>中就可以了。一个简单的package.json文件大概长这个样子：
<code>javascript
{
  "name": "your project name",
  "version": "x.x.x",
  "devDependencies": {
    "grunt": "~0.4.2",
    "grunt-autoprefixer": "~0.4.0",
    "grunt-contrib-watch": "~0.5.3",
    "grunt-contrib-concat": "~0.3.0",
    "grunt-contrib-cssmin": "~0.8.0",
    "load-grunt-tasks": "~0.2.0"
  }
}
</code></p>

<p>在写完类似的<code>package.json</code>（或添加完Grunt依赖后），运行<code>npm install</code>就可以从npm自动安装了，下面几个都是grunt的可选查件，大致上介绍几个可选查件（包括上面出现的和没出现的）:
* grunt-contrib-watch: 自动监听指定文件改变并执行相关任务流的插件
* grunt-contrib-concat: 文本合并插件
* grunt-contrib-cssmin: CSS代码压缩插件
* grunt-autoprefixer: 为CSS属性自动添加前缀，兼容信息来自著名的<a href="http://caniuse.com/">Can I Use</a>网站
* grunt-contrib-jshint：JavaScript代码提示插件
* grunt-contrib-uglify：JavaScript代码压缩插件
* load-grunt-tasks：自动加载Grunt插件的插件（好绕口）
* 还有一大堆请参见<a href="http://gruntjs.com/plugins">Grunt plugins</a>，这个是官网上的，但是我显示不出来,无止境的loading，所以可以去<a href="https://npmjs.org/">npm官网</a>上搜gruntplugin关键字</p>

<p>这些插件的安装也是一样写在devDependencies中，定好需要的版本号后直接使用<code>npm install</code>命令安装可以了。或者也可以反过来，先使用<code>npm install grunt --save-dev</code>安装，然后再将依赖加入到package.json的devDependencies中</p>

<h2 id="grunt-4">配置项目中的Grunt</h2>
<p>Grunt的配置都写在一个名为<code>Gruntfile.js</code>的文件中（当然，在这里面可以通过引入外部文件的方式来加载自己的配置文件），这个文件必须在项目的根目录下，也就是和<code>package.json</code>同一路径下，一个简单的<code>Gruntfile.js</code>文件大概长这个样子：
<code>javascript
module.exports = function(grunt) {
  grunt.initConfig({
    //确定需要加载的package.json文件的路径
    pkg: grunt.file.readJSON('package.json'),
    //定义任务
    concat: {
      dist: {
        src: [
          'src/css/*.css'
        ],
        dest: 'skyinlayer.css'
      }
    }
  });
  //加载插件
  grunt.loadNpmTasks('grunt-contrib-concat');
  //定义默认任务列表
  grunt.registerTask('default', ['concat']);
};
</code>
###引入package.json中的配置
通过<code>pkg</code>引入的<code>package.json</code>文件的JSON数据可以通过<code>&lt;% %&gt;</code>模板字符串来进行引用
###定义任务
定义任务部分则是定义了一个任务所需要的相关配置，比如这里定义了合并文件（concat）任务，相关配置确定了需要被合并的文件为<code>src/css/</code>下的所有后缀为<code>.css</code>的文件，合并完成的文件输出到根目录下的<code>skyinlayer.css</code>文件中。</p>

<p>在定义任务部分可以定义多个任务，比如我写一个纯CSS的项目，也需要经过合并、添加前缀、压缩等任务，，所以可以将其修改为如下：
```javascript
concat: {
  dist: {
    src: [
      ‘src/base.css’,
      ‘src/<em>*/</em>.css’
    ],
    dest: ‘skyinlayer.css’
  }
},</p>

<p>autoprefixer: {
  no_dest: {
    src: ‘skyinlayer.css’
  },
},</p>

<p>cssmin: {
  minify: {
    src: [‘skyinlayer.css’],
    dest: ‘skyinlayer.min.css’,
  },
}
```</p>

<h3 id="section-3">加载插件</h3>
<p>由于Grunt的任务都是通过npm插件的形式被引入的，所以需要进行查件加载，通过如下语句加载：
<code>javascript
grunt.loadNpmTasks('grunt-contrib-concat');
grunt.loadNpmTasks('grunt-autoprefixer');
grunt.loadNpmTasks('grunt-contrib-cssmin');
</code>
这样就加载了三个插件，分别用来指向上面定义的三个任务，值得注意的是可以使用<code>load-grunt-tasks</code>来自动加载所有在<code>package.json</code>中被依赖的grunt插件，其检测的标准是插件名称以<code>grunt-</code>字符串开头。如果使用了<code>load-grunt-tasks</code>，加载就变得很简单了，一句代码搞定：
<code>javascript
require('load-grunt-tasks')(grunt);
</code></p>

<h3 id="section-4">定义默认任务流程</h3>
<p>在定义完任务以及加载完插件之后，我们需要定义任务流程，确定任务执行的顺序。使用如下代码定义任务流程：
<code>javascript
grunt.registerTask('default', ['concat','autoprefixer','cssmin']);
</code>
这样定义完后，每次执行<code>grunt</code>命令，就会制动执行代码合并，添加前缀和CSS代码压缩三项任务了</p>

<h3 id="section-5">监听文件变化</h3>
<p>一般情况下，我们需要多次改动代码来查看效果，有时候改动很小甚至只是一个数字。这样每次改动都需要手动执行grunt命令太麻烦了，<code>grunt-contrib-watch</code>这个插件帮我们解决了这个问题。引入<code>grunt-contrib-watch</code>插件和上面一样（如果使用了<code>load-grunt-tasks</code>，不需要额外的引入过程）。定义watch任务：
<code>javascript
watch: {
  css: {
    files: [
      'src/**/*',
      '!node_modules'
    ],
    tasks: ['concat', 'autoprefixer', 'cssmin'],
  }
}
</code>
其中，files属性可以定义哪些文件需要监听改变，哪些不需要，而tasks则定义了文件改变后需要执行的任务流程。这样定义的话，比如我的<code>src/css/base.css</code>文件进行了变更，在保存的时候，将自动执行代码合并，前缀添加及代码压缩等任务</p>

<h2 id="section-6">总结</h2>
<p>Grunt其实还有很多更加深入的用法，比如读取json问价作为配置文件、根据配置文件动态的进行处理等等（比如<a href="https://github.com/daneden/animate.css">daneden的animate.css项目</a>），这里就只是介绍了一下基础的用法。学好了Grunt，以后也可以出去和别人吹牛逼说自己的项目工作流是自动化的啦（括弧笑）</p>

<h2 id="section-7">更多详细请参考</h2>
<p><a href="http://www.gruntjs.net/">Grunt官网</a></p>

<p><a href="http://www.w3cplus.com/blog/tags/372.html">W3CPlus的Grunt相关文章</a></p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/28/grunt.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 深入浅出BFC（Block formatting contexts） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/26/BFC.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 26 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="bfc">何为BFC</h2>
<p>BFC（Block formatting contexts）,是W3C CSS 2.1中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。在创建了BFC的元素中，子元素会一个接一个的被放置。垂直方向上，他们的起点是一个包含块的顶部，两个相邻元素之间的垂直距离取决于<code>margin</code>特性。BFC中相邻的块级元素的垂直边距(<code>margin-top</code>和<code>margin-bottom</code>)会被折叠（collapse）。在BFC中，每一个元素的左边与包含块的左边（<code>border-left</code>）相接触（如果从右到左的格式化，右边接触包含块的<code>border-right</code>），除非这个元素也创建了一个BFC。</p>

<h2 id="bfc-1">触发BFC</h2>
<p>满足以下任意一个情况就会触发BFC：
* 根节点
* 浮动（<code>float</code>不为<code>none</code>）
* 绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）
* <code>display: inline-block</code>的元素
* <code>display: table-cell</code>的元素（HTML的table格子默认就是这个）
* <code>display: table-caption</code>的元素(HTML的table caption默认就是这个)
* <code>overflow</code>不为<code>visible</code>的元素
* 伸缩盒元素（<code>display</code>为<code>flex</code>或<code>inline-flex</code>）</p>

<h2 id="bfc-2">BFC的作用</h2>
<p>BFC的主要知识点在清除浮动重叠与margin重叠上，margin重叠有如下规则：
* 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值
* 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值
* 两个外边距一正一负时，折叠结果是两者的相加的和</p>

<h3 id="bfcmargin">BFC清除嵌套元素的margin重叠</h3>
<p>如果父元素不触发BFC，
<code>html
&lt;div class="outer"&gt;
	&lt;div class="inner"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
CSS代码如下：
<code>css
.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}
</code></p>

<p>效果图：</p>

<p><img src="/img/BFC/1.png" alt="不触发BFC时垂直margin重叠" /></p>

<p>可以看到，子元素inner和父元素outer的<code>margin-top</code>重叠了</p>

<p>在outer上触发BFC，修改CSS：
<code>css
.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
	overflow: hidden;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}
</code></p>

<p>效果图：
<img src="/img/BFC/2.png" alt="触发BFC后垂直margin不重叠" /></p>

<p>在触发了父元素的BFC，于是乎margin不再重叠</p>

<h3 id="section">不与浮动元素重叠</h3>
<p><code>html
&lt;div class="outer"&gt;
	&lt;div class="left"&gt;&lt;/div&gt;
	&lt;div class="top"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .top {
	width: 200px;
	height: 100px;
	background-color: red;
} ```
</code></pre>

<p>效果图：</p>

<p><img src="/img/BFC/3.png" alt="两个矩形重叠" /></p>

<p><img src="/img/BFC/4.png" alt="检索left元素" /></p>

<p><img src="/img/BFC/5.png" alt="检索top元素" /></p>

<p>可以从上面三张图看到，两个长方形被重叠了</p>

<p>在非浮动元素（top）上触发BFC，修改CSS:
```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .top {
	width: 200px;
	height: 100px;
	background-color: red;
	overflow:hidden;
} ```
</code></pre>

<p>效果图：</p>

<p><img src="/img/BFC/6.png" alt="浮动元素与非浮动元素不再重叠" /></p>

<p>两个矩形不再重叠，不过需要注意在非浮动元素上触发BFC</p>

<h3 id="section-1">清除元素内部浮动</h3>
<p><code>html
&lt;div class="outer"&gt;
	&lt;div class="left"&gt;&lt;/div&gt;
	&lt;div class="right"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .right {
	width: 100px;
	height: 100px;
	background-color: red;
	float: right;
} ``` 效果图：
</code></pre>

<p><img src="/img/BFC/7.png" alt="outer没有被浮动元素撑开" /></p>

<p>可以看到，outer并没有被撑开，查看元素发现其高度为0px</p>

<p>修改css在outer上触发BFC：
```
.outer {
	background-color: #f0f0f0;
	width: 100%;
	overflow: hidden;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .right {
	width: 100px;
	height: 100px;
	background-color: red;
	float: right;
} ``` 效果图：
</code></pre>

<p><img src="/img/BFC/8.png" alt="触发BFC后outer被浮动元素撑开" /></p>

<p>在outer上触发BFC后可以看到，outer的高度变成了100px，被left和right两个浮动元素撑开了</p>

<h2 id="section-2">参考文献</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">Block formatting context</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/26/BFC.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 深入浅出BFC（Block formatting contexts） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/26/BFC.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 26 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="bfc">何为BFC</h2>
<p>BFC（Block formatting contexts）,是W3C CSS 2.1中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。在创建了BFC的元素中，子元素会一个接一个的被放置。垂直方向上，他们的起点是一个包含块的顶部，两个相邻元素之间的垂直距离取决于<code>margin</code>特性。BFC中相邻的块级元素的垂直边距(<code>margin-top</code>和<code>margin-bottom</code>)会被折叠（collapse）。在BFC中，每一个元素的左边与包含块的左边（<code>border-left</code>）相接触（如果从右到左的格式化，右边接触包含块的<code>border-right</code>），除非这个元素也创建了一个BFC。</p>

<h2 id="bfc-1">触发BFC</h2>
<p>满足以下任意一个情况就会触发BFC：
* 根节点
* 浮动（<code>float</code>不为<code>none</code>）
* 绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）
* <code>display: inline-block</code>的元素
* <code>display: table-cell</code>的元素（HTML的table格子默认就是这个）
* <code>display: table-caption</code>的元素(HTML的table caption默认就是这个)
* <code>overflow</code>不为<code>visible</code>的元素
* 伸缩盒元素（<code>display</code>为<code>flex</code>或<code>inline-flex</code>）</p>

<h2 id="bfc-2">BFC的作用</h2>
<p>BFC的主要知识点在清除浮动重叠与margin重叠上，margin重叠有如下规则：
* 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值
* 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值
* 两个外边距一正一负时，折叠结果是两者的相加的和</p>

<h3 id="bfcmargin">BFC清除嵌套元素的margin重叠</h3>
<p>如果父元素不触发BFC，
<code>html
&lt;div class="outer"&gt;
	&lt;div class="inner"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
CSS代码如下：
<code>css
.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}
</code></p>

<p>效果图：</p>

<p><img src="/img/BFC/1.png" alt="不触发BFC时垂直margin重叠" /></p>

<p>可以看到，子元素inner和父元素outer的<code>margin-top</code>重叠了</p>

<p>在outer上触发BFC，修改CSS：
<code>css
.outer {
	background-color: #f0f0f0;
	width: 100%;
	margin-top: 50px;
	overflow: hidden;
}
	.outer .inner {
		width: 100px;
		height: 100px;
		margin-top: 50px;
		background-color: blue;
	}
</code></p>

<p>效果图：
<img src="/img/BFC/2.png" alt="触发BFC后垂直margin不重叠" /></p>

<p>在触发了父元素的BFC，于是乎margin不再重叠</p>

<h3 id="section">不与浮动元素重叠</h3>
<p><code>html
&lt;div class="outer"&gt;
	&lt;div class="left"&gt;&lt;/div&gt;
	&lt;div class="top"&gt;&lt;/div&gt;
&lt;/div&gt;
</code>
```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .top {
	width: 200px;
	height: 100px;
	background-color: red;
} ```
</code></pre>

<p>效果图：</p>

<p><img src="/img/BFC/3.png" alt="两个矩形重叠" /></p>

<p><img src="/img/BFC/4.png" alt="检索left元素" /></p>

<p><img src="/img/BFC/5.png" alt="检索top元素" /></p>

<p>可以从上面三张图看到，两个长方形被重叠了</p>

<p>在非浮动元素（top）上触发BFC，修改CSS:
```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 200px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .top {
	width: 200px;
	height: 100px;
	background-color: red;
	overflow:hidden;
} ```
</code></pre>

<p>效果图：</p>

<p><img src="/img/BFC/6.png" alt="浮动元素与非浮动元素不再重叠" /></p>

<p>两个矩形不再重叠，不过需要注意在非浮动元素上触发BFC</p>

<h3 id="section-1">清除元素内部浮动</h3>
<p><code>html
&lt;div class="outer"&gt;
	&lt;div class="left"&gt;&lt;/div&gt;
	&lt;div class="right"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></p>

<p>```css
.outer {
	background-color: #f0f0f0;
	width: 100%;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .right {
	width: 100px;
	height: 100px;
	background-color: red;
	float: right;
} ``` 效果图：
</code></pre>

<p><img src="/img/BFC/7.png" alt="outer没有被浮动元素撑开" /></p>

<p>可以看到，outer并没有被撑开，查看元素发现其高度为0px</p>

<p>修改css在outer上触发BFC：
```
.outer {
	background-color: #f0f0f0;
	width: 100%;
	overflow: hidden;
}
	.outer .left {
		width: 100px;
		height: 100px;
		background-color: blue;
		float: left;
	}</p>

<pre><code>.outer .right {
	width: 100px;
	height: 100px;
	background-color: red;
	float: right;
} ``` 效果图：
</code></pre>

<p><img src="/img/BFC/8.png" alt="触发BFC后outer被浮动元素撑开" /></p>

<p>在outer上触发BFC后可以看到，outer的高度变成了100px，被left和right两个浮动元素撑开了</p>

<h2 id="section-2">参考文献</h2>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context">Block formatting context</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/26/BFC.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊一聊优雅降级、渐进增强和移动先行 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/25/design-strategies.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>前端开发，最重要的是让更多的人访问到我们的页面，并给他们优秀的用户体验。但在这美丽而残酷的世界，总有那么一些事情不尽如人意，浏览器之间差异便是其中一个。如今网页开发者和网页设计师们需要一个优秀的设计策略来引导跨浏览器、跨设备网页开发。这里就介绍了三种主流的设计策略。</p>

<h2 id="section">浏览器兼容设计策略</h2>
<p>###优雅降级(适度退化)
一般情况下，我们总是希望自己的网页能在所有的浏览器中能正常工作，但事实总是那么的残酷（因为M记的IE）。一种比较常见的策略，名叫优雅降级(也叫适度退化)。也就是先使得网页能在所有的现代浏览器中正常工作（不一定是最新，一般是当前最新版本的上一个发行版本），然后通过代码来监测网页能否在用户使用的老式浏览器中正常工作。比如IE自身的盒子模型问题，开发者就会根据具体的IE版本实现来进行降级。也就是说，如果使用优雅降级的策略，我们需要实现整个网页的所有功能和效果，为无法支持所有功能的浏览器专门去制定一些候选方案，关注其中的核心功能，在老式浏览器上降低用户体验而保持核心功能能够正常工作。</p>

<h3 id="section-1">渐进增强</h3>
<p>渐进增强的策略与优雅降级相反。首先从能被所有浏览器所支持的基本功能开始，逐步的去添加现代浏览器所支持的功能。用户体验中内容为王，在网页实现时最重要的就是将主要内容展现给用户。渐进增强就很符合这个理念。</p>

<p>要实现渐进增强，首先需要为所有设备准备好清晰的语义化HTML以及完善的内容，再通过无侵入的方式想页面中增加无害于基础浏览器的额外样式和功能。这样当浏览器更新换代时，就会不断提升用户体验</p>

<h3 id="section-2">不要为了兼容舍弃新技术</h3>
<p>有很多人整日只关注老式浏览器上的表现情况，和他们一谈HTML5和CSS3，他们的态度是：“IE6（7）支持吗？不支持用（学）它干嘛”，我很鄙视这种想法。我们不应该仅仅为了照顾那些老古董（老式浏览器用户），而阻碍大批量现代浏览器用户享受CSS3和HTML5所带来的优秀视觉体验和交互设计。同时浏览器本身也会随着时间而变得更加强大，老式浏览器所占的份额也越来越小，没理由不去使用CSS3和HTML5。</p>

<h2 id="section-3">响应式页面设计策略</h2>
<p>###移动先行
在响应式页面设计时我们需要考虑的几个问题：
1. 允许更多的人访问我们的网页（目前77%的人拥有手机，2011年出售的85%手机安装了浏览器）
2. 让设计者关注核心的内容和功能（如果你失去了屏幕大小的80%你会怎么做？）
3. 让设计者关注新技术，热爱创新（地理位置、触碰事件等等）</p>

<p>响应式页面的核心内容：
1. 根据设备的屏幕大小流式布局
2. 伸缩的图片和媒体保证在任何屏幕大小中完整显示
3. 通过为媒体查询增加断点</p>

<p>如今，随着移动互联网的发展，移动设备（智能手机、平板电脑等）所占有的比重越来越重，这也决定了视口大小的多种多样。同时随着传统数字设备（台式机、笔记本电脑、上网本）的发展，其视口大小也在不断扩大。这也导致了需要兼容的最大视口与最小视口的大小的差距逐渐增大。响应式web设计业应运而生。我们的目标就是（没有蛀牙！），让我们的页面兼容更多的设备。但是需要注意的是，将页面做成响应式页面只是权宜之计，最好的方法（预算够）是为移动端设备专门开发一个页面。这样可以为移动端设备做一些针对性的优化。</p>

<p>移动先行就是一种响应式页面设计策略，采用渐进增强的思想。最初只是为移动端的小视口设备（智能手机等）展现核心内容和功能，然后通过媒体查询为中视口设备（平板电脑等）添加更多的功能和视觉效果，再在大视口传统数字设备（台式机、笔记本电脑）上添加所有的内容和更加复杂的视觉效果，最后为了兼容超大视口（高分屏），可以适当加大原有内容的显示效果，并同时保持内容居中。</p>

<h3 id="section-4">参考文献</h3>
<p><a href="http://fatesinger.com/764.html">渐进增强与优雅降级</a></p>

<p><a href="http://bradfrostweb.com/blog/web/mobile-first-responsive-web-design/">Mobile-First Responsive Web Design</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/25/design-strategies.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊一聊优雅降级、渐进增强和移动先行 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/25/design-strategies.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>前端开发，最重要的是让更多的人访问到我们的页面，并给他们优秀的用户体验。但在这美丽而残酷的世界，总有那么一些事情不尽如人意，浏览器之间差异便是其中一个。如今网页开发者和网页设计师们需要一个优秀的设计策略来引导跨浏览器、跨设备网页开发。这里就介绍了三种主流的设计策略。</p>

<h2 id="section">浏览器兼容设计策略</h2>
<p>###优雅降级(适度退化)
一般情况下，我们总是希望自己的网页能在所有的浏览器中能正常工作，但事实总是那么的残酷（因为M记的IE）。一种比较常见的策略，名叫优雅降级(也叫适度退化)。也就是先使得网页能在所有的现代浏览器中正常工作（不一定是最新，一般是当前最新版本的上一个发行版本），然后通过代码来监测网页能否在用户使用的老式浏览器中正常工作。比如IE自身的盒子模型问题，开发者就会根据具体的IE版本实现来进行降级。也就是说，如果使用优雅降级的策略，我们需要实现整个网页的所有功能和效果，为无法支持所有功能的浏览器专门去制定一些候选方案，关注其中的核心功能，在老式浏览器上降低用户体验而保持核心功能能够正常工作。</p>

<h3 id="section-1">渐进增强</h3>
<p>渐进增强的策略与优雅降级相反。首先从能被所有浏览器所支持的基本功能开始，逐步的去添加现代浏览器所支持的功能。用户体验中内容为王，在网页实现时最重要的就是将主要内容展现给用户。渐进增强就很符合这个理念。</p>

<p>要实现渐进增强，首先需要为所有设备准备好清晰的语义化HTML以及完善的内容，再通过无侵入的方式想页面中增加无害于基础浏览器的额外样式和功能。这样当浏览器更新换代时，就会不断提升用户体验</p>

<h3 id="section-2">不要为了兼容舍弃新技术</h3>
<p>有很多人整日只关注老式浏览器上的表现情况，和他们一谈HTML5和CSS3，他们的态度是：“IE6（7）支持吗？不支持用（学）它干嘛”，我很鄙视这种想法。我们不应该仅仅为了照顾那些老古董（老式浏览器用户），而阻碍大批量现代浏览器用户享受CSS3和HTML5所带来的优秀视觉体验和交互设计。同时浏览器本身也会随着时间而变得更加强大，老式浏览器所占的份额也越来越小，没理由不去使用CSS3和HTML5。</p>

<h2 id="section-3">响应式页面设计策略</h2>
<p>###移动先行
在响应式页面设计时我们需要考虑的几个问题：
1. 允许更多的人访问我们的网页（目前77%的人拥有手机，2011年出售的85%手机安装了浏览器）
2. 让设计者关注核心的内容和功能（如果你失去了屏幕大小的80%你会怎么做？）
3. 让设计者关注新技术，热爱创新（地理位置、触碰事件等等）</p>

<p>响应式页面的核心内容：
1. 根据设备的屏幕大小流式布局
2. 伸缩的图片和媒体保证在任何屏幕大小中完整显示
3. 通过为媒体查询增加断点</p>

<p>如今，随着移动互联网的发展，移动设备（智能手机、平板电脑等）所占有的比重越来越重，这也决定了视口大小的多种多样。同时随着传统数字设备（台式机、笔记本电脑、上网本）的发展，其视口大小也在不断扩大。这也导致了需要兼容的最大视口与最小视口的大小的差距逐渐增大。响应式web设计业应运而生。我们的目标就是（没有蛀牙！），让我们的页面兼容更多的设备。但是需要注意的是，将页面做成响应式页面只是权宜之计，最好的方法（预算够）是为移动端设备专门开发一个页面。这样可以为移动端设备做一些针对性的优化。</p>

<p>移动先行就是一种响应式页面设计策略，采用渐进增强的思想。最初只是为移动端的小视口设备（智能手机等）展现核心内容和功能，然后通过媒体查询为中视口设备（平板电脑等）添加更多的功能和视觉效果，再在大视口传统数字设备（台式机、笔记本电脑）上添加所有的内容和更加复杂的视觉效果，最后为了兼容超大视口（高分屏），可以适当加大原有内容的显示效果，并同时保持内容居中。</p>

<h3 id="section-4">参考文献</h3>
<p><a href="http://fatesinger.com/764.html">渐进增强与优雅降级</a></p>

<p><a href="http://bradfrostweb.com/blog/web/mobile-first-responsive-web-design/">Mobile-First Responsive Web Design</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/25/design-strategies.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS优先级备忘 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/25/css-selectors-priority.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">常规优先级计算</h2>
<p>一个选择器的优先级是由如下方式计算的：
* 通配符（<code>*</code>）的权重为0
* 元素选择器(<code>div</code>)、伪元素(<code>::before</code>)的权重为1
* 类型选择器(<code>.className</code>)、属性选择器(<code>[someAttr=someValue]</code>)、伪类选择器(<code>:hover</code>)的权重为10
* id选择器（<code>#</code>）的权重为100
* 内联样式（HTML中的<code>style="blahblah"</code>）为1000
* 如果权重一样，后声明的优先</p>

<p>需要注意的是这里的10、100、1000并不是十进制的，进制数很大，在W3C上的原话： Concatenating the three numbers a-b-c (in a number system with a large base) gives the specificity.</p>

<p>确定伪元素有哪些：
* first-letter
* first-line
* before
* after</p>

<p>确伪类有哪些：
* active
* focus
* hover
* link
* visited
* first-child
* lang</p>

<p>需要注意的是伪类和伪元素的差别，伪类的优先级要高于伪元素。伪元素一般使用<code>::first-letter</code>，前面两个冒号，而伪类只有一个。但目前已知处于相互混淆的状态。用一个也是可以的。同时很多人将<code>::before</code>和<code>::after</code>也一起称为伪类，更加混淆了伪类和伪元素。虽然平常使用的时候差别并不大，但在计算优先级权重的时候还是有差别的，需要注意。</p>

<h2 id="section-1">特殊规则</h2>
<p>###!important永远覆盖其他
当!important规则被用在一个样式声明中，这个样式声明会覆盖任何其他声明，无论在声明列表的那个位置，与优先级无关</p>

<p>如下例所示：
<code>html
&lt;div class="outer" style="color:red"&gt;
    &lt;p&gt;这是outer中的一段文字&lt;/p&gt;
&lt;/div&gt;
</code></p>

<p>然后加上outer类的样式：
<code>css
.outer {
    color: green !important;
}
</code>
最终结果:</p>

<p><img src="/img/selector_priority/1.png" alt="结果" /></p>

<p>可见!important凌驾于一切之上</p>

<h3 id="not0">:not伪类的优先级为0</h3>
<p>需要注意的是伪类的优先级为0，比如如下例子：
<code>html
&lt;div class="outer"&gt;
    &lt;p&gt;这是outer中的文本，不属于inner&lt;/p&gt;
    &lt;div class="inner"&gt;
        &lt;p&gt;这是inner中的文本&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code>
给其添加样式如下：
```css
div:not(.outer) p {
    color: green;
}</p>

<p>div.outer p{
    color: red;
}
```
结果如图：</p>

<p><img src="/img/selector_priority/2.png" alt="结果" /></p>

<p>可以看到，outer的color属性为red，很好理解</p>

<p>但inner的color也是red，可以检索一下元素发现：</p>

<p><img src="/img/selector_priority/3.png" alt="结果" /></p>

<p>两个样式都被用在了inner上了，但<code>div.outer p</code>被最终采用。说明<code>div:not(.outer) p</code>的优先级不会大于<code>div.outer p</code>。</p>

<p>接下来给两个样式换个顺序：
```css
div.outer p{
    color: red;
}</p>

<p>div:not(.outer) p {
    color: green;
}
```
F5看看输出效果，inner的color属性变成green了</p>

<p><img src="/img/selector_priority/4.png" alt="结果" /></p>

<p>由此可以看出<code>div.outer p</code>的优先级也不会大于<code>div:not(.outer) p</code>。这俩优先级一样，会按照最后声明的样式进行加载。这也充分证明了<code>:not</code>伪类是没有优先级的</p>

<h2 id="section-2">参考文献</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/CSS/Specificity">MDN的CSS优先级文章</a></p>

<p><a href="http://www.w3.org/TR/selectors/#specificity">CSS3 Selectors Specificity</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/25/css-selectors-priority.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ CSS优先级备忘 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/25/css-selectors-priority.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 25 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">常规优先级计算</h2>
<p>一个选择器的优先级是由如下方式计算的：
* 通配符（<code>*</code>）的权重为0
* 元素选择器(<code>div</code>)、伪元素(<code>::before</code>)的权重为1
* 类型选择器(<code>.className</code>)、属性选择器(<code>[someAttr=someValue]</code>)、伪类选择器(<code>:hover</code>)的权重为10
* id选择器（<code>#</code>）的权重为100
* 内联样式（HTML中的<code>style="blahblah"</code>）为1000
* 如果权重一样，后声明的优先</p>

<p>需要注意的是这里的10、100、1000并不是十进制的，进制数很大，在W3C上的原话： Concatenating the three numbers a-b-c (in a number system with a large base) gives the specificity.</p>

<p>确定伪元素有哪些：
* first-letter
* first-line
* before
* after</p>

<p>确伪类有哪些：
* active
* focus
* hover
* link
* visited
* first-child
* lang</p>

<p>需要注意的是伪类和伪元素的差别，伪类的优先级要高于伪元素。伪元素一般使用<code>::first-letter</code>，前面两个冒号，而伪类只有一个。但目前已知处于相互混淆的状态。用一个也是可以的。同时很多人将<code>::before</code>和<code>::after</code>也一起称为伪类，更加混淆了伪类和伪元素。虽然平常使用的时候差别并不大，但在计算优先级权重的时候还是有差别的，需要注意。</p>

<h2 id="section-1">特殊规则</h2>
<p>###!important永远覆盖其他
当!important规则被用在一个样式声明中，这个样式声明会覆盖任何其他声明，无论在声明列表的那个位置，与优先级无关</p>

<p>如下例所示：
<code>html
&lt;div class="outer" style="color:red"&gt;
    &lt;p&gt;这是outer中的一段文字&lt;/p&gt;
&lt;/div&gt;
</code></p>

<p>然后加上outer类的样式：
<code>css
.outer {
    color: green !important;
}
</code>
最终结果:</p>

<p><img src="/img/selector_priority/1.png" alt="结果" /></p>

<p>可见!important凌驾于一切之上</p>

<h3 id="not0">:not伪类的优先级为0</h3>
<p>需要注意的是伪类的优先级为0，比如如下例子：
<code>html
&lt;div class="outer"&gt;
    &lt;p&gt;这是outer中的文本，不属于inner&lt;/p&gt;
    &lt;div class="inner"&gt;
        &lt;p&gt;这是inner中的文本&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code>
给其添加样式如下：
```css
div:not(.outer) p {
    color: green;
}</p>

<p>div.outer p{
    color: red;
}
```
结果如图：</p>

<p><img src="/img/selector_priority/2.png" alt="结果" /></p>

<p>可以看到，outer的color属性为red，很好理解</p>

<p>但inner的color也是red，可以检索一下元素发现：</p>

<p><img src="/img/selector_priority/3.png" alt="结果" /></p>

<p>两个样式都被用在了inner上了，但<code>div.outer p</code>被最终采用。说明<code>div:not(.outer) p</code>的优先级不会大于<code>div.outer p</code>。</p>

<p>接下来给两个样式换个顺序：
```css
div.outer p{
    color: red;
}</p>

<p>div:not(.outer) p {
    color: green;
}
```
F5看看输出效果，inner的color属性变成green了</p>

<p><img src="/img/selector_priority/4.png" alt="结果" /></p>

<p>由此可以看出<code>div.outer p</code>的优先级也不会大于<code>div:not(.outer) p</code>。这俩优先级一样，会按照最后声明的样式进行加载。这也充分证明了<code>:not</code>伪类是没有优先级的</p>

<h2 id="section-2">参考文献</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/CSS/Specificity">MDN的CSS优先级文章</a></p>

<p><a href="http://www.w3.org/TR/selectors/#specificity">CSS3 Selectors Specificity</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/25/css-selectors-priority.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（CSS动画篇） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/24/CSS3-animation-optimization.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近拜读了一下<a href="http://www.html5rocks.com/">html5rocks</a>上几位大神写的一篇关于CSS3动画性能优化的文章，学到了很多，在这里记录一下，其中的知识都是来源于这俩篇文章，我只是截取了其中比较关注的内容出来，原文地址<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a>及<a href="http://www.html5rocks.com/zh/tutorials/speed/layers/">Accelerated Rendering in Chrome</a></p>

<h2 id="section">原理</h2>
<p>现代浏览器在使用CSS3动画时，以下四种情形绘制的效率较高，分别是：
* 改变位置
* 改变大小
* 旋转
* 改变透明度
###层？重绘？回流和重布局？图层重组？
首先要了解CSS的图层的概念（Chrome浏览器）</p>

<p>浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：
1. 获取DOM后分割为多个图层
2. 对每个图层的节点计算样式结果（Recalculate style–样式重计算）
3. 为每个节点生成图形和位置（Layout–回流和重布局）
4. 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）
5. 图层作为纹理上传至GPU
6. 符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</p>

<p>Chrome中满足以下任意情况就会创建图层：
* 3D或透视变换（perspective transform）CSS属性
* 使用加速视频解码的<code>&lt;video&gt;</code>节点
* 拥有3D（WebGL）上下文或加速的2D上下文的<code>&lt;canvas&gt;</code>节点
* 混合插件（如Flash）
* 对自己的opacity做CSS动画或使用一个动画webkit变换的元素
* 拥有加速CSS过滤器的元素
* 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）
* 元素有一个<code>z-index</code>较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</p>

<p>需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）</p>

<h3 id="css">层和CSS动画</h3>
<p>简化一下上述过程，每一帧动画浏览器可能需要做如下工作：
1. 计算需要被加载到节点上的样式结果（Recalculate style–样式重计算）
2. 为每个节点生成图形和位置（Layout–回流和重布局）
3. 将每个节点填充到图层中（Paint Setup和Paint–重绘）
4. 组合图层到页面上（Composite Layers–图层重组）</p>

<p>如果我们需要使得动画的性能提高，需要做的就是减少浏览器在动画运行时所需要做的工作。最好的情况是，改变的属性仅仅印象图层的组合，变换（<code>transform</code>）和透明度（<code>opacity</code>）就属于这种情况</p>

<p>现代浏览器如Chrome，Firefox，Safari和Opera都对变换和透明度采用硬件加速，但IE10+不是很确定是否硬件加速</p>

<h2 id="section-1">触发重布局的属性</h2>
<p>有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性</p>

<p>一些常用的改变时会触发重布局的属性：
盒子模型相关属性会触发重布局：
* width
* height
* padding
* margin
* display
* border-width
* border
* min-height</p>

<p>定位属性及浮动也会触发重布局：
* top
* bottom
* left
* right
* position
* float
* clear</p>

<p>改变节点内部文字结构也会触发重布局：
* text-align
* overflow-y
* font-weight
* overflow
* font-family
* line-height
* vertival-align
* white-space
* font-size</p>

<p>这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局</p>

<h3 id="css-1">别使用CSS类名做状态标记</h3>
<p>如果在网页中使用CSS的类来对节点做状态标记，当这些节点的状态标记类修改时，将会触发节点的重绘和重布局。所以在节点上使用CSS类来做状态比较是代价很昂贵的</p>

<h2 id="section-2">触发重绘的属性</h2>
<p>修改时只触发重绘的属性有：
* color
* border-style
* border-radius
* visibility
* text-decoration
* background
* background-image
* background-position
* background-repeat
* background-size
* outline-color
* outline
* outline-style
* outline-width
* box-shadow</p>

<p>这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了
###手机就算重绘也很慢
在重绘时，这些节点会被加载到GPU中进行重绘，这对移动设备如手机的影响还是很大的。因为CPU不如台式机或笔记本电脑，所以绘画巫妖的时间更长。而且CPU与GPU之间的有较大的带宽限制，所以纹理的上传需要一定时间</p>

<h2 id="section-3">触发图层重组的属性</h2>
<p>###透明度竟然不会触发重绘？
需要注意的是，上面那些触发重绘的属性里面没有<code>opacity</code>（透明度），很奇怪不是吗？实际上透明度的改变后，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改<code>opacity</code>本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化
###强迫浏览器创建图层
在Blink和WebKit的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃
###Chrome中的抗锯齿
Chrome中，非根图层以及透明图层使用grayscale antialiasing而不是subpixel antialiasing，如果抗锯齿方法变化，这个效果将会非常显著。如果你打算预处理一个节点而不打算等到动画开始，可以通过这种强迫浏览器创建图层的方式进行
###transform变换是你的选择
我们通过节点的<code>transform</code>可以修改节点的位置、旋转、大小等。我们平常会使用<code>left</code>和<code>top</code>属性来修改节点的位置，但正如上面所述，<code>left</code>和<code>top</code>会触发重布局，修改时的代价相当大。取而代之的更好方法是使用<code>translate</code>，这个不会触发重布局</p>

<h2 id="jscss3">JS动画和CSS3动画的比较</h2>
<p>我们经常面临一个抉择：是使用JavaScript的动画还是使用CSS的动画，下面将对比一下这两种方式
###JS动画
缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况。</p>

<p>优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成</p>

<h3 id="css-2">CSS动画</h3>
<p>缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题。
优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行。</p>

<h2 id="section-4">前瞻</h2>
<p>Google目前正在探究通过JS的多线程（Web Workers）来提供更好的动画效果，而不会触发重布局及样式重计算</p>

<h2 id="section-5">结论</h2>
<p>动画给予了页面丰富的视觉体验。我们应该尽力避免使用会触发重布局和重绘的属性，以免失帧。最好提前申明动画，这样能让浏览器提前对动画进行优化。由于GPU的参与，现在用来做动画的最好属性是如下几个：
* opacity
* translate
* rotate
* scale</p>

<p>也许会有一些新的方式使得可以使用JavaScript做出更好的没有限制的动画，而且不用担心主线程的阻塞问题。但在那之前，还是好好考虑下如何做出流畅的动画吧</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/24/CSS3-animation-optimization.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（CSS动画篇） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/24/CSS3-animation-optimization.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 24 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近拜读了一下<a href="http://www.html5rocks.com/">html5rocks</a>上几位大神写的一篇关于CSS3动画性能优化的文章，学到了很多，在这里记录一下，其中的知识都是来源于这俩篇文章，我只是截取了其中比较关注的内容出来，原文地址<a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">High Performance Animations</a>及<a href="http://www.html5rocks.com/zh/tutorials/speed/layers/">Accelerated Rendering in Chrome</a></p>

<h2 id="section">原理</h2>
<p>现代浏览器在使用CSS3动画时，以下四种情形绘制的效率较高，分别是：
* 改变位置
* 改变大小
* 旋转
* 改变透明度
###层？重绘？回流和重布局？图层重组？
首先要了解CSS的图层的概念（Chrome浏览器）</p>

<p>浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染DOM的时候，浏览器所做的工作实际上是：
1. 获取DOM后分割为多个图层
2. 对每个图层的节点计算样式结果（Recalculate style–样式重计算）
3. 为每个节点生成图形和位置（Layout–回流和重布局）
4. 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）
5. 图层作为纹理上传至GPU
6. 符合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组）</p>

<p>Chrome中满足以下任意情况就会创建图层：
* 3D或透视变换（perspective transform）CSS属性
* 使用加速视频解码的<code>&lt;video&gt;</code>节点
* 拥有3D（WebGL）上下文或加速的2D上下文的<code>&lt;canvas&gt;</code>节点
* 混合插件（如Flash）
* 对自己的opacity做CSS动画或使用一个动画webkit变换的元素
* 拥有加速CSS过滤器的元素
* 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）
* 元素有一个<code>z-index</code>较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）</p>

<p>需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。所以这需要通过特殊的方式来强制gif图属于自己一个图层（<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>），CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）</p>

<h3 id="css">层和CSS动画</h3>
<p>简化一下上述过程，每一帧动画浏览器可能需要做如下工作：
1. 计算需要被加载到节点上的样式结果（Recalculate style–样式重计算）
2. 为每个节点生成图形和位置（Layout–回流和重布局）
3. 将每个节点填充到图层中（Paint Setup和Paint–重绘）
4. 组合图层到页面上（Composite Layers–图层重组）</p>

<p>如果我们需要使得动画的性能提高，需要做的就是减少浏览器在动画运行时所需要做的工作。最好的情况是，改变的属性仅仅印象图层的组合，变换（<code>transform</code>）和透明度（<code>opacity</code>）就属于这种情况</p>

<p>现代浏览器如Chrome，Firefox，Safari和Opera都对变换和透明度采用硬件加速，但IE10+不是很确定是否硬件加速</p>

<h2 id="section-1">触发重布局的属性</h2>
<p>有些节点，当你改变他时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。所以需要尽力避免这些属性</p>

<p>一些常用的改变时会触发重布局的属性：
盒子模型相关属性会触发重布局：
* width
* height
* padding
* margin
* display
* border-width
* border
* min-height</p>

<p>定位属性及浮动也会触发重布局：
* top
* bottom
* left
* right
* position
* float
* clear</p>

<p>改变节点内部文字结构也会触发重布局：
* text-align
* overflow-y
* font-weight
* overflow
* font-family
* line-height
* vertival-align
* white-space
* font-size</p>

<p>这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局</p>

<h3 id="css-1">别使用CSS类名做状态标记</h3>
<p>如果在网页中使用CSS的类来对节点做状态标记，当这些节点的状态标记类修改时，将会触发节点的重绘和重布局。所以在节点上使用CSS类来做状态比较是代价很昂贵的</p>

<h2 id="section-2">触发重绘的属性</h2>
<p>修改时只触发重绘的属性有：
* color
* border-style
* border-radius
* visibility
* text-decoration
* background
* background-image
* background-position
* background-repeat
* background-size
* outline-color
* outline
* outline-style
* outline-width
* box-shadow</p>

<p>这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了
###手机就算重绘也很慢
在重绘时，这些节点会被加载到GPU中进行重绘，这对移动设备如手机的影响还是很大的。因为CPU不如台式机或笔记本电脑，所以绘画巫妖的时间更长。而且CPU与GPU之间的有较大的带宽限制，所以纹理的上传需要一定时间</p>

<h2 id="section-3">触发图层重组的属性</h2>
<p>###透明度竟然不会触发重绘？
需要注意的是，上面那些触发重绘的属性里面没有<code>opacity</code>（透明度），很奇怪不是吗？实际上透明度的改变后，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改<code>opacity</code>本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化
###强迫浏览器创建图层
在Blink和WebKit的浏览器中，一当一个节点被设定了透明度的相关过渡效果或动画时，浏览器会将其作为一个单独的图层，但很多开发者使用<code>translateZ(0)</code>或者<code>translate3d(0,0,0)</code>去使浏览器创建图层。这种方式可以消除在动画开始之前的图层创建时间，使得动画尽快开始（创建图层和绘制图层还是比较慢的），而且不会随着抗锯齿而导出突变。不过这种方法需要节制，否则会因为创建过多的图层导致崩溃
###Chrome中的抗锯齿
Chrome中，非根图层以及透明图层使用grayscale antialiasing而不是subpixel antialiasing，如果抗锯齿方法变化，这个效果将会非常显著。如果你打算预处理一个节点而不打算等到动画开始，可以通过这种强迫浏览器创建图层的方式进行
###transform变换是你的选择
我们通过节点的<code>transform</code>可以修改节点的位置、旋转、大小等。我们平常会使用<code>left</code>和<code>top</code>属性来修改节点的位置，但正如上面所述，<code>left</code>和<code>top</code>会触发重布局，修改时的代价相当大。取而代之的更好方法是使用<code>translate</code>，这个不会触发重布局</p>

<h2 id="jscss3">JS动画和CSS3动画的比较</h2>
<p>我们经常面临一个抉择：是使用JavaScript的动画还是使用CSS的动画，下面将对比一下这两种方式
###JS动画
缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况。</p>

<p>优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成</p>

<h3 id="css-2">CSS动画</h3>
<p>缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题。
优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行。</p>

<h2 id="section-4">前瞻</h2>
<p>Google目前正在探究通过JS的多线程（Web Workers）来提供更好的动画效果，而不会触发重布局及样式重计算</p>

<h2 id="section-5">结论</h2>
<p>动画给予了页面丰富的视觉体验。我们应该尽力避免使用会触发重布局和重绘的属性，以免失帧。最好提前申明动画，这样能让浏览器提前对动画进行优化。由于GPU的参与，现在用来做动画的最好属性是如下几个：
* opacity
* translate
* rotate
* scale</p>

<p>也许会有一些新的方式使得可以使用JavaScript做出更好的没有限制的动画，而且不用担心主线程的阻塞问题。但在那之前，还是好好考虑下如何做出流畅的动画吧</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/24/CSS3-animation-optimization.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（Application Cache篇） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/20/application-cache.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前在segmentfault上刷问题看到一个关于manifest的问题，很好奇就研究了一下application cache。Application Cache是HTML5的新特性，允许浏览器在本地存储页面所需要的资源，使得页面离线也可以访问。之前研究的目的是为了在博客中使用，将一些不需要改动的CSS、JavaScript、图片文件离线缓存，这样加载速度必然飞起，希望能用在博客上，但是失败了，但还是记录一下学到的知识</p>

<h2 id="application-cache">Application Cache的配置文件</h2>
<p>首先需要在服务器上建立一个文件，里面的内容确定了哪些文件需要缓存，哪些文件不需要，如果资源无法访问会使用什么页面等</p>

<p>这个文件一般为<code>.appcache</code>类型，称为<strong>缓存清单(cache manifest)文件</strong>，一个完整的缓存清单文件如下：
```
CACHE MANIFEST
# version xx.xx.xx
CACHE:
needBeCached.png
needBeCached2.js</p>

<p>NETWORK:
notNeedBeCached.html
notNeedBeCached2.css</p>

<p>FALLBACK:
/ 404.html
<code>
可以看到，文件的头部信息</code>CACHE MANIFEST```用来标注这个文件是缓存清单文件，其后一般情况下（最好是）跟着一行标明版本的注释，这行注释非常重要，将在后面文件加载部分详细介绍这行注释的重要性</p>

<h3 id="cache">CACHE部分</h3>
<p>除了头部信息，这个缓存清单文件分为几部分，第一部分为CACHE部分: 
<code>
CACHE:
needBeCached.png
needBeCached2.js
</code>
这一部分标注了哪些资源文件需要被缓存可以列出多个</p>

<p>如果有路径，如需要缓存blog下的blog.css文件，可以写成<code>blog/blog.css</code>。</p>

<p>另外<code>CACHE:</code>可以被省略，让需要缓存的资源文件直接跟在注释之后</p>

<h3 id="network">NETWORK部分</h3>
<p>第二部分为NETWORK部分：
<code>
NETWORK:
notNeedBeCached.html
notNeedBeCached2.css
</code>
这一部分定义了哪些文件不需要缓存，这些文件需要与服务器连接</p>

<p>与CACHE一样，可以定义多个资源，而如果直接输入一个文件夹路径，也是合法的，比如<code>/blog</code>这样，blog文件夹下的所有文件都不会被缓存</p>

<p>可以使用通配符来，如除了上面CACHE中定义的资源，其他都必须与服务器连接：
<code>
NETWORK:
*
</code></p>

<p>需要注意一点是，载有这个manifest文件的HTML文档将一定会缓存，这个会在后面再次提到</p>

<h3 id="fallback">FALLBACK部分</h3>
<p>第三部分为FALLBACK部分：
<code>
FALLBACK:
/ 404.html
</code>
这一部分指定了一个后备页面，当资源无法访问时，浏览器会使用该页面</p>

<p>同样可以定义多条记录，每条记录列出两个URI，一个表示资源，一个表示后备页面。需要注意的是两个资源文件都需要使用相对路径切与manifest文件同源</p>

<p>同样可以使用通配符</p>

<h3 id="manifest">保存和引用manifest文件</h3>
<p>manifest文件可以保存在服务器上，保存为<code>.appcache</code>后缀，但必须与应用本身同源。在HTML文档中，可以指定清单文件的相对路径和绝对URL。需要注意的是，manifest文件的MIME类型必须是<code>text/cache-manifest</code></p>

<p>需要在HTML文档中引入manifest文件，可以使用类似如下代码：
<code>html
&lt;!doctype html&gt;
&lt;html manifest="manifest.appcache"&gt;
...
&lt;/html&gt;
</code>
这样，HTML文档加载后，就会根据manifest.appcache的内容来缓存资源文件，在下次访问相同页面的时候，会直接使用缓存的资源文件来进行加速</p>

<h2 id="section">缓存和加载机制</h2>
<p>在第一次访问时，浏览器加载完HTML文档后，会查看其是否有引入manifest文件。若引入，则加载manifest文件，然后根据manifest的文件内容进行资源的缓存，并缓存当前文档</p>

<p>之后访问，浏览器首先会查看manifest文件是否被修改（无论是内容还是注释），如果被修改，将当做第一次访问，重新根据manifest文件内容进行缓存</p>

<p>如果应用缓存存在，且manifest没有被修改，浏览器直接从缓存中加载文档（注意：加载文档）和资源，不会访问网络（注意：无论联网与否，都不会访问网络）</p>

<p>在缓存多个资源文件时，浏览器下载资源文件会先放在一个临时的缓存中，如果有任何一个资源文件下载失败，浏览器将停止其他缓存资源的下载，并清除临时缓存。如果所有资源文件都被成功下载，浏览器将会把这些资源文件以及引用manifest文件的HTML文档移动到永久离线缓存中</p>

<h2 id="section-1">满满的都是坑</h2>
<p>###一些小坑
1. 需要注意的是manifest文件放在服务器上，MIME类型必须是<code>text/cache-manifest</code>，如果使用 Apache，需要修改.htaccess文件。IE下默认application/octet-stream，需要在服务器指定
2. 每个需要缓存的页面的html都需要加入manifest属性
3. 不要将manifest文件本身加入缓存，如果加入，浏览器将不会检测到服务器上manifest的更新，页面版本将万年不变
4. 不要以为一个资源文件加载失败，其他文件就会被缓存，原因参见缓存和加载机制的最后一段</p>

<h3 id="section-2">一些大坑</h3>
<ol>
  <li>在manifest文件中定义的资源全部被成功加载后，这些资源文件连同<strong>引用manifest文件的HTML文档</strong>一并被移动到永久离线缓存中。所以如果想只缓存js、css、图片等文件，而不希望缓存HTML文档以保持获得最新内容的情况来说，这就是个大坑</li>
  <li>根据Application Cache的加载机制，如果仅仅修改资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改manifest文件，以触发资源文件的重新加载和缓存。这其中，最有效的方式是修改manifest文件内部的版本注释（所以说那句注释相当重要）</li>
  <li>如果资源没有被缓存，在而没有设置NETWORK的情况下，将会无法加载（浏览器不会去网络上进行加载），所以需要使用通配符来表明除了CACHE中确定的资源以外，其他资源都需要去网络上加载</li>
</ol>

<h3 id="iframe">使用iframe来避开一号坑？</h3>
<p>网上传言避开一号坑的方法是使用iframe来指定需要缓存的资源，而避开HTML文档的缓存。具体做法是在HTML中嵌入一个iframe，iframe中的页面的HTML标签包含manifest属性引用manifest文件，里面定义了需要缓存的文件。这样就会只缓存iframe中的HTML文档，而持续更新主页面：
```html
&lt;!doctype html&gt;
&lt;html lang="zh"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>主页面</title>
    <link rel="stylesheet" href="css/style.css" />
    <script src="js/javascript.js"></script>
</head>
<body>
    <iframe src="cache.html"></iframe>
</body>
<p>&lt;/html&gt;
<code>
可以看到，主页面的html标签中，并没有引入manifest文件。只是在其中加载了一个iframe，而这个iframe所加载的页面文档如下：
</code>html
&lt;!DOCTYPE html&gt;
&lt;html manifest="manifest.appcache"&gt;</p>
<head>
    &lt;meta charset=utf-8 /&gt;
    <title>缓存页面</title>
</head>
<body>
</body>
<p>&lt;/html&gt;
<code>
缓存页面中引入了manifest文件，这样浏览器就会缓存manifest文件中定义的资源列表，比如这里manifest文件的内容如下：
</code>
CACHE MANIFEST
# VERSION 1.0</p>

<p>CACHE:
css/someStyle.css
js/someJavaScript.js</p>

<p>NETWORK:
*
<code>
在chrome中运行，可以在命令行中看到如下效果：
</code>
Creating Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache Downloading event
Application Cache Progress event (0 of 2) http://localhost:8000/css/someStyle.css
Application Cache Progress event (1 of 2) http://localhost:8000/js/someJavaScript.js
Application Cache Progress event (2 of 2)
Application Cache Cached event 
<code>
浏览器缓存了manifest文件中定义的资源文件，其实同时还缓存了iframe中的缓存页面的文档，但不会缓存主页面，修改一下主页面，并按F5刷新
</code>
Document was loaded from Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache NoUpdate event 
<code>
可以看到主页面被更新了，但是someStyle.css和someJavaScript.js文件依旧从网络上加载了，而没有从cache中加载。打开chrome的</code>chrome://appcache-internals/<code>可以看到，里面cache.html、someStyle.css、someJavaScript.js确实被缓存了，去掉NETWORK段，结果也是一样
</code>
Flags       URL                                         Size (headers and data)
Master,     http://localhost:8000/cache.html            388 B
Explicit,   http://localhost:8000/css/someStyle.css     228 B
Explicit,   http://localhost:8000/js/someJavaScript.js  244 B
Manifest,   http://localhost:8000/manifest.appcache     316 B
```
在firefox、opera上测试也是一样，虽然被缓存了，但依旧会从网络上加载，而iframe的解答方法也是2011~2012年左右提出的，后来就没有相关文章了，估计已经彻底失效了</p>

<h2 id="section-3">总结</h2>
<p>Application主要是为了构建离线缓存，使得页面在离线模式下也能浏览。这比较适合一些页面上的应用以及静态的不经常变更的页面。其会缓存载体页面也是由于其机制。如果上面iframe机制实现有错误，或是有其他方法只缓存资源不缓存HTML文档，请联系我</p>

<h2 id="section-4">参考资料</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache">使用应用缓存</a></p>

<p><a href="http://zoomzhao.com/2012/11/08/application-cache-is-a-douchebag/">Application Cache 就是个坑</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/20/application-cache.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 前端性能优化（Application Cache篇） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/20/application-cache.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 20 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前在segmentfault上刷问题看到一个关于manifest的问题，很好奇就研究了一下application cache。Application Cache是HTML5的新特性，允许浏览器在本地存储页面所需要的资源，使得页面离线也可以访问。之前研究的目的是为了在博客中使用，将一些不需要改动的CSS、JavaScript、图片文件离线缓存，这样加载速度必然飞起，希望能用在博客上，但是失败了，但还是记录一下学到的知识</p>

<h2 id="application-cache">Application Cache的配置文件</h2>
<p>首先需要在服务器上建立一个文件，里面的内容确定了哪些文件需要缓存，哪些文件不需要，如果资源无法访问会使用什么页面等</p>

<p>这个文件一般为<code>.appcache</code>类型，称为<strong>缓存清单(cache manifest)文件</strong>，一个完整的缓存清单文件如下：
```
CACHE MANIFEST
# version xx.xx.xx
CACHE:
needBeCached.png
needBeCached2.js</p>

<p>NETWORK:
notNeedBeCached.html
notNeedBeCached2.css</p>

<p>FALLBACK:
/ 404.html
<code>
可以看到，文件的头部信息</code>CACHE MANIFEST```用来标注这个文件是缓存清单文件，其后一般情况下（最好是）跟着一行标明版本的注释，这行注释非常重要，将在后面文件加载部分详细介绍这行注释的重要性</p>

<h3 id="cache">CACHE部分</h3>
<p>除了头部信息，这个缓存清单文件分为几部分，第一部分为CACHE部分: 
<code>
CACHE:
needBeCached.png
needBeCached2.js
</code>
这一部分标注了哪些资源文件需要被缓存可以列出多个</p>

<p>如果有路径，如需要缓存blog下的blog.css文件，可以写成<code>blog/blog.css</code>。</p>

<p>另外<code>CACHE:</code>可以被省略，让需要缓存的资源文件直接跟在注释之后</p>

<h3 id="network">NETWORK部分</h3>
<p>第二部分为NETWORK部分：
<code>
NETWORK:
notNeedBeCached.html
notNeedBeCached2.css
</code>
这一部分定义了哪些文件不需要缓存，这些文件需要与服务器连接</p>

<p>与CACHE一样，可以定义多个资源，而如果直接输入一个文件夹路径，也是合法的，比如<code>/blog</code>这样，blog文件夹下的所有文件都不会被缓存</p>

<p>可以使用通配符来，如除了上面CACHE中定义的资源，其他都必须与服务器连接：
<code>
NETWORK:
*
</code></p>

<p>需要注意一点是，载有这个manifest文件的HTML文档将一定会缓存，这个会在后面再次提到</p>

<h3 id="fallback">FALLBACK部分</h3>
<p>第三部分为FALLBACK部分：
<code>
FALLBACK:
/ 404.html
</code>
这一部分指定了一个后备页面，当资源无法访问时，浏览器会使用该页面</p>

<p>同样可以定义多条记录，每条记录列出两个URI，一个表示资源，一个表示后备页面。需要注意的是两个资源文件都需要使用相对路径切与manifest文件同源</p>

<p>同样可以使用通配符</p>

<h3 id="manifest">保存和引用manifest文件</h3>
<p>manifest文件可以保存在服务器上，保存为<code>.appcache</code>后缀，但必须与应用本身同源。在HTML文档中，可以指定清单文件的相对路径和绝对URL。需要注意的是，manifest文件的MIME类型必须是<code>text/cache-manifest</code></p>

<p>需要在HTML文档中引入manifest文件，可以使用类似如下代码：
<code>html
&lt;!doctype html&gt;
&lt;html manifest="manifest.appcache"&gt;
...
&lt;/html&gt;
</code>
这样，HTML文档加载后，就会根据manifest.appcache的内容来缓存资源文件，在下次访问相同页面的时候，会直接使用缓存的资源文件来进行加速</p>

<h2 id="section">缓存和加载机制</h2>
<p>在第一次访问时，浏览器加载完HTML文档后，会查看其是否有引入manifest文件。若引入，则加载manifest文件，然后根据manifest的文件内容进行资源的缓存，并缓存当前文档</p>

<p>之后访问，浏览器首先会查看manifest文件是否被修改（无论是内容还是注释），如果被修改，将当做第一次访问，重新根据manifest文件内容进行缓存</p>

<p>如果应用缓存存在，且manifest没有被修改，浏览器直接从缓存中加载文档（注意：加载文档）和资源，不会访问网络（注意：无论联网与否，都不会访问网络）</p>

<p>在缓存多个资源文件时，浏览器下载资源文件会先放在一个临时的缓存中，如果有任何一个资源文件下载失败，浏览器将停止其他缓存资源的下载，并清除临时缓存。如果所有资源文件都被成功下载，浏览器将会把这些资源文件以及引用manifest文件的HTML文档移动到永久离线缓存中</p>

<h2 id="section-1">满满的都是坑</h2>
<p>###一些小坑
1. 需要注意的是manifest文件放在服务器上，MIME类型必须是<code>text/cache-manifest</code>，如果使用 Apache，需要修改.htaccess文件。IE下默认application/octet-stream，需要在服务器指定
2. 每个需要缓存的页面的html都需要加入manifest属性
3. 不要将manifest文件本身加入缓存，如果加入，浏览器将不会检测到服务器上manifest的更新，页面版本将万年不变
4. 不要以为一个资源文件加载失败，其他文件就会被缓存，原因参见缓存和加载机制的最后一段</p>

<h3 id="section-2">一些大坑</h3>
<ol>
  <li>在manifest文件中定义的资源全部被成功加载后，这些资源文件连同<strong>引用manifest文件的HTML文档</strong>一并被移动到永久离线缓存中。所以如果想只缓存js、css、图片等文件，而不希望缓存HTML文档以保持获得最新内容的情况来说，这就是个大坑</li>
  <li>根据Application Cache的加载机制，如果仅仅修改资源文件的内容（没有修改资源文件的路径或名称），浏览器将直接从本地离线缓存中获取资源文件。所以在每次修改资源文件的同时，需要修改manifest文件，以触发资源文件的重新加载和缓存。这其中，最有效的方式是修改manifest文件内部的版本注释（所以说那句注释相当重要）</li>
  <li>如果资源没有被缓存，在而没有设置NETWORK的情况下，将会无法加载（浏览器不会去网络上进行加载），所以需要使用通配符来表明除了CACHE中确定的资源以外，其他资源都需要去网络上加载</li>
</ol>

<h3 id="iframe">使用iframe来避开一号坑？</h3>
<p>网上传言避开一号坑的方法是使用iframe来指定需要缓存的资源，而避开HTML文档的缓存。具体做法是在HTML中嵌入一个iframe，iframe中的页面的HTML标签包含manifest属性引用manifest文件，里面定义了需要缓存的文件。这样就会只缓存iframe中的HTML文档，而持续更新主页面：
```html
&lt;!doctype html&gt;
&lt;html lang="zh"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>主页面</title>
    <link rel="stylesheet" href="css/style.css" />
    <script src="js/javascript.js"></script>
</head>
<body>
    <iframe src="cache.html"></iframe>
</body>
<p>&lt;/html&gt;
<code>
可以看到，主页面的html标签中，并没有引入manifest文件。只是在其中加载了一个iframe，而这个iframe所加载的页面文档如下：
</code>html
&lt;!DOCTYPE html&gt;
&lt;html manifest="manifest.appcache"&gt;</p>
<head>
    &lt;meta charset=utf-8 /&gt;
    <title>缓存页面</title>
</head>
<body>
</body>
<p>&lt;/html&gt;
<code>
缓存页面中引入了manifest文件，这样浏览器就会缓存manifest文件中定义的资源列表，比如这里manifest文件的内容如下：
</code>
CACHE MANIFEST
# VERSION 1.0</p>

<p>CACHE:
css/someStyle.css
js/someJavaScript.js</p>

<p>NETWORK:
*
<code>
在chrome中运行，可以在命令行中看到如下效果：
</code>
Creating Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache Downloading event
Application Cache Progress event (0 of 2) http://localhost:8000/css/someStyle.css
Application Cache Progress event (1 of 2) http://localhost:8000/js/someJavaScript.js
Application Cache Progress event (2 of 2)
Application Cache Cached event 
<code>
浏览器缓存了manifest文件中定义的资源文件，其实同时还缓存了iframe中的缓存页面的文档，但不会缓存主页面，修改一下主页面，并按F5刷新
</code>
Document was loaded from Application Cache with manifest http://localhost:8000/manifest.appcache
Application Cache Checking event
Application Cache NoUpdate event 
<code>
可以看到主页面被更新了，但是someStyle.css和someJavaScript.js文件依旧从网络上加载了，而没有从cache中加载。打开chrome的</code>chrome://appcache-internals/<code>可以看到，里面cache.html、someStyle.css、someJavaScript.js确实被缓存了，去掉NETWORK段，结果也是一样
</code>
Flags       URL                                         Size (headers and data)
Master,     http://localhost:8000/cache.html            388 B
Explicit,   http://localhost:8000/css/someStyle.css     228 B
Explicit,   http://localhost:8000/js/someJavaScript.js  244 B
Manifest,   http://localhost:8000/manifest.appcache     316 B
```
在firefox、opera上测试也是一样，虽然被缓存了，但依旧会从网络上加载，而iframe的解答方法也是2011~2012年左右提出的，后来就没有相关文章了，估计已经彻底失效了</p>

<h2 id="section-3">总结</h2>
<p>Application主要是为了构建离线缓存，使得页面在离线模式下也能浏览。这比较适合一些页面上的应用以及静态的不经常变更的页面。其会缓存载体页面也是由于其机制。如果上面iframe机制实现有错误，或是有其他方法只缓存资源不缓存HTML文档，请联系我</p>

<h2 id="section-4">参考资料</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache">使用应用缓存</a></p>

<p><a href="http://zoomzhao.com/2012/11/08/application-cache-is-a-douchebag/">Application Cache 就是个坑</a></p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/20/application-cache.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ PL/SQL编写存储函数 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/19/plsql-and-storage-function.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="plsql">PL/SQL安装</h2>
<hr />
<p><a href="http://pan.baidu.com/s/1ntwisrB">PL/SQL和Oracle920整合的压缩包</a>
提取码：cgsf</p>

<p>下载后由”PL_SQL_DEV_9 + Oracle920.rar”解压并安装</p>

<h3 id="oracle920">安装Oracle920</h3>
<ol>
  <li>解压压缩包，建议将Oracle920文件夹放在D盘根目录下，否则需要修改其注册表文件中的路径</li>
  <li>运行注册表文件oracle.reg</li>
  <li>在环境变量中添加bin文件夹路径，如放在D盘根目录下，则添加D:\oracle920\bin</li>
</ol>

<h3 id="plsql-1">安装pl/sql</h3>
<ol>
  <li>解压压缩包</li>
  <li>运行plsqldev906.exe安装</li>
  <li>运行chinese.exe添加中文补丁</li>
</ol>

<h3 id="section">注意事项</h3>
<ol>
  <li>若Oracle920路径不放在D盘根目录下，运行注册表文件oracle.reg文件前，用文本编辑工具打开，将所有涉及路径的地方修改成Oracle920文件夹的路径</li>
  <li>请在32位机上安装，64位自行百度解决方法</li>
</ol>

<h3 id="plsql-2">修改pl/sql登录时的服务器可选项</h3>
<p>由于无锡、绥化的Oracle服务器IP地址出现变更，需要修改服务器地址</p>

<p>存放地址的文件为(Oracle920所在文件夹)/Oracle920/network/ADMIN/tnsnames.ora，使用文本编辑工具打开</p>

<p>可以看到其中有类似代码：
<code>
hiservice_197 =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.197)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SID = hiservic)
    )
  )
</code>
其中<code>hiservice_197</code>即为PL/SQl选择服务器的服务器名。<code>HOST = 192.168.0.197</code>定义了IP地址，<code>PORT = 1521</code>定义了端口，<code>SID = hiservic</code>定义了连接的数据库，可以根据需要进行修改，或者按照同样的规则在文档最后进行添加</p>

<h2 id="plsql-3">PL/SQL使用</h2>
<p>###一般CRUD操作
很简单，在菜单 文件-&gt;新建-&gt;SQL窗口 来创建新的SQL窗口，在窗口中敲入SQL语句，按F8执行</p>

<p>若要通过图形界面进行新增、修改、删除，请在SQL语句后增加<code>for update</code>代码，比如原语句为<code>select * from user_info</code>，则修改为<code>select * from user_info for update</code>。</p>

<p>在执行前，点击SQL框下的“小锁”开启增加、删除、修改权限，使用“小锁”旁边的“加号”和“减号”来新增删除数据，修改直接单击需要修改的数据格即可。</p>

<p>修改完成后点击一下旁边的“绿勾”确认，然后点击左上角主菜单下的“提交按钮”或按F10进行提交，否则事务不会提交，修改不会生效</p>

<h3 id="section-1">存储过程相关</h3>
<p>在有友好插件的文本编辑工具中写完存储过程后，若要全部执行，可以直接复制到同上的SQL框</p>

<p>如需一个一个定义执行，可以在菜单 文件-&gt;新建-&gt;命令窗口 来创建命令行，然后通过复制代码的方式写入存储过程的结构和函数，最后一行加<code>/</code>来标志结束。在命令行中需要检测是否含有某结构或函数，可以使用<code>desc</code>进行查看，如检测某Object结构或Table结构是否存在，可以使用（xxxx为结构名）：
<code>sql
desc type xxxx
</code>
若要检测函数或表信息，则（xxxx为函数名或表名）：
<code>sql
desc xxxx
</code>
若需要检查编译错误，在菜单  文件-&gt;新建-&gt;程序窗口 来进行调试，比如存储函数，可以新建Function窗口，模板向导若已有代码，可以不必填写，点击确定后直接用已有代码进行覆盖即可。使用F8来编译，若编译错误，底下会显示编译错误的原因及产生错误的行数</p>

<p>若存储过程中有输出语句如<code>DBMS_OUTPUT.PUTLINE(xxxx)</code>则在SQL窗口中运行，运行完成后点击输出标签页查看输出</p>

<h2 id="section-2">一些存储函数实例</h2>
<p>###定义元数据结构
一般使用存储函数都是为了将现有的数据库表中的不规则的数据整理，生成iReport比较容易生成报表的结构。所以首先需要定义报表中需要的每一条数据的样式：
<code>sql
CREATE OR REPLACE TYPE objectName AS OBJECT (
    property_name_1 varchar2(255),
    property_name_2 number
);
</code>
其中<code>objectName</code>为结构名，<code>property_name_x</code>为属性名</p>

<p>这样就定义了一个简单的有一个字符串属性，一个数字属性的元数据结构。
###定义临时表结构
由于一般情况下都需要存储函数输出一整张每行都是这个结构的表，所以需要定义通过这个元数据结构组织成的表结构：
<code>sql
create or replace type tableName table of objectName;
</code>
其中<code>tableName</code>为表结构的名称，<code>objectName</code>为这个表结构所使用元数据结构的名称
###定义存储函数
定义存储函数：
<code>sql
create or replace function functionName(param1 number, param2 number)
return tableName pipelined
as
v_row objectName;
--变量定义
begin
--函数体
return;
end;
</code>
其中<code>functionName</code>为存储函数的名称，<code>tableName</code>为存储函数返回表结构的名称，<code>objectName</code>为表结构使用的元数据结构的名称</p>

<p>需要注意变量定义部分，所有后面使用到的变量都需要在这里先行定义</p>

<p>这个函数中定义了两个参数<code>param1</code>和<code>param2</code>，若不需要使用参数，则第一行直接改为<code>create or replace function functionName</code>，函数名后不需要添加括号
###遍历数据库中表获取数据
在函数体中通过<code>for in</code>遍历已有的表：
<code>
for itemName in (
    --sql语句
) loop
    --对表每一行数据进行操作
end loop;
</code>
这里sql语句和平常的sql语句没有太大区别，唯一的区别是可以使用变量作为<code>where</code>中的判断条件的参数，如有两个number型变量startTime，endTime，可以直接使用语句<code>where fieldName &lt; endTime and fieldName &gt;= startTime</code></p>

<h3 id="section-3">将单个结果输出到变量</h3>
<p>有的时候只需要一个统计结果，通过sql的聚集函数来实现，若需要将其结果存入变量中，可以使用<code>into</code>来实现：
<code>sql
select count(someUtTableName.id) into v_number_type_var
from someUtTableName
where balabala
</code>
这样就将count的结果存入到名叫<code>v_number_type_var</code>的变量之中了，这个变量需要在前面先行定义</p>

<h3 id="section-4">将数据组织成表</h3>
<p>若需要将数据组织成结构，添加到返回表中：
<code>sql
v_row := objectName('abc', 123);
pip row(v_row);
</code>
其中<code>objectName</code>为元数据结构，<code>v_row</code>为元数据结构的变量，这样就相当于往结果的表里增加了一行。括号里面可以使用变量，但类型必须与元数据结构定义严格一致。</p>

<h3 id="section-5">在函数中增加调试用的输出</h3>
<p>在函数体中加入如下代码:
<code>sql
DBMS_OUTPUT.PUTLINE('test information');
</code>
即可在运行的时候产生输出，括号内可以使用变量。在SQL框的输出标签页查看输出结果</p>

<h3 id="section-6">注释</h3>
<p>使用<code>--注释内容</code>来添加单行注释</p>

<p>使用<code>/*注释内容*/</code>来添加多行注释</p>

<h3 id="section-7">调用存储函数</h3>
<p>已经写好的存储函数需要在sql中进行调用，在写入iReport之前可以先在pl/sql中测试一下，比如已有存储函数functionName，接受两个number参数，则：
<code>sql
select * from table(functionName(123, 456))
</code>
若无参数，直接<code>from table(functionName())</code>即可。将其当做一张表来看，可以使用<code>group by</code>、<code>order by</code>、<code>where</code>等。select也可以选择需要的字段或改名</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/19/plsql-and-storage-function.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ PL/SQL编写存储函数 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/19/plsql-and-storage-function.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 19 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="plsql">PL/SQL安装</h2>
<hr />
<p><a href="http://pan.baidu.com/s/1ntwisrB">PL/SQL和Oracle920整合的压缩包</a>
提取码：cgsf</p>

<p>下载后由”PL_SQL_DEV_9 + Oracle920.rar”解压并安装</p>

<h3 id="oracle920">安装Oracle920</h3>
<ol>
  <li>解压压缩包，建议将Oracle920文件夹放在D盘根目录下，否则需要修改其注册表文件中的路径</li>
  <li>运行注册表文件oracle.reg</li>
  <li>在环境变量中添加bin文件夹路径，如放在D盘根目录下，则添加D:\oracle920\bin</li>
</ol>

<h3 id="plsql-1">安装pl/sql</h3>
<ol>
  <li>解压压缩包</li>
  <li>运行plsqldev906.exe安装</li>
  <li>运行chinese.exe添加中文补丁</li>
</ol>

<h3 id="section">注意事项</h3>
<ol>
  <li>若Oracle920路径不放在D盘根目录下，运行注册表文件oracle.reg文件前，用文本编辑工具打开，将所有涉及路径的地方修改成Oracle920文件夹的路径</li>
  <li>请在32位机上安装，64位自行百度解决方法</li>
</ol>

<h3 id="plsql-2">修改pl/sql登录时的服务器可选项</h3>
<p>由于无锡、绥化的Oracle服务器IP地址出现变更，需要修改服务器地址</p>

<p>存放地址的文件为(Oracle920所在文件夹)/Oracle920/network/ADMIN/tnsnames.ora，使用文本编辑工具打开</p>

<p>可以看到其中有类似代码：
<code>
hiservice_197 =
  (DESCRIPTION =
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.197)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SID = hiservic)
    )
  )
</code>
其中<code>hiservice_197</code>即为PL/SQl选择服务器的服务器名。<code>HOST = 192.168.0.197</code>定义了IP地址，<code>PORT = 1521</code>定义了端口，<code>SID = hiservic</code>定义了连接的数据库，可以根据需要进行修改，或者按照同样的规则在文档最后进行添加</p>

<h2 id="plsql-3">PL/SQL使用</h2>
<p>###一般CRUD操作
很简单，在菜单 文件-&gt;新建-&gt;SQL窗口 来创建新的SQL窗口，在窗口中敲入SQL语句，按F8执行</p>

<p>若要通过图形界面进行新增、修改、删除，请在SQL语句后增加<code>for update</code>代码，比如原语句为<code>select * from user_info</code>，则修改为<code>select * from user_info for update</code>。</p>

<p>在执行前，点击SQL框下的“小锁”开启增加、删除、修改权限，使用“小锁”旁边的“加号”和“减号”来新增删除数据，修改直接单击需要修改的数据格即可。</p>

<p>修改完成后点击一下旁边的“绿勾”确认，然后点击左上角主菜单下的“提交按钮”或按F10进行提交，否则事务不会提交，修改不会生效</p>

<h3 id="section-1">存储过程相关</h3>
<p>在有友好插件的文本编辑工具中写完存储过程后，若要全部执行，可以直接复制到同上的SQL框</p>

<p>如需一个一个定义执行，可以在菜单 文件-&gt;新建-&gt;命令窗口 来创建命令行，然后通过复制代码的方式写入存储过程的结构和函数，最后一行加<code>/</code>来标志结束。在命令行中需要检测是否含有某结构或函数，可以使用<code>desc</code>进行查看，如检测某Object结构或Table结构是否存在，可以使用（xxxx为结构名）：
<code>sql
desc type xxxx
</code>
若要检测函数或表信息，则（xxxx为函数名或表名）：
<code>sql
desc xxxx
</code>
若需要检查编译错误，在菜单  文件-&gt;新建-&gt;程序窗口 来进行调试，比如存储函数，可以新建Function窗口，模板向导若已有代码，可以不必填写，点击确定后直接用已有代码进行覆盖即可。使用F8来编译，若编译错误，底下会显示编译错误的原因及产生错误的行数</p>

<p>若存储过程中有输出语句如<code>DBMS_OUTPUT.PUTLINE(xxxx)</code>则在SQL窗口中运行，运行完成后点击输出标签页查看输出</p>

<h2 id="section-2">一些存储函数实例</h2>
<p>###定义元数据结构
一般使用存储函数都是为了将现有的数据库表中的不规则的数据整理，生成iReport比较容易生成报表的结构。所以首先需要定义报表中需要的每一条数据的样式：
<code>sql
CREATE OR REPLACE TYPE objectName AS OBJECT (
    property_name_1 varchar2(255),
    property_name_2 number
);
</code>
其中<code>objectName</code>为结构名，<code>property_name_x</code>为属性名</p>

<p>这样就定义了一个简单的有一个字符串属性，一个数字属性的元数据结构。
###定义临时表结构
由于一般情况下都需要存储函数输出一整张每行都是这个结构的表，所以需要定义通过这个元数据结构组织成的表结构：
<code>sql
create or replace type tableName table of objectName;
</code>
其中<code>tableName</code>为表结构的名称，<code>objectName</code>为这个表结构所使用元数据结构的名称
###定义存储函数
定义存储函数：
<code>sql
create or replace function functionName(param1 number, param2 number)
return tableName pipelined
as
v_row objectName;
--变量定义
begin
--函数体
return;
end;
</code>
其中<code>functionName</code>为存储函数的名称，<code>tableName</code>为存储函数返回表结构的名称，<code>objectName</code>为表结构使用的元数据结构的名称</p>

<p>需要注意变量定义部分，所有后面使用到的变量都需要在这里先行定义</p>

<p>这个函数中定义了两个参数<code>param1</code>和<code>param2</code>，若不需要使用参数，则第一行直接改为<code>create or replace function functionName</code>，函数名后不需要添加括号
###遍历数据库中表获取数据
在函数体中通过<code>for in</code>遍历已有的表：
<code>
for itemName in (
    --sql语句
) loop
    --对表每一行数据进行操作
end loop;
</code>
这里sql语句和平常的sql语句没有太大区别，唯一的区别是可以使用变量作为<code>where</code>中的判断条件的参数，如有两个number型变量startTime，endTime，可以直接使用语句<code>where fieldName &lt; endTime and fieldName &gt;= startTime</code></p>

<h3 id="section-3">将单个结果输出到变量</h3>
<p>有的时候只需要一个统计结果，通过sql的聚集函数来实现，若需要将其结果存入变量中，可以使用<code>into</code>来实现：
<code>sql
select count(someUtTableName.id) into v_number_type_var
from someUtTableName
where balabala
</code>
这样就将count的结果存入到名叫<code>v_number_type_var</code>的变量之中了，这个变量需要在前面先行定义</p>

<h3 id="section-4">将数据组织成表</h3>
<p>若需要将数据组织成结构，添加到返回表中：
<code>sql
v_row := objectName('abc', 123);
pip row(v_row);
</code>
其中<code>objectName</code>为元数据结构，<code>v_row</code>为元数据结构的变量，这样就相当于往结果的表里增加了一行。括号里面可以使用变量，但类型必须与元数据结构定义严格一致。</p>

<h3 id="section-5">在函数中增加调试用的输出</h3>
<p>在函数体中加入如下代码:
<code>sql
DBMS_OUTPUT.PUTLINE('test information');
</code>
即可在运行的时候产生输出，括号内可以使用变量。在SQL框的输出标签页查看输出结果</p>

<h3 id="section-6">注释</h3>
<p>使用<code>--注释内容</code>来添加单行注释</p>

<p>使用<code>/*注释内容*/</code>来添加多行注释</p>

<h3 id="section-7">调用存储函数</h3>
<p>已经写好的存储函数需要在sql中进行调用，在写入iReport之前可以先在pl/sql中测试一下，比如已有存储函数functionName，接受两个number参数，则：
<code>sql
select * from table(functionName(123, 456))
</code>
若无参数，直接<code>from table(functionName())</code>即可。将其当做一张表来看，可以使用<code>group by</code>、<code>order by</code>、<code>where</code>等。select也可以选择需要的字段或改名</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/19/plsql-and-storage-function.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计中的HTML5 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/15/responsive-html5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/14/responsive-web-design/">《聊聊响应式网页设计》</a></p>

<p>继上一篇《聊聊响应式网页设计》。这一篇记录了响应式网页设计中的HTML5部分。</p>

<h3 id="html5">HTML5带来了什么？</h3>

<h3 id="html5-1">何为HTML5？</h3>
<p>何为HTML5？wiki上的定义：HTML5是HTML下一个主要的修订版本，现在仍处于发展阶段。目标是取代1999年所制定的HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到符合当代的网络需求。</p>

<h3 id="section">多了些啥？</h3>
<p>相比较HTML4.01而言，其新增了很多有实质价值的东西。具体来说，HTML5添加了许多新的语法特征，其中包括<code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code>,和<code>&lt;canvas&gt;</code>元素，同时集成了SVG内容。这些元素是为了更容易的在网页中添加和处理多媒体和图片内容而添加的。其它新的元素包括<code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;header&gt;</code>, 和<code>&lt;nav&gt;</code>,是为了丰富文档的数据内容。新的属性的添加也是为了同样的目的。同时也有一些属性和元素被移除掉了。一些元素，像<code>&lt;a&gt;</code>, 和<code>&lt;menu&gt;</code>被修改，重新定义或标准化了。同时APIs和DOM已经成为HTML5中的基础部分了。HTML5还定义了处理非法文档的具体细节，使得所有浏览器和客户端程序能够一致地处理语法错误。</p>

<h3 id="html5-2">为什么现在开始HTML5？</h3>
<p>几乎所有现代浏览器都能正确理解常见的HTML5属性，其提供的新的结构元素、视频、音频标签对于老版本的IE可以使用腻子脚本（一段能给老版本浏览器带来新特性的JavaScript代码，如<a href="http://modernizr.com/">Modernizr</a>）来弥补。</p>

<h2 id="html5-3">如何编写HTML5页面？</h2>
<p>###使用HTML5文档类型声明
如果你使用了Emmet（原名zencoding），在页面中敲入<code>html:5</code>代码，按下CTRL+E，就会自动扩展成如下代码：
```html
&lt;!doctype html&gt;
&lt;html lang="en"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    
</body>
<p>&lt;/html&gt;
```
可以看到第一行的文档声明很简洁，没错，这就是HTML5的文档声明。</p>

<p>还记得其他的文档声明吗？
<code>html
&lt;!-- HTML4.01文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;!-- HTML4.01文档严格定义类型，此类型定义的文档可以使用HTML中的标签与元素，不能包含不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;!-- XHTML1.0文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!-- XHTML1.0文档严格定义类型，此类型定义的文档只可以使用HTML中定义的标签与元素，不能包含不被W3C推荐的标签（例如：font、b）(梦之都就使用了此类型)，不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;!-- XHTML1.0文档框架定义类型，等同于XHTML1.0文档过渡定义类型，但可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;
&lt;!-- XHTML1.1文档严格定义类型，等同于XHTML1.0文档过渡定义类型 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
</code></p>

<p>我勒个凑，为什么HTML5的文档声明如此简短？因为HTML5是以简洁的方式高速浏览器用“标准模式”渲染页面。这种思想贯穿HTML5始终。</p>

<h2 id="html5-4">细谈HTML5带来的改变</h2>
<p>###大小写？无所谓~
下面这两句代码实际上是一样的效果：
<code>html
&lt;img src="someImage.png" alt="someImage"&gt;
&lt;img SRC="someImage.png" aLt="someImage"&gt;
</code>
###引号？无所谓~
下面这两句也是一样的：
<code>html
&lt;div id="wrapper"&gt;&lt;/div&gt;
&lt;div id=wrapper&gt;&lt;/div&gt;
</code>
###闭合？那是XML才干的事~
下面这两句也是一样的：
<code>html
&lt;img src="someImage.png" alt="someImage"&gt;
&lt;img src="someImage.png" alt="someImage"/&gt;
</code>
###省略type，敲码更轻松
link标签和script的标签，经常被使用，而主要是CSS文件和JavaScript文件，何不将其作为默认？下面其实也是一样的
```html
<link href="CSS/main.css" rel="stylesheet" type="text/css" />
&lt;link href=CSS/main.css rel=stylesheet&gt;</p>

<script type="text/javascript"></script>

<script></script>

<p>```</p>

<h3 id="a">a标签能嵌套多个标签了</h3>
<p>如今，<code>&lt;a&gt;</code>标签之中可以嵌套一组元素了。不过需要注意的是，<code>&lt;a&gt;</code>标签不能嵌套<code>&lt;a&gt;</code>标签，也不能在<code>&lt;a&gt;</code>标签中嵌套表单</p>

<h3 id="section-1">增加了很多语义化元素</h3>
<p>HTML5中新增了很多语义化元素，使得HTML也能真正表达页面本质了，这个将在下面详细介绍</p>

<h2 id="section-2">新来的语义化元素们</h2>

<h3 id="section-3">section</h3>

<p>元素<code>&lt;section&gt;</code>用来定义文档或应用程序中的区域（或节）。它的主要功能是为了区分内容区域，如果只是想包裹起来便于设置样式的话，还是用<code>&lt;div&gt;</code>吧。HTML5允许每个<code>&lt;section&gt;</code>容器有自己独立的大钢结构</p>

<p>比如这个博客中的侧边栏就有类似如下代码：
```html</p>
<section>
    <header>
        <h2>最近的文章</h2>
    </header>
    <ul></ul>
</section>
<section>
    <header>
        <h2>文章类别</h2>
    </header>
    <ul></ul>
</section>
<section>
    <header>
        <h2>文章标签</h2>
    </header>
    <div></div>
</section>
<p>```
其中使用section将最近文章、文章类别、文章标签的区域区分开来</p>

<h3 id="nav">nav</h3>
<p>元素<code>&lt;nav&gt;</code>用来定义文档的主导航区域，其中的连接指向其他页面或是当前页面的其他区域。其中经常包含一组链接</p>

<p>比如在这个博客中，左侧的导航栏中有如下代码：
```html</p>
<nav>
    <ul>
        <li><a href="/index.html">首页</a></li>
        <li><a href="/archieves.html">所有文章</a></li>
        <li><a href="/items.html">小玩意儿</a></li>
        <li><a href="/about.html">关于我</a></li>
    </ul>
</nav>
<p>```
用来包含最核心的导航链接</p>

<h3 id="article">article</h3>
<p>元素<code>&lt;article&gt;</code>用来包裹独立的内容片断。和<code>&lt;section&gt;</code>很相似。《响应式Web设计》书上对他们俩的区分是真么说的：</p>

<p><em>当搭建一个页面是，想想你准备放入<code>&lt;article&gt;</code>标签的内容能否作为一个整块而被复制黏贴到另外一个完全不同的网站且能保持完整的意义？另一种办法是，想想包裹在<code>&lt;article&gt;</code>中的内容能否在RSS订阅源中独立成一篇文章？应该使用<code>&lt;article&gt;</code>标签包裹的内容，最明显的例子就是博客正文</em></p>

<h3 id="aside">aside</h3>
<p>元素<code>&lt;aside&gt;</code>用来表示与页面主内容松散相关的内容，实践中，一般用来做侧边栏，另外像引文、广告以及导航元素（友情链接）也可以使用</p>

<h3 id="hgroup">hgroup</h3>
<p>如果有页面有一组<code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>标签时，可以考虑使用<code>hgroup</code>将他们包裹，这样HTML5大纲的算法就会只提取第一个标题元素进入文档大纲</p>

<h3 id="header">header</h3>
<p>元素<code>&lt;header&gt;</code>不会被计入大纲，所以不能用其来划分内容结构，应该使用它来包含对区域内容的介绍说明。<code>&lt;header&gt;</code>可以用作网站头部的“刊头”区域，也可以用作对其他内容如<code>&lt;article&gt;</code>元素的简要介绍</p>

<h3 id="footer">footer</h3>
<p>元素<code>&lt;footer&gt;</code>与<code>&lt;header&gt;</code>一样,不会计入大钢结构,所以不能用于划分内容结构,但它可以用来包含一些其所在区域的辅助信息,比如一些超链接和版权信息啥的</p>

<h3 id="address">address</h3>
<p>元素<code>&lt;address&gt;</code>用于标注其最近的<code>&lt;article&gt;</code>或<code>&lt;body&gt;</code>祖先元素的联系信息</p>

<h2 id="section-4">为你的网页生成大纲吧</h2>

<p>书中介绍了两个将html转换成大纲的网站: <a href="http://gsnedders.html5.org/outliner/">HTML5 Outliner by gsnedders</a>和<a href="http://hoyois.github.io/html5outliner/">HTML5 Outliner by hoyois</a>，其中第二个需要用firefox打开</p>

<p>两者都支持直接输入URL、上传HTML文件、直接敲入HTML内容来生成大纲</p>

<p>比如下面这一段HTML，一个很常见的HTML文档：
```html
&lt;!doctype html&gt;
&lt;html lang="zh"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>标题</title>
</head>
<body>
    <h1>整个文章的主题</h1>
    <header>
        <nav>
            <hgroup>
                <h1>主导航条</h1>
                <h2>这里放置最主要的导航</h2>
            </hgroup>
            <ul>
                <li>导航1</li>
                <li>导航2</li>
                <li>导航3</li>
            </ul>
        </nav>
    </header>
    <aside>
        <h2>侧边栏</h2>
        <section>
            <h3>侧边栏区域1</h3>
            <ul></ul>
        </section>
        <section>
            <h3>侧边栏区域2</h3>
            <ul></ul>
        </section>
        <section>
            <h3>侧边栏区域3</h3>
            <ul></ul>
        </section>
    </aside>
    <section>
        <h1>内容</h1>
        <article>
            <hgroup>
                <h1>第一篇文章</h1>
                <h2>文章副标题</h2>
                <h3>文章描述</h3>
            </hgroup>
            <header>
                <nav>
                    <h2>文章内部导航</h2>
                    <ul>
                        <li>导航1</li>
                        <li>导航2</li>
                        <li>导航3</li>
                    </ul>
                </nav>
            </header>
            <p>正文内容</p>
        </article>
        <article>
            <hgroup>
                <h1>第二篇文章</h1>
                <h2>文章副标题</h2>
                <h3>文章描述</h3>
            </hgroup>
            <header>
                <nav>
                    <h2>文章内部导航</h2>
                    <ul>
                        <li>导航1</li>
                        <li>导航2</li>
                        <li>导航3</li>
                    </ul>
                </nav>
            </header>
            <p>正文内容</p>
        </article>
    </section>
    <footer>一些版权信息</footer>
</body>
<p>&lt;/html&gt;
```
生成的大纲如下：</p>

<ol>
  <li>整个文章的主题
    <ol>
      <li>主导航条</li>
      <li>侧边栏
        <ol>
          <li>侧边栏区域1</li>
          <li>侧边栏区域2</li>
          <li>侧边栏区域3</li>
        </ol>
      </li>
      <li>内容
        <ol>
          <li>第一篇文章
            <ol>
              <li>文章内部导航</li>
            </ol>
          </li>
          <li>第二篇文章
            <ol>
              <li>文章内部导航</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="html5-5">HTML5的文本级语义元素</h2>

<h3 id="b">b</h3>
<p>元素<code>&lt;b&gt;</code>通常用来给文本加粗，如今可以将其仅仅作为样式钩子来使用了</p>

<h3 id="em">em</h3>
<p>元素<code>&lt;em&gt;</code>，HTML5中赋予它的语义是：强调内容中的重点</p>

<h3 id="i">i</h3>
<p>元素<code>&lt;i&gt;</code>，过去只是给文本加斜体，如今它表示的语义是：一小段有不同于语态或语气的文字，或者样子上与普通文章有所差异以便标明不同特点的文字</p>

<p>注意这些元素，其中<code>&lt;b&gt;</code>已然会被很多浏览器默认渲染为粗体，而<code>&lt;i&gt;</code>则会被渲染为斜体，可以通过设置样式重置来消除浏览器默认的渲染效果</p>

<h2 id="html5-6">HTML5的多媒体标签</h2>
<p>###视频标签video
如今绝大部分浏览器都支持HTML5的视频和音频，就连IE也从9就支持了，放心大胆的去用吧</p>

<p>使用<code>&lt;video src="myVideo.ogg"&gt;&lt;/video&gt;</code>来嵌入视频，同时可以增加一些其他属性如：
* width：播放器的宽度
* height： 播放器的高度
* controls：为播放器添加控制栏
* autoplay：播放器加载完后自动对视频进行播放
* preload：媒体预加载
* loop：重复播放视频
* poster：定义视频缩略图</p>

<p>同时，由于每个浏览器自身支持的视频格式的不同，可以为了兼容不同的浏览器，定义一个视频源栈，浏览器会从栈顶向下查找，如果找到能播放的格式，就忽略后面的源，对其进行播放，代码如下：
<code>html
&lt;video width="640" height="360" contorls autoplay preload="auto" loop poster="myVidelPost.jpg"&gt;
    &lt;source src="video/myVideo.ogv" type="video/ogg"&gt;
    &lt;source src="video/myVideo.mp4" type="video/mp4"&gt;
&lt;/video&gt;
</code></p>

<h3 id="audio">audio</h3>
<p>元素<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>基本一致，除了width、height、poster外基本相同，但<code>audio</code>没有可视区域</p>

<h3 id="section-5">响应式设计中的视频</h3>
<p>通过设置width和height为百分比来达到响应式的效果，但这样没办法解决iframe中视频的响应问题，可以使用JavaScript来解决，其中<a href="http://fitvidsjs.com/">FitVids</a>就是一个用来解决iframe中视频响应问题的jQuery插件</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/15/responsive-html5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计中的HTML5 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/15/responsive-html5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 15 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/14/responsive-web-design/">《聊聊响应式网页设计》</a></p>

<p>继上一篇《聊聊响应式网页设计》。这一篇记录了响应式网页设计中的HTML5部分。</p>

<h3 id="html5">HTML5带来了什么？</h3>

<h3 id="html5-1">何为HTML5？</h3>
<p>何为HTML5？wiki上的定义：HTML5是HTML下一个主要的修订版本，现在仍处于发展阶段。目标是取代1999年所制定的HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到符合当代的网络需求。</p>

<h3 id="section">多了些啥？</h3>
<p>相比较HTML4.01而言，其新增了很多有实质价值的东西。具体来说，HTML5添加了许多新的语法特征，其中包括<code>&lt;video&gt;</code>, <code>&lt;audio&gt;</code>,和<code>&lt;canvas&gt;</code>元素，同时集成了SVG内容。这些元素是为了更容易的在网页中添加和处理多媒体和图片内容而添加的。其它新的元素包括<code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;header&gt;</code>, 和<code>&lt;nav&gt;</code>,是为了丰富文档的数据内容。新的属性的添加也是为了同样的目的。同时也有一些属性和元素被移除掉了。一些元素，像<code>&lt;a&gt;</code>, 和<code>&lt;menu&gt;</code>被修改，重新定义或标准化了。同时APIs和DOM已经成为HTML5中的基础部分了。HTML5还定义了处理非法文档的具体细节，使得所有浏览器和客户端程序能够一致地处理语法错误。</p>

<h3 id="html5-2">为什么现在开始HTML5？</h3>
<p>几乎所有现代浏览器都能正确理解常见的HTML5属性，其提供的新的结构元素、视频、音频标签对于老版本的IE可以使用腻子脚本（一段能给老版本浏览器带来新特性的JavaScript代码，如<a href="http://modernizr.com/">Modernizr</a>）来弥补。</p>

<h2 id="html5-3">如何编写HTML5页面？</h2>
<p>###使用HTML5文档类型声明
如果你使用了Emmet（原名zencoding），在页面中敲入<code>html:5</code>代码，按下CTRL+E，就会自动扩展成如下代码：
```html
&lt;!doctype html&gt;
&lt;html lang="en"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    
</body>
<p>&lt;/html&gt;
```
可以看到第一行的文档声明很简洁，没错，这就是HTML5的文档声明。</p>

<p>还记得其他的文档声明吗？
<code>html
&lt;!-- HTML4.01文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;!-- HTML4.01文档严格定义类型，此类型定义的文档可以使用HTML中的标签与元素，不能包含不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;
&lt;!-- XHTML1.0文档过渡定义类型，此类型定义的文档可以使用HTML中的标签与元素包括一些不被W3C推荐的标签（例如：font、b等），不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!-- XHTML1.0文档严格定义类型，此类型定义的文档只可以使用HTML中定义的标签与元素，不能包含不被W3C推荐的标签（例如：font、b）(梦之都就使用了此类型)，不可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;!-- XHTML1.0文档框架定义类型，等同于XHTML1.0文档过渡定义类型，但可以使用框架 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;
&lt;!-- XHTML1.1文档严格定义类型，等同于XHTML1.0文档过渡定义类型 --&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;
</code></p>

<p>我勒个凑，为什么HTML5的文档声明如此简短？因为HTML5是以简洁的方式高速浏览器用“标准模式”渲染页面。这种思想贯穿HTML5始终。</p>

<h2 id="html5-4">细谈HTML5带来的改变</h2>
<p>###大小写？无所谓~
下面这两句代码实际上是一样的效果：
<code>html
&lt;img src="someImage.png" alt="someImage"&gt;
&lt;img SRC="someImage.png" aLt="someImage"&gt;
</code>
###引号？无所谓~
下面这两句也是一样的：
<code>html
&lt;div id="wrapper"&gt;&lt;/div&gt;
&lt;div id=wrapper&gt;&lt;/div&gt;
</code>
###闭合？那是XML才干的事~
下面这两句也是一样的：
<code>html
&lt;img src="someImage.png" alt="someImage"&gt;
&lt;img src="someImage.png" alt="someImage"/&gt;
</code>
###省略type，敲码更轻松
link标签和script的标签，经常被使用，而主要是CSS文件和JavaScript文件，何不将其作为默认？下面其实也是一样的
```html
<link href="CSS/main.css" rel="stylesheet" type="text/css" />
&lt;link href=CSS/main.css rel=stylesheet&gt;</p>

<script type="text/javascript"></script>

<script></script>

<p>```</p>

<h3 id="a">a标签能嵌套多个标签了</h3>
<p>如今，<code>&lt;a&gt;</code>标签之中可以嵌套一组元素了。不过需要注意的是，<code>&lt;a&gt;</code>标签不能嵌套<code>&lt;a&gt;</code>标签，也不能在<code>&lt;a&gt;</code>标签中嵌套表单</p>

<h3 id="section-1">增加了很多语义化元素</h3>
<p>HTML5中新增了很多语义化元素，使得HTML也能真正表达页面本质了，这个将在下面详细介绍</p>

<h2 id="section-2">新来的语义化元素们</h2>

<h3 id="section-3">section</h3>

<p>元素<code>&lt;section&gt;</code>用来定义文档或应用程序中的区域（或节）。它的主要功能是为了区分内容区域，如果只是想包裹起来便于设置样式的话，还是用<code>&lt;div&gt;</code>吧。HTML5允许每个<code>&lt;section&gt;</code>容器有自己独立的大钢结构</p>

<p>比如这个博客中的侧边栏就有类似如下代码：
```html</p>
<section>
    <header>
        <h2>最近的文章</h2>
    </header>
    <ul></ul>
</section>
<section>
    <header>
        <h2>文章类别</h2>
    </header>
    <ul></ul>
</section>
<section>
    <header>
        <h2>文章标签</h2>
    </header>
    <div></div>
</section>
<p>```
其中使用section将最近文章、文章类别、文章标签的区域区分开来</p>

<h3 id="nav">nav</h3>
<p>元素<code>&lt;nav&gt;</code>用来定义文档的主导航区域，其中的连接指向其他页面或是当前页面的其他区域。其中经常包含一组链接</p>

<p>比如在这个博客中，左侧的导航栏中有如下代码：
```html</p>
<nav>
    <ul>
        <li><a href="/index.html">首页</a></li>
        <li><a href="/archieves.html">所有文章</a></li>
        <li><a href="/items.html">小玩意儿</a></li>
        <li><a href="/about.html">关于我</a></li>
    </ul>
</nav>
<p>```
用来包含最核心的导航链接</p>

<h3 id="article">article</h3>
<p>元素<code>&lt;article&gt;</code>用来包裹独立的内容片断。和<code>&lt;section&gt;</code>很相似。《响应式Web设计》书上对他们俩的区分是真么说的：</p>

<p><em>当搭建一个页面是，想想你准备放入<code>&lt;article&gt;</code>标签的内容能否作为一个整块而被复制黏贴到另外一个完全不同的网站且能保持完整的意义？另一种办法是，想想包裹在<code>&lt;article&gt;</code>中的内容能否在RSS订阅源中独立成一篇文章？应该使用<code>&lt;article&gt;</code>标签包裹的内容，最明显的例子就是博客正文</em></p>

<h3 id="aside">aside</h3>
<p>元素<code>&lt;aside&gt;</code>用来表示与页面主内容松散相关的内容，实践中，一般用来做侧边栏，另外像引文、广告以及导航元素（友情链接）也可以使用</p>

<h3 id="hgroup">hgroup</h3>
<p>如果有页面有一组<code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>标签时，可以考虑使用<code>hgroup</code>将他们包裹，这样HTML5大纲的算法就会只提取第一个标题元素进入文档大纲</p>

<h3 id="header">header</h3>
<p>元素<code>&lt;header&gt;</code>不会被计入大纲，所以不能用其来划分内容结构，应该使用它来包含对区域内容的介绍说明。<code>&lt;header&gt;</code>可以用作网站头部的“刊头”区域，也可以用作对其他内容如<code>&lt;article&gt;</code>元素的简要介绍</p>

<h3 id="footer">footer</h3>
<p>元素<code>&lt;footer&gt;</code>与<code>&lt;header&gt;</code>一样,不会计入大钢结构,所以不能用于划分内容结构,但它可以用来包含一些其所在区域的辅助信息,比如一些超链接和版权信息啥的</p>

<h3 id="address">address</h3>
<p>元素<code>&lt;address&gt;</code>用于标注其最近的<code>&lt;article&gt;</code>或<code>&lt;body&gt;</code>祖先元素的联系信息</p>

<h2 id="section-4">为你的网页生成大纲吧</h2>

<p>书中介绍了两个将html转换成大纲的网站: <a href="http://gsnedders.html5.org/outliner/">HTML5 Outliner by gsnedders</a>和<a href="http://hoyois.github.io/html5outliner/">HTML5 Outliner by hoyois</a>，其中第二个需要用firefox打开</p>

<p>两者都支持直接输入URL、上传HTML文件、直接敲入HTML内容来生成大纲</p>

<p>比如下面这一段HTML，一个很常见的HTML文档：
```html
&lt;!doctype html&gt;
&lt;html lang="zh"&gt;</p>
<head>
    <meta charset="UTF-8" />
    <title>标题</title>
</head>
<body>
    <h1>整个文章的主题</h1>
    <header>
        <nav>
            <hgroup>
                <h1>主导航条</h1>
                <h2>这里放置最主要的导航</h2>
            </hgroup>
            <ul>
                <li>导航1</li>
                <li>导航2</li>
                <li>导航3</li>
            </ul>
        </nav>
    </header>
    <aside>
        <h2>侧边栏</h2>
        <section>
            <h3>侧边栏区域1</h3>
            <ul></ul>
        </section>
        <section>
            <h3>侧边栏区域2</h3>
            <ul></ul>
        </section>
        <section>
            <h3>侧边栏区域3</h3>
            <ul></ul>
        </section>
    </aside>
    <section>
        <h1>内容</h1>
        <article>
            <hgroup>
                <h1>第一篇文章</h1>
                <h2>文章副标题</h2>
                <h3>文章描述</h3>
            </hgroup>
            <header>
                <nav>
                    <h2>文章内部导航</h2>
                    <ul>
                        <li>导航1</li>
                        <li>导航2</li>
                        <li>导航3</li>
                    </ul>
                </nav>
            </header>
            <p>正文内容</p>
        </article>
        <article>
            <hgroup>
                <h1>第二篇文章</h1>
                <h2>文章副标题</h2>
                <h3>文章描述</h3>
            </hgroup>
            <header>
                <nav>
                    <h2>文章内部导航</h2>
                    <ul>
                        <li>导航1</li>
                        <li>导航2</li>
                        <li>导航3</li>
                    </ul>
                </nav>
            </header>
            <p>正文内容</p>
        </article>
    </section>
    <footer>一些版权信息</footer>
</body>
<p>&lt;/html&gt;
```
生成的大纲如下：</p>

<ol>
  <li>整个文章的主题
    <ol>
      <li>主导航条</li>
      <li>侧边栏
        <ol>
          <li>侧边栏区域1</li>
          <li>侧边栏区域2</li>
          <li>侧边栏区域3</li>
        </ol>
      </li>
      <li>内容
        <ol>
          <li>第一篇文章
            <ol>
              <li>文章内部导航</li>
            </ol>
          </li>
          <li>第二篇文章
            <ol>
              <li>文章内部导航</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="html5-5">HTML5的文本级语义元素</h2>

<h3 id="b">b</h3>
<p>元素<code>&lt;b&gt;</code>通常用来给文本加粗，如今可以将其仅仅作为样式钩子来使用了</p>

<h3 id="em">em</h3>
<p>元素<code>&lt;em&gt;</code>，HTML5中赋予它的语义是：强调内容中的重点</p>

<h3 id="i">i</h3>
<p>元素<code>&lt;i&gt;</code>，过去只是给文本加斜体，如今它表示的语义是：一小段有不同于语态或语气的文字，或者样子上与普通文章有所差异以便标明不同特点的文字</p>

<p>注意这些元素，其中<code>&lt;b&gt;</code>已然会被很多浏览器默认渲染为粗体，而<code>&lt;i&gt;</code>则会被渲染为斜体，可以通过设置样式重置来消除浏览器默认的渲染效果</p>

<h2 id="html5-6">HTML5的多媒体标签</h2>
<p>###视频标签video
如今绝大部分浏览器都支持HTML5的视频和音频，就连IE也从9就支持了，放心大胆的去用吧</p>

<p>使用<code>&lt;video src="myVideo.ogg"&gt;&lt;/video&gt;</code>来嵌入视频，同时可以增加一些其他属性如：
* width：播放器的宽度
* height： 播放器的高度
* controls：为播放器添加控制栏
* autoplay：播放器加载完后自动对视频进行播放
* preload：媒体预加载
* loop：重复播放视频
* poster：定义视频缩略图</p>

<p>同时，由于每个浏览器自身支持的视频格式的不同，可以为了兼容不同的浏览器，定义一个视频源栈，浏览器会从栈顶向下查找，如果找到能播放的格式，就忽略后面的源，对其进行播放，代码如下：
<code>html
&lt;video width="640" height="360" contorls autoplay preload="auto" loop poster="myVidelPost.jpg"&gt;
    &lt;source src="video/myVideo.ogv" type="video/ogg"&gt;
    &lt;source src="video/myVideo.mp4" type="video/mp4"&gt;
&lt;/video&gt;
</code></p>

<h3 id="audio">audio</h3>
<p>元素<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>基本一致，除了width、height、poster外基本相同，但<code>audio</code>没有可视区域</p>

<h3 id="section-5">响应式设计中的视频</h3>
<p>通过设置width和height为百分比来达到响应式的效果，但这样没办法解决iframe中视频的响应问题，可以使用JavaScript来解决，其中<a href="http://fitvidsjs.com/">FitVids</a>就是一个用来解决iframe中视频响应问题的jQuery插件</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/15/responsive-html5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/14/responsive-web-design.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 14 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p><span class="image image-full"><img src="/img/responsive.png" alt="响应式Web设计" /></span></p>

<p>总是在各个地方看到响应式Web设计。一直对其很感兴趣，也只是零零散散的接触，但并没有系统的去学习响应式。这两天读了Ben Frain著（王永强 译）的《响应式Web设计-HTML5和CSS3实践》，收获颇多，在这里记录一下</p>

<h2 id="web">什么是响应式Web设计？</h2>
<p>响应式网页设计： 由伊桑·马科特提出。他将弹性网格布局、弹性图片、媒体和媒体查询这三种已有的开发技巧整合，命名为响应式网页设计。它是针对任意设备对网页内容进行完美布局的一种显示机制。</p>

<p>同时还有很多其他的叫法：流式设计、弹性布局、塑料布局、流体设计、自适应布局、跨设备设计以及弹性设计</p>

<p>响应式Web设计倡导的是，首先针对小屏幕进行设计，然后逐步增强针对大屏幕的设计和内容</p>

<h2 id="section">为什么要响应式？</h2>
<p>###小屏幕的崛起
根据<a href="http://gs.statcounter.com">统计数据</a>，使用台式机和笔记本上网的人越来越少，使用手机、pad等小屏幕上网的人越来越多。
这就表示，为了能让大多数用户能在自己的网站上有较好的用户体验，必须改变传统的针对台式机浏览器设计网页的思路，为移动终端上的网页浏览提供支持。</p>

<h3 id="section-1">响应还是不响应？</h3>
<p>但是，并不是响应式设计就一定是最佳选择。如果预算充足，做一个真正的手机版网站更为合适。这样就可以为不同的用户，根据他们的条件（设备、位置、网速等）来提供不同的内容、设计与交互。</p>

<p>响应式Web设计的最终目的，就是需要做出能响应各种设备大小的完美设计，同时为无论哪种设备提供好的用户体验</p>

<h2 id="section-2">如何做到响应式？</h2>
<p>要做到响应式，需要明确视口的概念：<code>视口指浏览器窗口内，网页实际显示的区域</code>。而不同设备上的用户体验不同，也是由于视口大小不同造成的。
###视口
这里，根据视口大小的不同，一般可以分为三个大类：</p>

<ul>
  <li>手机等小视口：一般使用的浏览器基本都是webkit内核的现代浏览器。屏幕较小，浏览时需要排除掉所有多余的信息，将网页内容主体直观的呈现在浏览器中</li>
  <li>平板电脑等中等大小视口：同手机等小视口终端设备，也是基本使用的webkit内核的现代浏览器，分辨率稍大。可以适当添加一些额外的导航信息放入其中</li>
  <li>台式机、笔记本电脑等大视口：浏览器内核种类多种多样，现代浏览器的比例在上升，但是一些老式的浏览器依旧被广泛使用，需要兼容这些老式的浏览器。屏幕较大，可以显示所有信息（主体或是其他额外信息）。同时分辨率还在不断增大</li>
</ul>

<p>由于大视口设备的分辨率还在不断增大（比如博主的分辨率就是1920*1080的，经常被其他同学吐槽字太小看不见…），导致大视口设备与小视口设备的差距也在不断增大</p>

<h3 id="section-3">设计方式</h3>
<p>所以在响应式页面设计时，首先，需要针对小视口设备进行设计，将网页中真正需要展示的内容放入其中。然后添加一些适当的跳转链接。在视口的分辨率达到一定时（这个分辨率临界点称为断点），在小视口设备所展现的页面上，添加一些相对重要的信息，用于适配中视口设备，形成新的设计。最后，在到达又一个临界点的时候，再次增加更多的信息，形成大视口的网页设计。</p>

<p>这是响应式页面设计真正所倡导的设计方式，由小至大，逐步扩展。但目前经常遇到的工作并不是编写新的响应式页面，更多的时候是需要将老的页面转换成响应式的。这点可以通过哪种逐步扩展的思想反过来，逐步删除一些不重要的信息，最终只留下重要的信息。或许会有人想在小视口和中视口的设计中也保留所有信息，但这样会破坏用户体验中“内容为主”的原则，而且也加大了小视口设备中页面设计的难度。</p>

<h2 id="section-4">响应式的实现方式？</h2>
<p>响应式的实现方式有两种： 
1. 通过JavaScript获取当前视口大小，来动态的加载CSS文件实现
2. 通过HTML5+CSS3的媒体查询来实现
###JavaScript实现
通过JavaScript实现是相对古老的方式，主要思路就是通过JavaScript的window对象获取当前视口的宽度和高度（一般是宽度，因为页面的高度一般是动态改变的），然后根据当前视口信息确定需要添加的CSS文件，使用诸如<code>document.createStyleSheet(cssFile);</code>的代码进行CSS文件的动态添加。这种方法依赖JavaScript，同时也会造成额外的性能问题
###HTML5和CSS3实现
现在HTML5+CSS3可以通过很简单的方式来添加，比如HTML5支持根据视口信息来动态添加CSS文件：
<code>html
&lt;link rel="stylesheet" href="css/screen.css" media="screen"&gt;
</code>
更多的支持我将会在后续的博文中进行详细介绍</p>

<p>而在CSS文件中，也可以根据视口信息应用样式：
<code>css
@media screen and (max-width: 960px) {
   /*需要在960px以下宽度设备中使用的CSS*/
}
</code>
媒体查询并不是上面简单的代码就能展示的，其可以查询的信息有： 
1. 视口高度
2. 视口宽度
3. 设备屏幕高度
4. 设备屏幕宽度
5. 设备方向（横向还是纵向）
6. 视口宽高比
7. 设备屏幕宽高比
8. 颜色的位数
9. 单色缓冲区中每像素所使用的位数
10. 屏幕或打印机的分辨率
11. 电视机的扫描方式
12. 输出设备是网格设备还是位图设备</p>

<p>其中除了电视机的扫描范围和设备是否是网格还是位图的检测外，其他检测都能用min和max创建一个查询范围，可谓相当强大。</p>

<p>也许会有一些顾虑，媒体查询是否被大多数浏览器支持。情况是，媒体查询已经被浏览器广泛支持，老版本的IE 6、7、8也可以通过JavaScript补丁进行修复。所以，没有理由拒绝使用媒体查询</p>

<h2 id="section-5">响应式的效果</h2>
<p>这篇博客实际上就是响应式的，使用了html5up的HTML5模板，放大缩小浏览器的可视区域，或者通过其他设备访问，将看到不一样的效果</p>

<h2 id="section-6">写在最后</h2>
<p>响应式Web设计需要的结果是使用有限的资源，为所有设备上的用户提供较好的用户体验。其实这个博客就是响应式的。其中涉及到较多的HTML5+CSS3的内容，所以经常需要在兼顾多种浏览器和开发成本上权衡利弊，后续会有HTML5和CSS3的文章。这两天没写文章了，之前的两天一篇文章的计划被打破了，必须加油了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/14/responsive-web-design.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 聊聊响应式网页设计 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/14/responsive-web-design.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Fri, 14 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p><span class="image image-full"><img src="/img/responsive.png" alt="响应式Web设计" /></span></p>

<p>总是在各个地方看到响应式Web设计。一直对其很感兴趣，也只是零零散散的接触，但并没有系统的去学习响应式。这两天读了Ben Frain著（王永强 译）的《响应式Web设计-HTML5和CSS3实践》，收获颇多，在这里记录一下</p>

<h2 id="web">什么是响应式Web设计？</h2>
<p>响应式网页设计： 由伊桑·马科特提出。他将弹性网格布局、弹性图片、媒体和媒体查询这三种已有的开发技巧整合，命名为响应式网页设计。它是针对任意设备对网页内容进行完美布局的一种显示机制。</p>

<p>同时还有很多其他的叫法：流式设计、弹性布局、塑料布局、流体设计、自适应布局、跨设备设计以及弹性设计</p>

<p>响应式Web设计倡导的是，首先针对小屏幕进行设计，然后逐步增强针对大屏幕的设计和内容</p>

<h2 id="section">为什么要响应式？</h2>
<p>###小屏幕的崛起
根据<a href="http://gs.statcounter.com">统计数据</a>，使用台式机和笔记本上网的人越来越少，使用手机、pad等小屏幕上网的人越来越多。
这就表示，为了能让大多数用户能在自己的网站上有较好的用户体验，必须改变传统的针对台式机浏览器设计网页的思路，为移动终端上的网页浏览提供支持。</p>

<h3 id="section-1">响应还是不响应？</h3>
<p>但是，并不是响应式设计就一定是最佳选择。如果预算充足，做一个真正的手机版网站更为合适。这样就可以为不同的用户，根据他们的条件（设备、位置、网速等）来提供不同的内容、设计与交互。</p>

<p>响应式Web设计的最终目的，就是需要做出能响应各种设备大小的完美设计，同时为无论哪种设备提供好的用户体验</p>

<h2 id="section-2">如何做到响应式？</h2>
<p>要做到响应式，需要明确视口的概念：<code>视口指浏览器窗口内，网页实际显示的区域</code>。而不同设备上的用户体验不同，也是由于视口大小不同造成的。
###视口
这里，根据视口大小的不同，一般可以分为三个大类：</p>

<ul>
  <li>手机等小视口：一般使用的浏览器基本都是webkit内核的现代浏览器。屏幕较小，浏览时需要排除掉所有多余的信息，将网页内容主体直观的呈现在浏览器中</li>
  <li>平板电脑等中等大小视口：同手机等小视口终端设备，也是基本使用的webkit内核的现代浏览器，分辨率稍大。可以适当添加一些额外的导航信息放入其中</li>
  <li>台式机、笔记本电脑等大视口：浏览器内核种类多种多样，现代浏览器的比例在上升，但是一些老式的浏览器依旧被广泛使用，需要兼容这些老式的浏览器。屏幕较大，可以显示所有信息（主体或是其他额外信息）。同时分辨率还在不断增大</li>
</ul>

<p>由于大视口设备的分辨率还在不断增大（比如博主的分辨率就是1920*1080的，经常被其他同学吐槽字太小看不见…），导致大视口设备与小视口设备的差距也在不断增大</p>

<h3 id="section-3">设计方式</h3>
<p>所以在响应式页面设计时，首先，需要针对小视口设备进行设计，将网页中真正需要展示的内容放入其中。然后添加一些适当的跳转链接。在视口的分辨率达到一定时（这个分辨率临界点称为断点），在小视口设备所展现的页面上，添加一些相对重要的信息，用于适配中视口设备，形成新的设计。最后，在到达又一个临界点的时候，再次增加更多的信息，形成大视口的网页设计。</p>

<p>这是响应式页面设计真正所倡导的设计方式，由小至大，逐步扩展。但目前经常遇到的工作并不是编写新的响应式页面，更多的时候是需要将老的页面转换成响应式的。这点可以通过哪种逐步扩展的思想反过来，逐步删除一些不重要的信息，最终只留下重要的信息。或许会有人想在小视口和中视口的设计中也保留所有信息，但这样会破坏用户体验中“内容为主”的原则，而且也加大了小视口设备中页面设计的难度。</p>

<h2 id="section-4">响应式的实现方式？</h2>
<p>响应式的实现方式有两种： 
1. 通过JavaScript获取当前视口大小，来动态的加载CSS文件实现
2. 通过HTML5+CSS3的媒体查询来实现
###JavaScript实现
通过JavaScript实现是相对古老的方式，主要思路就是通过JavaScript的window对象获取当前视口的宽度和高度（一般是宽度，因为页面的高度一般是动态改变的），然后根据当前视口信息确定需要添加的CSS文件，使用诸如<code>document.createStyleSheet(cssFile);</code>的代码进行CSS文件的动态添加。这种方法依赖JavaScript，同时也会造成额外的性能问题
###HTML5和CSS3实现
现在HTML5+CSS3可以通过很简单的方式来添加，比如HTML5支持根据视口信息来动态添加CSS文件：
<code>html
&lt;link rel="stylesheet" href="css/screen.css" media="screen"&gt;
</code>
更多的支持我将会在后续的博文中进行详细介绍</p>

<p>而在CSS文件中，也可以根据视口信息应用样式：
<code>css
@media screen and (max-width: 960px) {
   /*需要在960px以下宽度设备中使用的CSS*/
}
</code>
媒体查询并不是上面简单的代码就能展示的，其可以查询的信息有： 
1. 视口高度
2. 视口宽度
3. 设备屏幕高度
4. 设备屏幕宽度
5. 设备方向（横向还是纵向）
6. 视口宽高比
7. 设备屏幕宽高比
8. 颜色的位数
9. 单色缓冲区中每像素所使用的位数
10. 屏幕或打印机的分辨率
11. 电视机的扫描方式
12. 输出设备是网格设备还是位图设备</p>

<p>其中除了电视机的扫描范围和设备是否是网格还是位图的检测外，其他检测都能用min和max创建一个查询范围，可谓相当强大。</p>

<p>也许会有一些顾虑，媒体查询是否被大多数浏览器支持。情况是，媒体查询已经被浏览器广泛支持，老版本的IE 6、7、8也可以通过JavaScript补丁进行修复。所以，没有理由拒绝使用媒体查询</p>

<h2 id="section-5">响应式的效果</h2>
<p>这篇博客实际上就是响应式的，使用了html5up的HTML5模板，放大缩小浏览器的可视区域，或者通过其他设备访问，将看到不一样的效果</p>

<h2 id="section-6">写在最后</h2>
<p>响应式Web设计需要的结果是使用有限的资源，为所有设备上的用户提供较好的用户体验。其实这个博客就是响应式的。其中涉及到较多的HTML5+CSS3的内容，所以经常需要在兼顾多种浏览器和开发成本上权衡利弊，后续会有HTML5和CSS3的文章。这两天没写文章了，之前的两天一篇文章的计划被打破了，必须加油了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/14/responsive-web-design.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（21-37） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/11/javascript-puzzlers-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 11 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">第二十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = 111111111111111110000,
    b = 1111;
a + b;
</code>
A: 111111111111111111111</p>

<p>B: 111111111111111110000</p>

<p>C: NaN</p>

<p>D: Infinity</p>

<p>又是一道考查JavaScript数字的题，与第七题考察点相似。由于JavaScript实际上只有一种数字形式IEEE 754标准的64位双精度浮点数，其所能表示的整数范围为-2^53~2^53(包括边界值)。这里的111111111111111110000已经超过了2^53次方，所以会发生精度丢失的情况。综上选B</p>

<h3 id="section-1">第二十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var x = [].reverse;
x();
</code>
A: []</p>

<p>B: undefined</p>

<p>C: error</p>

<p>D: window</p>

<p>这题考查的是函数调用时的this和Array.prototype.reverse方法。</p>

<p>首先看Array.prototype.reverse方法，首先举几个栗子：
<code>javascript
console.log(Array.prototype.reverse.call("skyinlayer"));
//skyinlayer
console.log(Array.prototype.reverse.call({}));
//Object {}
console.log(Array.prototype.reverse.call(123));
//123
</code>
这几个栗子可以得出一个结论，Array.prototype.reverse方法的返回值，就是this</p>

<p>Javascript中this有如下几种情况：</p>

<p>全局下this，指向window对象
<code>javascript
console.log(this);
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
</code></p>

<p>函数调用，this指向全局window对象：
<code>javascript
function somefun(){
    console.log(this);
}
somefun();
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
</code></p>

<p>方法调用，this指向拥有该方法的对象：
<code>javascript
var someobj = {};
someobj.fun = function(){
    console.log(this);
};
console.log(someobj.fun());
//输出结果：
//Object {fun: function}
</code></p>

<p>调用构造函数，构造函数内部的this指向新创建对象：
<code>javascript
function Con() {
    console.log(this);
}
Con.prototype.somefun = function(){};
console.log(new Con());
//输出结果：
//Con {somefun: function}
</code></p>

<p>显示确定this：
<code>javascript
function somefun(){
    console.log(this);
};
somefun.apply("skyinlayer");
somefun.call("skyinlayer");
//输出结果：
//String {0: "s", 1: "k", 2: "y", 3: "i", 4: "n", 5: "l", 6: "a", 7: "y", 8: "e", 9: "r", length: 10}
//String {0: "s", 1: "k", 2: "y", 3: "i", 4: "n", 5: "l", 6: "a", 7: "y", 8: "e", 9: "r", length: 10} 
</code></p>

<p>这里可以看到，使用的是函数调用方式，this指向的是全局对象window，所以选D</p>

<h3 id="section-2">第二十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
Number.MIN_VALUE &gt; 0
</code>
A: false</p>

<p>B: true</p>

<p>C: error</p>

<p>D: other</p>

<p>考查的Number.MIN_VALUE的概念，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE">MDN传送门</a>，关键的几句话</p>

<ul>
  <li>
    <p>The Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.
翻译：Number.MIN_VALUE表示的是JavaScript中最小的正数</p>
  </li>
  <li>
    <p>The MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.
翻译：MIN_VALUE是接近0的数，而不是最小的数</p>
  </li>
  <li>
    <p>MIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (“underflow values”) are converted to 0.
翻译：MIN_VALUE值约等于5e-324，比起更小的值（大于0），将被转换为0</p>
  </li>
</ul>

<p>所以，这里是true，选B</p>

<p>顺带把Number的几个常量拉出来：
* Number.MAX_VALUE：最大的正数
* Number.MIN_VALUE：最小的正数
* Number.NaN：特殊值，用来表示这不是一个数
* Number.NEGATIVE_INFINITY：负无穷大
* Number.POSITIVE_INFINITY：正无穷大</p>

<p>如果要表示最小的负数和最大的负数，可以使用-Number.MAX_VALUE和-Number.MIN_VALUE</p>

<h3 id="section-3">第二十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]
</code>
A: [true, true]</p>

<p>B: [true, false]</p>

<p>C: error</p>

<p>D: other</p>

<p>运算符的运算顺序和隐式类型转换的题，从<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN上运算符优先级</a>，’&lt;’运算符顺序是从左到右，所以变成了[true &lt; 3, false &lt; 1]</p>

<p>接着进行隐式类型转换，’&lt;’操作符的转换规则（来自<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>）:</p>

<ol>
  <li>如果两个操作值都是数值，则进行数值比较</li>
  <li>如果两个操作值都是字符串，则比较字符串对应的字符编码值</li>
  <li>如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较</li>
  <li>如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较</li>
  <li>如果一个操作值是布尔值，则将其转换为数值，再进行比较</li>
</ol>

<p>所以，这里首先通过Number()转换为数字然后进行比较，true会转换成1，而false转换成0，就变成了[1 &lt; 3, 0 &lt; 1]</p>

<p>所以结果为A</p>

<h3 id="section-4">第二十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
// the most classic wtf
2 == [[[2]]]
</code>
A: true</p>

<p>B: false</p>

<p>C: undefined</p>

<p>D: other</p>

<p>又是隐式类型转换的题（汗）</p>

<p>题目作者的解释是：
both objects get converted to strings and in both cases the resulting string is “2”</p>

<p>也就是说左右两边都被转换成了字符串，而字符串都是”2”</p>

<p>这里首先需要对==右边的数组进行类型转换，根据以下规则（来自<a href="http://justjavac.iteye.com/blog/1848749">justjavac的文章《「译」JavaScript 的怪癖 1：隐式类型转换》</a>）：
1. 调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。
2. 否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。
3. 否则，抛出一个类型错误。</p>

<p>所以右侧被使用toString()方法转换为”2”，然后又通过Number(“2”)转换为数字2进行比较，结果就是true了，选A</p>

<h3 id="section-5">第二十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
3.toString()
3..toString()
3...toString()
</code>
A: “3”, error, error</p>

<p>B: “3”, “3.0”, error</p>

<p>C: error, “3”, error</p>

<p>D: other</p>

<p>说实话这题有点常见了，很多人都踩过3.toString()的坑（包括我）…虽然JavaScript会在调用方法时对原始值进行包装，但是这个点是小数点呢、还是方法调用的点呢，于是乎第一个就是error了，因为JavaScript解释器会将其认为是小数点。</p>

<p>而第二个则很好说通了，第一个点解释为小数点，变成了(3.0).toString()，结果就是”3”了</p>

<p>第三个也是，第一个点为小数点，第二个是方法调用的点，但是后面接的不是一个合法的方法名，于是乎就error了</p>

<p>综上，选C</p>

<h3 id="section-6">第二十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
(function(){
  var x = y = 1;
})();
console.log(y);
console.log(x);
</code>
A: 1, 1</p>

<p>B: error, error</p>

<p>C: 1, error</p>

<p>D: other</p>

<p>变量提升和隐式定义全局变量的题，也是一个JavaScript经典的坑…</p>

<p>还是那句话，在作用域内，变量定义和函数定义会先行提升，所以里面就变成了:
<code>javascript
(function(){
    var x;
    y = 1;
    x = 1;
})();
</code>
这点会问了，为什么不是<code>var x, y;</code>，这就是坑的地方…这里只会定义第一个变量x，而y则会通过不使用var的方式直接使用，于是乎就隐式定义了一个全局变量y</p>

<p>所以，y是全局作用域下，而x则是在函数内部，结果就为1, error，选C</p>

<h3 id="section-7">第二十八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = /123/,
    b = /123/;
a == b
a === b
</code>
A: true, true</p>

<p>B: true, false</p>

<p>C: false, false</p>

<p>D: other</p>

<p>首先需要明确JavaScript的正则表达式是什么。JavaScript中的正则表达式依旧是对象，使用typeof运算符就能得出结果：</p>

<p><code>javascript
console.log(typeof /123/);
//输出结果：
//"object"
</code></p>

<p>’==’运算符左右两边都是对象时，会比较他们是否指向同一个对象，可以理解为C语言中两个指针的值是否一样（指向同一片内存），所以两个结果自然都是false</p>

<h3 id="section-8">第二十九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = [1, 2, 3],
    b = [1, 2, 3],
    c = [1, 2, 4]
a == b
a === b
a &gt; c
a &lt; c
</code>
A: false, false, false, true</p>

<p>B: false, false, false, false</p>

<p>C: true, true, false, true</p>

<p>D: other</p>

<p>和上题类似，JavaScript中Array的本质也是对象，所以前两个的结果都是false，</p>

<p>而JavaScript中Array的’&gt;’运算符和’&lt;’运算符的比较方式类似于字符串比较字典序，会从第一个元素开始进行比较，如果一样比较第二个，还一样就比较第三个，如此类推，所以第三个结果为false，第四个为true。</p>

<p>综上所述，结果为false, false, false, true，选A</p>

<h3 id="section-9">第三十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = {}, b = Object.prototype;
[a.prototype === b, Object.getPrototypeOf(a) === b]
</code>
A: [false, true]</p>

<p>B: [true, true]</p>

<p>C: [false, false]</p>

<p>D: other</p>

<p>原型链的题（总会有的），考查的__proto__和prototype的区别。首先要明确对象和构造函数的关系，对象在创建的时候，其__proto__会指向其构造函数的prototype属性</p>

<p>Object实际上是一个构造函数（typeof Object的结果为”function”）,使用字面量创建对象和new Object创建对象是一样的，所以a.__proto__也就是Object.prototype，而Object.getPrototypeOf(a)与a.__proto__是一样的，所以第二个结果为true</p>

<p>而实例对象是没有prototype属性的，只有函数才有，所以a.prototype其实是undefined，第一个结果为false</p>

<p>综上，选A</p>

<h3 id="section-10">第三十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function f() {}
var a = f.prototype, b = Object.getPrototypeOf(f);
a === b
</code>
A: true</p>

<p>B: false</p>

<p>C: null</p>

<p>D: other</p>

<p>还是__proto__和prototype的区别，两者不是一个东西，所以选B</p>

<h3 id="section-11">第三十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function foo() { }
var oldName = foo.name;
foo.name = "bar";
[oldName, foo.name]
</code>
A: error</p>

<p>B: [””, “”]</p>

<p>C: [“foo”, “foo”]</p>

<p>D: [“foo”, “bar”]</p>

<p>考察了函数的name属性，使用函数定义方式时，会给function对象本身添加一个name属性，保存了函数的名称，很好理解oldName为”foo”。name属性时只读的，不允许修改，所以<code>foo.name = "bar";</code>之后，foo.name还是”foo”，所以结果为[“foo”, “foo”]，选C</p>

<p>PS：name属性不是一个标准属性，不要去使用，除非你想要坑别人</p>

<h3 id="section-12">第三十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
"1 2 3".replace(/\d/g, parseInt)
</code>
A: “1 2 3”</p>

<p>B: “0 1 2”</p>

<p>C: “NaN 2 3”</p>

<p>D: “1 NaN 3”</p>

<p>String.prototype.replace、正则表达式的全局匹配和parseInt（又是parseInt…），可以根据题意看出来题目上漏了一个’'</p>

<p>首先需要确定replace会传给parseInt哪些参数。举个栗子：
<code>javascript
"1 2 3".replace(/\d/g, function(){
    console.log(arguments);
});
//输出结果：
//["1", 0, "1 2 3"]
//["2", 2, "1 2 3"]
//["3", 4, "1 2 3"] 
</code>
一共三个：
1. match：正则表达式被匹配到的子字符串
2. offset：被匹配到的子字符串在原字符串中的位置
3. string：原字符串</p>

<p>这样就很好理解了，又回到之前parseInt的问题了，结果就是parseInt(“1”, 10), parseInt(“2”, 2), parseInt(“3”, 4)所以结果为”1, NaN, 3”，选D</p>

<h3 id="section-13">第三十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function f() {}
var parent = Object.getPrototypeOf(f);
f.name // ?
parent.name // ?
typeof eval(f.name) // ?
typeof eval(parent.name) //  ?
</code>
A: “f”, “Empty”, “function”, “function”</p>

<p>B: “f”, undefined, “function”, error</p>

<p>C: “f”, “Empty”, “function”, error</p>

<p>D: other</p>

<p>又是Function.name属性的题，和三十二题一样样，f.name值为”f”，而eval(“f”)则会输出f函数，所以结果为”function”</p>

<p>接着看parent，parent实际上就是f.__proto__，需要明确的是JavaScript中的函数也是对象，其也有自己的构造函数Function，所以f.__proto__ === Function.prototype结果是true，而Function.prototype就是一个名为Empty的function
<code>javascript
console.log(Function.prototype);
console.log(Function.prototype.name);
//输出结果：
//function Empty() {}
//Empty
</code>
所以parent.name的值为Empty</p>

<p>如果想直接在全局作用域下调用Empty，显示未定义…因为Empty并不在全局作用域下</p>

<p>综上所述，结果为C</p>

<h3 id="section-14">第三十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var lowerCaseOnly =  /^[a-z]+$/;
[lowerCaseOnly.test(null), lowerCaseOnly.test()]
</code>
A: [true, false]</p>

<p>B: error</p>

<p>C: [true, true]</p>

<p>D: [false, true]</p>

<p>正则表达式的test方法会自动将参数转换为字符串，原式就变成了<code>[lowerCaseOnly.test("null"), lowerCaseOnly.test("undefined")]</code>，结果都是真，所以选C</p>

<h3 id="section-15">第三十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[,,,].join(", ")
</code>
A: “, , , “</p>

<p>B: “undefined, undefined, undefined, undefined”</p>

<p>C: “, , “</p>

<p>D: “”</p>

<p>JavaScript中使用字面量创建数组时，如果最末尾有一个逗号’,’，会背省略，所以实际上这个数组只有三个元素（都是undefined）：
<code>javascript
console.log([,,,].length);
//输出结果：
//3
</code>
而三个元素，使用join方法，只需要添加两次，所以结果为”, , “，选C</p>

<h3 id="section-16">第三十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = {class: "Animal", name: 'Fido'};
a.class
</code>
A: “Animal”</p>

<p>B: Object</p>

<p>C: an error</p>

<p>D: other</p>

<p>经典坑中的一个，class是关键字。根据浏览器的不同，结果不同：</p>

<p>chrome的结果： “Animal”</p>

<p>Firefox的结果：”Animal”</p>

<p>Opera的结果：”Animal”</p>

<p>IE 8以上也是： “Animal”</p>

<p>IE 8 及以下： 报错</p>

<h3 id="section-17">总结</h3>
<p>终于把37题全部弄完了，虽然很多题都偏而怪，但其中涉及的知识还是相当重要的。JavaScript中的糟粕和精华永远是一个话题，也是笔试面试时经常遇到的问题。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/11/javascript-puzzlers-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（21-37） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/11/javascript-puzzlers-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 11 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">第二十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = 111111111111111110000,
    b = 1111;
a + b;
</code>
A: 111111111111111111111</p>

<p>B: 111111111111111110000</p>

<p>C: NaN</p>

<p>D: Infinity</p>

<p>又是一道考查JavaScript数字的题，与第七题考察点相似。由于JavaScript实际上只有一种数字形式IEEE 754标准的64位双精度浮点数，其所能表示的整数范围为-2^53~2^53(包括边界值)。这里的111111111111111110000已经超过了2^53次方，所以会发生精度丢失的情况。综上选B</p>

<h3 id="section-1">第二十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var x = [].reverse;
x();
</code>
A: []</p>

<p>B: undefined</p>

<p>C: error</p>

<p>D: window</p>

<p>这题考查的是函数调用时的this和Array.prototype.reverse方法。</p>

<p>首先看Array.prototype.reverse方法，首先举几个栗子：
<code>javascript
console.log(Array.prototype.reverse.call("skyinlayer"));
//skyinlayer
console.log(Array.prototype.reverse.call({}));
//Object {}
console.log(Array.prototype.reverse.call(123));
//123
</code>
这几个栗子可以得出一个结论，Array.prototype.reverse方法的返回值，就是this</p>

<p>Javascript中this有如下几种情况：</p>

<p>全局下this，指向window对象
<code>javascript
console.log(this);
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
</code></p>

<p>函数调用，this指向全局window对象：
<code>javascript
function somefun(){
    console.log(this);
}
somefun();
//输出结果：
//Window {top: Window, window: Window, location: Location, external: Object, chrome: Object…}
</code></p>

<p>方法调用，this指向拥有该方法的对象：
<code>javascript
var someobj = {};
someobj.fun = function(){
    console.log(this);
};
console.log(someobj.fun());
//输出结果：
//Object {fun: function}
</code></p>

<p>调用构造函数，构造函数内部的this指向新创建对象：
<code>javascript
function Con() {
    console.log(this);
}
Con.prototype.somefun = function(){};
console.log(new Con());
//输出结果：
//Con {somefun: function}
</code></p>

<p>显示确定this：
<code>javascript
function somefun(){
    console.log(this);
};
somefun.apply("skyinlayer");
somefun.call("skyinlayer");
//输出结果：
//String {0: "s", 1: "k", 2: "y", 3: "i", 4: "n", 5: "l", 6: "a", 7: "y", 8: "e", 9: "r", length: 10}
//String {0: "s", 1: "k", 2: "y", 3: "i", 4: "n", 5: "l", 6: "a", 7: "y", 8: "e", 9: "r", length: 10} 
</code></p>

<p>这里可以看到，使用的是函数调用方式，this指向的是全局对象window，所以选D</p>

<h3 id="section-2">第二十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
Number.MIN_VALUE &gt; 0
</code>
A: false</p>

<p>B: true</p>

<p>C: error</p>

<p>D: other</p>

<p>考查的Number.MIN_VALUE的概念，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE">MDN传送门</a>，关键的几句话</p>

<ul>
  <li>
    <p>The Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.
翻译：Number.MIN_VALUE表示的是JavaScript中最小的正数</p>
  </li>
  <li>
    <p>The MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.
翻译：MIN_VALUE是接近0的数，而不是最小的数</p>
  </li>
  <li>
    <p>MIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (“underflow values”) are converted to 0.
翻译：MIN_VALUE值约等于5e-324，比起更小的值（大于0），将被转换为0</p>
  </li>
</ul>

<p>所以，这里是true，选B</p>

<p>顺带把Number的几个常量拉出来：
* Number.MAX_VALUE：最大的正数
* Number.MIN_VALUE：最小的正数
* Number.NaN：特殊值，用来表示这不是一个数
* Number.NEGATIVE_INFINITY：负无穷大
* Number.POSITIVE_INFINITY：正无穷大</p>

<p>如果要表示最小的负数和最大的负数，可以使用-Number.MAX_VALUE和-Number.MIN_VALUE</p>

<h3 id="section-3">第二十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]
</code>
A: [true, true]</p>

<p>B: [true, false]</p>

<p>C: error</p>

<p>D: other</p>

<p>运算符的运算顺序和隐式类型转换的题，从<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN上运算符优先级</a>，’&lt;’运算符顺序是从左到右，所以变成了[true &lt; 3, false &lt; 1]</p>

<p>接着进行隐式类型转换，’&lt;’操作符的转换规则（来自<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>）:</p>

<ol>
  <li>如果两个操作值都是数值，则进行数值比较</li>
  <li>如果两个操作值都是字符串，则比较字符串对应的字符编码值</li>
  <li>如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较</li>
  <li>如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较</li>
  <li>如果一个操作值是布尔值，则将其转换为数值，再进行比较</li>
</ol>

<p>所以，这里首先通过Number()转换为数字然后进行比较，true会转换成1，而false转换成0，就变成了[1 &lt; 3, 0 &lt; 1]</p>

<p>所以结果为A</p>

<h3 id="section-4">第二十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
// the most classic wtf
2 == [[[2]]]
</code>
A: true</p>

<p>B: false</p>

<p>C: undefined</p>

<p>D: other</p>

<p>又是隐式类型转换的题（汗）</p>

<p>题目作者的解释是：
both objects get converted to strings and in both cases the resulting string is “2”</p>

<p>也就是说左右两边都被转换成了字符串，而字符串都是”2”</p>

<p>这里首先需要对==右边的数组进行类型转换，根据以下规则（来自<a href="http://justjavac.iteye.com/blog/1848749">justjavac的文章《「译」JavaScript 的怪癖 1：隐式类型转换》</a>）：
1. 调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。
2. 否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。
3. 否则，抛出一个类型错误。</p>

<p>所以右侧被使用toString()方法转换为”2”，然后又通过Number(“2”)转换为数字2进行比较，结果就是true了，选A</p>

<h3 id="section-5">第二十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
3.toString()
3..toString()
3...toString()
</code>
A: “3”, error, error</p>

<p>B: “3”, “3.0”, error</p>

<p>C: error, “3”, error</p>

<p>D: other</p>

<p>说实话这题有点常见了，很多人都踩过3.toString()的坑（包括我）…虽然JavaScript会在调用方法时对原始值进行包装，但是这个点是小数点呢、还是方法调用的点呢，于是乎第一个就是error了，因为JavaScript解释器会将其认为是小数点。</p>

<p>而第二个则很好说通了，第一个点解释为小数点，变成了(3.0).toString()，结果就是”3”了</p>

<p>第三个也是，第一个点为小数点，第二个是方法调用的点，但是后面接的不是一个合法的方法名，于是乎就error了</p>

<p>综上，选C</p>

<h3 id="section-6">第二十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
(function(){
  var x = y = 1;
})();
console.log(y);
console.log(x);
</code>
A: 1, 1</p>

<p>B: error, error</p>

<p>C: 1, error</p>

<p>D: other</p>

<p>变量提升和隐式定义全局变量的题，也是一个JavaScript经典的坑…</p>

<p>还是那句话，在作用域内，变量定义和函数定义会先行提升，所以里面就变成了:
<code>javascript
(function(){
    var x;
    y = 1;
    x = 1;
})();
</code>
这点会问了，为什么不是<code>var x, y;</code>，这就是坑的地方…这里只会定义第一个变量x，而y则会通过不使用var的方式直接使用，于是乎就隐式定义了一个全局变量y</p>

<p>所以，y是全局作用域下，而x则是在函数内部，结果就为1, error，选C</p>

<h3 id="section-7">第二十八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = /123/,
    b = /123/;
a == b
a === b
</code>
A: true, true</p>

<p>B: true, false</p>

<p>C: false, false</p>

<p>D: other</p>

<p>首先需要明确JavaScript的正则表达式是什么。JavaScript中的正则表达式依旧是对象，使用typeof运算符就能得出结果：</p>

<p><code>javascript
console.log(typeof /123/);
//输出结果：
//"object"
</code></p>

<p>’==’运算符左右两边都是对象时，会比较他们是否指向同一个对象，可以理解为C语言中两个指针的值是否一样（指向同一片内存），所以两个结果自然都是false</p>

<h3 id="section-8">第二十九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = [1, 2, 3],
    b = [1, 2, 3],
    c = [1, 2, 4]
a == b
a === b
a &gt; c
a &lt; c
</code>
A: false, false, false, true</p>

<p>B: false, false, false, false</p>

<p>C: true, true, false, true</p>

<p>D: other</p>

<p>和上题类似，JavaScript中Array的本质也是对象，所以前两个的结果都是false，</p>

<p>而JavaScript中Array的’&gt;’运算符和’&lt;’运算符的比较方式类似于字符串比较字典序，会从第一个元素开始进行比较，如果一样比较第二个，还一样就比较第三个，如此类推，所以第三个结果为false，第四个为true。</p>

<p>综上所述，结果为false, false, false, true，选A</p>

<h3 id="section-9">第三十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = {}, b = Object.prototype;
[a.prototype === b, Object.getPrototypeOf(a) === b]
</code>
A: [false, true]</p>

<p>B: [true, true]</p>

<p>C: [false, false]</p>

<p>D: other</p>

<p>原型链的题（总会有的），考查的__proto__和prototype的区别。首先要明确对象和构造函数的关系，对象在创建的时候，其__proto__会指向其构造函数的prototype属性</p>

<p>Object实际上是一个构造函数（typeof Object的结果为”function”）,使用字面量创建对象和new Object创建对象是一样的，所以a.__proto__也就是Object.prototype，而Object.getPrototypeOf(a)与a.__proto__是一样的，所以第二个结果为true</p>

<p>而实例对象是没有prototype属性的，只有函数才有，所以a.prototype其实是undefined，第一个结果为false</p>

<p>综上，选A</p>

<h3 id="section-10">第三十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function f() {}
var a = f.prototype, b = Object.getPrototypeOf(f);
a === b
</code>
A: true</p>

<p>B: false</p>

<p>C: null</p>

<p>D: other</p>

<p>还是__proto__和prototype的区别，两者不是一个东西，所以选B</p>

<h3 id="section-11">第三十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function foo() { }
var oldName = foo.name;
foo.name = "bar";
[oldName, foo.name]
</code>
A: error</p>

<p>B: [””, “”]</p>

<p>C: [“foo”, “foo”]</p>

<p>D: [“foo”, “bar”]</p>

<p>考察了函数的name属性，使用函数定义方式时，会给function对象本身添加一个name属性，保存了函数的名称，很好理解oldName为”foo”。name属性时只读的，不允许修改，所以<code>foo.name = "bar";</code>之后，foo.name还是”foo”，所以结果为[“foo”, “foo”]，选C</p>

<p>PS：name属性不是一个标准属性，不要去使用，除非你想要坑别人</p>

<h3 id="section-12">第三十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
"1 2 3".replace(/\d/g, parseInt)
</code>
A: “1 2 3”</p>

<p>B: “0 1 2”</p>

<p>C: “NaN 2 3”</p>

<p>D: “1 NaN 3”</p>

<p>String.prototype.replace、正则表达式的全局匹配和parseInt（又是parseInt…），可以根据题意看出来题目上漏了一个’'</p>

<p>首先需要确定replace会传给parseInt哪些参数。举个栗子：
<code>javascript
"1 2 3".replace(/\d/g, function(){
    console.log(arguments);
});
//输出结果：
//["1", 0, "1 2 3"]
//["2", 2, "1 2 3"]
//["3", 4, "1 2 3"] 
</code>
一共三个：
1. match：正则表达式被匹配到的子字符串
2. offset：被匹配到的子字符串在原字符串中的位置
3. string：原字符串</p>

<p>这样就很好理解了，又回到之前parseInt的问题了，结果就是parseInt(“1”, 10), parseInt(“2”, 2), parseInt(“3”, 4)所以结果为”1, NaN, 3”，选D</p>

<h3 id="section-13">第三十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function f() {}
var parent = Object.getPrototypeOf(f);
f.name // ?
parent.name // ?
typeof eval(f.name) // ?
typeof eval(parent.name) //  ?
</code>
A: “f”, “Empty”, “function”, “function”</p>

<p>B: “f”, undefined, “function”, error</p>

<p>C: “f”, “Empty”, “function”, error</p>

<p>D: other</p>

<p>又是Function.name属性的题，和三十二题一样样，f.name值为”f”，而eval(“f”)则会输出f函数，所以结果为”function”</p>

<p>接着看parent，parent实际上就是f.__proto__，需要明确的是JavaScript中的函数也是对象，其也有自己的构造函数Function，所以f.__proto__ === Function.prototype结果是true，而Function.prototype就是一个名为Empty的function
<code>javascript
console.log(Function.prototype);
console.log(Function.prototype.name);
//输出结果：
//function Empty() {}
//Empty
</code>
所以parent.name的值为Empty</p>

<p>如果想直接在全局作用域下调用Empty，显示未定义…因为Empty并不在全局作用域下</p>

<p>综上所述，结果为C</p>

<h3 id="section-14">第三十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var lowerCaseOnly =  /^[a-z]+$/;
[lowerCaseOnly.test(null), lowerCaseOnly.test()]
</code>
A: [true, false]</p>

<p>B: error</p>

<p>C: [true, true]</p>

<p>D: [false, true]</p>

<p>正则表达式的test方法会自动将参数转换为字符串，原式就变成了<code>[lowerCaseOnly.test("null"), lowerCaseOnly.test("undefined")]</code>，结果都是真，所以选C</p>

<h3 id="section-15">第三十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[,,,].join(", ")
</code>
A: “, , , “</p>

<p>B: “undefined, undefined, undefined, undefined”</p>

<p>C: “, , “</p>

<p>D: “”</p>

<p>JavaScript中使用字面量创建数组时，如果最末尾有一个逗号’,’，会背省略，所以实际上这个数组只有三个元素（都是undefined）：
<code>javascript
console.log([,,,].length);
//输出结果：
//3
</code>
而三个元素，使用join方法，只需要添加两次，所以结果为”, , “，选C</p>

<h3 id="section-16">第三十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = {class: "Animal", name: 'Fido'};
a.class
</code>
A: “Animal”</p>

<p>B: Object</p>

<p>C: an error</p>

<p>D: other</p>

<p>经典坑中的一个，class是关键字。根据浏览器的不同，结果不同：</p>

<p>chrome的结果： “Animal”</p>

<p>Firefox的结果：”Animal”</p>

<p>Opera的结果：”Animal”</p>

<p>IE 8以上也是： “Animal”</p>

<p>IE 8 及以下： 报错</p>

<h3 id="section-17">总结</h3>
<p>终于把37题全部弄完了，虽然很多题都偏而怪，但其中涉及的知识还是相当重要的。JavaScript中的糟粕和精华永远是一个话题，也是笔试面试时经常遇到的问题。</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/11/javascript-puzzlers-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（1-20） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/10/javascript-puzzlers.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 10 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近做了个heroku上的JavaScript的测试（<a href="http://javascript-puzzlers.herokuapp.com/">题目地址</a>），错了一大堆，感觉js的概念还有很多不是很清晰，这里记录一下</p>

<h3 id="section">第一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
["1", "2", "3"].map(parseInt) 
</code>
A：[“1”, “2”, “3”]</p>

<p>B：[1, 2, 3]</p>

<p>C：[0, 1, 2]</p>

<p>D：other</p>

<p>解答：这里考的是map、parseInt的用法。map会传递三个参数给其作为参数的函数，为(element, index, array)，分别为当前的元素、当前元素在数组中的位置、整个数组：</p>

<pre><code>&gt; ["1", "2", "3"].map(function(){console.log(arguments)}) 
["1", 0, Array[3]]
["2", 1, Array[3]]
["3", 2, Array[3]]
</code></pre>

<p>而parseInt只接收两个参数，为(element, radix)，element代表需要被转换为int的字符串，radix代表当前字符串里数字的进制数</p>

<p>所以相当于说，结果数组的元素实际分别为为：</p>

<pre><code>parseInt("1", 0)
parseInt("2", 1)
parseInt("3", 2)
</code></pre>

<p>parseInt(“1”, 0)的值为1，MDN上可以看到parseInt函数的radix为0时的行为</p>

<p>If radix is undefined or 0 (or absent), JavaScript assumes the following:</p>

<p>If the input string begins with “0x” or “0X”, radix is 16 (hexadecimal) and the remainder of the string is parsed.</p>

<p>If the input string begins with “0”, radix is eight (octal) or 10 (decimal).  Exactly which radix is chosen is implementation-dependent.  ECMAScript 5 specifies that 10 (decimal) is used, but not all browsers support this yet.  For this reason always specify a radix when using parseInt.</p>

<p>If the input string begins with any other value, the radix is 10 (decimal).</p>

<p>所以这里radix值实际为10，所以结果为1</p>

<p>而parseInt(“2”, 1)和parseInt(“3”, 2)则确实无法解析，会生成NaN</p>

<p>所以答案为[1,NaN,NaN]，为D</p>

<h3 id="section-1">第二题和第五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[typeof null, null instanceof Object]
</code>
A: [“object”, false]</p>

<p>B: [null, false]</p>

<p>C: [“object”, true]</p>

<p>D: other</p>

<p>考察typeof运算符和instanceof运算符，上MDN上看一下typeof运算符，一些基础类型的结果为：
Undefined           “undefined”
Null                “object”
Boolean             “boolean”
Number              “number”
String              “string”
Any other object    “object”
Array               “object”</p>

<p>自从javascript创造出来，typeof null的值就是object了</p>

<p>而null instanceof 任何类型 都是false</p>

<p>所以答案为[“object”, false], 选A</p>

<h3 id="section-2">第三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow)] ]
</code>
A: an error</p>

<p>B: [9, 0]</p>

<p>C: [9, NaN]</p>

<p>D: [9, undefined]</p>

<p>这题考的Math.pow和Array.prototype.reduce</p>

<p>Math.pow(base, exponent)接受两个参数：基数、需要计算的次方</p>

<p>reduce传递给其作为参数的函数几个值：
* previousValue：上一次计算的结果
* currentValue：当前元素的值
* index： 当前元素在数组中的位置
* array：整个数组</p>

<p>reduce本身接受两个参数，callback和initialValue，分别是reduce的回调函数和计算初始值–也就是第一次reduce的callback被调用时的previousValue的值，默认为0</p>

<p>reduce在数组为空且没有定义initialValue时，会抛出错误，如chrome下：TypeError: Reduce of empty array with no initial value</p>

<p>所以选A</p>

<h3 id="section-3">第四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');
</code>
A: Value is Something</p>

<p>B: Value is Nothing</p>

<p>C: NaN</p>

<p>D: other</p>

<p>这题考的javascript中的运算符符优先级，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN传送门</a>，这里’+’运算符的优先级要高于’?’所以运算符，实际上是 ‘Value is true’?’Something’ : ‘Nothing’，当字符串不为空时，转换为bool为true，所以结果为’Something’，选D</p>

<h3 id="section-4">第六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var name = 'World!';
(function () {
    if (typeof name === 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
</code>
A: Goodbye Jack</p>

<p>B: Hello Jack</p>

<p>C: Hello undefined</p>

<p>D: Hello World</p>

<p>这题考的是javascript作用域中的变量提升，javascript的作用于中使用var定义的变量都会被提升到所有代码的最前面，于是乎这段代码就成了：
<code>javascript
var name = 'World!';
(function () {
    var name;//现在还是undefined
    if (typeof name === 'undefined') {
        name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
</code>
这样就很好理解了，<code>typeof name === 'undefined'</code>的结果为true，所以最后会输出’Goodbye Jack’，选A</p>

<h3 id="section-5">第七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var END = Math.pow(2, 53);
var START = END - 100;
var count = 0;
for (var i = START; i &lt;= END; i++) {
    count++;
}
console.log(count);
</code>
A: 0</p>

<p>B: 100</p>

<p>C: 101</p>

<p>D: other</p>

<p>这题考查javascript中的数字的概念：首先明确一点，javascript和其他语言不同，仅有一种数字，IEEE 754标准的64位浮点数，能够表示的整数范围是-2^53~2^53（包含边界值），所以Math.pow(2, 53)即为javascript中所能表示的最大整数，在最大整数在继续增大就会出现精度丢失的情况，END + 1 的值其实是等于END的，这也就造成了死循环，所以选D</p>

<h3 id="section-6">第八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var ary = [0,1,2];
ary[10] = 10;
ary.filter(function(x) { return x === undefined;});
</code>
A: [undefined 脳 7]</p>

<p>B: [0, 1, 2, 10]</p>

<p>C: []</p>

<p>D: [undefined]</p>

<p>考查Array.prototype.filter方法的使用，MDN上有这么一句it is not invoked for indexes which have been deleted or which have never been assigned values，所以结果为空数组，选C</p>

<h3 id="section-7">第九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var two   = 0.2
var one   = 0.1
var eight = 0.8
var six   = 0.6
[two - one == one, eight - six == two]
</code>
A: [true, true]</p>

<p>B: [false, false]</p>

<p>C: [true, false]</p>

<p>D: other</p>

<p>浮点数计算时的精度丢失问题，其他语言也会出现…至于结果，反正我是蒙的…chrome中计算出来的结果：[0.1, 0.20000000000000007]，也就是[true, false]，选C</p>

<h3 id="section-8">第十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function showCase(value) {
    switch(value) {
    case 'A':
        console.log('Case A');
        break;
    case 'B':
        console.log('Case B');
        break;
    case undefined:
        console.log('undefined');
        break;
    default:
        console.log('Do not know!');
    }
}
showCase(new String('A'));
</code>
A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>这题考的是使用new方法创建基础类型，使用new方法创建的基础类型，首先来看个栗子(chrome):
<code>javascript
&gt; typeof new String("skyinlayer");
"object"
typeof "skyinlayer";
"string"
</code>
这样基本上就能看到结果了，但是为什么呢？MDN上的解释是，字符串字面量和直接调用String()方法（不使用new调用构造函数）的结果是原始字符串。JS自动回转化原始字符串到String对象。所以可以在原始字符串上使用用String对象的方法。而在上下文中，在原始字符串的方法被调用或者从其中获取属性时，JS会自动包裹原始字符串然后调用方法或者获取属性。</p>

<p>所以呢，JS本身有原始字符串和字符串对象之分，只不过在调用方法和获取属性时的时候会自动转换，但typeof运算符运算时是不会转换的。Number和Boolean同样适用</p>

<p>所以这里结果为Do not know!，选C</p>

<h3 id="section-9">第十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function showCase2(value) {
    switch(value) {
    case 'A':
        console.log('Case A');
        break;
    case 'B':
        console.log('Case B');
        break;
    case undefined:
        console.log('undefined');
        break;
    default:
        console.log('Do not know!');
    }
}
showCase(String('A'));
</code>
A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>和上题原理一样，不过这里没有使用new来生成字符串，所以生成的结果就是原始字符串，相当于<code>showCase('A')</code>，所以结果就是A了</p>

<h3 id="section-10">第十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function isOdd(num) {
    return num % 2 == 1;
}
function isEven(num) {
    return num % 2 == 0;
}
function isSane(num) {
    return isEven(num) || isOdd(num);
}
var values = [7, 4, '13', -9, Infinity];
values.map(isSane);
</code>
A: [true, true, true, true, true]</p>

<p>B: [true, true, true, true, false]</p>

<p>C: [true, true, true, false, false]</p>

<p>D: [true, true, false, false, false]</p>

<p>还是JS的数字相关，不过这次考察的是取模，这题我也是瞎蒙的（果断跪了）。</p>

<p>前两个基本上没什么疑问，必然是true</p>

<p>‘13’在进行计算前则会进行隐式类型转换（JS最恶心的部分之一），详细参见<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>，这里的规则就是将字符串通过Number()方法转换为数字，所以结果为13 % 2 ，也就是true</p>

<p>而JS中负数取模的结果是负数，这里-9%2的结果实际上是-1，所以为false</p>

<p>而Infinity对任意数取模都是NaN，所以是false</p>

<p>综上，结果为[true, true, true, false, false]，也就是C</p>

<h3 id="section-11">第十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
parseInt(3, 8)
parseInt(3, 2)
parseInt(3, 0)
</code>
A: 3, 3, 3</p>

<p>B: 3, 3, NaN</p>

<p>C: 3, NaN, NaN</p>

<p>D: other</p>

<p>还是parseInt的题，考的和第一题类似，第一个值为3没什么好说的。如果出现的数字不符合后面输入的进制，则为NaN，所以第二个值为NaN。而radix为0时的情况第一题下面有介绍，这里也是一样为默认10，所以结果为3，所以答案为3, NaN, 3，选D</p>

<h3 id="section-12">第十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
Array.isArray( Array.prototype )
</code>
A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>死知识，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">MDN传送门</a>，这是MDN官方给的例子…</p>

<h3 id="section-13">第十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = [0];
if ([0]) { 
  console.log(a == true);
} else { 
  console.log("wut");
}
</code>
A: true</p>

<p>B: false</p>

<p>C: “wut”</p>

<p>D: other</p>

<p>同样是一道隐式类型转换的题，不过这次考虑的是’==’运算符，a本身是一个长度为1的数组，而当数组不为空时，其转换成bool值为true。</p>

<p>而==左右的转换，会使用<code>如果一个操作值为布尔值，则在比较之前先将其转换为数值</code>的规则来转换，Number([0])，也就是0，于是变成了0 == true，结果自然是false，所以最终结果为B</p>

<h3 id="section-14">第十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[] == []
</code>
A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是数组字面量创建数组的原理和==运算符，首先JS中数组的真实类型是Object这点很明显<code>typeof []</code>的值为”object”，而==运算符当左右都是对象时，则会比较其是否指向同一个对象。而每次调用字面量创建，都会创造新的对象，也就是会开辟新的内存区域。所以指针的值自然不一样，结果为 false，选B</p>

<h3 id="section-15">第十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
'5' + 3  
'5' - 3  
</code>
A: 53, 2</p>

<p>B: 8, 2</p>

<p>C: error</p>

<p>D: other</p>

<p>又是一道隐式类型转换的题</p>

<p>加法： 加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来</p>

<p>减法： 如果操作值之一不是数值，则被隐式调用Number()函数进行转换</p>

<p>所以第一行结果为字符串运算，为’53’。第二行结果为2，选A</p>

<h3 id="section-16">第十八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
1 + - + + + - + 1 
</code>
A: 2</p>

<p>B: 1</p>

<p>C: error</p>

<p>D: other</p>

<p>C语言中的经典…对于这种问题，原理什么的不懂，蒙吧，结果是2</p>

<h3 id="section-17">第十九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var ary = Array(3);
ary[0]=2
ary.map(function(elem) { return '1'; }); 
</code>
A: [2, 1, 1]</p>

<p>B: [“1”, “1”, “1”]</p>

<p>C: [2, “1”, “1”]</p>

<p>D: other</p>

<p>又是考的Array.prototype.map的用法，map在使用的时候，只有数组中被初始化过元素才会被触发，其他都是undefined，所以结果为[“1”, undefined × 2]，选D</p>

<h3 id="section-18">第二十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function sidEffecting(ary) { 
  ary[0] = ary[2];
}
function bar(a,b,c) { 
  c = 10
  sidEffecting(arguments);
  return a + b + c;
}
bar(1,1,1)
</code>
A: 3</p>

<p>B: 12</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是JS的函数arguments的概念：</p>

<p>在调用函数时，函数内部的arguments维护着传递到这个函数的参数列表。它看起来是一个数组，但实际上它只是一个有length属性的Object，不从Array.prototype继承。所以无法使用一些Array.prototype的方法。</p>

<p>arguments对象其内部属性以及函数形参创建getter和setter方法，因此改变形参的值会影响到arguments对象的值，反过来也是一样</p>

<p>具体例子可以参见<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.arguments">Javascript秘密花园#arguments</a></p>

<p>所以，这里所有的更改都将生效，a和c的值都为10，a+b+c的值将为21，选D</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/10/javascript-puzzlers.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ JavaScript选择题解答（1-20） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/10/javascript-puzzlers.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 10 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>最近做了个heroku上的JavaScript的测试（<a href="http://javascript-puzzlers.herokuapp.com/">题目地址</a>），错了一大堆，感觉js的概念还有很多不是很清晰，这里记录一下</p>

<h3 id="section">第一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
["1", "2", "3"].map(parseInt) 
</code>
A：[“1”, “2”, “3”]</p>

<p>B：[1, 2, 3]</p>

<p>C：[0, 1, 2]</p>

<p>D：other</p>

<p>解答：这里考的是map、parseInt的用法。map会传递三个参数给其作为参数的函数，为(element, index, array)，分别为当前的元素、当前元素在数组中的位置、整个数组：</p>

<pre><code>&gt; ["1", "2", "3"].map(function(){console.log(arguments)}) 
["1", 0, Array[3]]
["2", 1, Array[3]]
["3", 2, Array[3]]
</code></pre>

<p>而parseInt只接收两个参数，为(element, radix)，element代表需要被转换为int的字符串，radix代表当前字符串里数字的进制数</p>

<p>所以相当于说，结果数组的元素实际分别为为：</p>

<pre><code>parseInt("1", 0)
parseInt("2", 1)
parseInt("3", 2)
</code></pre>

<p>parseInt(“1”, 0)的值为1，MDN上可以看到parseInt函数的radix为0时的行为</p>

<p>If radix is undefined or 0 (or absent), JavaScript assumes the following:</p>

<p>If the input string begins with “0x” or “0X”, radix is 16 (hexadecimal) and the remainder of the string is parsed.</p>

<p>If the input string begins with “0”, radix is eight (octal) or 10 (decimal).  Exactly which radix is chosen is implementation-dependent.  ECMAScript 5 specifies that 10 (decimal) is used, but not all browsers support this yet.  For this reason always specify a radix when using parseInt.</p>

<p>If the input string begins with any other value, the radix is 10 (decimal).</p>

<p>所以这里radix值实际为10，所以结果为1</p>

<p>而parseInt(“2”, 1)和parseInt(“3”, 2)则确实无法解析，会生成NaN</p>

<p>所以答案为[1,NaN,NaN]，为D</p>

<h3 id="section-1">第二题和第五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[typeof null, null instanceof Object]
</code>
A: [“object”, false]</p>

<p>B: [null, false]</p>

<p>C: [“object”, true]</p>

<p>D: other</p>

<p>考察typeof运算符和instanceof运算符，上MDN上看一下typeof运算符，一些基础类型的结果为：
Undefined           “undefined”
Null                “object”
Boolean             “boolean”
Number              “number”
String              “string”
Any other object    “object”
Array               “object”</p>

<p>自从javascript创造出来，typeof null的值就是object了</p>

<p>而null instanceof 任何类型 都是false</p>

<p>所以答案为[“object”, false], 选A</p>

<h3 id="section-2">第三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow)] ]
</code>
A: an error</p>

<p>B: [9, 0]</p>

<p>C: [9, NaN]</p>

<p>D: [9, undefined]</p>

<p>这题考的Math.pow和Array.prototype.reduce</p>

<p>Math.pow(base, exponent)接受两个参数：基数、需要计算的次方</p>

<p>reduce传递给其作为参数的函数几个值：
* previousValue：上一次计算的结果
* currentValue：当前元素的值
* index： 当前元素在数组中的位置
* array：整个数组</p>

<p>reduce本身接受两个参数，callback和initialValue，分别是reduce的回调函数和计算初始值–也就是第一次reduce的callback被调用时的previousValue的值，默认为0</p>

<p>reduce在数组为空且没有定义initialValue时，会抛出错误，如chrome下：TypeError: Reduce of empty array with no initial value</p>

<p>所以选A</p>

<h3 id="section-3">第四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');
</code>
A: Value is Something</p>

<p>B: Value is Nothing</p>

<p>C: NaN</p>

<p>D: other</p>

<p>这题考的javascript中的运算符符优先级，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN传送门</a>，这里’+’运算符的优先级要高于’?’所以运算符，实际上是 ‘Value is true’?’Something’ : ‘Nothing’，当字符串不为空时，转换为bool为true，所以结果为’Something’，选D</p>

<h3 id="section-4">第六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var name = 'World!';
(function () {
    if (typeof name === 'undefined') {
        var name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
</code>
A: Goodbye Jack</p>

<p>B: Hello Jack</p>

<p>C: Hello undefined</p>

<p>D: Hello World</p>

<p>这题考的是javascript作用域中的变量提升，javascript的作用于中使用var定义的变量都会被提升到所有代码的最前面，于是乎这段代码就成了：
<code>javascript
var name = 'World!';
(function () {
    var name;//现在还是undefined
    if (typeof name === 'undefined') {
        name = 'Jack';
        console.log('Goodbye ' + name);
    } else {
        console.log('Hello ' + name);
    }
})();
</code>
这样就很好理解了，<code>typeof name === 'undefined'</code>的结果为true，所以最后会输出’Goodbye Jack’，选A</p>

<h3 id="section-5">第七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var END = Math.pow(2, 53);
var START = END - 100;
var count = 0;
for (var i = START; i &lt;= END; i++) {
    count++;
}
console.log(count);
</code>
A: 0</p>

<p>B: 100</p>

<p>C: 101</p>

<p>D: other</p>

<p>这题考查javascript中的数字的概念：首先明确一点，javascript和其他语言不同，仅有一种数字，IEEE 754标准的64位浮点数，能够表示的整数范围是-2^53~2^53（包含边界值），所以Math.pow(2, 53)即为javascript中所能表示的最大整数，在最大整数在继续增大就会出现精度丢失的情况，END + 1 的值其实是等于END的，这也就造成了死循环，所以选D</p>

<h3 id="section-6">第八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var ary = [0,1,2];
ary[10] = 10;
ary.filter(function(x) { return x === undefined;});
</code>
A: [undefined 脳 7]</p>

<p>B: [0, 1, 2, 10]</p>

<p>C: []</p>

<p>D: [undefined]</p>

<p>考查Array.prototype.filter方法的使用，MDN上有这么一句it is not invoked for indexes which have been deleted or which have never been assigned values，所以结果为空数组，选C</p>

<h3 id="section-7">第九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var two   = 0.2
var one   = 0.1
var eight = 0.8
var six   = 0.6
[two - one == one, eight - six == two]
</code>
A: [true, true]</p>

<p>B: [false, false]</p>

<p>C: [true, false]</p>

<p>D: other</p>

<p>浮点数计算时的精度丢失问题，其他语言也会出现…至于结果，反正我是蒙的…chrome中计算出来的结果：[0.1, 0.20000000000000007]，也就是[true, false]，选C</p>

<h3 id="section-8">第十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function showCase(value) {
    switch(value) {
    case 'A':
        console.log('Case A');
        break;
    case 'B':
        console.log('Case B');
        break;
    case undefined:
        console.log('undefined');
        break;
    default:
        console.log('Do not know!');
    }
}
showCase(new String('A'));
</code>
A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>这题考的是使用new方法创建基础类型，使用new方法创建的基础类型，首先来看个栗子(chrome):
<code>javascript
&gt; typeof new String("skyinlayer");
"object"
typeof "skyinlayer";
"string"
</code>
这样基本上就能看到结果了，但是为什么呢？MDN上的解释是，字符串字面量和直接调用String()方法（不使用new调用构造函数）的结果是原始字符串。JS自动回转化原始字符串到String对象。所以可以在原始字符串上使用用String对象的方法。而在上下文中，在原始字符串的方法被调用或者从其中获取属性时，JS会自动包裹原始字符串然后调用方法或者获取属性。</p>

<p>所以呢，JS本身有原始字符串和字符串对象之分，只不过在调用方法和获取属性时的时候会自动转换，但typeof运算符运算时是不会转换的。Number和Boolean同样适用</p>

<p>所以这里结果为Do not know!，选C</p>

<h3 id="section-9">第十一题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function showCase2(value) {
    switch(value) {
    case 'A':
        console.log('Case A');
        break;
    case 'B':
        console.log('Case B');
        break;
    case undefined:
        console.log('undefined');
        break;
    default:
        console.log('Do not know!');
    }
}
showCase(String('A'));
</code>
A: Case A</p>

<p>B: Case B</p>

<p>C: Do not know!</p>

<p>D: undefined</p>

<p>和上题原理一样，不过这里没有使用new来生成字符串，所以生成的结果就是原始字符串，相当于<code>showCase('A')</code>，所以结果就是A了</p>

<h3 id="section-10">第十二题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function isOdd(num) {
    return num % 2 == 1;
}
function isEven(num) {
    return num % 2 == 0;
}
function isSane(num) {
    return isEven(num) || isOdd(num);
}
var values = [7, 4, '13', -9, Infinity];
values.map(isSane);
</code>
A: [true, true, true, true, true]</p>

<p>B: [true, true, true, true, false]</p>

<p>C: [true, true, true, false, false]</p>

<p>D: [true, true, false, false, false]</p>

<p>还是JS的数字相关，不过这次考察的是取模，这题我也是瞎蒙的（果断跪了）。</p>

<p>前两个基本上没什么疑问，必然是true</p>

<p>‘13’在进行计算前则会进行隐式类型转换（JS最恶心的部分之一），详细参见<a href="http://www.cnblogs.com/mizzle/archive/2011/08/12/2135885.html">$雨$的文章《Javascript类型转换的规则》</a>，这里的规则就是将字符串通过Number()方法转换为数字，所以结果为13 % 2 ，也就是true</p>

<p>而JS中负数取模的结果是负数，这里-9%2的结果实际上是-1，所以为false</p>

<p>而Infinity对任意数取模都是NaN，所以是false</p>

<p>综上，结果为[true, true, true, false, false]，也就是C</p>

<h3 id="section-11">第十三题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
parseInt(3, 8)
parseInt(3, 2)
parseInt(3, 0)
</code>
A: 3, 3, 3</p>

<p>B: 3, 3, NaN</p>

<p>C: 3, NaN, NaN</p>

<p>D: other</p>

<p>还是parseInt的题，考的和第一题类似，第一个值为3没什么好说的。如果出现的数字不符合后面输入的进制，则为NaN，所以第二个值为NaN。而radix为0时的情况第一题下面有介绍，这里也是一样为默认10，所以结果为3，所以答案为3, NaN, 3，选D</p>

<h3 id="section-12">第十四题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
Array.isArray( Array.prototype )
</code>
A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>死知识，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype">MDN传送门</a>，这是MDN官方给的例子…</p>

<h3 id="section-13">第十五题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var a = [0];
if ([0]) { 
  console.log(a == true);
} else { 
  console.log("wut");
}
</code>
A: true</p>

<p>B: false</p>

<p>C: “wut”</p>

<p>D: other</p>

<p>同样是一道隐式类型转换的题，不过这次考虑的是’==’运算符，a本身是一个长度为1的数组，而当数组不为空时，其转换成bool值为true。</p>

<p>而==左右的转换，会使用<code>如果一个操作值为布尔值，则在比较之前先将其转换为数值</code>的规则来转换，Number([0])，也就是0，于是变成了0 == true，结果自然是false，所以最终结果为B</p>

<h3 id="section-14">第十六题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
[] == []
</code>
A: true</p>

<p>B: false</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是数组字面量创建数组的原理和==运算符，首先JS中数组的真实类型是Object这点很明显<code>typeof []</code>的值为”object”，而==运算符当左右都是对象时，则会比较其是否指向同一个对象。而每次调用字面量创建，都会创造新的对象，也就是会开辟新的内存区域。所以指针的值自然不一样，结果为 false，选B</p>

<h3 id="section-15">第十七题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
'5' + 3  
'5' - 3  
</code>
A: 53, 2</p>

<p>B: 8, 2</p>

<p>C: error</p>

<p>D: other</p>

<p>又是一道隐式类型转换的题</p>

<p>加法： 加法运算中，如果有一个操作值为字符串类型，则将另一个操作值转换为字符串，最后连接起来</p>

<p>减法： 如果操作值之一不是数值，则被隐式调用Number()函数进行转换</p>

<p>所以第一行结果为字符串运算，为’53’。第二行结果为2，选A</p>

<h3 id="section-16">第十八题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
1 + - + + + - + 1 
</code>
A: 2</p>

<p>B: 1</p>

<p>C: error</p>

<p>D: other</p>

<p>C语言中的经典…对于这种问题，原理什么的不懂，蒙吧，结果是2</p>

<h3 id="section-17">第十九题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
var ary = Array(3);
ary[0]=2
ary.map(function(elem) { return '1'; }); 
</code>
A: [2, 1, 1]</p>

<p>B: [“1”, “1”, “1”]</p>

<p>C: [2, “1”, “1”]</p>

<p>D: other</p>

<p>又是考的Array.prototype.map的用法，map在使用的时候，只有数组中被初始化过元素才会被触发，其他都是undefined，所以结果为[“1”, undefined × 2]，选D</p>

<h3 id="section-18">第二十题</h3>
<p>What is the result of this expression? (or multiple ones)
<code>javascript
function sidEffecting(ary) { 
  ary[0] = ary[2];
}
function bar(a,b,c) { 
  c = 10
  sidEffecting(arguments);
  return a + b + c;
}
bar(1,1,1)
</code>
A: 3</p>

<p>B: 12</p>

<p>C: error</p>

<p>D: other</p>

<p>这题考的是JS的函数arguments的概念：</p>

<p>在调用函数时，函数内部的arguments维护着传递到这个函数的参数列表。它看起来是一个数组，但实际上它只是一个有length属性的Object，不从Array.prototype继承。所以无法使用一些Array.prototype的方法。</p>

<p>arguments对象其内部属性以及函数形参创建getter和setter方法，因此改变形参的值会影响到arguments对象的值，反过来也是一样</p>

<p>具体例子可以参见<a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#function.arguments">Javascript秘密花园#arguments</a></p>

<p>所以，这里所有的更改都将生效，a和c的值都为10，a+b+c的值将为21，选D</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/10/javascript-puzzlers.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（将本地博客上传至github） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/09/jekyll-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-4/">使用Jekyll在Github上搭建个人博客（文章分类索引）</a></p>

<h3 id="section">预先准备</h3>
<p>首先安装git bash和申请，这个文章很多，百度、Google上一抓一大把，就不重复赘述了</p>

<h3 id="git">对已有项目进行git初始化</h3>
<p>到jekyll项目下，运行命令：
<code>shell
$ git init
</code></p>

<h3 id="gh-pages">创建一个名为gh-pages的分支</h3>
<p><code>shell
$ git checkout --orphan gh-pages
</code>
<a href="http://jekyllrb.com/docs/github-pages/">Jekyll官网的github pages介绍</a>上说如果要部署在github上，必须名称叫gh-pages。所以先创建一个叫gh-pages的分支</p>

<h3 id="section-1">发布</h3>
<p>使用命令:
<code>shell
$ git add .
$ git commit -a -m "v0.0.1 first blood"
</code>
提交所有的修改到本地的git仓库</p>

<h3 id="github">上传到github</h3>
<p>使用命令：
<code>shell
$ git remote add origin https://github.com/(github用户名)/(jekyll项目名称).git
$ git push origin gh-pages
</code></p>

<h3 id="section-2">修改后提交</h3>
<p>使用命令：
<code>shell
$ git add .
$ git commit -a -m "自己的提交注释"
$ git push origin gh-pages
</code>
第一句增加所有新增的文件到项目中</p>

<p>第二句提交所有修改</p>

<p>第三句将修改提交到远程github服务器</p>

<h3 id="section-3">绑定到自己的域名</h3>
<p>如果是绑定到一级域名：
1. 首先在项目根目录下创建一个叫CNAME文件，里面写上自己的以及一级域名（如这个博客就是lingyu.wang）
2. 在DNS中为自己的域名增加一条A记录，指向207.97.227.245
3. 将项目提交到github上，等一会儿（不会超过1小时）
4. baseurl应该为”/”
5. 访问自己的域名看看结果吧</p>

<p>如果是绑定到二级域名，需要额外在DNS中增加一条CNAME，指向(github用户名).github.io，然后再CNAME文件中修改为自己的二级域名即可</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/09/jekyll-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（将本地博客上传至github） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/09/jekyll-5.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-4/">使用Jekyll在Github上搭建个人博客（文章分类索引）</a></p>

<h3 id="section">预先准备</h3>
<p>首先安装git bash和申请，这个文章很多，百度、Google上一抓一大把，就不重复赘述了</p>

<h3 id="git">对已有项目进行git初始化</h3>
<p>到jekyll项目下，运行命令：
<code>shell
$ git init
</code></p>

<h3 id="gh-pages">创建一个名为gh-pages的分支</h3>
<p><code>shell
$ git checkout --orphan gh-pages
</code>
<a href="http://jekyllrb.com/docs/github-pages/">Jekyll官网的github pages介绍</a>上说如果要部署在github上，必须名称叫gh-pages。所以先创建一个叫gh-pages的分支</p>

<h3 id="section-1">发布</h3>
<p>使用命令:
<code>shell
$ git add .
$ git commit -a -m "v0.0.1 first blood"
</code>
提交所有的修改到本地的git仓库</p>

<h3 id="github">上传到github</h3>
<p>使用命令：
<code>shell
$ git remote add origin https://github.com/(github用户名)/(jekyll项目名称).git
$ git push origin gh-pages
</code></p>

<h3 id="section-2">修改后提交</h3>
<p>使用命令：
<code>shell
$ git add .
$ git commit -a -m "自己的提交注释"
$ git push origin gh-pages
</code>
第一句增加所有新增的文件到项目中</p>

<p>第二句提交所有修改</p>

<p>第三句将修改提交到远程github服务器</p>

<h3 id="section-3">绑定到自己的域名</h3>
<p>如果是绑定到一级域名：
1. 首先在项目根目录下创建一个叫CNAME文件，里面写上自己的以及一级域名（如这个博客就是lingyu.wang）
2. 在DNS中为自己的域名增加一条A记录，指向207.97.227.245
3. 将项目提交到github上，等一会儿（不会超过1小时）
4. baseurl应该为”/”
5. 访问自己的域名看看结果吧</p>

<p>如果是绑定到二级域名，需要额外在DNS中增加一条CNAME，指向(github用户名).github.io，然后再CNAME文件中修改为自己的二级域名即可</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/09/jekyll-5.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用box-shadow绘制像素画 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/09/box-shadow-pix-image.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>曾经在codepen.io上看到很多像素画，都是css3实现的，点进去看才知道是使用box-shadow实现的，但是当时并不了解CSS3的box-shadow属性。如今稍微了解了box-shadow属性，并自己绘制了一个超级玛丽</p>

<p>希望实现的效果：</p>

<p><img src="/img/mario.jpg" alt="马里奥" /></p>

<h2 id="box-shadow">box-shadow属性</h2>
<p>首先了解一下CSS3的box-shadow属性</p>

<p><img src="/img/box-shadow.jpg" alt="box-shadow" /></p>

<p>可以看到浏览器的支持还是相当不错的，就连IE也从9就支持了</p>

<p>既然需要画像素画，当然主要是绘制矩形，而使用box-shadow可以很方便的实现。box-shadow属性的值可以为[水平偏移, 垂直偏移 , 阴影颜色]、[水平偏移, 垂直偏移 , 阴影模糊值 ,阴影颜色]或者[水平偏移, 垂直偏移 , 阴影模糊值 , 阴影延长值,阴影颜色]。由于绘制像素画不需要使用模糊效果，所以只要使用第一种格式[水平偏移, 垂直偏移 , 阴影颜色]就可以了。</p>

<p>那使用box-shadow如何绘制多个方块？
###定义基础元素
定义一个div用于作为box-shadow的拥有者：
<code>html
&lt;div class="pix"&gt;&lt;/div&gt;
</code></p>

<p><code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></p>

<p>将它作为最左上角的方块，由于被元素覆盖的box-shadow将不会被显示（就算元素本身的background-color为transparent也不行），颜色直接由background-color属性来确定。关键是定义它的width和height属性，这两个属性决定了每个方块的宽和高。</p>

<p>效果很简单：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/12/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-1">在其四周绘制方块</h3>
<p>首先在其右侧绘制一个与原始大小等大的方块，这就要使用box-shadow属性了。给元素添加box-shadow，并添加一个阴影值<code>100px 0 blue</code>，这样就相当于在该元素的左边100px，绘制了一个与元素等大的颜色为blue的方块。</p>

<p>css代码修改为：
<code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/10/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>在元素下面绘制一个等大的方块类似，再给box-shadow添加一个值：<code>0 100px blue</code>，css代码修改为：
<code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue, 0 100px blue
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/13/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>再添加几个，比如以原始元素为[0,0]，添加[2,0],[1,1],[0,2],背景为绿色：
分别在box-shadow中添加三个属性分别表示这三个方块：</p>

<p><code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 
        100px 0 blue, 
        0 100px blue,
        200px 0 green
        100px 100px green,
        0 200px green;
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/14/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>这里可以看到，完全可以使用box-shadow绘制像素画，每个像素（方块）用一行box-shadow的值表示就可以了</p>

<h2 id="section-2">画超级玛丽</h2>
<p>一般画像素画之前需要做点准备：
1. 首先需要确定每个像素（格子）的真正大小，一般为方块，这里我取了32X32大小。
2. 然后需要确定整幅图需要格子的行数和列数，可以数一数，横向12格，纵向16格。
3. 如果有范本可以直接一行一行添加格子的box-shadow值，如果直接凭空画，可以把整张图拆分成多个部分进行绘制。甚至拆成多个div，每个div定义自己的box-shadow值</p>

<p>既然已经知道使用box-shadow画方块的方法了，自然就可以画超级玛丽了。看最上面的图就可以知道8-bit时代的超级玛丽都是由方块组成，主要有三个颜色：
1. 帽子和肚兜（？）的红色：#E6002E
2. 身体的黄色：#F8B600
3. 头发、胡须、衣服、鞋子的深绿色：#808A27
这里通过一行一行的方式进行绘制：</p>

<p>一步一步话，先画帽子：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>接着绘制脸：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/1/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>然后绘制身体：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/2/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>最后把脚画上：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/3/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>这样就齐活了，以前dos系统或者fc游戏机中的像素画都可以通过这种方式绘制</p>

<p>完整的代码：</p>

<p><code>css
.pix {
    width: 32px;
    height: 32px;
    background-color: transparent;
    box-shadow: 
    /*帽子*/ 
    96px 0 #E6002E, 128px 0 #E6002E, 160px 0 #E6002E, 192px 0 #E6002E, 224px 0 #E6002E, 64px 32px #E6002E, 96px 32px #E6002E, 128px 32px #E6002E, 160px 32px #E6002E, 192px 32px #E6002E, 224px 32px #E6002E, 256px 32px #E6002E, 288px 32px #E6002E, 320px 32px #E6002E, 
    /*头*/ 
    64px 64px #808A27, 96px 64px #808A27, 128px 64px #808A27, 160px 64px #F8B600, 192px 64px #F8B600, 224px 64px #808A27, 256px 64px #F8B600, 32px 96px #808A27, 64px 96px #F8B600, 96px 96px #808A27, 128px 96px #F8B600, 160px 96px #F8B600, 192px 96px #F8B600, 224px 96px #808A27, 256px 96px #F8B600, 288px 96px #F8B600, 320px 96px #F8B600, 32px 128px #808A27, 64px 128px #F8B600, 96px 128px #808A27, 128px 128px #808A27, 160px 128px #F8B600, 192px 128px #F8B600, 224px 128px #F8B600, 256px 128px #808A27, 288px 128px #F8B600, 320px 128px #F8B600, 352px 128px #F8B600, 32px 160px #808A27, 64px 160px #808A27, 96px 160px #F8B600, 128px 160px #F8B600, 160px 160px #F8B600, 192px 160px #F8B600, 224px 160px #808A27, 256px 160px #808A27, 288px 160px #808A27, 320px 160px #808A27, 96px 192px #F8B600, 128px 192px #F8B600, 160px 192px #F8B600, 192px 192px #F8B600, 224px 192px #F8B600, 256px 192px #F8B600, 288px 192px #F8B600, 
    /*身体*/ 
    64px 224px #808A27, 96px 224px #808A27, 128px 224px #E6002E, 160px 224px #808A27, 192px 224px #808A27, 224px 224px #808A27, 32px 256px #808A27, 64px 256px #808A27, 96px 256px #808A27, 128px 256px #E6002E, 160px 256px #808A27, 192px 256px #808A27, 224px 256px #E6002E, 256px 256px #808A27, 288px 256px #808A27, 320px 256px #808A27, 0px 288px #808A27, 32px 288px #808A27, 64px 288px #808A27, 96px 288px #808A27, 128px 288px #E6002E, 160px 288px #E6002E, 192px 288px #E6002E, 224px 288px #E6002E, 256px 288px #808A27, 288px 288px #808A27, 320px 288px #808A27, 352px 288px #808A27, 0px 320px #F8B600, 32px 320px #F8B600, 64px 320px #808A27, 96px 320px #E6002E, 128px 320px #F8B600, 160px 320px #E6002E, 192px 320px #E6002E, 224px 320px #F8B600, 256px 320px #E6002E, 288px 320px #808A27, 320px 320px #F8B600, 352px 320px #F8B600, 0px 352px #F8B600, 32px 352px #F8B600, 64px 352px #F8B600, 96px 352px #E6002E, 128px 352px #E6002E, 160px 352px #E6002E, 192px 352px #E6002E, 224px 352px #E6002E, 256px 352px #E6002E, 288px 352px #F8B600, 320px 352px #F8B600, 352px 352px #F8B600, 0px 384px #F8B600, 32px 384px #F8B600, 64px 384px #E6002E, 96px 384px #E6002E, 128px 384px #E6002E, 160px 384px #E6002E, 192px 384px #E6002E, 224px 384px #E6002E, 256px 384px #E6002E, 288px 384px #E6002E, 320px 384px #F8B600, 352px 384px #F8B600, 64px 416px #E6002E, 96px 416px #E6002E, 128px 416px #E6002E, 224px 416px #E6002E, 256px 416px #E6002E, 288px 416px #E6002E, 
    /*脚*/ 
    32px 448px #808A27, 64px 448px #808A27, 96px 448px #808A27, 256px 448px #808A27, 288px 448px #808A27, 320px 448px #808A27, 0px 480px #808A27, 32px 480px #808A27, 64px 480px #808A27, 96px 480px #808A27, 256px 480px #808A27, 288px 480px #808A27, 320px 480px #808A27, 352px 480px #808A27;
}
</code></p>

<h2 id="section-3">总结</h2>
<p>使用box-shadow绘制像素画好处就是思路很简单，易于实现</p>

<p>但坏处也很多，绘制精细的绘画肯定是要完蛋的。同时庞大的css代码量导致加载速度变得很慢。所以一般情况下，可以直接通过div+css等现行进行大体的绘制，需要一些特殊小图形的时候才使用像素画绘制。同时像素画也可以通过写脚本动态的生成。免去了手动敲CSS的麻烦</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/09/box-shadow-pix-image.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用box-shadow绘制像素画 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/09/box-shadow-pix-image.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 09 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">前面的话</h2>
<p>曾经在codepen.io上看到很多像素画，都是css3实现的，点进去看才知道是使用box-shadow实现的，但是当时并不了解CSS3的box-shadow属性。如今稍微了解了box-shadow属性，并自己绘制了一个超级玛丽</p>

<p>希望实现的效果：</p>

<p><img src="/img/mario.jpg" alt="马里奥" /></p>

<h2 id="box-shadow">box-shadow属性</h2>
<p>首先了解一下CSS3的box-shadow属性</p>

<p><img src="/img/box-shadow.jpg" alt="box-shadow" /></p>

<p>可以看到浏览器的支持还是相当不错的，就连IE也从9就支持了</p>

<p>既然需要画像素画，当然主要是绘制矩形，而使用box-shadow可以很方便的实现。box-shadow属性的值可以为[水平偏移, 垂直偏移 , 阴影颜色]、[水平偏移, 垂直偏移 , 阴影模糊值 ,阴影颜色]或者[水平偏移, 垂直偏移 , 阴影模糊值 , 阴影延长值,阴影颜色]。由于绘制像素画不需要使用模糊效果，所以只要使用第一种格式[水平偏移, 垂直偏移 , 阴影颜色]就可以了。</p>

<p>那使用box-shadow如何绘制多个方块？
###定义基础元素
定义一个div用于作为box-shadow的拥有者：
<code>html
&lt;div class="pix"&gt;&lt;/div&gt;
</code></p>

<p><code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
}
</code></p>

<p>将它作为最左上角的方块，由于被元素覆盖的box-shadow将不会被显示（就算元素本身的background-color为transparent也不行），颜色直接由background-color属性来确定。关键是定义它的width和height属性，这两个属性决定了每个方块的宽和高。</p>

<p>效果很简单：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/12/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<h3 id="section-1">在其四周绘制方块</h3>
<p>首先在其右侧绘制一个与原始大小等大的方块，这就要使用box-shadow属性了。给元素添加box-shadow，并添加一个阴影值<code>100px 0 blue</code>，这样就相当于在该元素的左边100px，绘制了一个与元素等大的颜色为blue的方块。</p>

<p>css代码修改为：
<code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/10/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>在元素下面绘制一个等大的方块类似，再给box-shadow添加一个值：<code>0 100px blue</code>，css代码修改为：
<code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 100px 0 blue, 0 100px blue
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/13/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>再添加几个，比如以原始元素为[0,0]，添加[2,0],[1,1],[0,2],背景为绿色：
分别在box-shadow中添加三个属性分别表示这三个方块：</p>

<p><code>css
.pix {
    width: 100px;
    height: 100px;
    background-color: red;
    box-shadow: 
        100px 0 blue, 
        0 100px blue,
        200px 0 green
        100px 100px green,
        0 200px green;
}
</code></p>

<p>效果如下：</p>

<iframe width="100%" height="300" src="http://jsfiddle.net/skyinlayer/56pgb/14/embedded/result" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>这里可以看到，完全可以使用box-shadow绘制像素画，每个像素（方块）用一行box-shadow的值表示就可以了</p>

<h2 id="section-2">画超级玛丽</h2>
<p>一般画像素画之前需要做点准备：
1. 首先需要确定每个像素（格子）的真正大小，一般为方块，这里我取了32X32大小。
2. 然后需要确定整幅图需要格子的行数和列数，可以数一数，横向12格，纵向16格。
3. 如果有范本可以直接一行一行添加格子的box-shadow值，如果直接凭空画，可以把整张图拆分成多个部分进行绘制。甚至拆成多个div，每个div定义自己的box-shadow值</p>

<p>既然已经知道使用box-shadow画方块的方法了，自然就可以画超级玛丽了。看最上面的图就可以知道8-bit时代的超级玛丽都是由方块组成，主要有三个颜色：
1. 帽子和肚兜（？）的红色：#E6002E
2. 身体的黄色：#F8B600
3. 头发、胡须、衣服、鞋子的深绿色：#808A27
这里通过一行一行的方式进行绘制：</p>

<p>一步一步话，先画帽子：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>接着绘制脸：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/1/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>然后绘制身体：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/2/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>最后把脚画上：</p>

<iframe width="100%" height="600" src="http://jsfiddle.net/skyinlayer/s36mK/3/embedded/result,css,html" allowfullscreen="allowfullscreen" frameborder="0">&nbsp;</iframe>

<p>这样就齐活了，以前dos系统或者fc游戏机中的像素画都可以通过这种方式绘制</p>

<p>完整的代码：</p>

<p><code>css
.pix {
    width: 32px;
    height: 32px;
    background-color: transparent;
    box-shadow: 
    /*帽子*/ 
    96px 0 #E6002E, 128px 0 #E6002E, 160px 0 #E6002E, 192px 0 #E6002E, 224px 0 #E6002E, 64px 32px #E6002E, 96px 32px #E6002E, 128px 32px #E6002E, 160px 32px #E6002E, 192px 32px #E6002E, 224px 32px #E6002E, 256px 32px #E6002E, 288px 32px #E6002E, 320px 32px #E6002E, 
    /*头*/ 
    64px 64px #808A27, 96px 64px #808A27, 128px 64px #808A27, 160px 64px #F8B600, 192px 64px #F8B600, 224px 64px #808A27, 256px 64px #F8B600, 32px 96px #808A27, 64px 96px #F8B600, 96px 96px #808A27, 128px 96px #F8B600, 160px 96px #F8B600, 192px 96px #F8B600, 224px 96px #808A27, 256px 96px #F8B600, 288px 96px #F8B600, 320px 96px #F8B600, 32px 128px #808A27, 64px 128px #F8B600, 96px 128px #808A27, 128px 128px #808A27, 160px 128px #F8B600, 192px 128px #F8B600, 224px 128px #F8B600, 256px 128px #808A27, 288px 128px #F8B600, 320px 128px #F8B600, 352px 128px #F8B600, 32px 160px #808A27, 64px 160px #808A27, 96px 160px #F8B600, 128px 160px #F8B600, 160px 160px #F8B600, 192px 160px #F8B600, 224px 160px #808A27, 256px 160px #808A27, 288px 160px #808A27, 320px 160px #808A27, 96px 192px #F8B600, 128px 192px #F8B600, 160px 192px #F8B600, 192px 192px #F8B600, 224px 192px #F8B600, 256px 192px #F8B600, 288px 192px #F8B600, 
    /*身体*/ 
    64px 224px #808A27, 96px 224px #808A27, 128px 224px #E6002E, 160px 224px #808A27, 192px 224px #808A27, 224px 224px #808A27, 32px 256px #808A27, 64px 256px #808A27, 96px 256px #808A27, 128px 256px #E6002E, 160px 256px #808A27, 192px 256px #808A27, 224px 256px #E6002E, 256px 256px #808A27, 288px 256px #808A27, 320px 256px #808A27, 0px 288px #808A27, 32px 288px #808A27, 64px 288px #808A27, 96px 288px #808A27, 128px 288px #E6002E, 160px 288px #E6002E, 192px 288px #E6002E, 224px 288px #E6002E, 256px 288px #808A27, 288px 288px #808A27, 320px 288px #808A27, 352px 288px #808A27, 0px 320px #F8B600, 32px 320px #F8B600, 64px 320px #808A27, 96px 320px #E6002E, 128px 320px #F8B600, 160px 320px #E6002E, 192px 320px #E6002E, 224px 320px #F8B600, 256px 320px #E6002E, 288px 320px #808A27, 320px 320px #F8B600, 352px 320px #F8B600, 0px 352px #F8B600, 32px 352px #F8B600, 64px 352px #F8B600, 96px 352px #E6002E, 128px 352px #E6002E, 160px 352px #E6002E, 192px 352px #E6002E, 224px 352px #E6002E, 256px 352px #E6002E, 288px 352px #F8B600, 320px 352px #F8B600, 352px 352px #F8B600, 0px 384px #F8B600, 32px 384px #F8B600, 64px 384px #E6002E, 96px 384px #E6002E, 128px 384px #E6002E, 160px 384px #E6002E, 192px 384px #E6002E, 224px 384px #E6002E, 256px 384px #E6002E, 288px 384px #E6002E, 320px 384px #F8B600, 352px 384px #F8B600, 64px 416px #E6002E, 96px 416px #E6002E, 128px 416px #E6002E, 224px 416px #E6002E, 256px 416px #E6002E, 288px 416px #E6002E, 
    /*脚*/ 
    32px 448px #808A27, 64px 448px #808A27, 96px 448px #808A27, 256px 448px #808A27, 288px 448px #808A27, 320px 448px #808A27, 0px 480px #808A27, 32px 480px #808A27, 64px 480px #808A27, 96px 480px #808A27, 256px 480px #808A27, 288px 480px #808A27, 320px 480px #808A27, 352px 480px #808A27;
}
</code></p>

<h2 id="section-3">总结</h2>
<p>使用box-shadow绘制像素画好处就是思路很简单，易于实现</p>

<p>但坏处也很多，绘制精细的绘画肯定是要完蛋的。同时庞大的css代码量导致加载速度变得很慢。所以一般情况下，可以直接通过div+css等现行进行大体的绘制，需要一些特殊小图形的时候才使用像素画绘制。同时像素画也可以通过写脚本动态的生成。免去了手动敲CSS的麻烦</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/09/box-shadow-pix-image.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（文章分类索引） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/06/jekyll-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p>今天又滚出去野了一天，打牌输了，好在输的不多，聊天聊到了以后的路子，不太好走啊…</p>

<h2 id="category">使用Category分类</h2>
<p>一般来说，一个个人博客的文章会分为很多种，比如说有记录生活情感的、技术交流的、转载他人的等等，而在jekyll中，可以使用Category进行分类，使用方法非常简单
###为文章定义分类
首先要确定文章属于哪个分类。这个配置可以设置在文章的头信息中，使用category或者categories确定，如文章属于“test”类别：
<code>
---
layout: MyTemplate
title: Category Sample
category: test
---
</code>
或者使用categories，这个属性接受一个数组，代表这篇文章所述的类，如文章属于“test”和“sample”类别：
<code>
---
layout: MyTemplate
title: Category Sample
categories: [test, sample]
---
</code>
加入这些信息后，文章所属分类就定义好了。但是还需要在页面（或者模板）中输出分类所有的文章才能完成以分类为基础的索引功能
###输出所有分类
所有的分类信息都被存储在site对象的categories中，所以可以通过liquid的for标签进行输出：
```html
{% for category in site.categories %}</p>
<h2>{{ category | first }}</h2>
<p>&lt;/span&gt;{{ category | last | size }}&lt;/span&gt;
&lt;ul class="arc-list"&gt;
    {% for post in category.last %}
        &lt;li&gt;{{ post.date | date:”%d/%m/%Y”}}<a href="{{ post.url }}">{{ post.title }}</a>&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
{% endfor %}
```
上面代码可以看到，首先从site中取出所有categories的信息，分别输出。categories的元素为一个两个元素的数组，第一个元素为category的名字，第二个元素则为一个数组，保存有该分类下文章的列表</p>

<p>于是乎就很简单了：
*  使用<code>{{ category | first }}</code>输出分类的名称
*  使用<code>{{ category | last | size }}</code>输出该分类下文章的数目
*  遍历category.last输出所有文章的信息，构建到该文章的索引</p>

<p>这样就完成了在一个页面上输出所有分类，及其所有文章索引的方法了。但是需要注意的是，这种方式只能获取所有分类，而不能获取某个单一分类下的文章。毕竟jekyll编译完成后是静态页面，没有办法动态生成（除非为每一个分类都创建一个html文件，并在首页上创建一大堆通向这些html文件的a标签）。事实上，这个问题有一个解决方法是使用jekyll插件去解决。但是github不支持三方jekyll插件。所以必须绕个弯子来实现这种方式</p>

<h3 id="section">输出单个分类下的所有文章</h3>
<p>我们可以轻松获得所有分类下的所有文章，但是没有办法只输出一个分类下的文章。</p>

<p>首先可以想到的解决方法方法：首先把所有分类和所有文章的html生成好，然后全部隐藏。把需要显示的分类的名称放在url中，使用javascript读取名称出来后根据名称显示该分类。这样做有一个坏处：如果文章数较多，而每个文章都有很多分类，那么就会出现html文件很大，加载很慢的情况。</p>

<p>于是乎又想到一种方法，将所有的数据压缩在JSON中，然后通过javascript解析JSON对象，然后动态生成html。这种方法不过是一个折中，如果需要生成的html较为复杂，完全可以使用第一种方法。但如果只是简单的索引，这种方法就足够了。根据需要考量吧。下面放一点简单的源码来介绍一下这种方法：
<code>javascript
var dataStr = '{ {% for cat in site.categories %}{% if cat[0] != site.categories.first[0] %},{% endif %}"{{ cat[0] }}":[{% for post in cat[1] %}{% if post != cat[1].first %},{% endif %}{"url":"{{post.url}}", "title":"{{post.title}}", "date":"{{post.date | date:"%d/%m/%Y"}}"}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get("cat"),
    archieves = data[curTag];
</code>
首先通过上面介绍过的方法构建JSON字符串，这里只是一个模板，读取了所有分类，并以分类名称为key，文章列表为value构建了一个对象。文章列表的元素也是一个对象，有date，url，title三个值，分别表示文章的日期、url路径、标题，帮助生成索引。解析完之后就可以通过url中的category的名称取出来了。这里使用了一个叫jQuery.query的插件，专门取url的参数并进行包装。</p>

<p>综上所述，比如只显示单一分类的页面叫showCategory.html，要显示java分类，那么首页中给个a标签，href为<code>/showCategory.html?cat=java</code>就行了，方便快捷（笑）</p>

<h3 id="section-1">类别为中文时问题</h3>
<p>Windows下，使用UTF-8编码时当category为中文时，在通过url进入文章时，会出现如下错误
<code>
Internal Server Error
"\xAE\xBE" from GBK to UTF-8
</code>
我并不知道这个编码为何会需要从GBK转换为UTF-8，所以只能通过其他方式进行避开。网上应该会有人解答这个问题，需要进一步去查了，这里讲一下我怎么避开的吧</p>

<p>首先介绍一下jekyll的Permalinks这个配置，这个配置定义了文章被jekyll处理后生成结果的最终路径，默认为<code>/:categories/:year/:month/:day/:title.html</code>，也就是说，如一篇文章叫“2014-2-6-this-is-a-title.md”，在文章中定义的文类为[测试, new]，那么最终这篇文章的路径将会是“_site/测试/new/2014/02/06/this-is-a-title.html”，也就是说如果category为中文名称的话，中文将会出现在url中。然后就会根据中文去jekyll的action中索引，然后导致错误。</p>

<p>避开方法就是去掉根据permlinks中的categories，因为一般情况下根据时间来生成文件夹就已经够了，在_config.yml中新增一行：
<code>
permalink: /:year/:month/:day/:title
</code>
规则可以自己定，具体参照<a href="http://jekyllrb.com/docs/permalinks/">jekyll的Permlinks配置介绍页面</a>，别出现categories就行了</p>

<h2 id="section-2">使用文章标签索引文章</h2>
<p>现在很多博客都支持给文章添加标签，表示这篇文章具体是哪几方面的技术。jekyll也是支持标签的，而且不需要额外的插件。使用方法和categories类似
###给文章添加标签
文章中的标签配置使用tags来定义，内容为一个数组，放在文章的头中，如本文的标签定义：
<code>
---
layout: MyTemplate
title: 使用Jekyll在Github上搭建个人博客（文章分类索引）
tags: [github, jekyll]
---
</code>
###输出所有标签
一般情况下，标签与文章为很复杂的多对多关系，所以如果生成所有标签及含有该标签的所有文章，html将会非常庞大，所以一般只是生成所有的标签，然后通过点击标签到达该标签的索引页面，页面中仅显示含有该标签的文章。</p>

<p>输出所有标签，可以通过liquid的for标签遍历site.tags来实现：
<code>html
{% for tag in site.tags %}
    &lt;a href="/show_by_tag.html?tag={{ tag[0] }}"&gt; {{ tag[0] }}&lt;/a&gt;
{% endfor %}
</code>
tag[0]是标签的名称</p>

<h3 id="section-3">输出含有某标签的所有文章数</h3>
<p>实现思路和上面categories一样，先生成JSON字符串再通过javascript动态生成html，具体代码：
<code>javascript
var dataStr = '{ {% for tag in site.tags %}{% if tag[0] != site.tags.first[0] %},{% endif %}"{{ tag[0] }}":[{% for post in tag[1] %}{% if post != tag[1].first %},{% endif %}{"url":"{{post.url}}", "title":"{{post.title}}", "date":"{{post.date | date:"%d/%m/%Y"}}"}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get("tag"),
    archieves = data[curTag];
</code>
这里还是一样，使用jQuery.query插件获取url中的参数，和上面的<code>&lt;a href="/show_by_tag.html?tag={{ tag[0] }}"&gt; {{ tag[0] }}&lt;/a&gt;</code>相对应</p>

<p>标签没有字符集问题，放心使用吧</p>

<h2 id="section-4">总结</h2>
<p>文章的分类其实实现并不难，但是需要绕点小弯子。如果有更好的不需要使用插件的方法希望能告知我，感激不尽</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/06/jekyll-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（文章分类索引） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/06/jekyll-4.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 06 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/02/06/jekyll-3/">使用Jekyll在Github上搭建个人博客（分页实现）</a></p>

<p>今天又滚出去野了一天，打牌输了，好在输的不多，聊天聊到了以后的路子，不太好走啊…</p>

<h2 id="category">使用Category分类</h2>
<p>一般来说，一个个人博客的文章会分为很多种，比如说有记录生活情感的、技术交流的、转载他人的等等，而在jekyll中，可以使用Category进行分类，使用方法非常简单
###为文章定义分类
首先要确定文章属于哪个分类。这个配置可以设置在文章的头信息中，使用category或者categories确定，如文章属于“test”类别：
<code>
---
layout: MyTemplate
title: Category Sample
category: test
---
</code>
或者使用categories，这个属性接受一个数组，代表这篇文章所述的类，如文章属于“test”和“sample”类别：
<code>
---
layout: MyTemplate
title: Category Sample
categories: [test, sample]
---
</code>
加入这些信息后，文章所属分类就定义好了。但是还需要在页面（或者模板）中输出分类所有的文章才能完成以分类为基础的索引功能
###输出所有分类
所有的分类信息都被存储在site对象的categories中，所以可以通过liquid的for标签进行输出：
```html
{% for category in site.categories %}</p>
<h2>{{ category | first }}</h2>
<p>&lt;/span&gt;{{ category | last | size }}&lt;/span&gt;
&lt;ul class="arc-list"&gt;
    {% for post in category.last %}
        &lt;li&gt;{{ post.date | date:”%d/%m/%Y”}}<a href="{{ post.url }}">{{ post.title }}</a>&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
{% endfor %}
```
上面代码可以看到，首先从site中取出所有categories的信息，分别输出。categories的元素为一个两个元素的数组，第一个元素为category的名字，第二个元素则为一个数组，保存有该分类下文章的列表</p>

<p>于是乎就很简单了：
*  使用<code>{{ category | first }}</code>输出分类的名称
*  使用<code>{{ category | last | size }}</code>输出该分类下文章的数目
*  遍历category.last输出所有文章的信息，构建到该文章的索引</p>

<p>这样就完成了在一个页面上输出所有分类，及其所有文章索引的方法了。但是需要注意的是，这种方式只能获取所有分类，而不能获取某个单一分类下的文章。毕竟jekyll编译完成后是静态页面，没有办法动态生成（除非为每一个分类都创建一个html文件，并在首页上创建一大堆通向这些html文件的a标签）。事实上，这个问题有一个解决方法是使用jekyll插件去解决。但是github不支持三方jekyll插件。所以必须绕个弯子来实现这种方式</p>

<h3 id="section">输出单个分类下的所有文章</h3>
<p>我们可以轻松获得所有分类下的所有文章，但是没有办法只输出一个分类下的文章。</p>

<p>首先可以想到的解决方法方法：首先把所有分类和所有文章的html生成好，然后全部隐藏。把需要显示的分类的名称放在url中，使用javascript读取名称出来后根据名称显示该分类。这样做有一个坏处：如果文章数较多，而每个文章都有很多分类，那么就会出现html文件很大，加载很慢的情况。</p>

<p>于是乎又想到一种方法，将所有的数据压缩在JSON中，然后通过javascript解析JSON对象，然后动态生成html。这种方法不过是一个折中，如果需要生成的html较为复杂，完全可以使用第一种方法。但如果只是简单的索引，这种方法就足够了。根据需要考量吧。下面放一点简单的源码来介绍一下这种方法：
<code>javascript
var dataStr = '{ {% for cat in site.categories %}{% if cat[0] != site.categories.first[0] %},{% endif %}"{{ cat[0] }}":[{% for post in cat[1] %}{% if post != cat[1].first %},{% endif %}{"url":"{{post.url}}", "title":"{{post.title}}", "date":"{{post.date | date:"%d/%m/%Y"}}"}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get("cat"),
    archieves = data[curTag];
</code>
首先通过上面介绍过的方法构建JSON字符串，这里只是一个模板，读取了所有分类，并以分类名称为key，文章列表为value构建了一个对象。文章列表的元素也是一个对象，有date，url，title三个值，分别表示文章的日期、url路径、标题，帮助生成索引。解析完之后就可以通过url中的category的名称取出来了。这里使用了一个叫jQuery.query的插件，专门取url的参数并进行包装。</p>

<p>综上所述，比如只显示单一分类的页面叫showCategory.html，要显示java分类，那么首页中给个a标签，href为<code>/showCategory.html?cat=java</code>就行了，方便快捷（笑）</p>

<h3 id="section-1">类别为中文时问题</h3>
<p>Windows下，使用UTF-8编码时当category为中文时，在通过url进入文章时，会出现如下错误
<code>
Internal Server Error
"\xAE\xBE" from GBK to UTF-8
</code>
我并不知道这个编码为何会需要从GBK转换为UTF-8，所以只能通过其他方式进行避开。网上应该会有人解答这个问题，需要进一步去查了，这里讲一下我怎么避开的吧</p>

<p>首先介绍一下jekyll的Permalinks这个配置，这个配置定义了文章被jekyll处理后生成结果的最终路径，默认为<code>/:categories/:year/:month/:day/:title.html</code>，也就是说，如一篇文章叫“2014-2-6-this-is-a-title.md”，在文章中定义的文类为[测试, new]，那么最终这篇文章的路径将会是“_site/测试/new/2014/02/06/this-is-a-title.html”，也就是说如果category为中文名称的话，中文将会出现在url中。然后就会根据中文去jekyll的action中索引，然后导致错误。</p>

<p>避开方法就是去掉根据permlinks中的categories，因为一般情况下根据时间来生成文件夹就已经够了，在_config.yml中新增一行：
<code>
permalink: /:year/:month/:day/:title
</code>
规则可以自己定，具体参照<a href="http://jekyllrb.com/docs/permalinks/">jekyll的Permlinks配置介绍页面</a>，别出现categories就行了</p>

<h2 id="section-2">使用文章标签索引文章</h2>
<p>现在很多博客都支持给文章添加标签，表示这篇文章具体是哪几方面的技术。jekyll也是支持标签的，而且不需要额外的插件。使用方法和categories类似
###给文章添加标签
文章中的标签配置使用tags来定义，内容为一个数组，放在文章的头中，如本文的标签定义：
<code>
---
layout: MyTemplate
title: 使用Jekyll在Github上搭建个人博客（文章分类索引）
tags: [github, jekyll]
---
</code>
###输出所有标签
一般情况下，标签与文章为很复杂的多对多关系，所以如果生成所有标签及含有该标签的所有文章，html将会非常庞大，所以一般只是生成所有的标签，然后通过点击标签到达该标签的索引页面，页面中仅显示含有该标签的文章。</p>

<p>输出所有标签，可以通过liquid的for标签遍历site.tags来实现：
<code>html
{% for tag in site.tags %}
    &lt;a href="/show_by_tag.html?tag={{ tag[0] }}"&gt; {{ tag[0] }}&lt;/a&gt;
{% endfor %}
</code>
tag[0]是标签的名称</p>

<h3 id="section-3">输出含有某标签的所有文章数</h3>
<p>实现思路和上面categories一样，先生成JSON字符串再通过javascript动态生成html，具体代码：
<code>javascript
var dataStr = '{ {% for tag in site.tags %}{% if tag[0] != site.tags.first[0] %},{% endif %}"{{ tag[0] }}":[{% for post in tag[1] %}{% if post != tag[1].first %},{% endif %}{"url":"{{post.url}}", "title":"{{post.title}}", "date":"{{post.date | date:"%d/%m/%Y"}}"}{% endfor %}]{% endfor %} }',
    data = JSON.parse(dataStr),
    curTag = $.query.get("tag"),
    archieves = data[curTag];
</code>
这里还是一样，使用jQuery.query插件获取url中的参数，和上面的<code>&lt;a href="/show_by_tag.html?tag={{ tag[0] }}"&gt; {{ tag[0] }}&lt;/a&gt;</code>相对应</p>

<p>标签没有字符集问题，放心使用吧</p>

<h2 id="section-4">总结</h2>
<p>文章的分类其实实现并不难，但是需要绕点小弯子。如果有更好的不需要使用插件的方法希望能告知我，感激不尽</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/06/jekyll-4.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 【转载】入静和入世 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/05/repost-rujingyurushi.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>本文为转载，<a href="http://home.wangjianshuo.com/cn/20120801_eae-3.htm">原文地址</a></p>

<p>本文受Paul Graham的Maker’s Schedule, Manager’s Schedule启发而作，建议大家有空去读一下。</p>

<p>人有两种思考状态，我将一种称为入静，另一种称为入世。</p>

<h3 id="section">入静</h3>

<p>程序员和作家需要的是一种入静的状态。他们需要整段的，不被打扰的时间才可以工作。一个下午三点种的会议，哪怕仅仅持续15分钟，一个下午就会因此废了。问题不是会议占据的时间，关键问题是会议把一个下午分成了两块，让每块都不够大，都不足以入静。因为对于下午废掉的担心，上午的工作也受到影响，不太敢开始解决真正困难的问题。所以整天都在一种心神不宁的状态。</p>

<p>人的大脑远没有我们想象的那么简单。那是非常精密的，需要我们细心体会的工作状态。一个典型的程序员的一天是这样的：</p>

<pre><code>早上想到今天有一整天的整块时间，能够躲在一个不受打扰的地方开始写代码，想想就是件高兴的事情。然后开始打开代码，开始看，开始象电脑一样处理，慢慢的，世界安静了，问题浮现了，头脑里的问号产生了。怎么解决呢？怎么解决呢？怎么解决呢？。。。。开始思考了。开始发呆了。。。开始写点东西，跑一跑，又引入了一个新的问号。。。这就是入静的状态。
</code></pre>

<p>在足够长的思考这件事情的空余，或许要上一下厕所，在路上遇到同时打招呼，但脑子还在那个状态，打招呼的是谁不记得了，也不想去注意，以免思路被打乱。然后回到座位上，脑子里其实彻底没有去过厕所的记忆，而继续思考。。。中午吃饭的时候，如果一个人最好，接着在那个状态里。。。或者随便聊点轻松的话题，并没有大碍，只要不是动脑筋的东西。这样下午可以相对容易的回到短暂离开的状态。因为我们的明意识在放松，潜意识其实还在连续的工作。</p>

<p>这种入境的状态就像睡觉。需要足够长的时间才能进入状态。我想大家都能理解凌晨三点的一个电话对于睡眠意味着什么吧。</p>

<p>在会多的公司，程序员会自己觉得效率特低，归罪于会多，其实不是会多，而是打断。</p>

<h3 id="section-1">入世</h3>

<p>还有另外一种人，姑且叫做入世的人。他们的时间是按小时划分的，每个小时总要换一个会，在哪里和谁开会不重要，重要的是过一个小时一定有会。如果在两个会之间空出来一个小时，这一个小时反而是浪费时间，一定要想办法填满。找谁聊聊呢？给谁打个电话呢？旅游者是这种工作方式的极致表现。到一个地方仅有的几十个小时，一定要用活动填满，每一个小时一定要换一个地方，才能够不辜负大老远来一趟。经理，商人，投资人，甚至服务员都是这种状态。很难想象一个卖菜的不和人打交道而仅仅静思会有生计。一个证券交易员哪怕十分钟不和另外的人发生交易就会亏钱，商人必须不断的和人打交道，认识其他的商人，才能有足够的消息。经理们更多的是在协调资源，而不是创造新的东西，他们，需要用入世的方式工作。</p>

<p>两个处于入世状态的人很容易约会，甚至容易约一些没有特别目的的会，“好久不见了。聚聚？” “好呀，喝杯茶吧。”这种会议常常能产生意想不到的产出，主要原因是，切换思维状态，对于入世的人来说，成本太低了，而对于入静状态的人简直就是灾难。</p>

<h3 id="section-2">入世和入静</h3>

<p>我们其实都需要两种状态。读书就需要入静，需要相对长一点的时间。沟通就需要入世，需要高效的和人打交道。不同的工作需要不同的状态。我们需要明了这种区别，不要在两种状态频繁切换。一个礼拜可以把会集中在一起，好让自己定期给自己些完全没有会的闭关时间，这样才会平衡。</p>

<p>最后，要给身边有程序员的同学们和经理们提个醒：请大家一定要理解程序员的工作状态，不要在一天的中间安排会议。当看到一个程序员冥思苦想的时候，不要过去打扰，甚至在极端的情况下，一句友好的问候都是多余的。</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/05/repost-rujingyurushi.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 【转载】入静和入世 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/05/repost-rujingyurushi.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>本文为转载，<a href="http://home.wangjianshuo.com/cn/20120801_eae-3.htm">原文地址</a></p>

<p>本文受Paul Graham的Maker’s Schedule, Manager’s Schedule启发而作，建议大家有空去读一下。</p>

<p>人有两种思考状态，我将一种称为入静，另一种称为入世。</p>

<h3 id="section">入静</h3>

<p>程序员和作家需要的是一种入静的状态。他们需要整段的，不被打扰的时间才可以工作。一个下午三点种的会议，哪怕仅仅持续15分钟，一个下午就会因此废了。问题不是会议占据的时间，关键问题是会议把一个下午分成了两块，让每块都不够大，都不足以入静。因为对于下午废掉的担心，上午的工作也受到影响，不太敢开始解决真正困难的问题。所以整天都在一种心神不宁的状态。</p>

<p>人的大脑远没有我们想象的那么简单。那是非常精密的，需要我们细心体会的工作状态。一个典型的程序员的一天是这样的：</p>

<pre><code>早上想到今天有一整天的整块时间，能够躲在一个不受打扰的地方开始写代码，想想就是件高兴的事情。然后开始打开代码，开始看，开始象电脑一样处理，慢慢的，世界安静了，问题浮现了，头脑里的问号产生了。怎么解决呢？怎么解决呢？怎么解决呢？。。。。开始思考了。开始发呆了。。。开始写点东西，跑一跑，又引入了一个新的问号。。。这就是入静的状态。
</code></pre>

<p>在足够长的思考这件事情的空余，或许要上一下厕所，在路上遇到同时打招呼，但脑子还在那个状态，打招呼的是谁不记得了，也不想去注意，以免思路被打乱。然后回到座位上，脑子里其实彻底没有去过厕所的记忆，而继续思考。。。中午吃饭的时候，如果一个人最好，接着在那个状态里。。。或者随便聊点轻松的话题，并没有大碍，只要不是动脑筋的东西。这样下午可以相对容易的回到短暂离开的状态。因为我们的明意识在放松，潜意识其实还在连续的工作。</p>

<p>这种入境的状态就像睡觉。需要足够长的时间才能进入状态。我想大家都能理解凌晨三点的一个电话对于睡眠意味着什么吧。</p>

<p>在会多的公司，程序员会自己觉得效率特低，归罪于会多，其实不是会多，而是打断。</p>

<h3 id="section-1">入世</h3>

<p>还有另外一种人，姑且叫做入世的人。他们的时间是按小时划分的，每个小时总要换一个会，在哪里和谁开会不重要，重要的是过一个小时一定有会。如果在两个会之间空出来一个小时，这一个小时反而是浪费时间，一定要想办法填满。找谁聊聊呢？给谁打个电话呢？旅游者是这种工作方式的极致表现。到一个地方仅有的几十个小时，一定要用活动填满，每一个小时一定要换一个地方，才能够不辜负大老远来一趟。经理，商人，投资人，甚至服务员都是这种状态。很难想象一个卖菜的不和人打交道而仅仅静思会有生计。一个证券交易员哪怕十分钟不和另外的人发生交易就会亏钱，商人必须不断的和人打交道，认识其他的商人，才能有足够的消息。经理们更多的是在协调资源，而不是创造新的东西，他们，需要用入世的方式工作。</p>

<p>两个处于入世状态的人很容易约会，甚至容易约一些没有特别目的的会，“好久不见了。聚聚？” “好呀，喝杯茶吧。”这种会议常常能产生意想不到的产出，主要原因是，切换思维状态，对于入世的人来说，成本太低了，而对于入静状态的人简直就是灾难。</p>

<h3 id="section-2">入世和入静</h3>

<p>我们其实都需要两种状态。读书就需要入静，需要相对长一点的时间。沟通就需要入世，需要高效的和人打交道。不同的工作需要不同的状态。我们需要明了这种区别，不要在两种状态频繁切换。一个礼拜可以把会集中在一起，好让自己定期给自己些完全没有会的闭关时间，这样才会平衡。</p>

<p>最后，要给身边有程序员的同学们和经理们提个醒：请大家一定要理解程序员的工作状态，不要在一天的中间安排会议。当看到一个程序员冥思苦想的时候，不要过去打扰，甚至在极端的情况下，一句友好的问候都是多余的。</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/05/repost-rujingyurushi.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（分页实现） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/05/jekyll-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p>之前已经介绍了如何搭建环境和如何创建整个博客项目，并编写了博文，这篇文章主要就是介绍分页功能如何通过jekyll实现。</p>

<h3 id="section">前言</h3>
<p>一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能</p>

<h3 id="section-1">开启分页功能</h3>
<p>首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：
<code>
paginate: 5
paginate_path: "page:num"
</code>
第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推</p>

<p>需要注意的几个点：
* 分页只在html文件中起作用
* paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验</p>

<h3 id="section-2">使用分页</h3>
<p>只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：
<code>html
{% for post in paginator.posts %}
    &lt;a href="{{ post.url }}"&gt;{{ post.title }}&lt;/a&gt;
{% endfor %}
</code>
这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推</p>

<h3 id="section-3">换页</h3>
<p>只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性</p>

<p>首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的<code>total_pages</code>属性能判断总页数：
<code>html
{% if paginator.total_pages &gt; 1 %}
&lt;!-- 分页代码 --&gt;
{% endif %}
</code></p>

<p>我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的<code>previous_page</code>属性来判断是否是第一个页面，使用paginator的<code>previous_page_path</code>来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：
<code>html
{% if paginator.previous_page %}
    &lt;a href="{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}"上一页&lt;/a&gt;
{% endif %}
</code></p>

<p>接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的<code>page</code>属性来确定当前页，如果是当前页，则按钮无效，否则使用<code>{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}</code>来将:num替换成当前页面的数字生成页面路径：
<code>html
{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &lt;span class="active"&gt;{{ page }}&lt;/span&gt;
    {% elsif page == 1 %}
      &lt;a href="{{ '/index.html' | prepend: site.baseurl | replace: '//', '/' }}"&gt;{{ page }}&lt;/a&gt;
    {% else %}
      &lt;a href="{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}"&gt;{{ page }}&lt;/a&gt;
    {% endif %}
{% endfor %}
</code></p>

<p>最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的<code>next_page_path</code>来确定是否还有下一页：
<code>html
{% if paginator.next_page %}
    &lt;a href="{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}"&gt;下一页&lt;/a&gt;
{% endif %}
</code>
这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的
###总结
jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/05/jekyll-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（分页实现） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/05/jekyll-3.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Wed, 05 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/27/jekyll-2/">使用Jekyll在Github上搭建个人博客（博客编写）</a></p>

<p>之前已经介绍了如何搭建环境和如何创建整个博客项目，并编写了博文，这篇文章主要就是介绍分页功能如何通过jekyll实现。</p>

<h3 id="section">前言</h3>
<p>一个博客不可能只有几篇文章，如果所有文章全部放在一个页面中，在文章不多的情况下也许较为直观，一旦文章数量增加，不仅加大了用户需要加载的数据量，也为用户检索文章造成了障碍，所以基本上每个博客都会有文章的分页。一般的分页都是通过像JSP的模板引擎直接在从数据库中分页取出时生成动态生成页面，或者通过ajax从数据库分页取出传递到前端。但现在github+jekyll是静态的页面，没有数据库。好在jekyll支持分页功能</p>

<h3 id="section-1">开启分页功能</h3>
<p>首先我们需要在jekyll中开启分页功能，在jekyll的_config.yml中加入分页配置：
<code>
paginate: 5
paginate_path: "page:num"
</code>
第一行定义了每页的文章数量，而第二行则定义了在分页的结果，比如在/index.html中使用分页，定义为page:num，则第二页的路径将是/page2/index.html，第三页的路径将是/page3/index.html，以此类推</p>

<p>需要注意的几个点：
* 分页只在html文件中起作用
* paginate_path同时定义了需要被分页的文件，本人测试这个叫index.html，具体目录由paginate_path中的路径定义，如果定义的目录没有，则会向上寻找index.html，直到根目录的index.html，具体机制官网上没有详细说，所以还需要进一步实验</p>

<h3 id="section-2">使用分页</h3>
<p>只是开启了分页还没有用，我们需要确实使用到首页之中，在首页(/index.html)中添加如下代码：
<code>html
{% for post in paginator.posts %}
    &lt;a href="{{ post.url }}"&gt;{{ post.title }}&lt;/a&gt;
{% endfor %}
</code>
这样，jekyll就会根据paginator来进行分页了，被分出来多少页，就会有多少个页面生成。排1-5的文章就在/index.html中了，而排6-10的文章则在/page2/index.html中，依次类推</p>

<h3 id="section-3">换页</h3>
<p>只是分页还不够，我们还需要在每个页面上做一个跳转到其他页面的导航，这里需要用到paginator的一些其他属性</p>

<p>首先检测总的页数，如果只有一页，自然就不需要分页了。通过paginator的<code>total_pages</code>属性能判断总页数：
<code>html
{% if paginator.total_pages &gt; 1 %}
&lt;!-- 分页代码 --&gt;
{% endif %}
</code></p>

<p>我们需要一个跳转到上一页的按钮，这个按钮在第一页不需要显示，通过paginator的<code>previous_page</code>属性来判断是否是第一个页面，使用paginator的<code>previous_page_path</code>来输出上一页的路径，注意在前面添加baseurl，并进行一些必要的字符替换：
<code>html
{% if paginator.previous_page %}
    &lt;a href="{{ paginator.previous_page_path | prepend: site.baseurl | replace: '//', '/' }}"上一页&lt;/a&gt;
{% endif %}
</code></p>

<p>接着是生成所有页面的按钮，并使当前页按钮无效化，遍历所有页面，使用paginator的<code>page</code>属性来确定当前页，如果是当前页，则按钮无效，否则使用<code>{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}</code>来将:num替换成当前页面的数字生成页面路径：
<code>html
{% for page in (1..paginator.total_pages) %}
    {% if page == paginator.page %}
      &lt;span class="active"&gt;{{ page }}&lt;/span&gt;
    {% elsif page == 1 %}
      &lt;a href="{{ '/index.html' | prepend: site.baseurl | replace: '//', '/' }}"&gt;{{ page }}&lt;/a&gt;
    {% else %}
      &lt;a href="{{ site.paginate_path | prepend: site.baseurl | replace: '//', '/' | replace: ':num', page }}"&gt;{{ page }}&lt;/a&gt;
    {% endif %}
{% endfor %}
</code></p>

<p>最后生成一个下一页的按钮，在最后一页不显示，和上一页按钮类似，通过paginator的<code>next_page_path</code>来确定是否还有下一页：
<code>html
{% if paginator.next_page %}
    &lt;a href="{{ paginator.next_page_path | prepend: site.baseurl | replace: '//', '/' }}"&gt;下一页&lt;/a&gt;
{% endif %}
</code>
这样一个完整的分页导航功能就做好了，效果就和博客主页上的分页效果是一样的
###总结
jekyll的分页总的来说还算给力，基本的功能可以完成。但是有一些缺陷，就是category，tag的分类分页无法实现，必须通过插件的方式来做。但是github不允许三方插件，所以只能通过一些其他的方式实现了</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/05/jekyll-3.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 再见，蛇年！你好，马年！ ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/02/03/new-year.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 03 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">辞旧岁</h2>
<hr />
<p>过年在老家闲得无聊，回头又翻了一下自己这一年来的微博，这一年来写的一些读书笔记啥的。感叹时光荏苒，岁月如梭。感觉自己进入研究生来并没有过了多久，可如今快是研二下学期了。这个2013年算是收获相当大的一年。</p>

<h3 id="javassh">Java+SSH</h3>
<p>遥想一年之前，刚刚结束研究生生涯满是课程的第一个学期，基本上也没干什么事，就是初步学习了一下SSH(struts+spring+hibernate)。至于前端内容还完全没有涉及。对Java+SSH也仅仅停留在一个实验阶段。并没有实际的融入到实验室的项目之中。记得当时用SSH自己写了一个Java的博客，但是无奈前端技能太差，写出来的页面丑的不堪入目，而使用的一些模板也是完全看不懂CSS和JavaScript导致无法修改。后来也就放弃了，不过也算是使用SSH搭的第一个项目，也算是懂了SSH和JSP的基本知识，收获颇多。之后融入了实验室项目之后，在学长的带领下，协助开发了基于iReport+JasperReport的报表系统，可以说是一次相当好的Java练兵。</p>

<p>读了的相关的书：
1. 《轻量级Java EE企业应用实战 —— Struts 2＋Spring＋Hibernate整合开发》–李刚
2. 《Java编程思想》——（美）埃克尔著 陈昊鹏 译</p>

<h3 id="python">Python</h3>
<p>当时还自学了一点python，买了好几本书，也看了不少。记得玩的是pyqt，当时在用pyqt写一个浏览器。而就是这个python的小玩意，让我接触了脚本语言，并深刻被脚本语言的简洁、优美所震撼。当时实验室导师还说，以后会用到python，很鼓励学来着，后来完全没有用到过，呵呵呵呵呵….于是乎python在正式进入实验室项目之后，就没再接触Python了，挺遗憾的。而在其中接触的Qt4的知识如今也基本上还给上帝了，但那段时间过得相当快乐，完全是出于自己的爱好去做自己想做的事，没有什么束缚也没有什么压力</p>

<p>读了的相关的书：
1. 《Python学习手册》——[美] 鲁特兹（Mark Lutz） 著 李军，等 译
2. 《Python核心编程》——[美] 丘恩（Chun,W.J.） 著 宋吉广 译
3. 《精通Qt4编程》——蔡志明等 著</p>

<h3 id="section-1">设计模式</h3>
<p>记得读设计模式的书都是大半夜躺床上读的，当时没买ipad mini，就把电子书下载到手机里，由于屏幕分辨率太低，就把手机横过来看的，屏幕里只能显示差不多1/3页。读的四人帮的设计模式，虽然页数不多，但由于太过抽象，强行读了一点就崩溃了。于是乎买了本Head First设计模式，虽然里面图很多，占了相当大的篇幅，但那种亲切的讲述方式，确实相对死板的概念更容易接受，不过里面并没有将所有的设计模式讲全。读完之后又重新回头结合Java编程思想里面的一些与之相关的内容沉淀了一下，收获丰富啊。这也为后来学习JavaScript模式里面的知识打了基础</p>

<p>读了的相关的书：
1. 《Head First设计模式》——[美] 弗里曼（Freeman,E.），等 著 UML China 编 OReilly Taiwan公司 译
2. 《设计模式：可复用面向对象软件的基础》——Erich Gamma，等 著 刘建中，等 译
3. 《大话设计模式》–程杰 著</p>

<h3 id="section-2">前端知识</h3>
<p>学习前端知识虽然开始的很早，但前期都是小打小闹，知识也零零散散。读了《Head First HTML与CSS》，虽然并没有太详细的知识，但也算是对HTML和CSS有了一个基本的了解。</p>

<p>而之后读了Nicholas C.Zakas大神写的《JavaScript高级程序设计》，可以说是看这书入门的javascript。有的人推荐大犀牛——《JavaScript权威指南》，我倒不这么看，那本书感觉作为手册倒是更好，不适合作为初学者入门。</p>

<p>在读完之后，又仔细的研读了[汤姆大叔的深入理解JavaScript系列](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)和[JavaScript秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)，深入学习了JavaScript，深刻理解了JS与其他语言的不同，体会到了其中的糟粕和精华。汤姆大叔的系列博客也导致我买了他翻译的《JavaScript编程精解》，而其中的知识也是相当的精辟，但是书的价格，呵呵…</p>

<p>之后看的一些其他书，小犀牛书（JavaScript学习指南）感觉没什么油水，而鹧鸪书（JavaScript模式）则是相当的不错，里面讲了JavaScript特有的代码模式和设计模式，可以说字字珠玑，而JSON创始人Douglas Crockford的蝴蝶书（JavaScript语言精粹）讲的也是相当不错，里面的轨道图印象深刻啊。至于HTML和CSS之后读了《精通CSS+DIV网页样式与布局》，也算是了解了HTML和CSS的一些基础知识。之后也进行了相当多的尝试。编写了一些[简单的jQuery插件](https://github.com/LingyuCoder/wlyUI)。</p>

<p>就大概在这个时候，开启了我第一个真正的个人项目：XMPP的Web IM，这是一段相当长的时间，本来是实验室要做一个web im，我就研究了一下，后来导师又说取消了，但我觉得这一方面相当有趣，于是乎我以个人兴趣为驱动细细钻研XMPP协议和Web IM，编写出了一个完整的Web IM，可以说是这一年最有意义的内容了，而这也直接导致我的研究生毕业设计也变成了Web IM相关</p>

<p>在把Web IM基本功能完工以后，本着广撒网的态度，又开始接触CSS3和HTML5了，写了一些CSS3的动画，并结合JavaScript写了一些小玩意，比如[小玩意里面的时钟](http://lingyu.wang/items.html)和[可翻页的书籍](http://lingyu.wang/about.html)，差不多同一时间，又开始玩LESS，深刻体会到了CSS3的美妙和美好的未来，但也撞到了前端之路的大障碍：浏览器兼容性</p>

<p>HTML5主要则是钻研了canvas，感觉canvas给了浏览器无限的可能，初步使用canvas在页面上写了一个[RPG引擎](https://github.com/LingyuCoder/HTML5_GAME)，使用炎龙骑士团II黄金城之谜的图片素材（好吧，我不盈利，求不告我侵权），只是完成了其中的一些基础模块：人物移动、战斗系统、物品系统、装备系统、场景切换、剧情事件、NPC及对话等等，后来由于实验室项目上的一些其他事情就搁置了，后续我会尝试编写一个完整的游戏出来，不过不知道要到什么时候了</p>

<p>就是这些经历，让我深深爱上了前端，而立志做一个前端工程师。对自己的未来也相当期待，希望能找到像阿里之类前端很强的公司</p>

<p>读了的相关的书：
1. 《Head First HTML与CSS》——Elisabeth Robson，Eric Freeman 著 徐阳，丁小峰，等 译
2. 《JavaScript高级程序设计》——Nicholas C.Zakas 著 李松峰，曹力 译
3. 《JavaScript语言精粹》——Douglas Crockford（道格拉斯·克罗克福德） 著 赵泽欣，等 译
4. 《JavaScript编程精解》——[美] Marijn Haverbeke 著 徐涛 译
5. 《基于MVC的JavaScript Web富应用开发》——[美] Alex MacCaw 著 李晶,张散集 译
6. 《JavaScript模式》——[美] 斯托扬·斯特凡洛夫 著 陈新 译
7. 《JavaScript学习指南》——[美] Shelley Powers 著 谢春祥 译
8. 《精通CSS+DIV网页样式与布局》——前沿科技 编</p>

<h3 id="nodejs--mongodb">Node.js + MongoDB</h3>
<p>之前学长学姐有研究NodeJS，服务器端的JavaScript对我这种人来说确实相当有吸引力。出于个人的爱好，开始了自学NodeJS这个年轻的语言。这个学习过程就是读的BYVoid的Node书入门，之后基本上就是看API，看文档了。在朴灵的《深入浅出Node.js》出来之前，使用有限的Node知识，写了一个[多人管理的博客系统](https://github.com/LingyuCoder/NodeBlog)，支持在线写文章、评论、点赞、回复等功能。之后使用实验室的电脑搭建了自己的博客，可惜后来服务器被没收了，又没有找到合适的空间，于是乎就没再弄了。而express、async等等的使用经验却不会消失</p>

<p>在编写博客系统的时候，本着好奇的态度，又自学了MongoDB，将博客的数据库定为MongoDB。并用NodeJS实际操作了MongoDB，这个经验相当宝贵，但MongoDB还没有系统的学习，只是通过网上的资料学了个基础，不过书已经到位，就等翻开了</p>

<p>读了的相关的书：
1. 《Node.js开发指南》——BYVoid 著
2. 《JavaScript异步编程：设计快速响应的网络应用》——[美] Trevor Burnham 著 许青松 译</p>

<h2 id="section-3">迎新年</h2>
<hr />
<p>去年的收获相当多啊，主要还是本着广撒网的态度，什么都去学，什么都去接触。但新的一年，有了明确的目的：找一个好工作。这是决定未来的一年，今年要为找实习，找工作做好面试笔试的准备。而之前和学长聊天的过程中，也总结出我还需要补充的一些知识：
1. CSS的跨浏览器兼容问题
2. TCP/IP协议
3. HTTP协议
4. java的类对象，泛型和多线程
5. 算法
6. …</p>

<p>这些都要在近期去学习，这样有针对性的学习应该还是会很有效率的。</p>

<p>面试题啊，面经什么的也要开始看了，了解各个公司的现状，未来发展趋势也是相当重要。面试题还是需要相当大的积累，而如今我立志做前端工程师，面试题也会相当的详细，所以一些比较常见的方面比如JavaScript的原型、作用域什么的可定要回头再重新看看。CSS的position、float、display等等一些常见属性也要上MDN重新详细的看看。</p>

<p>同时，实验室的工作还是不能遗漏，该完成的功能必须完成，该修改的bug也要尽力去修正。而负责的模块的文档也要写出来，并且将我负责的所有内容，传承给学弟学妹。之前递交的两个本科毕业设计课题也需要精力去指导</p>

<p>还有一个问题，就是自己的研究生毕业设计问题，开的题目代码量比较大，虽然有一部分在之前的Web IM中实现了，可以直接复用。但还有很多扩展功能并没有实现，比如WebRTC之类的还需要特别调研，工作量略大啊</p>

<p>看来，新的一年，将会是忙碌的一年，也将是决定命运的一年。在这里，祝自己能找个好实习，然后顺顺利利的找个心仪的好工作吧，O(∩_∩)O哈哈~</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/02/03/new-year.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 再见，蛇年！你好，马年！ ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/02/03/new-year.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 03 Feb 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h2 id="section">辞旧岁</h2>
<hr />
<p>过年在老家闲得无聊，回头又翻了一下自己这一年来的微博，这一年来写的一些读书笔记啥的。感叹时光荏苒，岁月如梭。感觉自己进入研究生来并没有过了多久，可如今快是研二下学期了。这个2013年算是收获相当大的一年。</p>

<h3 id="javassh">Java+SSH</h3>
<p>遥想一年之前，刚刚结束研究生生涯满是课程的第一个学期，基本上也没干什么事，就是初步学习了一下SSH(struts+spring+hibernate)。至于前端内容还完全没有涉及。对Java+SSH也仅仅停留在一个实验阶段。并没有实际的融入到实验室的项目之中。记得当时用SSH自己写了一个Java的博客，但是无奈前端技能太差，写出来的页面丑的不堪入目，而使用的一些模板也是完全看不懂CSS和JavaScript导致无法修改。后来也就放弃了，不过也算是使用SSH搭的第一个项目，也算是懂了SSH和JSP的基本知识，收获颇多。之后融入了实验室项目之后，在学长的带领下，协助开发了基于iReport+JasperReport的报表系统，可以说是一次相当好的Java练兵。</p>

<p>读了的相关的书：
1. 《轻量级Java EE企业应用实战 —— Struts 2＋Spring＋Hibernate整合开发》–李刚
2. 《Java编程思想》——（美）埃克尔著 陈昊鹏 译</p>

<h3 id="python">Python</h3>
<p>当时还自学了一点python，买了好几本书，也看了不少。记得玩的是pyqt，当时在用pyqt写一个浏览器。而就是这个python的小玩意，让我接触了脚本语言，并深刻被脚本语言的简洁、优美所震撼。当时实验室导师还说，以后会用到python，很鼓励学来着，后来完全没有用到过，呵呵呵呵呵….于是乎python在正式进入实验室项目之后，就没再接触Python了，挺遗憾的。而在其中接触的Qt4的知识如今也基本上还给上帝了，但那段时间过得相当快乐，完全是出于自己的爱好去做自己想做的事，没有什么束缚也没有什么压力</p>

<p>读了的相关的书：
1. 《Python学习手册》——[美] 鲁特兹（Mark Lutz） 著 李军，等 译
2. 《Python核心编程》——[美] 丘恩（Chun,W.J.） 著 宋吉广 译
3. 《精通Qt4编程》——蔡志明等 著</p>

<h3 id="section-1">设计模式</h3>
<p>记得读设计模式的书都是大半夜躺床上读的，当时没买ipad mini，就把电子书下载到手机里，由于屏幕分辨率太低，就把手机横过来看的，屏幕里只能显示差不多1/3页。读的四人帮的设计模式，虽然页数不多，但由于太过抽象，强行读了一点就崩溃了。于是乎买了本Head First设计模式，虽然里面图很多，占了相当大的篇幅，但那种亲切的讲述方式，确实相对死板的概念更容易接受，不过里面并没有将所有的设计模式讲全。读完之后又重新回头结合Java编程思想里面的一些与之相关的内容沉淀了一下，收获丰富啊。这也为后来学习JavaScript模式里面的知识打了基础</p>

<p>读了的相关的书：
1. 《Head First设计模式》——[美] 弗里曼（Freeman,E.），等 著 UML China 编 OReilly Taiwan公司 译
2. 《设计模式：可复用面向对象软件的基础》——Erich Gamma，等 著 刘建中，等 译
3. 《大话设计模式》–程杰 著</p>

<h3 id="section-2">前端知识</h3>
<p>学习前端知识虽然开始的很早，但前期都是小打小闹，知识也零零散散。读了《Head First HTML与CSS》，虽然并没有太详细的知识，但也算是对HTML和CSS有了一个基本的了解。</p>

<p>而之后读了Nicholas C.Zakas大神写的《JavaScript高级程序设计》，可以说是看这书入门的javascript。有的人推荐大犀牛——《JavaScript权威指南》，我倒不这么看，那本书感觉作为手册倒是更好，不适合作为初学者入门。</p>

<p>在读完之后，又仔细的研读了[汤姆大叔的深入理解JavaScript系列](http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)和[JavaScript秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)，深入学习了JavaScript，深刻理解了JS与其他语言的不同，体会到了其中的糟粕和精华。汤姆大叔的系列博客也导致我买了他翻译的《JavaScript编程精解》，而其中的知识也是相当的精辟，但是书的价格，呵呵…</p>

<p>之后看的一些其他书，小犀牛书（JavaScript学习指南）感觉没什么油水，而鹧鸪书（JavaScript模式）则是相当的不错，里面讲了JavaScript特有的代码模式和设计模式，可以说字字珠玑，而JSON创始人Douglas Crockford的蝴蝶书（JavaScript语言精粹）讲的也是相当不错，里面的轨道图印象深刻啊。至于HTML和CSS之后读了《精通CSS+DIV网页样式与布局》，也算是了解了HTML和CSS的一些基础知识。之后也进行了相当多的尝试。编写了一些[简单的jQuery插件](https://github.com/LingyuCoder/wlyUI)。</p>

<p>就大概在这个时候，开启了我第一个真正的个人项目：XMPP的Web IM，这是一段相当长的时间，本来是实验室要做一个web im，我就研究了一下，后来导师又说取消了，但我觉得这一方面相当有趣，于是乎我以个人兴趣为驱动细细钻研XMPP协议和Web IM，编写出了一个完整的Web IM，可以说是这一年最有意义的内容了，而这也直接导致我的研究生毕业设计也变成了Web IM相关</p>

<p>在把Web IM基本功能完工以后，本着广撒网的态度，又开始接触CSS3和HTML5了，写了一些CSS3的动画，并结合JavaScript写了一些小玩意，比如[小玩意里面的时钟](http://lingyu.wang/items.html)和[可翻页的书籍](http://lingyu.wang/about.html)，差不多同一时间，又开始玩LESS，深刻体会到了CSS3的美妙和美好的未来，但也撞到了前端之路的大障碍：浏览器兼容性</p>

<p>HTML5主要则是钻研了canvas，感觉canvas给了浏览器无限的可能，初步使用canvas在页面上写了一个[RPG引擎](https://github.com/LingyuCoder/HTML5_GAME)，使用炎龙骑士团II黄金城之谜的图片素材（好吧，我不盈利，求不告我侵权），只是完成了其中的一些基础模块：人物移动、战斗系统、物品系统、装备系统、场景切换、剧情事件、NPC及对话等等，后来由于实验室项目上的一些其他事情就搁置了，后续我会尝试编写一个完整的游戏出来，不过不知道要到什么时候了</p>

<p>就是这些经历，让我深深爱上了前端，而立志做一个前端工程师。对自己的未来也相当期待，希望能找到像阿里之类前端很强的公司</p>

<p>读了的相关的书：
1. 《Head First HTML与CSS》——Elisabeth Robson，Eric Freeman 著 徐阳，丁小峰，等 译
2. 《JavaScript高级程序设计》——Nicholas C.Zakas 著 李松峰，曹力 译
3. 《JavaScript语言精粹》——Douglas Crockford（道格拉斯·克罗克福德） 著 赵泽欣，等 译
4. 《JavaScript编程精解》——[美] Marijn Haverbeke 著 徐涛 译
5. 《基于MVC的JavaScript Web富应用开发》——[美] Alex MacCaw 著 李晶,张散集 译
6. 《JavaScript模式》——[美] 斯托扬·斯特凡洛夫 著 陈新 译
7. 《JavaScript学习指南》——[美] Shelley Powers 著 谢春祥 译
8. 《精通CSS+DIV网页样式与布局》——前沿科技 编</p>

<h3 id="nodejs--mongodb">Node.js + MongoDB</h3>
<p>之前学长学姐有研究NodeJS，服务器端的JavaScript对我这种人来说确实相当有吸引力。出于个人的爱好，开始了自学NodeJS这个年轻的语言。这个学习过程就是读的BYVoid的Node书入门，之后基本上就是看API，看文档了。在朴灵的《深入浅出Node.js》出来之前，使用有限的Node知识，写了一个[多人管理的博客系统](https://github.com/LingyuCoder/NodeBlog)，支持在线写文章、评论、点赞、回复等功能。之后使用实验室的电脑搭建了自己的博客，可惜后来服务器被没收了，又没有找到合适的空间，于是乎就没再弄了。而express、async等等的使用经验却不会消失</p>

<p>在编写博客系统的时候，本着好奇的态度，又自学了MongoDB，将博客的数据库定为MongoDB。并用NodeJS实际操作了MongoDB，这个经验相当宝贵，但MongoDB还没有系统的学习，只是通过网上的资料学了个基础，不过书已经到位，就等翻开了</p>

<p>读了的相关的书：
1. 《Node.js开发指南》——BYVoid 著
2. 《JavaScript异步编程：设计快速响应的网络应用》——[美] Trevor Burnham 著 许青松 译</p>

<h2 id="section-3">迎新年</h2>
<hr />
<p>去年的收获相当多啊，主要还是本着广撒网的态度，什么都去学，什么都去接触。但新的一年，有了明确的目的：找一个好工作。这是决定未来的一年，今年要为找实习，找工作做好面试笔试的准备。而之前和学长聊天的过程中，也总结出我还需要补充的一些知识：
1. CSS的跨浏览器兼容问题
2. TCP/IP协议
3. HTTP协议
4. java的类对象，泛型和多线程
5. 算法
6. …</p>

<p>这些都要在近期去学习，这样有针对性的学习应该还是会很有效率的。</p>

<p>面试题啊，面经什么的也要开始看了，了解各个公司的现状，未来发展趋势也是相当重要。面试题还是需要相当大的积累，而如今我立志做前端工程师，面试题也会相当的详细，所以一些比较常见的方面比如JavaScript的原型、作用域什么的可定要回头再重新看看。CSS的position、float、display等等一些常见属性也要上MDN重新详细的看看。</p>

<p>同时，实验室的工作还是不能遗漏，该完成的功能必须完成，该修改的bug也要尽力去修正。而负责的模块的文档也要写出来，并且将我负责的所有内容，传承给学弟学妹。之前递交的两个本科毕业设计课题也需要精力去指导</p>

<p>还有一个问题，就是自己的研究生毕业设计问题，开的题目代码量比较大，虽然有一部分在之前的Web IM中实现了，可以直接复用。但还有很多扩展功能并没有实现，比如WebRTC之类的还需要特别调研，工作量略大啊</p>

<p>看来，新的一年，将会是忙碌的一年，也将是决定命运的一年。在这里，祝自己能找个好实习，然后顺顺利利的找个心仪的好工作吧，O(∩_∩)O哈哈~</p>
 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/02/03/new-year.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用jQuery监听DOM元素大小变化 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/01/28/jquery-resize.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 28 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">起因</h3>
<p>今天写页面的时候突然有这么个需求，由于父元素（一个DIV）的height是由javascript计算出来的固定的值，而在其中增加了一个多说插件，在用户评论后，子元素（DIV）的height属性增加，导致子元素溢出。但是又不知道如何为多说的评论按钮增加回调函数，于是乎就想到了根据子元素的大小变化来重新计算父元素的height。</p>

<h3 id="onresize">onresize?</h3>
<p>平常，都是在整个浏览器窗口变化时触发一个修改布局的回调函数。使用的是window对象的resize事件，利用：
<code>javascript
window.onresize = callback;
</code>
来绑定。但根据resize事件的target是<code>defaultView (window)</code>，这里详见<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/resize">MDN的resize文档</a>，也就是说只有window对象有resize事件，于是乎就想到使用jQuery自己的事件机制来模拟一个普通元素上的resize事件</p>

<h3 id="jquery">使用jQuery事件的实现思路</h3>
<p>可以想到一种比较简单的方式：
1. 在元素绑定resize对象时，记录元素的width和height
2. 使用requestAnimationFrame、setTimeout、setInterval，每隔一段时间查询其width和height，如果和记录的width和height不一样，运行回调函数并更新记录中的width为height</p>

<h3 id="jquery-1">jQuery插件</h3>
<p>这个功能Ben Alman编写了一个jQuery插件，<a href="http://benalman.com/projects/jquery-resize-plugin/">这是传送门</a>
该插件的代码（核心部分），详细代码请查看<a href="https://raw.github.com/cowboy/jquery-resize/v1.1/jquery.ba-resize.js">Ben Alman博客</a>的内容：</p>

<p>```javascript
(function($, window, undefined) {
  var elems = $([]),
    jq_resize = $.resize = $.extend($.resize, {}),
    timeout_id,
    str_setTimeout = ‘setTimeout’,
    str_resize = ‘resize’,
    str_data = str_resize + ‘-special-event’,
    str_delay = ‘delay’,
    str_throttle = ‘throttleWindow’;
  jq_resize[str_delay] = 250;
  jq_resize[str_throttle] = true;
  $.event.special[str_resize] = {
    setup: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.add(elem);
      $.data(this, str_data, {
        w: elem.width(),
        h: elem.height()
      });
      if (elems.length === 1) {
        loopy();
      }
    },
    teardown: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.not(elem);
      elem.removeData(str_data);
      if (!elems.length) {
        clearTimeout(timeout_id);
      }
    },
    add: function(handleObj) {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var old_handler;
      function new_handler(e, w, h) {
        var elem = $(this),
          data = $.data(this, str_data);
        data.w = w !== undefined ? w : elem.width();
        data.h = h !== undefined ? h : elem.height();
        old_handler.apply(this, arguments);
      }
      if ($.isFunction(handleObj)) {
        old_handler = handleObj;
        return new_handler;
      } else {
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
  };</p>

<p>function loopy() {
    timeout_id = window<a href="function() {
      elems.each(function() {
        var elem = $(this),
          width = elem.width(),
          height = elem.height(),
          data = $.data(this, str_data);
        if (width !== data.w || height !== data.h) {
          elem.trigger(str_resize, [data.w = width, data.h = height]);
        }
      });
      loopy();
    }, jq_resize[str_delay]">str_setTimeout</a>;
  }
})(jQuery, this);
<code>
jQuery为jQuery插件的开发者提供了添加自定义事件的接口，详细可以参考[jQuery官方文档](http://learn.jquery.com/events/event-extensions/)，这里就是典型的jQuery自定义事件添加方式，其中有三个钩子：
1. setup：</code>The setup hook is called the first time an event of a particular type is attached to an element.<code>首次绑定时执行，如果返回 false，使用默认方式绑定事件
2. teardown：</code>The teardown hook is called when the final event of a particular type is removed from an element.<code>若指定该方法，其在移除事件处理程序(removeEventListener)前执行，如果返回 false，移除默认绑定事件
3. add：</code>Each time an event handler is added to an element through an API such as .on(), jQuery calls this hook.```每一次给元素绑定事件，都会执行这个方法</p>

<p>setup、teardown和add三个钩子，每个钩子最先做的事都是检测是否该对象为window对象，然后根据window对象特殊处理，因为window对象本身有resize事件</p>

<p>从setup钩子可以看到，在初始化整个事件处理时，创建一个元素队列，队列中的每隔元素都把width和height放在data中，然后每隔250ms启动loopy函数，在loopy函数中判断是否变化，如果有变，触发回调函数并更新data中的width和height</p>

<p>从teardown钩子可以看到，在元素移除事件时，只需要将元素从元素队列移除，并清除元素中的data数据。如果是元素队列中的最后一个元素，则不再继续执行loopy</p>

<p>add钩子中，对回调函数进行了包装</p>

<p>由此可以看到一个简单的jQuery自定义函数的实现机制</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/01/28/jquery-resize.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用jQuery监听DOM元素大小变化 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/01/28/jquery-resize.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Tue, 28 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">起因</h3>
<p>今天写页面的时候突然有这么个需求，由于父元素（一个DIV）的height是由javascript计算出来的固定的值，而在其中增加了一个多说插件，在用户评论后，子元素（DIV）的height属性增加，导致子元素溢出。但是又不知道如何为多说的评论按钮增加回调函数，于是乎就想到了根据子元素的大小变化来重新计算父元素的height。</p>

<h3 id="onresize">onresize?</h3>
<p>平常，都是在整个浏览器窗口变化时触发一个修改布局的回调函数。使用的是window对象的resize事件，利用：
<code>javascript
window.onresize = callback;
</code>
来绑定。但根据resize事件的target是<code>defaultView (window)</code>，这里详见<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/resize">MDN的resize文档</a>，也就是说只有window对象有resize事件，于是乎就想到使用jQuery自己的事件机制来模拟一个普通元素上的resize事件</p>

<h3 id="jquery">使用jQuery事件的实现思路</h3>
<p>可以想到一种比较简单的方式：
1. 在元素绑定resize对象时，记录元素的width和height
2. 使用requestAnimationFrame、setTimeout、setInterval，每隔一段时间查询其width和height，如果和记录的width和height不一样，运行回调函数并更新记录中的width为height</p>

<h3 id="jquery-1">jQuery插件</h3>
<p>这个功能Ben Alman编写了一个jQuery插件，<a href="http://benalman.com/projects/jquery-resize-plugin/">这是传送门</a>
该插件的代码（核心部分），详细代码请查看<a href="https://raw.github.com/cowboy/jquery-resize/v1.1/jquery.ba-resize.js">Ben Alman博客</a>的内容：</p>

<p>```javascript
(function($, window, undefined) {
  var elems = $([]),
    jq_resize = $.resize = $.extend($.resize, {}),
    timeout_id,
    str_setTimeout = ‘setTimeout’,
    str_resize = ‘resize’,
    str_data = str_resize + ‘-special-event’,
    str_delay = ‘delay’,
    str_throttle = ‘throttleWindow’;
  jq_resize[str_delay] = 250;
  jq_resize[str_throttle] = true;
  $.event.special[str_resize] = {
    setup: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.add(elem);
      $.data(this, str_data, {
        w: elem.width(),
        h: elem.height()
      });
      if (elems.length === 1) {
        loopy();
      }
    },
    teardown: function() {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var elem = $(this);
      elems = elems.not(elem);
      elem.removeData(str_data);
      if (!elems.length) {
        clearTimeout(timeout_id);
      }
    },
    add: function(handleObj) {
      if (!jq_resize[str_throttle] &amp;&amp; this[str_setTimeout]) {
        return false;
      }
      var old_handler;
      function new_handler(e, w, h) {
        var elem = $(this),
          data = $.data(this, str_data);
        data.w = w !== undefined ? w : elem.width();
        data.h = h !== undefined ? h : elem.height();
        old_handler.apply(this, arguments);
      }
      if ($.isFunction(handleObj)) {
        old_handler = handleObj;
        return new_handler;
      } else {
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
  };</p>

<p>function loopy() {
    timeout_id = window<a href="function() {
      elems.each(function() {
        var elem = $(this),
          width = elem.width(),
          height = elem.height(),
          data = $.data(this, str_data);
        if (width !== data.w || height !== data.h) {
          elem.trigger(str_resize, [data.w = width, data.h = height]);
        }
      });
      loopy();
    }, jq_resize[str_delay]">str_setTimeout</a>;
  }
})(jQuery, this);
<code>
jQuery为jQuery插件的开发者提供了添加自定义事件的接口，详细可以参考[jQuery官方文档](http://learn.jquery.com/events/event-extensions/)，这里就是典型的jQuery自定义事件添加方式，其中有三个钩子：
1. setup：</code>The setup hook is called the first time an event of a particular type is attached to an element.<code>首次绑定时执行，如果返回 false，使用默认方式绑定事件
2. teardown：</code>The teardown hook is called when the final event of a particular type is removed from an element.<code>若指定该方法，其在移除事件处理程序(removeEventListener)前执行，如果返回 false，移除默认绑定事件
3. add：</code>Each time an event handler is added to an element through an API such as .on(), jQuery calls this hook.```每一次给元素绑定事件，都会执行这个方法</p>

<p>setup、teardown和add三个钩子，每个钩子最先做的事都是检测是否该对象为window对象，然后根据window对象特殊处理，因为window对象本身有resize事件</p>

<p>从setup钩子可以看到，在初始化整个事件处理时，创建一个元素队列，队列中的每隔元素都把width和height放在data中，然后每隔250ms启动loopy函数，在loopy函数中判断是否变化，如果有变，触发回调函数并更新data中的width和height</p>

<p>从teardown钩子可以看到，在元素移除事件时，只需要将元素从元素队列移除，并清除元素中的data数据。如果是元素队列中的最后一个元素，则不再继续执行loopy</p>

<p>add钩子中，对回调函数进行了包装</p>

<p>由此可以看到一个简单的jQuery自定义函数的实现机制</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/01/28/jquery-resize.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（博客编写） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/01/27/jekyll-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 27 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p>这篇文章主要介绍博客内容的编写及本地测试，内容主要来自<a href="http://jekyllrb.com/docs/home/">Jekyll的文档</a>、<a href="http://docs.shopify.com/themes/liquid-basics">Liquid的文档</a>
##创建项目
—
到想要创建项目的文件夹下（如d:/），运行命令：
<code>shell
jekyll new blog
</code>
这样就会创建一个新文件夹d:/blog，其结构如下：
1. 文件夹_layouts：用于存放模板的文件夹，里面有两个模板，default.html和post.html
2. 文件夹_posts：用于存放博客文章的文件夹，里面有一篇markdown格式的文章–2014-01-27-welcome-to-jekyll.markdown
3. 文件夹css：存放博客所用css的文件夹
4. .gitignore：可以删掉，后面会将项目添加到git项目，所以这个不需要了
5. _coinfig.yml：jekyll的配置文件，里面可以定义相当多的配置参数，具体配置参数可以参照其<a href="http://jekyllrb.com/docs/configuration/">官网</a>
6. index.html：项目的首页</p>

<p>根据实际需要，可能还需要创建如下文件或文件夹：
1. _includes:用于存放一些固定的HTML代码段，文件为.html格式，可以在模板中通过liquid标签引入，常用来在各个模板中复用如 导航条、标签栏、侧边栏 之类的在每个页面上都一样不变的内容，需要注意的是，这个代码段也可以是未被编译的，也就是说也可以使用liquid标签放在这些代码段中
2. image和js等自定义文件夹：用来存放一些需要的资源文件，如图片或者javascript文件，可以任意命名
3. CNAME文件：用来在github上做域名绑定的，将在后面介绍
4. favicon.ico：网站的小图标
5. 
….</p>

<p>创建完需要的文件夹之后，首先需要修改的就是jekyll的配置文件_config.yml，这个配置文件的内容相当多，详细见<a href="http://jekyllrb.com/docs/configuration/">官方文档</a>，如果没有太多的额外需求，只需要设定两个参数就行了，一个是编码的字符集，一个是项目的路径，我这里是这么设定的：
<code>
baseurl: /
encoding: utf-8
</code></p>

<p>这样一个博客项目就创建完成了</p>

<h2 id="section">编写博文</h2>
<hr />
<p>大致上jekyll生成html的流程，jekyll首先会读取如下内容进入内存中：
1. _posts及文件夹下的所有文章，将其参数和文章内容组织保存在内存中，所有的文章的内容、参数都在site.posts对象（其他文件夹下的文章不会放入site.posts中）
2. _layouts文件夹下的所有模板
3. _includes文件夹下的所有需要被引入的内容</p>

<p>然后根据每一篇需要编译的文章选择的其参数定义的模板来创建一个模板，并将当前文章的内容、参数等进行扩展后放在page对象、content对象中，然后进行模板的编译，生成html文件，并按照一定规则放在_site文件夹下。也就是说在创建一篇文章时，其实所有文章的内容都已经被读取出来了，这也为文章相互之间的关联提供了可能</p>

<p>可以看一下_posts下的jekyll给的例子：
```markdown
—
layout: post
title:  “Welcome to Jekyll!”
date:   2014-01-27 21:57:11
categories: jekyll update
—</p>

<p>You’ll find this post in your <code>_posts</code> directory - edit this post and re-build (or run with the <code>-w</code> switch) to see your changes!
To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention: YYYY-MM-DD-name-of-post.ext.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<p>{% highlight ruby %}
def print_hi(name)
  puts “Hi, #{name}”
end
print_hi(‘Tom’)
#=&gt; prints ‘Hi, Tom’ to STDOUT.
{% endhighlight %}</p>

<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/mojombo/jekyll">Jekyll’s GitHub repo</a>.</p>

<p><code>
可以看到在博文的最上方有被两个</code>—```包裹起来的一段，这里就定义了文章的一些参数，更多参数在<a href="http://jekyllrb.com/docs/frontmatter/">FrontMatter</a>和<a href="http://jekyllrb.com/docs/variables/">Variables</a>获取，简单的只需要关注几个就好：
1. title：文章的标题
2. date：文章的日期
3. categories：定义了文章所属的目录，一个list，将会根据这个目录的list来创建目录并将文章html放在生成的目录下，文章分类时候用，这里就不使用了
4. layout：文章所使用的模板名称，也就是_layouts中定义的模板的文件名去掉.html
5. tags：例子中没有，定义了文章的标签，也是一个list，文章分类时候用，这里就不使用了</p>

<p>这里就写一个最简单的文章，只是用其中的两个参数：layout，title，如下：
```
—
layout: mylayout
title: hello-jekyll
—</p>

<p>Hello jekyll!
```
将这个写完的文章保存为  “年-月-日-标题.markdown”的名字形式，因为如果不修改permlinks，jekyll会根据文章的标题来创建文件夹，如2014-01-27-hello会创建成/2014/01/27/hello.html。这里就保存成2014-01-27-hello.markdown</p>

<p>ps：文章的文件名不要使用中文，否则会出现bug，因为在url中会escape，而服务器查找却是按照escape后的字符串去查找
，就会出现找不到文章的情况，使用英文代替就好，定义了title变量就无所谓文件名中标题的内容了</p>

<p>博客不能没有主页，所以我们修改index.html文件如下：
```html
—
layout: mylayout
title: Hello Jekyll!
—
&lt;ul class="posts"&gt;
{% for post in site.posts %}</p>
<li><span>{{ post.date | date_to_string }}</span> &raquo; <a href="{{ post.url }}">{{ post.title }}</a></li>
<p>{% endfor %}
&lt;/ul&gt;
<code>
还是使用我们刚才的模板，这回编译完成后生成的结果如下：
</code>html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
        Hello Jekyll!
        <ul class="posts">
          <li><span>27 Jan 2014</span> &raquo; <a href="/2014/01/27/hello.html">hello-jekyll</a></li>
        </ul>
    </body>
</html>
<p>```
由于index文件名中没有时间，所以时间直接被忽略了，而内容段则通过liquid的for标签进行了迭代，遍历了_posts下的所有文章，将其文章的时间、路径、标题组织成html文件，生成指向博文的连接</p>

<h2 id="section-1">创建模板</h2>
<hr />
<p>我们可以打开jekyll给的例子default.html看一看模板的结构:
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <title>{{ page.title }}</title>
        <meta name="viewport" content="width=device-width" />

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css" />

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">{{ site.name }}</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          {{ content }}

          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
<p>```
可以看到，模板和普通的html文件几乎是一样的。jekyll使用的是一个叫liquid的模板引擎创建html文件，这个模板引擎也有<a href="http://docs.shopify.com/themes/liquid-basics">详细的文档</a>，现在就只关注其中比较核心的部分，文章的标题和文章的内容</p>

<p>可以看到模板的有这么两句{{ page.title }}, {{ content }}，这两句就分别是文章标题和文章内容的占位符，如果有文章使用了这个模板，如过使用上面写的那篇hello的文章，标题就是hello-jekyll，content就是Hello jekyll!，这里定义一个自己的新模板，保存为mylayout.html
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
          {{ page.title }}
          {{ page.date }}
          {{ content }}
    </body>
</html>
<p>```
第一行是标题，然后是博文时间（在文件名中定义），然后是博文内容
这样一个简单的模板就创建好了</p>

<h2 id="section-2">调试</h2>
<hr />
<p>在博客文件夹下，在命令行中输入<code>jekyll build --trace</code>就可以将所有文章文件根据其模板进行编译，生成结果，放在根目录下的_site中，这里我们使用后，会出现如下结果：\blog\_site\2014\01\27文件夹下有一个hello.html，其内容为：
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
          hello-jekyll
          2014-01-27 00:00:00 +0800
          <p>Hello jekyll!</p>
    </body>
</html>
<p><code>
可以看到，这就是编译完的博文文件，如我们设定的，第一行是标题，然后是文件名定义的时间，然后是博文内容，如果编译错误，将会在命令行中看到一个错误栈，可以方便调试，具体哪里出错了，如果不需要看错误栈，直接使用</code>jekyll build```就行了</p>

<p>如果想要在本地开启一个服务器查看效果，可以使用命令<code>jekyll serve</code>，这样会开启一个监听端口4000的服务器，浏览器中查看localhost:4000，则会进入index.html的内容中，点击文章的标题就可以跳转到具体的博文了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/01/27/jekyll-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（博客编写） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/01/27/jekyll-2.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Mon, 27 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>系列文章传送门：</p>

<p><a href="http://lingyu.wang#/art/blog/2014/01/25/jekyll-1/">使用Jekyll在Github上搭建个人博客（环境搭建）</a></p>

<p>这篇文章主要介绍博客内容的编写及本地测试，内容主要来自<a href="http://jekyllrb.com/docs/home/">Jekyll的文档</a>、<a href="http://docs.shopify.com/themes/liquid-basics">Liquid的文档</a>
##创建项目
—
到想要创建项目的文件夹下（如d:/），运行命令：
<code>shell
jekyll new blog
</code>
这样就会创建一个新文件夹d:/blog，其结构如下：
1. 文件夹_layouts：用于存放模板的文件夹，里面有两个模板，default.html和post.html
2. 文件夹_posts：用于存放博客文章的文件夹，里面有一篇markdown格式的文章–2014-01-27-welcome-to-jekyll.markdown
3. 文件夹css：存放博客所用css的文件夹
4. .gitignore：可以删掉，后面会将项目添加到git项目，所以这个不需要了
5. _coinfig.yml：jekyll的配置文件，里面可以定义相当多的配置参数，具体配置参数可以参照其<a href="http://jekyllrb.com/docs/configuration/">官网</a>
6. index.html：项目的首页</p>

<p>根据实际需要，可能还需要创建如下文件或文件夹：
1. _includes:用于存放一些固定的HTML代码段，文件为.html格式，可以在模板中通过liquid标签引入，常用来在各个模板中复用如 导航条、标签栏、侧边栏 之类的在每个页面上都一样不变的内容，需要注意的是，这个代码段也可以是未被编译的，也就是说也可以使用liquid标签放在这些代码段中
2. image和js等自定义文件夹：用来存放一些需要的资源文件，如图片或者javascript文件，可以任意命名
3. CNAME文件：用来在github上做域名绑定的，将在后面介绍
4. favicon.ico：网站的小图标
5. 
….</p>

<p>创建完需要的文件夹之后，首先需要修改的就是jekyll的配置文件_config.yml，这个配置文件的内容相当多，详细见<a href="http://jekyllrb.com/docs/configuration/">官方文档</a>，如果没有太多的额外需求，只需要设定两个参数就行了，一个是编码的字符集，一个是项目的路径，我这里是这么设定的：
<code>
baseurl: /
encoding: utf-8
</code></p>

<p>这样一个博客项目就创建完成了</p>

<h2 id="section">编写博文</h2>
<hr />
<p>大致上jekyll生成html的流程，jekyll首先会读取如下内容进入内存中：
1. _posts及文件夹下的所有文章，将其参数和文章内容组织保存在内存中，所有的文章的内容、参数都在site.posts对象（其他文件夹下的文章不会放入site.posts中）
2. _layouts文件夹下的所有模板
3. _includes文件夹下的所有需要被引入的内容</p>

<p>然后根据每一篇需要编译的文章选择的其参数定义的模板来创建一个模板，并将当前文章的内容、参数等进行扩展后放在page对象、content对象中，然后进行模板的编译，生成html文件，并按照一定规则放在_site文件夹下。也就是说在创建一篇文章时，其实所有文章的内容都已经被读取出来了，这也为文章相互之间的关联提供了可能</p>

<p>可以看一下_posts下的jekyll给的例子：
```markdown
—
layout: post
title:  “Welcome to Jekyll!”
date:   2014-01-27 21:57:11
categories: jekyll update
—</p>

<p>You’ll find this post in your <code>_posts</code> directory - edit this post and re-build (or run with the <code>-w</code> switch) to see your changes!
To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention: YYYY-MM-DD-name-of-post.ext.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<p>{% highlight ruby %}
def print_hi(name)
  puts “Hi, #{name}”
end
print_hi(‘Tom’)
#=&gt; prints ‘Hi, Tom’ to STDOUT.
{% endhighlight %}</p>

<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/mojombo/jekyll">Jekyll’s GitHub repo</a>.</p>

<p><code>
可以看到在博文的最上方有被两个</code>—```包裹起来的一段，这里就定义了文章的一些参数，更多参数在<a href="http://jekyllrb.com/docs/frontmatter/">FrontMatter</a>和<a href="http://jekyllrb.com/docs/variables/">Variables</a>获取，简单的只需要关注几个就好：
1. title：文章的标题
2. date：文章的日期
3. categories：定义了文章所属的目录，一个list，将会根据这个目录的list来创建目录并将文章html放在生成的目录下，文章分类时候用，这里就不使用了
4. layout：文章所使用的模板名称，也就是_layouts中定义的模板的文件名去掉.html
5. tags：例子中没有，定义了文章的标签，也是一个list，文章分类时候用，这里就不使用了</p>

<p>这里就写一个最简单的文章，只是用其中的两个参数：layout，title，如下：
```
—
layout: mylayout
title: hello-jekyll
—</p>

<p>Hello jekyll!
```
将这个写完的文章保存为  “年-月-日-标题.markdown”的名字形式，因为如果不修改permlinks，jekyll会根据文章的标题来创建文件夹，如2014-01-27-hello会创建成/2014/01/27/hello.html。这里就保存成2014-01-27-hello.markdown</p>

<p>ps：文章的文件名不要使用中文，否则会出现bug，因为在url中会escape，而服务器查找却是按照escape后的字符串去查找
，就会出现找不到文章的情况，使用英文代替就好，定义了title变量就无所谓文件名中标题的内容了</p>

<p>博客不能没有主页，所以我们修改index.html文件如下：
```html
—
layout: mylayout
title: Hello Jekyll!
—
&lt;ul class="posts"&gt;
{% for post in site.posts %}</p>
<li><span>{{ post.date | date_to_string }}</span> &raquo; <a href="{{ post.url }}">{{ post.title }}</a></li>
<p>{% endfor %}
&lt;/ul&gt;
<code>
还是使用我们刚才的模板，这回编译完成后生成的结果如下：
</code>html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
        Hello Jekyll!
        <ul class="posts">
          <li><span>27 Jan 2014</span> &raquo; <a href="/2014/01/27/hello.html">hello-jekyll</a></li>
        </ul>
    </body>
</html>
<p>```
由于index文件名中没有时间，所以时间直接被忽略了，而内容段则通过liquid的for标签进行了迭代，遍历了_posts下的所有文章，将其文章的时间、路径、标题组织成html文件，生成指向博文的连接</p>

<h2 id="section-1">创建模板</h2>
<hr />
<p>我们可以打开jekyll给的例子default.html看一看模板的结构:
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <title>{{ page.title }}</title>
        <meta name="viewport" content="width=device-width" />

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css" />

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">{{ site.name }}</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          {{ content }}

          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
<p>```
可以看到，模板和普通的html文件几乎是一样的。jekyll使用的是一个叫liquid的模板引擎创建html文件，这个模板引擎也有<a href="http://docs.shopify.com/themes/liquid-basics">详细的文档</a>，现在就只关注其中比较核心的部分，文章的标题和文章的内容</p>

<p>可以看到模板的有这么两句{{ page.title }}, {{ content }}，这两句就分别是文章标题和文章内容的占位符，如果有文章使用了这个模板，如过使用上面写的那篇hello的文章，标题就是hello-jekyll，content就是Hello jekyll!，这里定义一个自己的新模板，保存为mylayout.html
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
          {{ page.title }}
          {{ page.date }}
          {{ content }}
    </body>
</html>
<p>```
第一行是标题，然后是博文时间（在文件名中定义），然后是博文内容
这样一个简单的模板就创建好了</p>

<h2 id="section-2">调试</h2>
<hr />
<p>在博客文件夹下，在命令行中输入<code>jekyll build --trace</code>就可以将所有文章文件根据其模板进行编译，生成结果，放在根目录下的_site中，这里我们使用后，会出现如下结果：\blog\_site\2014\01\27文件夹下有一个hello.html，其内容为：
```html
&lt;!DOCTYPE html&gt;</p>
<html>
    <head>
        <meta charset="utf-8" />
        <title>test</title>
    </head>
    <body>
          hello-jekyll
          2014-01-27 00:00:00 +0800
          <p>Hello jekyll!</p>
    </body>
</html>
<p><code>
可以看到，这就是编译完的博文文件，如我们设定的，第一行是标题，然后是文件名定义的时间，然后是博文内容，如果编译错误，将会在命令行中看到一个错误栈，可以方便调试，具体哪里出错了，如果不需要看错误栈，直接使用</code>jekyll build```就行了</p>

<p>如果想要在本地开启一个服务器查看效果，可以使用命令<code>jekyll serve</code>，这样会开启一个监听端口4000的服务器，浏览器中查看localhost:4000，则会进入index.html的内容中，点击文章的标题就可以跳转到具体的博文了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/01/27/jekyll-2.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（环境搭建） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/01/25/jekyll-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 25 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前曾经使用nodejs写了一个博客系统，但是偷偷用的公司服务器。无奈被发现了，o(╯□╰)o，被勒令下线了之后只能想其他方法写博客了。原本是想换个地方搭建，于是找百度的同学要了个BAE的nodejs权限，但是抢不到配额，呵呵呵…于是乎就想到了Github上使用静态页面搭建博客的方法
##为什么是Jekyll+github？
—
其 <a href="http://jekyllrb.com/">官网首页</a> 上的描述是： <code>Transform your plain text into static websites and blogs</code>。Jekyll将原始文本根据一定规则转换成静态的网页和博客。但这个转换并不是简单的字符串替换就了事了，而是首先读取各个文件中的内容，根据配置文件中描述的参数在内存中构建一个巨大的对象存储整个博客的信息，然后再将这些信息根据配置文件中定义的输出方式来生成具体的HTML文件。整个项目是由Ruby写的，所以若需要在本地调试则需要安装Ruby。</p>

<p>使用Jekyll搭建博客有几个好处：
1. 不需要使用额外的数据库
2. 支持markdown，liquid，以及原始的html、css
3. 可以定义模板，并在模板上进行代码复用
4. github对其支持，可以直接在github上搭建，可以继承github上的各种好处（版本控制，免费，无流量限制）
5. 有很多扩展插件（但是在github上用不了，github不允许用户使用扩展插件，大概是出于安全性考虑）</p>

<p>当然缺点也有很多：
1. 生成的是静态网页，无法动态加载，若需要外部服务如评论，只能使用类似于disquz，多说这样的外部插件了
2. 仅仅适合小型网站，不适合大中型网站
3. 没有数据库及服务端的逻辑</p>

<p>由此可见，用来搭建个人博客相当合适（github版本控制，免费，无流量限制，支持markdown，无需关心服务器端逻辑和数据库）
##本地安装Jekyll
—
###首先安装Ruby及gem
1. 从<a href="http://rubyinstaller.org/">RubyInstaller</a>下载ruby，如果有经验的可以直接从<a href="https://www.ruby-lang.org/zh_cn/downloads/">Ruby官网</a>进行下载，前者安装比较无脑，会有一些额外的依赖包进行安装，版本也较低，而Ruby官网的版本则相对较高，但是没有额外的依赖包。下载的时候版本选较高一些的，否则会有bug，我选择的是2.0.0p353(2013-11-22)。安装的时候记得勾选添加环境变量。</p>

<ol>
  <li>
    <p>安装devkit，<a href="http://rubyinstaller.org/">RubyInstaller</a>页面中往下拉就能看到。选择自己版本的Ruby对应的devkit，下载并解压，然后执行:
<code>shell
cd devkit
ruby dk.rb init
ruby dk.rb install
</code>
这样就完成ruby环境的安装了</p>
  </li>
  <li>
    <p>安装gem，这个也可以去<a href="http://rubygems.org/">gem的官网</a>进行下载，然后直接安装就行了，安装完成后使用<code>gem -v</code>查看一下是否安装成功。我安装的是2.1.11版本</p>
  </li>
  <li>
    <p>gem是可以选择源的，默认的源有点慢，可以使用<code>ruby.taobao.org</code>的源，方便快捷
查看当前源</p>
  </li>
</ol>

<p>```shell
D:\node\jekyll&gt;gem sources list
<em>** CURRENT SOURCES **</em></p>

<p>https://rubygems.org/</p>

<p>D:\node\jekyll&gt;
```</p>

<p>添加新源
<code>shell
gem sources -a http://ruby.taobao.org/
</code></p>

<p>删除默认源
<code>shell
gem sources --remove https://rubygems.org/
</code></p>

<p>再次查看的时候保证只有<code>http://ruby.taobao.org/</code>就行了</p>

<p>如果上面出错，去网上找找教程吧，ruby环境的搭建和gem的安装教程还是蛮多的，基本google一下遍地都是。</p>

<h3 id="gemjekyll">使用gem安装Jekyll</h3>
<p>使用命令<code>gem install jekyll</code>就可以安装jekyll及所有需要的依赖，但不包括插件，安装jekyll的时候需要注意一下安装的版问题，jekyll的最新版本为1.4.3，但是有一个bug，<a href="http://stackoverflow.com/questions/21137096/jekyll-error-running-jekyll-serve">stackoverflow</a>上有人遇到过，我自己在使用的时候也遇到了类似的问题，解决方法是安装1.4.2版本，所以这里的安装命令为：<code>gem install jekyll --version "=1.4.2"</code>。安装完成后使用<code>jekyll -v</code>查看一下是否安装成功了</p>

<h3 id="jekyllwindows">Jekyll在windows下的字符集问题</h3>
<p>这个问题较多人遇到过，主要是在启动jekyll服务器的时候出现，以及一些中文文件名上出现，可以参考网上的解答：
1. <a href="http://blog.jsfor.com/skill/2013/09/07/jekyll-local-structures-notes/">windows下本地jekyll博客搭建手记</a>
2. <a href="http://chxt6896.github.io/blog/2012/02/13/blog-jekyll-native.html">Jekyll 本地调试之若干问题</a>
3. <a href="http://yanping.me/cn/blog/2012/10/09/chinese-charset-problems-with-jekyll/">在Windows下使用jekyll如何避免出现中文字符集错误</a></p>

<p>在这里，我仅仅是改了git bash的字符集，并没有去改jekyll的源文件，因为<code>self.content = File.read(File.join(base, name))</code>语句已经变了，不敢随便改。中文文件名的问题则通过改为全英文文件命名来避开，category里中文的问题则通过修改Permalinks来避开，这些后面会详细介绍</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/01/25/jekyll-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 使用Jekyll在Github上搭建个人博客（环境搭建） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/01/25/jekyll-1.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sat, 25 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>之前曾经使用nodejs写了一个博客系统，但是偷偷用的公司服务器。无奈被发现了，o(╯□╰)o，被勒令下线了之后只能想其他方法写博客了。原本是想换个地方搭建，于是找百度的同学要了个BAE的nodejs权限，但是抢不到配额，呵呵呵…于是乎就想到了Github上使用静态页面搭建博客的方法
##为什么是Jekyll+github？
—
其 <a href="http://jekyllrb.com/">官网首页</a> 上的描述是： <code>Transform your plain text into static websites and blogs</code>。Jekyll将原始文本根据一定规则转换成静态的网页和博客。但这个转换并不是简单的字符串替换就了事了，而是首先读取各个文件中的内容，根据配置文件中描述的参数在内存中构建一个巨大的对象存储整个博客的信息，然后再将这些信息根据配置文件中定义的输出方式来生成具体的HTML文件。整个项目是由Ruby写的，所以若需要在本地调试则需要安装Ruby。</p>

<p>使用Jekyll搭建博客有几个好处：
1. 不需要使用额外的数据库
2. 支持markdown，liquid，以及原始的html、css
3. 可以定义模板，并在模板上进行代码复用
4. github对其支持，可以直接在github上搭建，可以继承github上的各种好处（版本控制，免费，无流量限制）
5. 有很多扩展插件（但是在github上用不了，github不允许用户使用扩展插件，大概是出于安全性考虑）</p>

<p>当然缺点也有很多：
1. 生成的是静态网页，无法动态加载，若需要外部服务如评论，只能使用类似于disquz，多说这样的外部插件了
2. 仅仅适合小型网站，不适合大中型网站
3. 没有数据库及服务端的逻辑</p>

<p>由此可见，用来搭建个人博客相当合适（github版本控制，免费，无流量限制，支持markdown，无需关心服务器端逻辑和数据库）
##本地安装Jekyll
—
###首先安装Ruby及gem
1. 从<a href="http://rubyinstaller.org/">RubyInstaller</a>下载ruby，如果有经验的可以直接从<a href="https://www.ruby-lang.org/zh_cn/downloads/">Ruby官网</a>进行下载，前者安装比较无脑，会有一些额外的依赖包进行安装，版本也较低，而Ruby官网的版本则相对较高，但是没有额外的依赖包。下载的时候版本选较高一些的，否则会有bug，我选择的是2.0.0p353(2013-11-22)。安装的时候记得勾选添加环境变量。</p>

<ol>
  <li>
    <p>安装devkit，<a href="http://rubyinstaller.org/">RubyInstaller</a>页面中往下拉就能看到。选择自己版本的Ruby对应的devkit，下载并解压，然后执行:
<code>shell
cd devkit
ruby dk.rb init
ruby dk.rb install
</code>
这样就完成ruby环境的安装了</p>
  </li>
  <li>
    <p>安装gem，这个也可以去<a href="http://rubygems.org/">gem的官网</a>进行下载，然后直接安装就行了，安装完成后使用<code>gem -v</code>查看一下是否安装成功。我安装的是2.1.11版本</p>
  </li>
  <li>
    <p>gem是可以选择源的，默认的源有点慢，可以使用<code>ruby.taobao.org</code>的源，方便快捷
查看当前源</p>
  </li>
</ol>

<p>```shell
D:\node\jekyll&gt;gem sources list
<em>** CURRENT SOURCES **</em></p>

<p>https://rubygems.org/</p>

<p>D:\node\jekyll&gt;
```</p>

<p>添加新源
<code>shell
gem sources -a http://ruby.taobao.org/
</code></p>

<p>删除默认源
<code>shell
gem sources --remove https://rubygems.org/
</code></p>

<p>再次查看的时候保证只有<code>http://ruby.taobao.org/</code>就行了</p>

<p>如果上面出错，去网上找找教程吧，ruby环境的搭建和gem的安装教程还是蛮多的，基本google一下遍地都是。</p>

<h3 id="gemjekyll">使用gem安装Jekyll</h3>
<p>使用命令<code>gem install jekyll</code>就可以安装jekyll及所有需要的依赖，但不包括插件，安装jekyll的时候需要注意一下安装的版问题，jekyll的最新版本为1.4.3，但是有一个bug，<a href="http://stackoverflow.com/questions/21137096/jekyll-error-running-jekyll-serve">stackoverflow</a>上有人遇到过，我自己在使用的时候也遇到了类似的问题，解决方法是安装1.4.2版本，所以这里的安装命令为：<code>gem install jekyll --version "=1.4.2"</code>。安装完成后使用<code>jekyll -v</code>查看一下是否安装成功了</p>

<h3 id="jekyllwindows">Jekyll在windows下的字符集问题</h3>
<p>这个问题较多人遇到过，主要是在启动jekyll服务器的时候出现，以及一些中文文件名上出现，可以参考网上的解答：
1. <a href="http://blog.jsfor.com/skill/2013/09/07/jekyll-local-structures-notes/">windows下本地jekyll博客搭建手记</a>
2. <a href="http://chxt6896.github.io/blog/2012/02/13/blog-jekyll-native.html">Jekyll 本地调试之若干问题</a>
3. <a href="http://yanping.me/cn/blog/2012/10/09/chinese-charset-problems-with-jekyll/">在Windows下使用jekyll如何避免出现中文字符集错误</a></p>

<p>在这里，我仅仅是改了git bash的字符集，并没有去改jekyll的源文件，因为<code>self.content = File.read(File.join(base, name))</code>语句已经变了，不敢随便改。中文文件名的问题则通过改为全英文文件命名来避开，category里中文的问题则通过修改Permalinks来避开，这些后面会详细介绍</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/01/25/jekyll-1.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 闭合浮动最佳方案（clearfix） ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2014/01/09/clearfix.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 09 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>传统方法：
<code>css
.clear{clear:both;height:0;overflow:hidden;}
</code>
这样在需要闭合的地方加一个div.clear就行了，但是会改变html文档结构，所以建议使用以下方式：
<code>css
.clearfix:after{content:".";display:block;height:0;clear:both;visibility:hidden}
.clearfix{*+height:1%;}
</code>
使用after伪类后可以不用改变html文档结构即完成浮动闭合,加在浮动元素的父元素上就可以了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2014/01/09/clearfix.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 闭合浮动最佳方案（clearfix） ]]></title>
                <link>http://skyinlayer.com/#/art/build/2014/01/09/clearfix.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Thu, 09 Jan 2014 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<p>传统方法：
<code>css
.clear{clear:both;height:0;overflow:hidden;}
</code>
这样在需要闭合的地方加一个div.clear就行了，但是会改变html文档结构，所以建议使用以下方式：
<code>css
.clearfix:after{content:".";display:block;height:0;clear:both;visibility:hidden}
.clearfix{*+height:1%;}
</code>
使用after伪类后可以不用改变html文档结构即完成浮动闭合,加在浮动元素的父元素上就可以了</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2014/01/09/clearfix.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 搭建HTML5简易聊天室 ]]></title>
                <link>http://skyinlayer.com/#/art/publish/2013/12/08/websocket.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">前面的话</h3>
<hr />
<p>之前曾经写过一个符合xmpp协议的Web IM，但使用的是JSJaC，后台用的也是与之配套的jabber client，发现nodejs的事件模式更适合作为Web IM的客户端。</p>

<p>而传统的ajax轮询机制也早晚被全双工websocket所取代，所以就打算在我的毕业设计的Web IM平台中使用websocket。</p>

<p>在这里调研一下并作出了一个简单的版聊demo，这里讲一下这个简单demo的实现方式</p>

<h3 id="websocket">WebSocket</h3>
<hr />
<p>什么是WebSocket？</p>

<p><a href="http://datatracker.ietf.org/doc/rfc6455/?include_text=1">WebSocket的协议</a> 目前还没有仔细去研读，有时间研读一下</p>

<p>根据<a href="http://www.websocket.org/">WebSocket.org</a>上的定义：</p>

<blockquote>
  <p>The WebSocket specification—developed as part of the HTML5 initiative—      introduced the WebSocket JavaScript interface, which defines a full-duplex single socket connection over which messages can be sent between client and server. The WebSocket standard simplifies much of the complexity around bi-directional web communication and connection management.</p>
</blockquote>

<p>如上所述websocket定义了一个浏览器和服务器之间的全双工的单一的socket连接。</p>

<p>WebSocket的API？</p>

<p><a href="http://dev.w3.org/html5/websockets/">W3C的WS的API</a> ，定义了具体的WS的接口，而一般只要注意怎么使用就行了，可以清楚地看到WS客户端的几个事件：</p>

<ol>
  <li>onopen  在WS客户端和WS服务器建立连接成功后调用</li>
  <li>onmessage 在WS服务器给WS客户端发送数据时调用</li>
  <li>onerror 如果连接失败，发送、接收数据失败或者处理数据出现错误，则会被调用</li>
  <li>onclose 在WS客户端接收到WS服务器关闭时进行调用</li>
</ol>

<h3 id="websocket-1">WebSocket服务器实现</h3>
<hr />
<p>nodejs有很多websocket的三方库，都很实用，在stackoverflow上有人问过具体应该使用哪个库，而回答者给与了<a href="http://stackoverflow.com/questions/16392260/which-websocket-library-to-use-with-node-js">较为全面的解答</a></p>

<p>这里面对各个websocket库进行了一个对比，可以根据自己的需要选择。</p>

<p>其中可以注意一下<a href="http://socket.io/#home">socket.io</a>，它对不同的浏览器有比较好的支持，在不支持websocket的时候可以转变成ajax的轮询等其他的替换，浏览器的支持也相当不错。同时还能和目前比较流行的node的web框架express相结合，其文档的例子写的很好。</p>

<p>由于我只是想搭建一个简单快捷的WS服务器，所以选用了号称probably the fastest WebSocket library for node.js的<a href="https://github.com/einaros/ws">ws</a> </p>

<p>在项目中使用npm安装：</p>

<pre><code> npm install ws
</code></pre>

<p>如果需要使用命令行的简易WS客户端，可以：</p>

<pre><code>npm install ws -g
</code></pre>

<p>创建一个WS服务器：</p>

<pre><code>var WebSocketServer = require('ws').Server,
    wss = new WebSocketServer({
    port: process.env.WSPORT || 3001
}); 这样wss就成为了一个监听3001端口的WS服务器，我们需要为WS服务器创建WS客户端连接时候的事件：

wss.on('connection', function(ws) {});
</code></pre>

<p>这样，在有WS客户端连接我们的WS服务器时就会触发这个事件，但连接之后我么还需要传递信息，所以需要丰富这个事件的回调函数。</p>

<p>回调函数有一个参数ws，这个ws掌管着和WS客户端的连接，其事件也和WS客户端相同，不过不需要onopen。需要绑定的还有message，close：</p>

<pre><code>wss.on('connection', function(ws) {
    ws.on('message', function(data) {
        
    });
    ws.on('close', function() {
        
    });
});
</code></pre>

<p>message事件在WS客户端给这个WS服务器发数据时调用，data就是这个数据，一般为string类型</p>

<p>close事件在WS客服端给这个WS服务器发送关闭请求时调用</p>

<p>一个简单的聊天室，需要在一个用户加入时告诉其他所有用户有新用户加入，也就是需要一个广播的方法，我们可以根据ws的示例来定义广播方法：</p>

<pre><code>wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};
</code></pre>

<p>这里可以看到wss的clients存放了所有与wss相连的WS客户端连接。</p>

<p>在一个WS客户端连接了WS服务器，我们需要把现有的所有房间内用户的信息给新进入房间的用户，并告诉所有房间内的用户有新用户加入，默认新进入房间的用户叫“游客”，修改代码：</p>

<pre><code>wss.on('connection', function(ws) {
    ws.on('message', function(data) {
    });
    ws.on('close', function() {
    });
    //给每个用户一个单独的id
    ws.uid = uuid.v4();
    //新进入房间的用户的昵称
    ws.nick = "游客";
    //把目前所有房间内人员的信息发给新用户
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: "join"
        }));
    }
    //将新加入用户的信息告诉所有房间内的用户
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "join"
    });
});
</code></pre>

<p>这样新用户加入时的服务器端处理就完成了</p>

<p>在一个用户向服务器发送信息时,需要广播这条信息,同时也要指出发送人的信息,所以修改代码:</p>

<pre><code>ws.on('message', function(data) {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        time: moment(data.time).format("HH:mm:ss"),
        message: data.message,
        type: "message"
    });
});
</code></pre>

<p>在一个WS客户端向WS服务器发送关闭请求时，需要通知其他所有房间内的用户，所以修改代码：</p>

<pre><code>ws.on('close', function() {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "exit"
    });
}); 在一个用户要修改自己的昵称，WS客户端需要向WS服务器发送申请，所以修改代码：

ws.on('message', function(data) {
    //解析数据
    data = JSON.parse(data);
    //若为message,则为WS客户端向WS服务器发送信息,进行广播
    if (data.type === "message") {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            time: moment(data.time).format("HH:mm:ss"),
            message: data.message,
            type: "message"
        });
    //若为nickname,则为WS客户端向WS服务器发送昵称修改请求,则修改用户昵称,并进行广播
    } else if (data.type === "nickname") {
        wss.broadcast({
            oldnick: ws.nick,
            nick: data.nick,
            uid: ws.uid,
            type: "nickname"
        });
        ws.nick = data.nick;
    }
});
</code></pre>

<p>这样一个简单的聊天室的WS服务器就完成了,所有代码如下:</p>

<pre><code>var WebSocketServer = require('ws').Server,
    wss = new WebSocketServer({
        port: process.env.WSPORT || 3001
    });

wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};

wss.on('connection', function(ws) {
    ws.on('message', function(data) {
        data = JSON.parse(data);
        if (data.type === "message") {
            wss.broadcast({
                nick: ws.nick,
                uid: ws.uid,
                time: moment(data.time).format("HH:mm:ss"),
                message: data.message,
                type: "message"
            });
        } else if (data.type === "nickname") {
            wss.broadcast({
                oldnick: ws.nick,
                nick: data.nick,
                uid: ws.uid,
                type: "nickname"
            });
            ws.nick = data.nick;
        }
    });
    ws.on('close', function() {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            type: "exit"
        });
    });
    ws.uid = uuid.v4();
    ws.nick = "游客";
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: "join"
        }));
    }
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "join"
    });
});
</code></pre>

<h3 id="websocket-2">WebSocket客户端实现</h3>
<hr />
<p>在浏览器中,则需要建立一个WS客户端</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket("ws://localhost:3001");
</code></pre>

<p>给它按照WebSocket的API绑定事件:</p>

<pre><code>//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $("#nickname").val("游客");
    $logs.append("&lt;div class='alert alert-success'&gt;您已加入版聊&lt;/div&gt;");
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append("&lt;div class='alert alert-danger'&gt;您已断开版聊&lt;/div&gt;");
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === "message") {
        $chat.append("&lt;p&gt;" + data.nick + "(" + data.time + "): " + data.message + "&lt;/p&gt;");
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === "join") {
        if ($("p[uid='" + data.uid + "']", $users).length === 0) {
            $users.append("&lt;p uid='" + data.uid + "'&gt;" + data.nick + "&lt;/p&gt;");
            $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "加入了版聊&lt;/div&gt;");
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === "exit") {
        $("p[uid='" + data.uid + "']", $users).remove();
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "离开了版聊&lt;/div&gt;");
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === "nickname") {
        $("#nickname").val(data.nick);
        $("p[uid='" + data.uid + "']", $users).text(data.nick);
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.oldnick + " 修改昵称为 " + data.nick + "&lt;/div&gt;");
    }
};
</code></pre>

<p>具体需要发送信息时,使用ws.send发送：</p>

<pre><code>//从WS客户端向WS服务器发送信息数据
ws.send(JSON.stringify({
    time: new Date().getTime(),
    message: message,
    type: "message"
}));
</code></pre>

<p>需要发送修改昵称请求时，采用同样的方式：</p>

<pre><code>//从WS客户端向WS服务器发送昵称修改请求
ws.send(JSON.stringify({
    nick: nick,
    type: "nickname"
}));
</code></pre>

<p>这样一个完整的WS客户端代码：</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket("ws://localhost:3001");
//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $("#nickname").val("游客");
    $logs.append("&lt;div class='alert alert-success'&gt;您已加入版聊&lt;/div&gt;");
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append("&lt;div class='alert alert-danger'&gt;您已断开版聊&lt;/div&gt;");
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === "message") {
        $chat.append("&lt;p&gt;" + data.nick + "(" + data.time + "): " + data.message + "&lt;/p&gt;");
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === "join") {
        if ($("p[uid='" + data.uid + "']", $users).length === 0) {
            $users.append("&lt;p uid='" + data.uid + "'&gt;" + data.nick + "&lt;/p&gt;");
            $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "加入了版聊&lt;/div&gt;");
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === "exit") {
        $("p[uid='" + data.uid + "']", $users).remove();
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "离开了版聊&lt;/div&gt;");
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === "nickname") {
        $("#nickname").val(data.nick);
        $("p[uid='" + data.uid + "']", $users).text(data.nick);
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.oldnick + " 修改昵称为 " + data.nick + "&lt;/div&gt;");
    }
};
//发送消息按钮事件
$("#send").click(function(event) {
    var message = $("#message").val();
    if (message.trim() !== "") {
        //从WS客户端向WS服务器发送信息数据
        ws.send(JSON.stringify({
            time: new Date().getTime(),
            message: message,
            type: "message"
        }));
    }
});
//修改昵称按钮事件
$("#changeNick").click(function(event) {
    var nick = $("#nickname").val();
    if (nick.trim() !== "") {
        //从WS客户端向WS服务器发送昵称修改请求
        ws.send(JSON.stringify({
            nick: nick,
            type: "nickname"
        }));
    }
});
</code></pre>

<h3 id="section-1">写在最后</h3>
<hr />
<p>这样一个完整的基于WebSocket的简单聊天室就完成了，试用一下，虽然功能不完善，但是已经可以用了，并且兼容firefox25和chrome</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/publish/2013/12/08/websocket.html</guid>
            </item>
        
            <item>
                <title><![CDATA[ 搭建HTML5简易聊天室 ]]></title>
                <link>http://skyinlayer.com/#/art/build/2013/12/08/websocket.html</link>
                <category>IT技术</category>
                <author>lingyucoder@gmail.com (skyinlayer)</author>
                <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
                <description><![CDATA[ 
<h3 id="section">前面的话</h3>
<hr />
<p>之前曾经写过一个符合xmpp协议的Web IM，但使用的是JSJaC，后台用的也是与之配套的jabber client，发现nodejs的事件模式更适合作为Web IM的客户端。</p>

<p>而传统的ajax轮询机制也早晚被全双工websocket所取代，所以就打算在我的毕业设计的Web IM平台中使用websocket。</p>

<p>在这里调研一下并作出了一个简单的版聊demo，这里讲一下这个简单demo的实现方式</p>

<h3 id="websocket">WebSocket</h3>
<hr />
<p>什么是WebSocket？</p>

<p><a href="http://datatracker.ietf.org/doc/rfc6455/?include_text=1">WebSocket的协议</a> 目前还没有仔细去研读，有时间研读一下</p>

<p>根据<a href="http://www.websocket.org/">WebSocket.org</a>上的定义：</p>

<blockquote>
  <p>The WebSocket specification—developed as part of the HTML5 initiative—      introduced the WebSocket JavaScript interface, which defines a full-duplex single socket connection over which messages can be sent between client and server. The WebSocket standard simplifies much of the complexity around bi-directional web communication and connection management.</p>
</blockquote>

<p>如上所述websocket定义了一个浏览器和服务器之间的全双工的单一的socket连接。</p>

<p>WebSocket的API？</p>

<p><a href="http://dev.w3.org/html5/websockets/">W3C的WS的API</a> ，定义了具体的WS的接口，而一般只要注意怎么使用就行了，可以清楚地看到WS客户端的几个事件：</p>

<ol>
  <li>onopen  在WS客户端和WS服务器建立连接成功后调用</li>
  <li>onmessage 在WS服务器给WS客户端发送数据时调用</li>
  <li>onerror 如果连接失败，发送、接收数据失败或者处理数据出现错误，则会被调用</li>
  <li>onclose 在WS客户端接收到WS服务器关闭时进行调用</li>
</ol>

<h3 id="websocket-1">WebSocket服务器实现</h3>
<hr />
<p>nodejs有很多websocket的三方库，都很实用，在stackoverflow上有人问过具体应该使用哪个库，而回答者给与了<a href="http://stackoverflow.com/questions/16392260/which-websocket-library-to-use-with-node-js">较为全面的解答</a></p>

<p>这里面对各个websocket库进行了一个对比，可以根据自己的需要选择。</p>

<p>其中可以注意一下<a href="http://socket.io/#home">socket.io</a>，它对不同的浏览器有比较好的支持，在不支持websocket的时候可以转变成ajax的轮询等其他的替换，浏览器的支持也相当不错。同时还能和目前比较流行的node的web框架express相结合，其文档的例子写的很好。</p>

<p>由于我只是想搭建一个简单快捷的WS服务器，所以选用了号称probably the fastest WebSocket library for node.js的<a href="https://github.com/einaros/ws">ws</a> </p>

<p>在项目中使用npm安装：</p>

<pre><code> npm install ws
</code></pre>

<p>如果需要使用命令行的简易WS客户端，可以：</p>

<pre><code>npm install ws -g
</code></pre>

<p>创建一个WS服务器：</p>

<pre><code>var WebSocketServer = require('ws').Server,
    wss = new WebSocketServer({
    port: process.env.WSPORT || 3001
}); 这样wss就成为了一个监听3001端口的WS服务器，我们需要为WS服务器创建WS客户端连接时候的事件：

wss.on('connection', function(ws) {});
</code></pre>

<p>这样，在有WS客户端连接我们的WS服务器时就会触发这个事件，但连接之后我么还需要传递信息，所以需要丰富这个事件的回调函数。</p>

<p>回调函数有一个参数ws，这个ws掌管着和WS客户端的连接，其事件也和WS客户端相同，不过不需要onopen。需要绑定的还有message，close：</p>

<pre><code>wss.on('connection', function(ws) {
    ws.on('message', function(data) {
        
    });
    ws.on('close', function() {
        
    });
});
</code></pre>

<p>message事件在WS客户端给这个WS服务器发数据时调用，data就是这个数据，一般为string类型</p>

<p>close事件在WS客服端给这个WS服务器发送关闭请求时调用</p>

<p>一个简单的聊天室，需要在一个用户加入时告诉其他所有用户有新用户加入，也就是需要一个广播的方法，我们可以根据ws的示例来定义广播方法：</p>

<pre><code>wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};
</code></pre>

<p>这里可以看到wss的clients存放了所有与wss相连的WS客户端连接。</p>

<p>在一个WS客户端连接了WS服务器，我们需要把现有的所有房间内用户的信息给新进入房间的用户，并告诉所有房间内的用户有新用户加入，默认新进入房间的用户叫“游客”，修改代码：</p>

<pre><code>wss.on('connection', function(ws) {
    ws.on('message', function(data) {
    });
    ws.on('close', function() {
    });
    //给每个用户一个单独的id
    ws.uid = uuid.v4();
    //新进入房间的用户的昵称
    ws.nick = "游客";
    //把目前所有房间内人员的信息发给新用户
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: "join"
        }));
    }
    //将新加入用户的信息告诉所有房间内的用户
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "join"
    });
});
</code></pre>

<p>这样新用户加入时的服务器端处理就完成了</p>

<p>在一个用户向服务器发送信息时,需要广播这条信息,同时也要指出发送人的信息,所以修改代码:</p>

<pre><code>ws.on('message', function(data) {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        time: moment(data.time).format("HH:mm:ss"),
        message: data.message,
        type: "message"
    });
});
</code></pre>

<p>在一个WS客户端向WS服务器发送关闭请求时，需要通知其他所有房间内的用户，所以修改代码：</p>

<pre><code>ws.on('close', function() {
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "exit"
    });
}); 在一个用户要修改自己的昵称，WS客户端需要向WS服务器发送申请，所以修改代码：

ws.on('message', function(data) {
    //解析数据
    data = JSON.parse(data);
    //若为message,则为WS客户端向WS服务器发送信息,进行广播
    if (data.type === "message") {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            time: moment(data.time).format("HH:mm:ss"),
            message: data.message,
            type: "message"
        });
    //若为nickname,则为WS客户端向WS服务器发送昵称修改请求,则修改用户昵称,并进行广播
    } else if (data.type === "nickname") {
        wss.broadcast({
            oldnick: ws.nick,
            nick: data.nick,
            uid: ws.uid,
            type: "nickname"
        });
        ws.nick = data.nick;
    }
});
</code></pre>

<p>这样一个简单的聊天室的WS服务器就完成了,所有代码如下:</p>

<pre><code>var WebSocketServer = require('ws').Server,
    wss = new WebSocketServer({
        port: process.env.WSPORT || 3001
    });

wss.broadcast = function(data) {
    for (var i in this.clients) this.clients[i].send(JSON.stringify(data));
};

wss.on('connection', function(ws) {
    ws.on('message', function(data) {
        data = JSON.parse(data);
        if (data.type === "message") {
            wss.broadcast({
                nick: ws.nick,
                uid: ws.uid,
                time: moment(data.time).format("HH:mm:ss"),
                message: data.message,
                type: "message"
            });
        } else if (data.type === "nickname") {
            wss.broadcast({
                oldnick: ws.nick,
                nick: data.nick,
                uid: ws.uid,
                type: "nickname"
            });
            ws.nick = data.nick;
        }
    });
    ws.on('close', function() {
        wss.broadcast({
            nick: ws.nick,
            uid: ws.uid,
            type: "exit"
        });
    });
    ws.uid = uuid.v4();
    ws.nick = "游客";
    for (var i in this.clients) {
        ws.send(JSON.stringify({
            nick: this.clients[i].nick,
            uid: this.clients[i].uid,
            type: "join"
        }));
    }
    wss.broadcast({
        nick: ws.nick,
        uid: ws.uid,
        type: "join"
    });
});
</code></pre>

<h3 id="websocket-2">WebSocket客户端实现</h3>
<hr />
<p>在浏览器中,则需要建立一个WS客户端</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket("ws://localhost:3001");
</code></pre>

<p>给它按照WebSocket的API绑定事件:</p>

<pre><code>//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $("#nickname").val("游客");
    $logs.append("&lt;div class='alert alert-success'&gt;您已加入版聊&lt;/div&gt;");
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append("&lt;div class='alert alert-danger'&gt;您已断开版聊&lt;/div&gt;");
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === "message") {
        $chat.append("&lt;p&gt;" + data.nick + "(" + data.time + "): " + data.message + "&lt;/p&gt;");
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === "join") {
        if ($("p[uid='" + data.uid + "']", $users).length === 0) {
            $users.append("&lt;p uid='" + data.uid + "'&gt;" + data.nick + "&lt;/p&gt;");
            $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "加入了版聊&lt;/div&gt;");
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === "exit") {
        $("p[uid='" + data.uid + "']", $users).remove();
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "离开了版聊&lt;/div&gt;");
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === "nickname") {
        $("#nickname").val(data.nick);
        $("p[uid='" + data.uid + "']", $users).text(data.nick);
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.oldnick + " 修改昵称为 " + data.nick + "&lt;/div&gt;");
    }
};
</code></pre>

<p>具体需要发送信息时,使用ws.send发送：</p>

<pre><code>//从WS客户端向WS服务器发送信息数据
ws.send(JSON.stringify({
    time: new Date().getTime(),
    message: message,
    type: "message"
}));
</code></pre>

<p>需要发送修改昵称请求时，采用同样的方式：</p>

<pre><code>//从WS客户端向WS服务器发送昵称修改请求
ws.send(JSON.stringify({
    nick: nick,
    type: "nickname"
}));
</code></pre>

<p>这样一个完整的WS客户端代码：</p>

<pre><code>//创建一个WS客户端
var ws = new WebSocket("ws://localhost:3001");
//WS客户端连接到WS服务器后, 设定默认昵称,并加入版聊
ws.onopen = function(event) {
    $("#nickname").val("游客");
    $logs.append("&lt;div class='alert alert-success'&gt;您已加入版聊&lt;/div&gt;");
};
//如果WS服务器关闭,给予断开提示
ws.onclose = function(event) {
    $logs.append("&lt;div class='alert alert-danger'&gt;您已断开版聊&lt;/div&gt;");
};
//如果WS服务器向这个WS客户端发送信息:
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    //发送文本信息, 显示到页面上
    if (data.type === "message") {
        $chat.append("&lt;p&gt;" + data.nick + "(" + data.time + "): " + data.message + "&lt;/p&gt;");
    //有新用户加入, 显示用户加入通知, 并修改当前用户列表
    } else if (data.type === "join") {
        if ($("p[uid='" + data.uid + "']", $users).length === 0) {
            $users.append("&lt;p uid='" + data.uid + "'&gt;" + data.nick + "&lt;/p&gt;");
            $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "加入了版聊&lt;/div&gt;");
        }
    //有用户离开, 显示用户离开通知, 并修改当前用户列表
    } else if (data.type === "exit") {
        $("p[uid='" + data.uid + "']", $users).remove();
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.nick + "离开了版聊&lt;/div&gt;");
    //有用户修改昵称, 显示用户修改昵称, 修改用户列表
    } else if (data.type === "nickname") {
        $("#nickname").val(data.nick);
        $("p[uid='" + data.uid + "']", $users).text(data.nick);
        $logs.append("&lt;div class='alert alert-warning'&gt;" + data.oldnick + " 修改昵称为 " + data.nick + "&lt;/div&gt;");
    }
};
//发送消息按钮事件
$("#send").click(function(event) {
    var message = $("#message").val();
    if (message.trim() !== "") {
        //从WS客户端向WS服务器发送信息数据
        ws.send(JSON.stringify({
            time: new Date().getTime(),
            message: message,
            type: "message"
        }));
    }
});
//修改昵称按钮事件
$("#changeNick").click(function(event) {
    var nick = $("#nickname").val();
    if (nick.trim() !== "") {
        //从WS客户端向WS服务器发送昵称修改请求
        ws.send(JSON.stringify({
            nick: nick,
            type: "nickname"
        }));
    }
});
</code></pre>

<h3 id="section-1">写在最后</h3>
<hr />
<p>这样一个完整的基于WebSocket的简单聊天室就完成了，试用一下，虽然功能不完善，但是已经可以用了，并且兼容firefox25和chrome</p>

 ]]></description>
                <guid isPermaLink="false">http://skyinlayer.com/build/2013/12/08/websocket.html</guid>
            </item>
        
    </channel>
</rss>